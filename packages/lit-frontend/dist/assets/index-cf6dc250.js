var _a;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = globalThis, e$4 = t$2.ShadowRoot && (void 0 === t$2.ShadyCSS || t$2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$5 = Symbol(), o$3 = /* @__PURE__ */ new WeakMap();
let n$4 = class n {
  constructor(t2, e3, o2) {
    if (this._$cssResult$ = true, o2 !== s$5)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e3;
  }
  get styleSheet() {
    let t2 = this.o;
    const s5 = this.t;
    if (e$4 && void 0 === t2) {
      const e3 = void 0 !== s5 && 1 === s5.length;
      e3 && (t2 = o$3.get(s5)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e3 && o$3.set(s5, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$5 = (t2) => new n$4("string" == typeof t2 ? t2 : t2 + "", void 0, s$5), i$3 = (t2, ...e3) => {
  const o2 = 1 === t2.length ? t2[0] : e3.reduce((e4, s5, o3) => e4 + ((t3) => {
    if (true === t3._$cssResult$)
      return t3.cssText;
    if ("number" == typeof t3)
      return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s5) + t2[o3 + 1], t2[0]);
  return new n$4(o2, t2, s$5);
}, S$1 = (s5, o2) => {
  if (e$4)
    s5.adoptedStyleSheets = o2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet);
  else
    for (const e3 of o2) {
      const o3 = document.createElement("style"), n3 = t$2.litNonce;
      void 0 !== n3 && o3.setAttribute("nonce", n3), o3.textContent = e3.cssText, s5.appendChild(o3);
    }
}, c$3 = e$4 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e3 = "";
  for (const s5 of t3.cssRules)
    e3 += s5.cssText;
  return r$5(e3);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$2, defineProperty: e$3, getOwnPropertyDescriptor: r$4, getOwnPropertyNames: h$1, getOwnPropertySymbols: o$2, getPrototypeOf: n$3 } = Object, a$1 = globalThis, c$2 = a$1.trustedTypes, l$1 = c$2 ? c$2.emptyScript : "", p$1 = a$1.reactiveElementPolyfillSupport, d$1 = (t2, s5) => t2, u$1 = { toAttribute(t2, s5) {
  switch (s5) {
    case Boolean:
      t2 = t2 ? l$1 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s5) {
  let i2 = t2;
  switch (s5) {
    case Boolean:
      i2 = null !== t2;
      break;
    case Number:
      i2 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i2 = JSON.parse(t2);
      } catch (t3) {
        i2 = null;
      }
  }
  return i2;
} }, f$1 = (t2, s5) => !i$2(t2, s5), y$1 = { attribute: true, type: String, converter: u$1, reflect: false, hasChanged: f$1 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class b extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s5 = y$1) {
    if (s5.state && (s5.attribute = false), this._$Ei(), this.elementProperties.set(t2, s5), !s5.noAccessor) {
      const i2 = Symbol(), r2 = this.getPropertyDescriptor(t2, i2, s5);
      void 0 !== r2 && e$3(this.prototype, t2, r2);
    }
  }
  static getPropertyDescriptor(t2, s5, i2) {
    const { get: e3, set: h2 } = r$4(this.prototype, t2) ?? { get() {
      return this[s5];
    }, set(t3) {
      this[s5] = t3;
    } };
    return { get() {
      return e3 == null ? void 0 : e3.call(this);
    }, set(s6) {
      const r2 = e3 == null ? void 0 : e3.call(this);
      h2.call(this, s6), this.requestUpdate(t2, r2, i2);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? y$1;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties")))
      return;
    const t2 = n$3(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const t3 = this.properties, s5 = [...h$1(t3), ...o$2(t3)];
      for (const i2 of s5)
        this.createProperty(i2, t3[i2]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s5 = litPropertyMetadata.get(t2);
      if (void 0 !== s5)
        for (const [t3, i2] of s5)
          this.elementProperties.set(t3, i2);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s5] of this.elementProperties) {
      const i2 = this._$Eu(t3, s5);
      void 0 !== i2 && this._$Eh.set(i2, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s5) {
    const i2 = [];
    if (Array.isArray(s5)) {
      const e3 = new Set(s5.flat(1 / 0).reverse());
      for (const s6 of e3)
        i2.unshift(c$3(s6));
    } else
      void 0 !== s5 && i2.push(c$3(s5));
    return i2;
  }
  static _$Eu(t2, s5) {
    const i2 = s5.attribute;
    return false === i2 ? void 0 : "string" == typeof i2 ? i2 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var _a2;
    this._$ES = new Promise((t2) => this.enableUpdating = t2), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (_a2 = this.constructor.l) == null ? void 0 : _a2.forEach((t2) => t2(this));
  }
  addController(t2) {
    var _a2;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t2), void 0 !== this.renderRoot && this.isConnected && ((_a2 = t2.hostConnected) == null ? void 0 : _a2.call(t2));
  }
  removeController(t2) {
    var _a2;
    (_a2 = this._$EO) == null ? void 0 : _a2.delete(t2);
  }
  _$E_() {
    const t2 = /* @__PURE__ */ new Map(), s5 = this.constructor.elementProperties;
    for (const i2 of s5.keys())
      this.hasOwnProperty(i2) && (t2.set(i2, this[i2]), delete this[i2]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    var _a2;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (_a2 = this._$EO) == null ? void 0 : _a2.forEach((t2) => {
      var _a3;
      return (_a3 = t2.hostConnected) == null ? void 0 : _a3.call(t2);
    });
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    var _a2;
    (_a2 = this._$EO) == null ? void 0 : _a2.forEach((t2) => {
      var _a3;
      return (_a3 = t2.hostDisconnected) == null ? void 0 : _a3.call(t2);
    });
  }
  attributeChangedCallback(t2, s5, i2) {
    this._$AK(t2, i2);
  }
  _$EC(t2, s5) {
    var _a2;
    const i2 = this.constructor.elementProperties.get(t2), e3 = this.constructor._$Eu(t2, i2);
    if (void 0 !== e3 && true === i2.reflect) {
      const r2 = (void 0 !== ((_a2 = i2.converter) == null ? void 0 : _a2.toAttribute) ? i2.converter : u$1).toAttribute(s5, i2.type);
      this._$Em = t2, null == r2 ? this.removeAttribute(e3) : this.setAttribute(e3, r2), this._$Em = null;
    }
  }
  _$AK(t2, s5) {
    var _a2;
    const i2 = this.constructor, e3 = i2._$Eh.get(t2);
    if (void 0 !== e3 && this._$Em !== e3) {
      const t3 = i2.getPropertyOptions(e3), r2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== ((_a2 = t3.converter) == null ? void 0 : _a2.fromAttribute) ? t3.converter : u$1;
      this._$Em = e3, this[e3] = r2.fromAttribute(s5, t3.type), this._$Em = null;
    }
  }
  requestUpdate(t2, s5, i2) {
    if (void 0 !== t2) {
      if (i2 ?? (i2 = this.constructor.getPropertyOptions(t2)), !(i2.hasChanged ?? f$1)(this[t2], s5))
        return;
      this.P(t2, s5, i2);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t2, s5, i2) {
    this._$AL.has(t2) || this._$AL.set(t2, s5), true === i2.reflect && this._$Em !== t2 && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t2);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _a2;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [t4, s6] of this._$Ep)
          this[t4] = s6;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0)
        for (const [s6, i2] of t3)
          true !== i2.wrapped || this._$AL.has(s6) || void 0 === this[s6] || this.P(s6, this[s6], i2);
    }
    let t2 = false;
    const s5 = this._$AL;
    try {
      t2 = this.shouldUpdate(s5), t2 ? (this.willUpdate(s5), (_a2 = this._$EO) == null ? void 0 : _a2.forEach((t3) => {
        var _a3;
        return (_a3 = t3.hostUpdate) == null ? void 0 : _a3.call(t3);
      }), this.update(s5)) : this._$EU();
    } catch (s6) {
      throw t2 = false, this._$EU(), s6;
    }
    t2 && this._$AE(s5);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    var _a2;
    (_a2 = this._$EO) == null ? void 0 : _a2.forEach((t3) => {
      var _a3;
      return (_a3 = t3.hostUpdated) == null ? void 0 : _a3.call(t3);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((t3) => this._$EC(t3, this[t3]))), this._$EU();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
}
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d$1("elementProperties")] = /* @__PURE__ */ new Map(), b[d$1("finalized")] = /* @__PURE__ */ new Map(), p$1 == null ? void 0 : p$1({ ReactiveElement: b }), (a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = globalThis, i$1 = t$1.trustedTypes, s$4 = i$1 ? i$1.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$2 = "$lit$", h = `lit$${(Math.random() + "").slice(9)}$`, o$1 = "?" + h, n$2 = `<${o$1}>`, r$3 = document, l = () => r$3.createComment(""), c$1 = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, a = Array.isArray, u = (t2) => a(t2) || "function" == typeof (t2 == null ? void 0 : t2[Symbol.iterator]), d = "[ 	\n\f\r]", f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v = /-->/g, _ = />/g, m = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p = /'/g, g = /"/g, $ = /^(?:script|style|textarea|title)$/i, y = (t2) => (i2, ...s5) => ({ _$litType$: t2, strings: i2, values: s5 }), x = y(1), w = Symbol.for("lit-noChange"), T = Symbol.for("lit-nothing"), A = /* @__PURE__ */ new WeakMap(), E = r$3.createTreeWalker(r$3, 129);
function C(t2, i2) {
  if (!Array.isArray(t2) || !t2.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s$4 ? s$4.createHTML(i2) : i2;
}
const P = (t2, i2) => {
  const s5 = t2.length - 1, o2 = [];
  let r2, l2 = 2 === i2 ? "<svg>" : "", c2 = f;
  for (let i3 = 0; i3 < s5; i3++) {
    const s6 = t2[i3];
    let a2, u2, d2 = -1, y2 = 0;
    for (; y2 < s6.length && (c2.lastIndex = y2, u2 = c2.exec(s6), null !== u2); )
      y2 = c2.lastIndex, c2 === f ? "!--" === u2[1] ? c2 = v : void 0 !== u2[1] ? c2 = _ : void 0 !== u2[2] ? ($.test(u2[2]) && (r2 = RegExp("</" + u2[2], "g")), c2 = m) : void 0 !== u2[3] && (c2 = m) : c2 === m ? ">" === u2[0] ? (c2 = r2 ?? f, d2 = -1) : void 0 === u2[1] ? d2 = -2 : (d2 = c2.lastIndex - u2[2].length, a2 = u2[1], c2 = void 0 === u2[3] ? m : '"' === u2[3] ? g : p) : c2 === g || c2 === p ? c2 = m : c2 === v || c2 === _ ? c2 = f : (c2 = m, r2 = void 0);
    const x2 = c2 === m && t2[i3 + 1].startsWith("/>") ? " " : "";
    l2 += c2 === f ? s6 + n$2 : d2 >= 0 ? (o2.push(a2), s6.slice(0, d2) + e$2 + s6.slice(d2) + h + x2) : s6 + h + (-2 === d2 ? i3 : x2);
  }
  return [C(t2, l2 + (t2[s5] || "<?>") + (2 === i2 ? "</svg>" : "")), o2];
};
class V {
  constructor({ strings: t2, _$litType$: s5 }, n3) {
    let r2;
    this.parts = [];
    let c2 = 0, a2 = 0;
    const u2 = t2.length - 1, d2 = this.parts, [f2, v2] = P(t2, s5);
    if (this.el = V.createElement(f2, n3), E.currentNode = this.el.content, 2 === s5) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r2 = E.nextNode()) && d2.length < u2; ) {
      if (1 === r2.nodeType) {
        if (r2.hasAttributes())
          for (const t3 of r2.getAttributeNames())
            if (t3.endsWith(e$2)) {
              const i2 = v2[a2++], s6 = r2.getAttribute(t3).split(h), e3 = /([.?@])?(.*)/.exec(i2);
              d2.push({ type: 1, index: c2, name: e3[2], strings: s6, ctor: "." === e3[1] ? k : "?" === e3[1] ? H : "@" === e3[1] ? I : R }), r2.removeAttribute(t3);
            } else
              t3.startsWith(h) && (d2.push({ type: 6, index: c2 }), r2.removeAttribute(t3));
        if ($.test(r2.tagName)) {
          const t3 = r2.textContent.split(h), s6 = t3.length - 1;
          if (s6 > 0) {
            r2.textContent = i$1 ? i$1.emptyScript : "";
            for (let i2 = 0; i2 < s6; i2++)
              r2.append(t3[i2], l()), E.nextNode(), d2.push({ type: 2, index: ++c2 });
            r2.append(t3[s6], l());
          }
        }
      } else if (8 === r2.nodeType)
        if (r2.data === o$1)
          d2.push({ type: 2, index: c2 });
        else {
          let t3 = -1;
          for (; -1 !== (t3 = r2.data.indexOf(h, t3 + 1)); )
            d2.push({ type: 7, index: c2 }), t3 += h.length - 1;
        }
      c2++;
    }
  }
  static createElement(t2, i2) {
    const s5 = r$3.createElement("template");
    return s5.innerHTML = t2, s5;
  }
}
function N(t2, i2, s5 = t2, e3) {
  var _a2, _b;
  if (i2 === w)
    return i2;
  let h2 = void 0 !== e3 ? (_a2 = s5._$Co) == null ? void 0 : _a2[e3] : s5._$Cl;
  const o2 = c$1(i2) ? void 0 : i2._$litDirective$;
  return (h2 == null ? void 0 : h2.constructor) !== o2 && ((_b = h2 == null ? void 0 : h2._$AO) == null ? void 0 : _b.call(h2, false), void 0 === o2 ? h2 = void 0 : (h2 = new o2(t2), h2._$AT(t2, s5, e3)), void 0 !== e3 ? (s5._$Co ?? (s5._$Co = []))[e3] = h2 : s5._$Cl = h2), void 0 !== h2 && (i2 = N(t2, h2._$AS(t2, i2.values), h2, e3)), i2;
}
class S {
  constructor(t2, i2) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i2;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i2 }, parts: s5 } = this._$AD, e3 = ((t2 == null ? void 0 : t2.creationScope) ?? r$3).importNode(i2, true);
    E.currentNode = e3;
    let h2 = E.nextNode(), o2 = 0, n3 = 0, l2 = s5[0];
    for (; void 0 !== l2; ) {
      if (o2 === l2.index) {
        let i3;
        2 === l2.type ? i3 = new M(h2, h2.nextSibling, this, t2) : 1 === l2.type ? i3 = new l2.ctor(h2, l2.name, l2.strings, this, t2) : 6 === l2.type && (i3 = new L(h2, this, t2)), this._$AV.push(i3), l2 = s5[++n3];
      }
      o2 !== (l2 == null ? void 0 : l2.index) && (h2 = E.nextNode(), o2++);
    }
    return E.currentNode = r$3, e3;
  }
  p(t2) {
    let i2 = 0;
    for (const s5 of this._$AV)
      void 0 !== s5 && (void 0 !== s5.strings ? (s5._$AI(t2, s5, i2), i2 += s5.strings.length - 2) : s5._$AI(t2[i2])), i2++;
  }
}
class M {
  get _$AU() {
    var _a2;
    return ((_a2 = this._$AM) == null ? void 0 : _a2._$AU) ?? this._$Cv;
  }
  constructor(t2, i2, s5, e3) {
    this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = t2, this._$AB = i2, this._$AM = s5, this.options = e3, this._$Cv = (e3 == null ? void 0 : e3.isConnected) ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i2 = this._$AM;
    return void 0 !== i2 && 11 === (t2 == null ? void 0 : t2.nodeType) && (t2 = i2.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i2 = this) {
    t2 = N(this, t2, i2), c$1(t2) ? t2 === T || null == t2 || "" === t2 ? (this._$AH !== T && this._$AR(), this._$AH = T) : t2 !== this._$AH && t2 !== w && this._(t2) : void 0 !== t2._$litType$ ? this.$(t2) : void 0 !== t2.nodeType ? this.T(t2) : u(t2) ? this.k(t2) : this._(t2);
  }
  S(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  T(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.S(t2));
  }
  _(t2) {
    this._$AH !== T && c$1(this._$AH) ? this._$AA.nextSibling.data = t2 : this.T(r$3.createTextNode(t2)), this._$AH = t2;
  }
  $(t2) {
    var _a2;
    const { values: i2, _$litType$: s5 } = t2, e3 = "number" == typeof s5 ? this._$AC(t2) : (void 0 === s5.el && (s5.el = V.createElement(C(s5.h, s5.h[0]), this.options)), s5);
    if (((_a2 = this._$AH) == null ? void 0 : _a2._$AD) === e3)
      this._$AH.p(i2);
    else {
      const t3 = new S(e3, this), s6 = t3.u(this.options);
      t3.p(i2), this.T(s6), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i2 = A.get(t2.strings);
    return void 0 === i2 && A.set(t2.strings, i2 = new V(t2)), i2;
  }
  k(t2) {
    a(this._$AH) || (this._$AH = [], this._$AR());
    const i2 = this._$AH;
    let s5, e3 = 0;
    for (const h2 of t2)
      e3 === i2.length ? i2.push(s5 = new M(this.S(l()), this.S(l()), this, this.options)) : s5 = i2[e3], s5._$AI(h2), e3++;
    e3 < i2.length && (this._$AR(s5 && s5._$AB.nextSibling, e3), i2.length = e3);
  }
  _$AR(t2 = this._$AA.nextSibling, i2) {
    var _a2;
    for ((_a2 = this._$AP) == null ? void 0 : _a2.call(this, false, true, i2); t2 && t2 !== this._$AB; ) {
      const i3 = t2.nextSibling;
      t2.remove(), t2 = i3;
    }
  }
  setConnected(t2) {
    var _a2;
    void 0 === this._$AM && (this._$Cv = t2, (_a2 = this._$AP) == null ? void 0 : _a2.call(this, t2));
  }
}
class R {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i2, s5, e3, h2) {
    this.type = 1, this._$AH = T, this._$AN = void 0, this.element = t2, this.name = i2, this._$AM = e3, this.options = h2, s5.length > 2 || "" !== s5[0] || "" !== s5[1] ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = T;
  }
  _$AI(t2, i2 = this, s5, e3) {
    const h2 = this.strings;
    let o2 = false;
    if (void 0 === h2)
      t2 = N(this, t2, i2, 0), o2 = !c$1(t2) || t2 !== this._$AH && t2 !== w, o2 && (this._$AH = t2);
    else {
      const e4 = t2;
      let n3, r2;
      for (t2 = h2[0], n3 = 0; n3 < h2.length - 1; n3++)
        r2 = N(this, e4[s5 + n3], i2, n3), r2 === w && (r2 = this._$AH[n3]), o2 || (o2 = !c$1(r2) || r2 !== this._$AH[n3]), r2 === T ? t2 = T : t2 !== T && (t2 += (r2 ?? "") + h2[n3 + 1]), this._$AH[n3] = r2;
    }
    o2 && !e3 && this.j(t2);
  }
  j(t2) {
    t2 === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
}
class k extends R {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t2) {
    this.element[this.name] = t2 === T ? void 0 : t2;
  }
}
class H extends R {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== T);
  }
}
class I extends R {
  constructor(t2, i2, s5, e3, h2) {
    super(t2, i2, s5, e3, h2), this.type = 5;
  }
  _$AI(t2, i2 = this) {
    if ((t2 = N(this, t2, i2, 0) ?? T) === w)
      return;
    const s5 = this._$AH, e3 = t2 === T && s5 !== T || t2.capture !== s5.capture || t2.once !== s5.once || t2.passive !== s5.passive, h2 = t2 !== T && (s5 === T || e3);
    e3 && this.element.removeEventListener(this.name, this, s5), h2 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    var _a2;
    "function" == typeof this._$AH ? this._$AH.call(((_a2 = this.options) == null ? void 0 : _a2.host) ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
}
class L {
  constructor(t2, i2, s5) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i2, this.options = s5;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    N(this, t2);
  }
}
const Z = t$1.litHtmlPolyfillSupport;
Z == null ? void 0 : Z(V, M), (t$1.litHtmlVersions ?? (t$1.litHtmlVersions = [])).push("3.1.2");
const j = (t2, i2, s5) => {
  const e3 = (s5 == null ? void 0 : s5.renderBefore) ?? i2;
  let h2 = e3._$litPart$;
  if (void 0 === h2) {
    const t3 = (s5 == null ? void 0 : s5.renderBefore) ?? null;
    e3._$litPart$ = h2 = new M(i2.insertBefore(l(), t3), t3, void 0, s5 ?? {});
  }
  return h2._$AI(t2), h2;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$3 = class s extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a2;
    const t2 = super.createRenderRoot();
    return (_a2 = this.renderOptions).renderBefore ?? (_a2.renderBefore = t2.firstChild), t2;
  }
  update(t2) {
    const i2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = j(i2, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a2;
    super.connectedCallback(), (_a2 = this._$Do) == null ? void 0 : _a2.setConnected(true);
  }
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback(), (_a2 = this._$Do) == null ? void 0 : _a2.setConnected(false);
  }
  render() {
    return w;
  }
};
s$3._$litElement$ = true, s$3["finalized"] = true, (_a = globalThis.litElementHydrateSupport) == null ? void 0 : _a.call(globalThis, { LitElement: s$3 });
const r$2 = globalThis.litElementPolyfillSupport;
r$2 == null ? void 0 : r$2({ LitElement: s$3 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = (t2) => (e3, o2) => {
  void 0 !== o2 ? o2.addInitializer(() => {
    customElements.define(t2, e3);
  }) : customElements.define(t2, e3);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o = { attribute: true, type: String, converter: u$1, reflect: false, hasChanged: f$1 }, r$1 = (t2 = o, e3, r2) => {
  const { kind: n3, metadata: i2 } = r2;
  let s5 = globalThis.litPropertyMetadata.get(i2);
  if (void 0 === s5 && globalThis.litPropertyMetadata.set(i2, s5 = /* @__PURE__ */ new Map()), s5.set(r2.name, t2), "accessor" === n3) {
    const { name: o2 } = r2;
    return { set(r3) {
      const n4 = e3.get.call(this);
      e3.set.call(this, r3), this.requestUpdate(o2, n4, t2);
    }, init(e4) {
      return void 0 !== e4 && this.P(o2, void 0, t2), e4;
    } };
  }
  if ("setter" === n3) {
    const { name: o2 } = r2;
    return function(r3) {
      const n4 = this[o2];
      e3.call(this, r3), this.requestUpdate(o2, n4, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n3);
};
function n$1(t2) {
  return (e3, o2) => "object" == typeof o2 ? r$1(t2, e3, o2) : ((t3, e4, o3) => {
    const r2 = e4.hasOwnProperty(o3);
    return e4.constructor.createProperty(o3, r2 ? { ...t3, wrapped: true } : t3), r2 ? Object.getOwnPropertyDescriptor(e4, o3) : void 0;
  })(t2, e3, o2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r(r2) {
  return n$1({ ...r2, state: true, attribute: false });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$2 = class s2 extends Event {
  constructor(s5, t2, e3) {
    super("context-request", { bubbles: true, composed: true }), this.context = s5, this.callback = t2, this.subscribe = e3 ?? false;
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function n2(n3) {
  return n3;
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$1 = class s3 {
  constructor(t2, s5, i2, h2) {
    if (this.subscribe = false, this.provided = false, this.value = void 0, this.t = (t3, s6) => {
      this.unsubscribe && (this.unsubscribe !== s6 && (this.provided = false, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = t3, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = true, this.callback && this.callback(t3, s6)), this.unsubscribe = s6;
    }, this.host = t2, void 0 !== s5.context) {
      const t3 = s5;
      this.context = t3.context, this.callback = t3.callback, this.subscribe = t3.subscribe ?? false;
    } else
      this.context = s5, this.callback = i2, this.subscribe = h2 ?? false;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new s$2(this.context, this.t, this.subscribe));
  }
};
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class s4 {
  get value() {
    return this.o;
  }
  set value(s5) {
    this.setValue(s5);
  }
  setValue(s5, t2 = false) {
    const i2 = t2 || !Object.is(s5, this.o);
    this.o = s5, i2 && this.updateObservers();
  }
  constructor(s5) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [s6, { disposer: t2 }] of this.subscriptions)
        s6(this.o, t2);
    }, void 0 !== s5 && (this.value = s5);
  }
  addCallback(s5, t2, i2) {
    if (!i2)
      return void s5(this.value);
    this.subscriptions.has(s5) || this.subscriptions.set(s5, { disposer: () => {
      this.subscriptions.delete(s5);
    }, consumerHost: t2 });
    const { disposer: h2 } = this.subscriptions.get(s5);
    s5(this.value, h2);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$1 = class e extends Event {
  constructor(t2) {
    super("context-provider", { bubbles: true, composed: true }), this.context = t2;
  }
};
class i extends s4 {
  constructor(s5, e3, i2) {
    var _a2, _b;
    super(void 0 !== e3.context ? e3.initialValue : i2), this.onContextRequest = (t2) => {
      const s6 = t2.composedPath()[0];
      t2.context === this.context && s6 !== this.host && (t2.stopPropagation(), this.addCallback(t2.callback, s6, t2.subscribe));
    }, this.onProviderRequest = (s6) => {
      const e4 = s6.composedPath()[0];
      if (s6.context !== this.context || e4 === this.host)
        return;
      const i3 = /* @__PURE__ */ new Set();
      for (const [s7, { consumerHost: e5 }] of this.subscriptions)
        i3.has(s7) || (i3.add(s7), e5.dispatchEvent(new s$2(this.context, s7, true)));
      s6.stopPropagation();
    }, this.host = s5, void 0 !== e3.context ? this.context = e3.context : this.context = e3, this.attachListeners(), (_b = (_a2 = this.host).addController) == null ? void 0 : _b.call(_a2, this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new e$1(this.context));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e2({ context: e3 }) {
  return (n3, i$12) => {
    const o2 = /* @__PURE__ */ new WeakMap();
    if ("object" == typeof i$12)
      return i$12.addInitializer(function() {
        o2.set(this, new i(this, { context: e3 }));
      }), { get() {
        return n3.get.call(this);
      }, set(t2) {
        var _a2;
        return (_a2 = o2.get(this)) == null ? void 0 : _a2.setValue(t2), n3.set.call(this, t2);
      }, init(t2) {
        var _a2;
        return (_a2 = o2.get(this)) == null ? void 0 : _a2.setValue(t2), t2;
      } };
    {
      n3.constructor.addInitializer((n4) => {
        o2.set(n4, new i(n4, { context: e3 }));
      });
      const r2 = Object.getOwnPropertyDescriptor(n3, i$12);
      let s5;
      if (void 0 === r2) {
        const t2 = /* @__PURE__ */ new WeakMap();
        s5 = { get: function() {
          return t2.get(this);
        }, set: function(e4) {
          o2.get(this).setValue(e4), t2.set(this, e4);
        }, configurable: true, enumerable: true };
      } else {
        const t2 = r2.set;
        s5 = { ...r2, set: function(e4) {
          o2.get(this).setValue(e4), t2 == null ? void 0 : t2.call(this, e4);
        } };
      }
      return void Object.defineProperty(n3, i$12, s5);
    }
  };
}
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function c({ context: c2, subscribe: e3 }) {
  return (o2, n3) => {
    "object" == typeof n3 ? n3.addInitializer(function() {
      new s$1(this, { context: c2, callback: (t2) => {
        this[n3.name] = t2;
      }, subscribe: e3 });
    }) : o2.constructor.addInitializer((o3) => {
      new s$1(o3, { context: c2, callback: (t2) => {
        o3[n3] = t2;
      }, subscribe: e3 });
    });
  };
}
let Main$1 = class Main extends s$3 {
  constructor(update2, getModel, setModel) {
    super();
    this.updateFn = update2;
    this.getModel = getModel;
    this.setModel = setModel;
    this.addEventListener(
      "mvu:message",
      (ev) => {
        const msg = ev.detail;
        console.log("Got message: ", msg);
        this.receive(msg);
      }
    );
  }
  receive(msg) {
    const next = this.updateFn(this.getModel(), msg);
    const promise = next;
    if (typeof (promise == null ? void 0 : promise.then) === "function") {
      promise.then((mapFn) => {
        const next2 = mapFn(this.getModel());
        console.log("Updating model in Promise:", next2);
        this.setModel(next2);
      });
    } else {
      console.log("Updating model:", next);
      this.setModel(next);
    }
  }
};
let View$1 = class View extends s$3 {
  dispatchMessage(msg, target = this) {
    const ev = new CustomEvent("mvu:message", {
      bubbles: true,
      composed: true,
      detail: msg
    });
    target.dispatchEvent(ev);
  }
};
class Dispatch {
  constructor() {
    this._handlers = /* @__PURE__ */ new Map();
    this.update = this._update.bind(this);
  }
  addMessage(type, handler) {
    console.log("Message added for dispatch:", type);
    this._handlers.set(type, handler);
  }
  // bound function
  _update(model, msg) {
    const { type } = msg;
    const handler = this._handlers.get(type);
    return handler ? handler(msg, model) : model;
  }
}
function updateProps$1(props) {
  return (m2) => Object.assign({}, m2, props);
}
function noUpdate$1(m2) {
  return m2;
}
const SERVER_ROOT = window.location.origin;
const API_PATH = "/api";
const TOKEN_KEY = "JWT_AUTH_TOKEN";
const _APIUser = class _APIUser2 {
  constructor() {
    this.authenticated = false;
    this.username = "fellow_traveler";
    this.signOut = () => {
    };
  }
  static deauthenticate(user) {
    const anon = new _APIUser2();
    console.log("Deauthenticating", user, _APIUser2._theUser);
    if (user === _APIUser2._theUser) {
      localStorage.removeItem(TOKEN_KEY);
      _APIUser2._theUser = anon;
    }
    return anon;
  }
};
_APIUser._theUser = new _APIUser();
let APIUser = _APIUser;
class AuthenticatedUser extends APIUser {
  constructor(token, signOut) {
    super();
    const base64Url = token.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const payload = decodeURIComponent(
      window.atob(base64).split("").map(function(c2) {
        return "%" + ("00" + c2.charCodeAt(0).toString(16)).slice(-2);
      }).join("")
    );
    const jsonPayload = JSON.parse(payload);
    console.log("Token payload", jsonPayload);
    this.token = token;
    this.authenticated = true;
    this.username = jsonPayload.username;
    this.signOut = signOut;
  }
  static authenticate(token, signOut) {
    const authenticatedUser = new AuthenticatedUser(
      token,
      signOut
    );
    APIUser._theUser = authenticatedUser;
    localStorage.setItem(TOKEN_KEY, token);
    return authenticatedUser;
  }
  static authenticateFromLocalStorage(signOut) {
    const priorToken = localStorage.getItem(TOKEN_KEY);
    return priorToken ? AuthenticatedUser.authenticate(priorToken, signOut) : APIUser._theUser;
  }
}
class JSONRequest {
  constructor(body) {
    this._base = API_PATH;
    this.json = body;
  }
  base(newBase = "") {
    this._base = newBase;
    return this;
  }
  get(endpoint) {
    return fetch(this._url(endpoint), {
      headers: this._headers(),
      body: this.json && JSON.stringify(this.json)
    });
  }
  post(endpoint) {
    return fetch(this._url(endpoint), {
      method: "POST",
      headers: this._headers(),
      body: this.json && JSON.stringify(this.json)
    });
  }
  put(endpoint) {
    return fetch(this._url(endpoint), {
      method: "PUT",
      headers: this._headers(),
      body: this.json && JSON.stringify(this.json)
    });
  }
  _headers() {
    const hasBody = this.json !== void 0;
    const isAuthenticated = APIUser._theUser.authenticated;
    const contentType = { "Content-Type": "application/json" };
    if (isAuthenticated) {
      const token = APIUser._theUser.token;
      const authorization = {
        Authorization: `Bearer ${token}`
      };
      if (hasBody)
        return { ...contentType, ...authorization };
      else
        return authorization;
    } else {
      if (hasBody)
        return { ...contentType };
      else
        return void 0;
    }
  }
  _url(path) {
    return `${SERVER_ROOT}${this._base}${path}`;
  }
}
class FormDataRequest extends JSONRequest {
  constructor(body) {
    super(Object.fromEntries(body));
  }
}
class APIRequest extends JSONRequest {
  constructor() {
    super(void 0);
  }
}
var __defProp$j = Object.defineProperty;
var __getOwnPropDesc$j = Object.getOwnPropertyDescriptor;
var __decorateClass$j = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$j(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$j(target, key, result);
  return result;
};
const context = n2("BlazingModel");
const init = {
  user: new APIUser()
};
class Main2 extends Main$1 {
  constructor(update2) {
    super(
      update2,
      () => this.model,
      (next) => this.model = next
    );
    this.model = init;
  }
}
__decorateClass$j([
  e2({ context }),
  r()
], Main2.prototype, "model", 2);
class View2 extends View$1 {
  getFromModel(key) {
    if (this._model) {
      return this._model[key];
    }
  }
}
__decorateClass$j([
  c({ context, subscribe: true }),
  n$1({ attribute: false })
], View2.prototype, "_model", 2);
const createDispatch = () => new Dispatch();
const updateProps = updateProps$1;
const noUpdate = noUpdate$1;
const months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
const formatDate = (date) => {
  const dt = (typeof date === "string" ? new Date(date) : date) || /* @__PURE__ */ new Date();
  const m2 = months[dt.getUTCMonth()];
  const d2 = dt.getUTCDate();
  return `${d2} ${m2}`;
};
function convertStartEndDates(obj) {
  const datestrings = obj;
  let result = obj;
  result.startDate = new Date(datestrings.startDate);
  result.endDate = new Date(datestrings.endDate);
  return result;
}
var __defProp$i = Object.defineProperty;
var __getOwnPropDesc$i = Object.getOwnPropertyDescriptor;
var __decorateClass$i = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$i(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$i(target, key, result);
  return result;
};
let CalendarWidget = class extends s$3 {
  constructor() {
    super(...arguments);
    this.startDate = Date.now().toString();
    this.endDate = Date.now().toString();
  }
  _handleChange(value) {
    const selectionEvent = new CustomEvent(
      "calendar-widget:select",
      {
        bubbles: true,
        detail: { date: value ? new Date(value) : value }
      }
    );
    this.dispatchEvent(selectionEvent);
  }
  _handleClear() {
    var _a2;
    const current = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector(
      "input:checked"
    );
    if (current) {
      current.checked = false;
    }
    const clearEvent = new CustomEvent(
      "calendar-widget:clear",
      { bubbles: true }
    );
    this.dispatchEvent(clearEvent);
  }
  render() {
    const start = new Date(this.startDate);
    const end = new Date(this.endDate);
    const dates = datesInRange(start, end);
    const renderDate = (d2) => {
      const ymd = {
        d: d2.getUTCDate(),
        m: d2.getUTCMonth() + 1,
        y: d2.getUTCFullYear(),
        day: d2.getUTCDay()
      };
      const format = ({
        y: y2,
        m: m2,
        d: d22
      }) => [y2, m2, d22].join("-");
      return x`
        <label style="grid-column: ${ymd.day + 1}">
          ${ymd.d}
          <input
            type="radio"
            name="cal"
            value="${format(ymd)}" />
        </label>
      `;
    };
    return x` <section>
      <fieldset
        @change="${(event) => {
      const target = event.target;
      this._handleChange(target.value);
    }}">
        <h6>Su</h6>
        <h6>Mo</h6>
        <h6>Tu</h6>
        <h6>We</h6>
        <h6>Th</h6>
        <h6>Fr</h6>
        <h6>Sa</h6>
        ${dates.map(renderDate)}
      </fieldset>
      <button id="clear" @click="${() => this._handleClear()}">
        Clear Selection
      </button>
    </section>`;
  }
};
CalendarWidget.styles = i$3`
    * {
      margin: 0;
      box-sizing: border-box;
    }

    fieldset {
      display: grid;
      grid-template-columns: repeat(7, 2rem);
      gap: var(--size-spacing-small);
      justify-content: center;
      justify-items: streth;
      border: 0;
      padding: 0;
    }

    h6 {
      text-align: center;
    }

    label {
      position: relative;
      width: 100%;
      height: 100%;
      aspect-ratio: 1;
      padding: var(--size-spacing-small);
      white-space: nowrap;
      text-align: center;
      background-color: var(--color-background-control);
      border: var(--line-weight-fine) solid var(--color-accent);
      color: var(--color-text-control);
      font-size: var(--size-type-small);
      z-index: 0;
    }

    input {
      appearance: none;
      background: white;
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      z-index: -1;
    }

    input:checked {
      background: var(--color-accent);
    }

    label:has(input:checked) {
      background-color: var(--color-accent);
      color: var(--color-text-control-inverted);
    }

    button {
      display: block;
      margin: 0 auto;
    }
  `;
__decorateClass$i([
  n$1({ attribute: "start-date", type: Date })
], CalendarWidget.prototype, "startDate", 2);
__decorateClass$i([
  n$1({ attribute: "end-date", type: Date })
], CalendarWidget.prototype, "endDate", 2);
CalendarWidget = __decorateClass$i([
  t("calendar-widget")
], CalendarWidget);
function datesInRange(start, end) {
  const endTime = end ? end.getTime() : start.getTime();
  let result = [];
  let i2 = new Date(start);
  while (i2.getTime() <= endTime) {
    result.push(new Date(i2));
    i2.setUTCDate(i2.getUTCDate() + 1);
  }
  return result;
}
var __defProp$h = Object.defineProperty;
var __getOwnPropDesc$h = Object.getOwnPropertyDescriptor;
var __decorateClass$h = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$h(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$h(target, key, result);
  return result;
};
let EntourageTable = class extends s$3 {
  get entourage() {
    return this.using || {};
  }
  render() {
    const { name, people } = this.entourage;
    const rows = people || [];
    const link = this.href ? x`
          <a href=${this.href}>Chat Now...</a>
        ` : "";
    const renderRow = (row) => {
      const {
        userid,
        avatar,
        name: name2 = "** NO NAME **",
        nickname,
        color
      } = row;
      const avatarImg = avatar ? x`
            <img src="${avatar}" />
          ` : (nickname || name2).slice(0, 1);
      const colorStyle = color ? `style="--color-avatar-bg: ${color}"` : "";
      return x`
        <tr>
          <td>
            <span class="avatar" ${colorStyle}>
              ${avatarImg}
            </span>
          </td>
          <td class="name">
            <a href="./profile/${userid}">${name2}</a>
          </td>
        </tr>
      `;
    };
    return x`
      <section>
        <h3>${name || "Entourage"}</h3>
        ${link}
        <table>
          <tbody>${rows.map(renderRow)}</tbody>
        </table>
      </section>
    `;
  }
};
EntourageTable.styles = i$3`
    :host {
      --color-avatar-bg: var(--color-accent);
    }
    * {
      margin: 0;
      box-sizing: border-box;
    }
    table {
      width: 100%;
    }
    thead {
      font-size: var(--size-font-min);
    }
    th,
    td {
      padding: 0 var(--size-spacing-small);
      vertical-align: middle;
    }
    .avatar {
      display: inline-block;
      position: relative;
      width: var(--size-icon-medium);
      aspect-ratio: 1;
      background-color: var(--color-avatar-bg);
      border-radius: 50%;
      text-align: center;
      font-size: calc(0.66 * var(--size-icon-medium));
      font-family: var(--font-family-display);
      color: var(--color-link-inverted);
      overflow: hidden;
    }
    .name {
      width: 100%;
      font-family: var(--font-family-display);
      color: var(--color-accent);
    }
    a[href] {
      font: inherit;
      color: inherit;
    }
    img {
      width: 100%;
    }
  `;
__decorateClass$h([
  n$1({ attribute: false })
], EntourageTable.prototype, "using", 2);
__decorateClass$h([
  n$1()
], EntourageTable.prototype, "href", 2);
EntourageTable = __decorateClass$h([
  t("entourage-table")
], EntourageTable);
var __defProp$g = Object.defineProperty;
var __getOwnPropDesc$g = Object.getOwnPropertyDescriptor;
var __decorateClass$g = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$g(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$g(target, key, result);
  return result;
};
let ItineraryItemElement = class extends s$3 {
  constructor() {
    super(...arguments);
    this.startDate = "1970-01-01";
    this.hidden = false;
    this._calendar_widget_select = (_2) => {
    };
    this._calendar_widget_clear = (_2) => {
    };
  }
  render() {
    const item = this.renderItem();
    return x`
      <span id="dates">
        <time datetime=${this.startDate}>
          ${formatDate(this.startDate)}
        </time>
        ${this.endDate ? x` <time datetime=${this.endDate}>
              ${formatDate(this.endDate)}
            </time>` : null}
      </span>
      ${item}
    `;
  }
  renderItem() {
    return x`<slot></slot>`;
  }
  connectedCallback() {
    const hideOrShow = (event) => {
      const selectionEvent = event;
      const selectedDate = selectionEvent.detail.date;
      const hidden = selectedDate < new Date(this.startDate) || selectedDate > new Date(this.endDate || this.startDate);
      if (hidden) {
        console.log("Hiding item", this);
        this.setAttribute("hidden", "hidden");
      } else {
        console.log("Revealing item", this);
        this.removeAttribute("hidden");
      }
    };
    const showAll = (_2) => {
      this.removeAttribute("hidden");
    };
    document.addEventListener(
      "calendar-widget:select",
      this._calendar_widget_select = hideOrShow
    );
    document.addEventListener(
      "calendar-widget:clear",
      this._calendar_widget_clear = showAll
    );
    super.connectedCallback();
  }
  disconnectedCallback() {
    document.removeEventListener(
      "calendar-widget:select",
      this._calendar_widget_select
    );
    document.removeEventListener(
      "calendar-widget:clear",
      this._calendar_widget_clear
    );
    super.disconnectedCallback();
  }
};
ItineraryItemElement.styles = i$3`
    * {
      margin: 0;
      box-sizing: border-box;
    }
    :host(*) {
      display: contents;
    }
    :host([hidden]) {
      display: none;
    }
    #dates {
      display: flex;
      grid-column: start;
      place-self: stretch;
      flex-direction: column;
      justify-content: space-between;
      height: 100%;
      font-size: var(--size-type-small);
      font-family: var(--font-family-display);
      border-bottom: var(--line-weight-superfine) solid
        var(--color-accent);
    }
    #dates time {
      white-space: nowrap;
    }
    #dates time:first-child {
      font-weight: var(--font-weight-bold);
    }
    #dates time + time {
      visibility: hidden;
    }
    .destination {
      grid-column: primary/end;
      background: var(--color-background-card);
      border-radius: var(--size-corner-medium);
      aspect-ratio: 16/9;
      background-size: cover;
      background-position: left 25%;
    }
    .transportation {
      display: grid;
      grid-column: primary/end;
      grid-template-columns: subgrid;
      align-items: center;
    }
    .transportation > h3 {
      display: contents;
      font-size: var(--size-type-mlarge);
      font-style: oblique;
    }
    .destination > h3 {
      padding: 0 var(--size-spacing-medium);
    }
    .destination[style] > h3 {
      color: var(--color-text-inverted);
      text-decoration: none;
      font-weight: var(--font-weight-bold;);
      text-shadow: var(--shadow-dropdown);
      text-align: right;
    }
    .transportation > h3 > :first-child {
      text-align: right;
    }
    ::slotted([slot="via"]) {
      font-weight: var(--font-weight-light);
      font-style: normal;
      font-size: 75%;
    }
    ::slotted([slot="via"])::before {
      display: inline;
      content: "via ";
    }
    h3 {
      font-family: var(--font-family-display);
      font-size: var(--size-type-large);
      font-weight: var(--font-weight-normal);
      color: var(--color-accent);
    }
    a {
      color: inherit;
      text-decoration: none;
    }
    a.itemLink {
      display: contents;
    }
    svg.icon {
      display: inline;
      fill: currentColor;
      height: var(--size-icon-large);
      width: var(--size-icon-large);
      vertical-align: middle;
    }
  `;
__decorateClass$g([
  n$1({ attribute: "start-date" })
], ItineraryItemElement.prototype, "startDate", 2);
__decorateClass$g([
  n$1({ attribute: "end-date" })
], ItineraryItemElement.prototype, "endDate", 2);
__decorateClass$g([
  n$1()
], ItineraryItemElement.prototype, "href", 2);
__decorateClass$g([
  n$1({ reflect: true, type: Boolean })
], ItineraryItemElement.prototype, "hidden", 2);
ItineraryItemElement = __decorateClass$g([
  t("itinerary-item")
], ItineraryItemElement);
let ItineraryDestinationElement = class extends ItineraryItemElement {
  renderItem() {
    const content = x`<slot></slot>`;
    const link = this.href ? x`<a class="itemLink" href="${this.href}"
          >${content}</a
        >` : content;
    const style = this.imgSrc ? `background-image: url(${this.imgSrc})` : "";
    return x`<section class="destination" style=${style}>
      <h3>${link}</h3>
    </section>`;
  }
};
__decorateClass$g([
  n$1({ attribute: "img-src" })
], ItineraryDestinationElement.prototype, "imgSrc", 2);
ItineraryDestinationElement = __decorateClass$g([
  t("itinerary-destination")
], ItineraryDestinationElement);
let ItineraryTransportationElement = class extends ItineraryItemElement {
  renderItem() {
    const icons = {
      air: "icon-airplane",
      rail: "icon-train"
    };
    const iconId = this.type ? icons[this.type] : "icon-default";
    return x`<section class="transportation">
      <h3 class="subgrid">
        <span>
          <slot name="origin">BGN</slot>
        </span>
        <svg class="icon">
          <use href="/icons/transportation.svg#${iconId}" />
        </svg>
        <span>
          <slot name="terminus">END</slot>
          <slot name="via"></slot>
        </span>
      </h3>
    </section>`;
  }
};
__decorateClass$g([
  n$1()
], ItineraryTransportationElement.prototype, "type", 2);
ItineraryTransportationElement = __decorateClass$g([
  t("itinerary-transportation")
], ItineraryTransportationElement);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var mapboxGl = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var shared, worker, mapboxgl2;
    function define(_2, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl2 = chunk(sharedChunk);
        if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
          mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
    }
    define(["exports"], function(e3) {
      var t2 = "undefined" != typeof self ? self : {}, i2 = "3.1.2";
      let r2;
      const n3 = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        if (null == r2) {
          const e4 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          try {
            r2 = null != {}.API_URL_REGEX ? new RegExp({}.API_URL_REGEX) : e4;
          } catch (t3) {
            r2 = e4;
          }
        }
        return r2;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        if (!n3.API_URL)
          return null;
        try {
          const e4 = new URL(n3.API_URL);
          return "api.mapbox.cn" === e4.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === e4.hostname ? "https://events.mapbox.com/events/v2" : null;
        } catch (e4) {
          return null;
        }
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf" }, o2 = { supported: false, testSupport: function(e4) {
        !l2 && a2 && (c2 ? h2(e4) : s5 = e4);
      } };
      let s5, a2, l2 = false, c2 = false;
      function h2(e4) {
        const t3 = e4.createTexture();
        e4.bindTexture(e4.TEXTURE_2D, t3);
        try {
          if (e4.texImage2D(e4.TEXTURE_2D, 0, e4.RGBA, e4.RGBA, e4.UNSIGNED_BYTE, a2), e4.isContextLost())
            return;
          o2.supported = true;
        } catch (e5) {
        }
        e4.deleteTexture(t3), l2 = true;
      }
      t2.document && (a2 = t2.document.createElement("img"), a2.onload = function() {
        s5 && h2(s5), s5 = null, c2 = true;
      }, a2.onerror = function() {
        l2 = true, s5 = null;
      }, a2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const u2 = "01";
      function d2(e4) {
        return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
      }
      var p2 = f2;
      function f2(e4, t3, i3, r3) {
        this.cx = 3 * e4, this.bx = 3 * (i3 - e4) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t3, this.by = 3 * (r3 - t3) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e4, this.p1y = t3, this.p2x = i3, this.p2y = r3;
      }
      f2.prototype = { sampleCurveX: function(e4) {
        return ((this.ax * e4 + this.bx) * e4 + this.cx) * e4;
      }, sampleCurveY: function(e4) {
        return ((this.ay * e4 + this.by) * e4 + this.cy) * e4;
      }, sampleCurveDerivativeX: function(e4) {
        return (3 * this.ax * e4 + 2 * this.bx) * e4 + this.cx;
      }, solveCurveX: function(e4, t3) {
        if (void 0 === t3 && (t3 = 1e-6), e4 < 0)
          return 0;
        if (e4 > 1)
          return 1;
        for (var i3 = e4, r3 = 0; r3 < 8; r3++) {
          var n4 = this.sampleCurveX(i3) - e4;
          if (Math.abs(n4) < t3)
            return i3;
          var o3 = this.sampleCurveDerivativeX(i3);
          if (Math.abs(o3) < 1e-6)
            break;
          i3 -= n4 / o3;
        }
        var s6 = 0, a3 = 1;
        for (i3 = e4, r3 = 0; r3 < 20 && (n4 = this.sampleCurveX(i3), !(Math.abs(n4 - e4) < t3)); r3++)
          e4 > n4 ? s6 = i3 : a3 = i3, i3 = 0.5 * (a3 - s6) + s6;
        return i3;
      }, solve: function(e4, t3) {
        return this.sampleCurveY(this.solveCurveX(e4, t3));
      } };
      var m2 = d2(p2), _2 = g2;
      function g2(e4, t3) {
        this.x = e4, this.y = t3;
      }
      g2.prototype = { clone: function() {
        return new g2(this.x, this.y);
      }, add: function(e4) {
        return this.clone()._add(e4);
      }, sub: function(e4) {
        return this.clone()._sub(e4);
      }, multByPoint: function(e4) {
        return this.clone()._multByPoint(e4);
      }, divByPoint: function(e4) {
        return this.clone()._divByPoint(e4);
      }, mult: function(e4) {
        return this.clone()._mult(e4);
      }, div: function(e4) {
        return this.clone()._div(e4);
      }, rotate: function(e4) {
        return this.clone()._rotate(e4);
      }, rotateAround: function(e4, t3) {
        return this.clone()._rotateAround(e4, t3);
      }, matMult: function(e4) {
        return this.clone()._matMult(e4);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(e4) {
        return this.x === e4.x && this.y === e4.y;
      }, dist: function(e4) {
        return Math.sqrt(this.distSqr(e4));
      }, distSqr: function(e4) {
        var t3 = e4.x - this.x, i3 = e4.y - this.y;
        return t3 * t3 + i3 * i3;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(e4) {
        return Math.atan2(this.y - e4.y, this.x - e4.x);
      }, angleWith: function(e4) {
        return this.angleWithSep(e4.x, e4.y);
      }, angleWithSep: function(e4, t3) {
        return Math.atan2(this.x * t3 - this.y * e4, this.x * e4 + this.y * t3);
      }, _matMult: function(e4) {
        var t3 = e4[2] * this.x + e4[3] * this.y;
        return this.x = e4[0] * this.x + e4[1] * this.y, this.y = t3, this;
      }, _add: function(e4) {
        return this.x += e4.x, this.y += e4.y, this;
      }, _sub: function(e4) {
        return this.x -= e4.x, this.y -= e4.y, this;
      }, _mult: function(e4) {
        return this.x *= e4, this.y *= e4, this;
      }, _div: function(e4) {
        return this.x /= e4, this.y /= e4, this;
      }, _multByPoint: function(e4) {
        return this.x *= e4.x, this.y *= e4.y, this;
      }, _divByPoint: function(e4) {
        return this.x /= e4.x, this.y /= e4.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var e4 = this.y;
        return this.y = this.x, this.x = -e4, this;
      }, _rotate: function(e4) {
        var t3 = Math.cos(e4), i3 = Math.sin(e4), r3 = i3 * this.x + t3 * this.y;
        return this.x = t3 * this.x - i3 * this.y, this.y = r3, this;
      }, _rotateAround: function(e4, t3) {
        var i3 = Math.cos(e4), r3 = Math.sin(e4), n4 = t3.y + r3 * (this.x - t3.x) + i3 * (this.y - t3.y);
        return this.x = t3.x + i3 * (this.x - t3.x) - r3 * (this.y - t3.y), this.y = n4, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, g2.convert = function(e4) {
        return e4 instanceof g2 ? e4 : Array.isArray(e4) ? new g2(e4[0], e4[1]) : e4;
      };
      var y2 = d2(_2);
      function x2(e4, t3) {
        if (Array.isArray(e4)) {
          if (!Array.isArray(t3) || e4.length !== t3.length)
            return false;
          for (let i3 = 0; i3 < e4.length; i3++)
            if (!x2(e4[i3], t3[i3]))
              return false;
          return true;
        }
        if ("object" == typeof e4 && null !== e4 && null !== t3) {
          if ("object" != typeof t3)
            return false;
          if (Object.keys(e4).length !== Object.keys(t3).length)
            return false;
          for (const i3 in e4)
            if (!x2(e4[i3], t3[i3]))
              return false;
          return true;
        }
        return e4 === t3;
      }
      const v2 = Math.PI / 180, b2 = 180 / Math.PI;
      function w2(e4) {
        return e4 * v2;
      }
      function T2(e4) {
        return e4 * b2;
      }
      const E2 = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function M2(e4) {
        if (e4 <= 0)
          return 0;
        if (e4 >= 1)
          return 1;
        const t3 = e4 * e4, i3 = t3 * e4;
        return 4 * (e4 < 0.5 ? i3 : 3 * (e4 - t3) + i3 - 0.75);
      }
      function A2(e4) {
        let t3 = 1 / 0, i3 = 1 / 0, r3 = -1 / 0, n4 = -1 / 0;
        for (const o3 of e4)
          t3 = Math.min(t3, o3.x), i3 = Math.min(i3, o3.y), r3 = Math.max(r3, o3.x), n4 = Math.max(n4, o3.y);
        return { min: new y2(t3, i3), max: new y2(r3, n4) };
      }
      function S2(e4, t3, i3 = 0, r3 = true) {
        const n4 = new y2(i3, i3), o3 = e4.sub(n4), s6 = t3.add(n4), a3 = [o3, new y2(s6.x, o3.y), s6, new y2(o3.x, s6.y)];
        return r3 && a3.push(o3.clone()), a3;
      }
      function I2(e4, t3, i3, r3) {
        const n4 = new m2(e4, t3, i3, r3);
        return function(e5) {
          return n4.solve(e5);
        };
      }
      const C2 = I2(0.25, 0.1, 0.25, 1);
      function z(e4, t3, i3) {
        return Math.min(i3, Math.max(t3, e4));
      }
      function P2(e4, t3, i3) {
        return (i3 = z((i3 - e4) / (t3 - e4), 0, 1)) * i3 * (3 - 2 * i3);
      }
      function D(e4, t3, i3) {
        const r3 = i3 - t3, n4 = ((e4 - t3) % r3 + r3) % r3 + t3;
        return n4 === t3 ? i3 : n4;
      }
      function R2(e4, t3, i3) {
        if (!e4.length)
          return i3(null, []);
        let r3 = e4.length;
        const n4 = new Array(e4.length);
        let o3 = null;
        e4.forEach((e5, s6) => {
          t3(e5, (e6, t4) => {
            e6 && (o3 = e6), n4[s6] = t4, 0 == --r3 && i3(o3, n4);
          });
        });
      }
      function L2(e4) {
        const t3 = [];
        for (const i3 in e4)
          t3.push(e4[i3]);
        return t3;
      }
      function k2(e4, ...t3) {
        for (const i3 of t3)
          for (const t4 in i3)
            e4[t4] = i3[t4];
        return e4;
      }
      function O(e4, t3) {
        const i3 = {};
        for (let r3 = 0; r3 < t3.length; r3++) {
          const n4 = t3[r3];
          n4 in e4 && (i3[n4] = e4[n4]);
        }
        return i3;
      }
      let B = 1;
      function F() {
        return B++;
      }
      function N2() {
        return function e4(t3) {
          return t3 ? (t3 ^ Math.random() * (16 >> t3 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, e4);
        }();
      }
      function U(e4) {
        return e4 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e4) / Math.LN2));
      }
      function V2(e4) {
        return !!e4 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e4);
      }
      function j2(e4, t3) {
        e4.forEach((e5) => {
          t3[e5] && (t3[e5] = t3[e5].bind(t3));
        });
      }
      function G(e4, t3) {
        return -1 !== e4.indexOf(t3, e4.length - t3.length);
      }
      function q(e4, t3, i3) {
        const r3 = {};
        for (const n4 in e4)
          r3[n4] = t3.call(i3 || this, e4[n4], n4, e4);
        return r3;
      }
      function Z2(e4, t3, i3) {
        const r3 = {};
        for (const n4 in e4)
          t3.call(i3 || this, e4[n4], n4, e4) && (r3[n4] = e4[n4]);
        return r3;
      }
      function $2(e4) {
        return Array.isArray(e4) ? e4.map($2) : "object" == typeof e4 && e4 ? q(e4, $2) : e4;
      }
      const W = {};
      function H2(e4) {
        W[e4] || ("undefined" != typeof console && console.warn(e4), W[e4] = true);
      }
      function X(e4, t3, i3) {
        return (i3.y - e4.y) * (t3.x - e4.x) > (t3.y - e4.y) * (i3.x - e4.x);
      }
      function Y(e4) {
        let t3 = 0;
        for (let i3, r3, n4 = 0, o3 = e4.length, s6 = o3 - 1; n4 < o3; s6 = n4++)
          i3 = e4[n4], r3 = e4[s6], t3 += (r3.x - i3.x) * (i3.y + r3.y);
        return t3;
      }
      function K([e4, t3, i3]) {
        const r3 = w2(t3 + 90), n4 = w2(i3);
        return { x: e4 * Math.cos(r3) * Math.sin(n4), y: e4 * Math.sin(r3) * Math.sin(n4), z: e4 * Math.cos(n4), azimuthal: t3, polar: i3 };
      }
      function J(e4, t3, i3) {
        const r3 = Math.sqrt(e4 * e4 + t3 * t3 + i3 * i3), n4 = r3 > 0 ? Math.acos(i3 / r3) * b2 : 0;
        let o3 = 0 !== e4 || 0 !== t3 ? Math.atan2(-t3, -e4) * b2 + 90 : 0;
        return o3 < 0 && (o3 += 360), [r3, o3, n4];
      }
      function Q() {
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
      }
      function ee(e4) {
        const t3 = {};
        if (e4.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (e5, i3, r3, n4) => {
          const o3 = r3 || n4;
          return t3[i3] = !o3 || o3.toLowerCase(), "";
        }), t3["max-age"]) {
          const e5 = parseInt(t3["max-age"], 10);
          isNaN(e5) ? delete t3["max-age"] : t3["max-age"] = e5;
        }
        return t3;
      }
      let te = null;
      function ie() {
        return !!t2.document.fullscreenElement || !!t2.document.webkitFullscreenElement;
      }
      function re(e4) {
        try {
          const i3 = t2[e4];
          return i3.setItem("_mapbox_test_", 1), i3.removeItem("_mapbox_test_"), true;
        } catch (e5) {
          return false;
        }
      }
      function ne(e4, t3) {
        return [e4[4 * t3], e4[4 * t3 + 1], e4[4 * t3 + 2], e4[4 * t3 + 3]];
      }
      function oe(e4, t3, i3) {
        e4[4 * t3 + 0] = i3[0], e4[4 * t3 + 1] = i3[1], e4[4 * t3 + 2] = i3[2], e4[4 * t3 + 3] = i3[3];
      }
      function se(e4, t3) {
        return [Math.pow(e4[0], 2.2) * t3, Math.pow(e4[1], 2.2) * t3, Math.pow(e4[2], 2.2) * t3];
      }
      function ae(e4) {
        return [Math.pow(e4[0], 1 / 2.2), Math.pow(e4[1], 1 / 2.2), Math.pow(e4[2], 1 / 2.2)];
      }
      const le = "mapbox-tiles";
      let ce = 500, he = 50;
      let ue, de;
      function pe() {
        try {
          return t2.caches;
        } catch (e4) {
        }
      }
      function fe() {
        pe() && !ue && (ue = t2.caches.open(le));
      }
      function me(e4) {
        const t3 = e4.indexOf("?");
        if (t3 < 0)
          return e4;
        const i3 = function(e5) {
          const t4 = e5.indexOf("?");
          return t4 > 0 ? e5.slice(t4 + 1).split("&") : [];
        }(e4), r3 = i3.filter((e5) => {
          const t4 = e5.split("=");
          return "language" === t4[0] || "worldview" === t4[0];
        });
        return r3.length ? `${e4.slice(0, t3)}?${r3.join("&")}` : e4.slice(0, t3);
      }
      let _e = 1 / 0;
      function ge(e4) {
        _e++, _e > he && (e4.getActor().send("enforceCacheSizeLimit", ce), _e = 0);
      }
      const ye = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image", Model: "Model" };
      "function" == typeof Object.freeze && Object.freeze(ye);
      class xe extends Error {
        constructor(e4, t3, i3) {
          401 === t3 && De(i3) && (e4 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e4), this.status = t3, this.url = i3;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const ve = Q() ? () => self.worker && self.worker.referrer : () => ("blob:" === t2.location.protocol ? t2.parent : t2).location.href;
      const be = function(e4, i3) {
        if (!(/^file:/.test(r3 = e4.url) || /^file:/.test(ve()) && !/^\w+:/.test(r3))) {
          if (t2.fetch && t2.Request && t2.AbortController && t2.Request.prototype.hasOwnProperty("signal"))
            return function(e5, i4) {
              const r4 = new t2.AbortController(), n4 = new t2.Request(e5.url, { method: e5.method || "GET", body: e5.body, credentials: e5.credentials, headers: e5.headers, referrer: ve(), referrerPolicy: e5.referrerPolicy, signal: r4.signal });
              let o3 = false, s6 = false;
              const a3 = (l3 = n4.url).indexOf("sku=") > 0 && De(l3);
              var l3;
              "json" === e5.type && n4.headers.set("Accept", "application/json");
              const c3 = (r5, o4, l4) => {
                if (s6)
                  return;
                if (r5 && "SecurityError" !== r5.message && H2(r5.toString()), o4 && l4)
                  return h3(o4);
                const c4 = Date.now();
                t2.fetch(n4).then((t3) => {
                  if (t3.ok) {
                    const e6 = a3 ? t3.clone() : null;
                    return h3(t3, e6, c4);
                  }
                  return i4(new xe(t3.statusText, t3.status, e5.url));
                }).catch((t3) => {
                  "AbortError" !== t3.name && i4(new Error(`${t3.message} ${e5.url}`));
                });
              }, h3 = (r5, a4, l4) => {
                ("arrayBuffer" === e5.type ? r5.arrayBuffer() : "json" === e5.type ? r5.json() : r5.text()).then((e6) => {
                  s6 || (a4 && l4 && function(e7, i5, r6) {
                    if (fe(), !ue)
                      return;
                    const n5 = { status: i5.status, statusText: i5.statusText, headers: new t2.Headers() };
                    i5.headers.forEach((e8, t3) => n5.headers.set(t3, e8));
                    const o4 = ee(i5.headers.get("Cache-Control") || "");
                    if (o4["no-store"])
                      return;
                    o4["max-age"] && n5.headers.set("Expires", new Date(r6 + 1e3 * o4["max-age"]).toUTCString());
                    const s7 = n5.headers.get("Expires");
                    s7 && (new Date(s7).getTime() - r6 < 42e4 || function(e8, t3) {
                      if (void 0 === de)
                        try {
                          new Response(new ReadableStream()), de = true;
                        } catch (e9) {
                          de = false;
                        }
                      de ? t3(e8.body) : e8.blob().then(t3);
                    }(i5, (i6) => {
                      const r7 = new t2.Response(i6, n5);
                      fe(), ue && ue.then((t3) => t3.put(me(e7.url), r7)).catch((e8) => H2(e8.message));
                    }));
                  }(n4, a4, l4), o3 = true, i4(null, e6, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
                }).catch((e6) => {
                  s6 || i4(new Error(e6.message));
                });
              };
              return a3 ? function(e6, t3) {
                if (fe(), !ue)
                  return t3(null);
                const i5 = me(e6.url);
                ue.then((e7) => {
                  e7.match(i5).then((r5) => {
                    const n5 = function(e8) {
                      if (!e8)
                        return false;
                      const t4 = new Date(e8.headers.get("Expires") || 0), i6 = ee(e8.headers.get("Cache-Control") || "");
                      return t4 > Date.now() && !i6["no-cache"];
                    }(r5);
                    e7.delete(i5), n5 && e7.put(i5, r5.clone()), t3(null, r5, n5);
                  }).catch(t3);
                }).catch(t3);
              }(n4, c3) : c3(null, null), { cancel: () => {
                s6 = true, o3 || r4.abort();
              } };
            }(e4, i3);
          if (Q() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", e4, i3, void 0, true);
        }
        var r3;
        return function(e5, i4) {
          const r4 = new t2.XMLHttpRequest();
          r4.open(e5.method || "GET", e5.url, true), "arrayBuffer" === e5.type && (r4.responseType = "arraybuffer");
          for (const t3 in e5.headers)
            r4.setRequestHeader(t3, e5.headers[t3]);
          return "json" === e5.type && (r4.responseType = "text", r4.setRequestHeader("Accept", "application/json")), r4.withCredentials = "include" === e5.credentials, r4.onerror = () => {
            i4(new Error(r4.statusText));
          }, r4.onload = () => {
            if ((r4.status >= 200 && r4.status < 300 || 0 === r4.status) && null !== r4.response) {
              let t3 = r4.response;
              if ("json" === e5.type)
                try {
                  t3 = JSON.parse(r4.response);
                } catch (e6) {
                  return i4(e6);
                }
              i4(null, t3, r4.getResponseHeader("Cache-Control"), r4.getResponseHeader("Expires"));
            } else
              i4(new xe(r4.statusText, r4.status, e5.url));
          }, r4.send(e5.body), { cancel: () => r4.abort() };
        }(e4, i3);
      }, we = function(e4, t3) {
        return be(k2(e4, { type: "json" }), t3);
      }, Te = function(e4, t3) {
        return be(k2(e4, { type: "arrayBuffer" }), t3);
      };
      function Ee(e4) {
        const i3 = t2.document.createElement("a");
        return i3.href = e4, i3.protocol === t2.document.location.protocol && i3.host === t2.document.location.host;
      }
      const Me = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let Ae, Se;
      Ae = [], Se = 0;
      const Ie = function(e4, i3) {
        if (o2.supported && (e4.headers || (e4.headers = {}), e4.headers.accept = "image/webp,*/*"), Se >= n3.MAX_PARALLEL_IMAGE_REQUESTS) {
          const t3 = { requestParameters: e4, callback: i3, cancelled: false, cancel() {
            this.cancelled = true;
          } };
          return Ae.push(t3), t3;
        }
        Se++;
        let r3 = false;
        const s6 = () => {
          if (!r3)
            for (r3 = true, Se--; Ae.length && Se < n3.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const e5 = Ae.shift(), { requestParameters: t3, callback: i4, cancelled: r4 } = e5;
              r4 || (e5.cancel = Ie(t3, i4).cancel);
            }
        }, a3 = Te(e4, (e5, r4, n4, o3) => {
          s6(), e5 ? i3(e5) : r4 && (t2.createImageBitmap ? function(e6, i4) {
            const r5 = new t2.Blob([new Uint8Array(e6)], { type: "image/png" });
            t2.createImageBitmap(r5).then((e7) => {
              i4(null, e7);
            }).catch((e7) => {
              i4(new Error(`Could not load image because of ${e7.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(r4, (e6, t3) => i3(e6, t3, n4, o3)) : function(e6, i4) {
            const r5 = new t2.Image(), n5 = t2.URL;
            r5.onload = () => {
              i4(null, r5), n5.revokeObjectURL(r5.src), r5.onload = null, t2.requestAnimationFrame(() => {
                r5.src = Me;
              });
            }, r5.onerror = () => i4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const o4 = new t2.Blob([new Uint8Array(e6)], { type: "image/png" });
            r5.src = e6.byteLength ? n5.createObjectURL(o4) : Me;
          }(r4, (e6, t3) => i3(e6, t3, n4, o3)));
        });
        return { cancel: () => {
          a3.cancel(), s6();
        } };
      }, Ce = "NO_ACCESS_TOKEN";
      class ze {
        constructor(e4, t3, i3) {
          this._transformRequestFn = e4, this._customAccessToken = t3, this._silenceAuthErrors = !!i3, this._createSkuToken();
        }
        _createSkuToken() {
          const e4 = function() {
            let e5 = "";
            for (let t3 = 0; t3 < 10; t3++)
              e5 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", u2, e5].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = e4.token, this._skuTokenExpiresAt = e4.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(e4, t3) {
          return this._transformRequestFn && this._transformRequestFn(e4, t3) || { url: e4 };
        }
        normalizeStyleURL(e4, t3) {
          if (!Pe(e4))
            return e4;
          const r3 = Be(e4);
          return r3.params.push(`sdk=js-${i2}`), r3.path = `/styles/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || t3);
        }
        normalizeGlyphsURL(e4, t3) {
          if (!Pe(e4))
            return e4;
          const i3 = Be(e4);
          return i3.path = `/fonts/v1${i3.path}`, this._makeAPIURL(i3, this._customAccessToken || t3);
        }
        normalizeModelURL(e4, t3) {
          if (!Pe(e4))
            return e4;
          const i3 = Be(e4);
          return i3.path = `/models/v1${i3.path}`, this._makeAPIURL(i3, this._customAccessToken || t3);
        }
        normalizeSourceURL(e4, t3, i3, r3) {
          if (!Pe(e4))
            return e4;
          const n4 = Be(e4);
          return n4.path = `/v4/${n4.authority}.json`, n4.params.push("secure"), i3 && n4.params.push(`language=${i3}`), r3 && n4.params.push(`worldview=${r3}`), this._makeAPIURL(n4, this._customAccessToken || t3);
        }
        normalizeSpriteURL(e4, t3, i3, r3) {
          const n4 = Be(e4);
          return Pe(e4) ? (n4.path = `/styles/v1${n4.path}/sprite${t3}${i3}`, this._makeAPIURL(n4, this._customAccessToken || r3)) : (n4.path += `${t3}${i3}`, Fe(n4));
        }
        normalizeTileURL(e4, t3, i3) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), e4 && !Pe(e4))
            return e4;
          const r3 = Be(e4);
          r3.path = r3.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${t3 || i3 && "raster" !== r3.authority && 512 === i3 ? "@2x" : ""}${o2.supported ? ".webp" : "$1"}`), "raster" === r3.authority ? r3.path = `/${n3.RASTER_URL_PREFIX}${r3.path}` : (r3.path = r3.path.replace(/^.+\/v4\//, "/"), r3.path = `/${n3.TILE_URL_VERSION}${r3.path}`);
          const s6 = this._customAccessToken || function(e5) {
            for (const t4 of e5) {
              const e6 = t4.match(/^access_token=(.*)$/);
              if (e6)
                return e6[1];
            }
            return null;
          }(r3.params) || n3.ACCESS_TOKEN;
          return n3.REQUIRE_ACCESS_TOKEN && s6 && this._skuToken && r3.params.push(`sku=${this._skuToken}`), this._makeAPIURL(r3, s6);
        }
        canonicalizeTileURL(e4, t3) {
          const i3 = Be(e4);
          if (!i3.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !i3.path.match(/\.[\w]+$/))
            return e4;
          let r3 = "mapbox://";
          i3.path.match(/^\/raster\/v1\//) ? r3 += `raster/${i3.path.replace(`/${n3.RASTER_URL_PREFIX}/`, "")}` : r3 += `tiles/${i3.path.replace(`/${n3.TILE_URL_VERSION}/`, "")}`;
          let o3 = i3.params;
          return t3 && (o3 = o3.filter((e5) => !e5.match(/^access_token=/))), o3.length && (r3 += `?${o3.join("&")}`), r3;
        }
        canonicalizeTileset(e4, t3) {
          const i3 = !!t3 && Pe(t3), r3 = [];
          for (const t4 of e4.tiles || [])
            De(t4) ? r3.push(this.canonicalizeTileURL(t4, i3)) : r3.push(t4);
          return r3;
        }
        _makeAPIURL(e4, t3) {
          const i3 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", r3 = Be(n3.API_URL);
          if (e4.protocol = r3.protocol, e4.authority = r3.authority, "http" === e4.protocol) {
            const t4 = e4.params.indexOf("secure");
            t4 >= 0 && e4.params.splice(t4, 1);
          }
          if ("/" !== r3.path && (e4.path = `${r3.path}${e4.path}`), !n3.REQUIRE_ACCESS_TOKEN)
            return Fe(e4);
          if (t3 = t3 || n3.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!t3)
              throw new Error(`An API access token is required to use Mapbox GL. ${i3}`);
            if ("s" === t3[0])
              throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${i3}`);
          }
          return e4.params = e4.params.filter((e5) => -1 === e5.indexOf("access_token")), e4.params.push(`access_token=${t3 || ""}`), Fe(e4);
        }
      }
      function Pe(e4) {
        return 0 === e4.indexOf("mapbox:");
      }
      function De(e4) {
        return n3.API_URL_REGEX.test(e4);
      }
      function Re(e4) {
        return n3.API_CDN_URL_REGEX.test(e4);
      }
      function Le(e4) {
        return n3.API_STYLE_REGEX.test(e4) && !ke(e4);
      }
      function ke(e4) {
        return n3.API_SPRITE_REGEX.test(e4);
      }
      const Oe = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function Be(e4) {
        const t3 = e4.match(Oe);
        if (!t3)
          throw new Error("Unable to parse URL object");
        return { protocol: t3[1], authority: t3[2], path: t3[3] || "/", params: t3[4] ? t3[4].split("&") : [] };
      }
      function Fe(e4) {
        const t3 = e4.params.length ? `?${e4.params.join("&")}` : "";
        return `${e4.protocol}://${e4.authority}${e4.path}${t3}`;
      }
      const Ne = "mapbox.eventData";
      function Ue(e4) {
        if (!e4)
          return null;
        const i3 = e4.split(".");
        if (!i3 || 3 !== i3.length)
          return null;
        try {
          return JSON.parse(decodeURIComponent(t2.atob(i3[1]).split("").map((e5) => "%" + ("00" + e5.charCodeAt(0).toString(16)).slice(-2)).join("")));
        } catch (e5) {
          return null;
        }
      }
      class Ve {
        constructor(e4) {
          this.type = e4, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(e4) {
          const i3 = Ue(n3.ACCESS_TOKEN);
          let r3 = "";
          return r3 = i3 && i3.u ? t2.btoa(encodeURIComponent(i3.u).replace(/%([0-9A-F]{2})/g, (e5, t3) => String.fromCharCode(Number("0x" + t3)))) : n3.ACCESS_TOKEN || "", e4 ? `${Ne}.${e4}:${r3}` : `${Ne}:${r3}`;
        }
        fetchEventData() {
          const e4 = re("localStorage"), i3 = this.getStorageKey(), r3 = this.getStorageKey("uuid");
          if (e4)
            try {
              const e5 = t2.localStorage.getItem(i3);
              e5 && (this.eventData = JSON.parse(e5));
              const n4 = t2.localStorage.getItem(r3);
              n4 && (this.anonId = n4);
            } catch (e5) {
              H2("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const e4 = re("localStorage"), i3 = this.getStorageKey(), r3 = this.getStorageKey("uuid");
          if (e4)
            try {
              t2.localStorage.setItem(r3, this.anonId), Object.keys(this.eventData).length >= 1 && t2.localStorage.setItem(i3, JSON.stringify(this.eventData));
            } catch (e5) {
              H2("Unable to write to LocalStorage");
            }
        }
        processRequests(e4) {
        }
        postEvent(e4, t3, i3, r3) {
          if (!n3.EVENTS_URL)
            return;
          const o3 = Be(n3.EVENTS_URL);
          o3.params.push(`access_token=${r3 || n3.ACCESS_TOKEN || ""}`);
          const s6 = { event: this.type, created: new Date(e4).toISOString() }, a3 = t3 ? k2(s6, t3) : s6, l3 = { url: Fe(o3), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([a3]) };
          this.pendingRequest = function(e5, t4) {
            return be(k2(e5, { method: "POST" }), t4);
          }(l3, (e5) => {
            this.pendingRequest = null, i3(e5), this.saveEventData(), this.processRequests(r3);
          });
        }
        queueRequest(e4, t3) {
          this.queue.push(e4), this.processRequests(t3);
        }
      }
      const je = new class extends Ve {
        constructor(e4) {
          super("appUserTurnstile"), this._customAccessToken = e4;
        }
        postTurnstileEvent(e4, t3) {
          n3.EVENTS_URL && n3.ACCESS_TOKEN && Array.isArray(e4) && e4.some((e5) => Pe(e5) || De(e5)) && this.queueRequest(Date.now(), t3);
        }
        processRequests(e4) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const t3 = Ue(n3.ACCESS_TOKEN), r3 = t3 ? t3.u : n3.ACCESS_TOKEN;
          let o3 = r3 !== this.eventData.tokenU;
          V2(this.anonId) || (this.anonId = N2(), o3 = true);
          const s6 = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const e5 = new Date(this.eventData.lastSuccess), t4 = new Date(s6), i3 = (s6 - this.eventData.lastSuccess) / 864e5;
            o3 = o3 || i3 >= 1 || i3 < -1 || e5.getDate() !== t4.getDate();
          } else
            o3 = true;
          o3 ? this.postEvent(s6, { sdkIdentifier: "mapbox-gl-js", sdkVersion: i2, skuId: u2, "enabled.telemetry": false, userId: this.anonId }, (e5) => {
            e5 || (this.eventData.lastSuccess = s6, this.eventData.tokenU = r3);
          }, e4) : this.processRequests();
        }
      }(), Ge = je.postTurnstileEvent.bind(je), qe = new class extends Ve {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(e4, t3, i3, r3) {
          this.skuToken = t3, this.errorCb = r3, n3.EVENTS_URL && (i3 || n3.ACCESS_TOKEN ? this.queueRequest({ id: e4, timestamp: Date.now() }, i3) : this.errorCb(new Error(Ce)));
        }
        processRequests(e4) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: t3, timestamp: r3 } = this.queue.shift();
          t3 && this.success[t3] || (this.anonId || this.fetchEventData(), V2(this.anonId) || (this.anonId = N2()), this.postEvent(r3, { sdkIdentifier: "mapbox-gl-js", sdkVersion: i2, skuId: u2, skuToken: this.skuToken, userId: this.anonId }, (e5) => {
            e5 ? this.errorCb(e5) : t3 && (this.success[t3] = true);
          }, e4));
        }
      }(), Ze = qe.postMapLoadEvent.bind(qe), $e = new class extends Ve {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(e4, t3) {
          n3.EVENTS_URL && (e4 || n3.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: t3 }, e4);
        }
        processRequests(e4) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { timestamp: r3, performanceData: n4 } = this.queue.shift(), o3 = function(e5) {
            const r4 = t2.performance.getEntriesByType("resource"), n5 = t2.performance.getEntriesByType("mark"), o4 = function(e6) {
              const t3 = {};
              if (e6) {
                for (const i3 in e6)
                  if ("other" !== i3)
                    for (const r5 of e6[i3]) {
                      const e7 = `${i3}ResolveRangeMin`, n6 = `${i3}ResolveRangeMax`, o5 = `${i3}RequestCount`, s7 = `${i3}RequestCachedCount`;
                      t3[e7] = Math.min(t3[e7] || 1 / 0, r5.startTime), t3[n6] = Math.max(t3[n6] || -1 / 0, r5.responseEnd);
                      const a4 = (e8) => {
                        void 0 === t3[e8] && (t3[e8] = 0), ++t3[e8];
                      };
                      void 0 !== r5.transferSize && 0 === r5.transferSize && a4(s7), a4(o5);
                    }
              }
              return t3;
            }(function(e6, t3) {
              const i3 = {};
              if (e6)
                for (const r5 of e6) {
                  const e7 = t3(r5);
                  void 0 === i3[e7] && (i3[e7] = []), i3[e7].push(r5);
                }
              return i3;
            }(r4, et)), s6 = t2.devicePixelRatio, a3 = t2.navigator.connection || t2.navigator.mozConnection || t2.navigator.webkitConnection, l3 = { counters: [], metadata: [], attributes: [] }, c3 = (e6, t3, i3) => {
              null != i3 && e6.push({ name: t3, value: i3.toString() });
            };
            for (const e6 in o4)
              c3(l3.counters, e6, o4[e6]);
            if (e5.interactionRange[0] !== 1 / 0 && e5.interactionRange[1] !== -1 / 0 && (c3(l3.counters, "interactionRangeMin", e5.interactionRange[0]), c3(l3.counters, "interactionRangeMax", e5.interactionRange[1])), n5)
              for (const e6 of Object.keys(Je)) {
                const t3 = Je[e6], i3 = n5.find((e7) => e7.name === t3);
                i3 && c3(l3.counters, t3, i3.startTime);
              }
            return c3(l3.counters, "visibilityHidden", e5.visibilityHidden), c3(l3.attributes, "style", function(e6) {
              if (e6)
                for (const t3 of e6) {
                  const e7 = t3.name.split("?")[0];
                  if (Le(e7)) {
                    const t4 = e7.split("/").slice(-2);
                    if (2 === t4.length)
                      return `mapbox://styles/${t4[0]}/${t4[1]}`;
                  }
                }
            }(r4)), c3(l3.attributes, "terrainEnabled", e5.terrainEnabled ? "true" : "false"), c3(l3.attributes, "fogEnabled", e5.fogEnabled ? "true" : "false"), c3(l3.attributes, "projection", e5.projection), c3(l3.attributes, "zoom", e5.zoom), c3(l3.metadata, "devicePixelRatio", s6), c3(l3.metadata, "connectionEffectiveType", a3 ? a3.effectiveType : void 0), c3(l3.metadata, "navigatorUserAgent", t2.navigator.userAgent), c3(l3.metadata, "screenWidth", t2.screen.width), c3(l3.metadata, "screenHeight", t2.screen.height), c3(l3.metadata, "windowWidth", t2.innerWidth), c3(l3.metadata, "windowHeight", t2.innerHeight), c3(l3.metadata, "mapWidth", e5.width / s6), c3(l3.metadata, "mapHeight", e5.height / s6), c3(l3.metadata, "webglRenderer", e5.renderer), c3(l3.metadata, "webglVendor", e5.vendor), c3(l3.metadata, "sdkVersion", i2), c3(l3.metadata, "sdkIdentifier", "mapbox-gl-js"), l3;
          }(n4);
          for (const e5 of o3.metadata)
            ;
          for (const e5 of o3.counters)
            ;
          for (const e5 of o3.attributes)
            ;
          this.postEvent(r3, o3, () => {
          }, e4);
        }
      }(), We = $e.postPerformanceEvent.bind($e), He = new class extends Ve {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(e4, t3, i3, r3) {
          if (!n3.API_URL || !n3.SESSION_PATH)
            return;
          const o3 = Be(n3.API_URL + n3.SESSION_PATH);
          o3.params.push(`sku=${t3 || ""}`), o3.params.push(`access_token=${r3 || n3.ACCESS_TOKEN || ""}`);
          const s6 = { url: Fe(o3), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = function(e5, t4) {
            return be(k2(e5, { method: "GET" }), t4);
          }(s6, (e5) => {
            this.pendingRequest = null, i3(e5), this.saveEventData(), this.processRequests(r3);
          });
        }
        getSessionAPI(e4, t3, i3, r3) {
          this.skuToken = t3, this.errorCb = r3, n3.SESSION_PATH && n3.API_URL && (i3 || n3.ACCESS_TOKEN ? this.queueRequest({ id: e4, timestamp: Date.now() }, i3) : this.errorCb(new Error(Ce)));
        }
        processRequests(e4) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: t3, timestamp: i3 } = this.queue.shift();
          t3 && this.success[t3] || this.getSession(i3, this.skuToken, (e5) => {
            e5 ? this.errorCb(e5) : t3 && (this.success[t3] = true);
          }, e4);
        }
      }(), Xe = He.getSessionAPI.bind(He), Ye = /* @__PURE__ */ new Set();
      function Ke(e4, t3) {
        t3 ? Ye.add(e4) : Ye.delete(e4);
      }
      const Je = { create: "create", load: "load", fullLoad: "fullLoad" }, Qe = { mark(e4) {
        t2.performance.mark(e4);
      }, measure(e4, i3, r3) {
        t2.performance.measure(e4, i3, r3);
      } };
      function et(e4) {
        const t3 = e4.name.split("?")[0];
        return Re(t3) && t3.includes("mapbox-gl.js") ? "javascript" : Re(t3) && t3.includes("mapbox-gl.css") ? "css" : function(e5) {
          return n3.API_FONTS_REGEX.test(e5);
        }(t3) ? "fontRange" : ke(t3) ? "sprite" : Le(t3) ? "style" : function(e5) {
          return n3.API_TILEJSON_REGEX.test(e5);
        }(t3) ? "tilejson" : "other";
      }
      const tt = t2.performance;
      function it(e4) {
        const t3 = e4 ? e4.url.toString() : void 0;
        return tt.getEntriesByName(t3);
      }
      var rt = nt;
      function nt(e4) {
        return !function(e5) {
          return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return false;
            var e6, t4, i3 = new Blob([""], { type: "text/javascript" }), r3 = URL.createObjectURL(i3);
            try {
              t4 = new Worker(r3), e6 = true;
            } catch (t5) {
              e6 = false;
            }
            return t4 && t4.terminate(), URL.revokeObjectURL(r3), e6;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var e6 = document.createElement("canvas");
            e6.width = e6.height = 1;
            var t4 = e6.getContext("2d");
            if (!t4)
              return false;
            var i3 = t4.getImageData(0, 0, 1, 1);
            return i3 && i3.width === e6.width;
          }() ? (void 0 === ot[t3 = e5 && e5.failIfMajorPerformanceCaveat] && (ot[t3] = function(e6) {
            var t4, i3 = function(e7) {
              var t5 = document.createElement("canvas"), i4 = Object.create(nt.webGLContextAttributes);
              return i4.failIfMajorPerformanceCaveat = e7, t5.getContext("webgl", i4) || t5.getContext("experimental-webgl", i4);
            }(e6);
            if (!i3)
              return false;
            try {
              t4 = i3.createShader(i3.VERTEX_SHADER);
            } catch (e7) {
              return false;
            }
            return !(!t4 || i3.isContextLost()) && (i3.shaderSource(t4, "void main() {}"), i3.compileShader(t4), true === i3.getShaderParameter(t4, i3.COMPILE_STATUS));
          }(t3)), ot[t3] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var t3;
        }(e4);
      }
      var ot = {};
      let st, at, lt, ct, ht;
      function ut() {
        return null == st && (st = t2.OffscreenCanvas && new t2.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof t2.createImageBitmap), st;
      }
      nt.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
      const dt = { now: () => void 0 !== ct ? ct : t2.performance.now(), setNow(e4) {
        ct = e4;
      }, restoreNow() {
        ct = void 0;
      }, frame(e4) {
        const i3 = t2.requestAnimationFrame(e4);
        return { cancel: () => t2.cancelAnimationFrame(i3) };
      }, getImageData(e4, i3 = 0) {
        const { width: r3, height: n4 } = e4;
        ht || (ht = t2.document.createElement("canvas"));
        const o3 = ht.getContext("2d", { willReadFrequently: true });
        if (!o3)
          throw new Error("failed to create canvas 2d context");
        return (r3 > ht.width || n4 > ht.height) && (ht.width = r3, ht.height = n4), o3.clearRect(-i3, -i3, r3 + 2 * i3, n4 + 2 * i3), o3.drawImage(e4, 0, 0, r3, n4), o3.getImageData(-i3, -i3, r3 + 2 * i3, n4 + 2 * i3);
      }, resolveURL: (e4) => (at || (at = t2.document.createElement("a")), at.href = e4, at.href), get devicePixelRatio() {
        return t2.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!t2.matchMedia && (null == lt && (lt = t2.matchMedia("(prefers-reduced-motion: reduce)")), lt.matches);
      }, hasCanvasFingerprintNoise() {
        if (!ut())
          return false;
        const e4 = new t2.OffscreenCanvas(85, 1), i3 = e4.getContext("2d", { willReadFrequently: true });
        let r3 = 0;
        for (let t3 = 0; t3 < e4.width; ++t3)
          i3.fillStyle = `rgba(${r3++},${r3++},${r3++}, 255)`, i3.fillRect(t3, 0, 1, 1);
        const n4 = i3.getImageData(0, 0, e4.width, e4.height);
        r3 = 0;
        for (let e5 = 0; e5 < n4.data.length; ++e5)
          if (e5 % 4 != 3 && r3++ !== n4.data[e5])
            return true;
        return false;
      } };
      function pt(e4, i3, r3) {
        const n4 = t2.document.createElement(e4);
        return void 0 !== i3 && (n4.className = i3), r3 && r3.appendChild(n4), n4;
      }
      function ft(e4, i3, r3) {
        const n4 = t2.document.createElementNS("http://www.w3.org/2000/svg", e4);
        for (const e5 of Object.keys(i3))
          n4.setAttributeNS(null, e5, i3[e5]);
        return r3 && r3.appendChild(n4), n4;
      }
      const mt = t2.document && t2.document.documentElement.style, _t = mt && void 0 !== mt.userSelect ? "userSelect" : "WebkitUserSelect";
      let gt;
      function yt() {
        mt && _t && (gt = mt[_t], mt[_t] = "none");
      }
      function xt() {
        mt && _t && (mt[_t] = gt);
      }
      function vt(e4) {
        e4.preventDefault(), e4.stopPropagation(), t2.removeEventListener("click", vt, true);
      }
      function bt() {
        t2.addEventListener("click", vt, true), t2.setTimeout(() => {
          t2.removeEventListener("click", vt, true);
        }, 0);
      }
      function wt(e4, t3) {
        const i3 = e4.getBoundingClientRect();
        return Mt(e4, i3, t3);
      }
      function Tt(e4, t3) {
        const i3 = e4.getBoundingClientRect(), r3 = [];
        for (let n4 = 0; n4 < t3.length; n4++)
          r3.push(Mt(e4, i3, t3[n4]));
        return r3;
      }
      function Et(e4) {
        return void 0 !== t2.InstallTrigger && 2 === e4.button && e4.ctrlKey && t2.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e4.button;
      }
      function Mt(e4, t3, i3) {
        const r3 = e4.offsetWidth === t3.width ? 1 : e4.offsetWidth / t3.width;
        return new y2((i3.clientX - t3.left) * r3, (i3.clientY - t3.top) * r3);
      }
      function At(e4, t3, i3) {
        i3[e4] && -1 !== i3[e4].indexOf(t3) || (i3[e4] = i3[e4] || [], i3[e4].push(t3));
      }
      function St(e4, t3, i3) {
        if (i3 && i3[e4]) {
          const r3 = i3[e4].indexOf(t3);
          -1 !== r3 && i3[e4].splice(r3, 1);
        }
      }
      class It {
        constructor(e4, t3 = {}) {
          k2(this, t3), this.type = e4;
        }
      }
      class Ct extends It {
        constructor(e4, t3 = {}) {
          super("error", k2({ error: e4 }, t3));
        }
      }
      class zt {
        on(e4, t3) {
          return this._listeners = this._listeners || {}, At(e4, t3, this._listeners), this;
        }
        off(e4, t3) {
          return St(e4, t3, this._listeners), St(e4, t3, this._oneTimeListeners), this;
        }
        once(e4, t3) {
          return t3 ? (this._oneTimeListeners = this._oneTimeListeners || {}, At(e4, t3, this._oneTimeListeners), this) : new Promise((t4) => this.once(e4, t4));
        }
        fire(e4, t3) {
          "string" == typeof e4 && (e4 = new It(e4, t3 || {}));
          const i3 = e4.type;
          if (this.listens(i3)) {
            e4.target = this;
            const t4 = this._listeners && this._listeners[i3] ? this._listeners[i3].slice() : [];
            for (const i4 of t4)
              i4.call(this, e4);
            const r3 = this._oneTimeListeners && this._oneTimeListeners[i3] ? this._oneTimeListeners[i3].slice() : [];
            for (const t5 of r3)
              St(i3, t5, this._oneTimeListeners), t5.call(this, e4);
            const n4 = this._eventedParent;
            n4 && (k2(e4, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), n4.fire(e4));
          } else
            e4 instanceof Ct && console.error(e4.error);
          return this;
        }
        listens(e4) {
          return !!(this._listeners && this._listeners[e4] && this._listeners[e4].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e4] && this._oneTimeListeners[e4].length > 0 || this._eventedParent && this._eventedParent.listens(e4));
        }
        setEventedParent(e4, t3) {
          return this._eventedParent = e4, this._eventedParentData = t3, this;
        }
      }
      var Pt = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"expression":{},"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","default":[0,1],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      class Dt {
        constructor(e4, t3, i3, r3) {
          this.message = (e4 ? `${e4}: ` : "") + i3, r3 && (this.identifier = r3), null != t3 && t3.__line__ && (this.line = t3.__line__);
        }
      }
      class Rt extends Dt {
      }
      function Lt(e4, ...t3) {
        for (const i3 of t3)
          for (const t4 in i3)
            e4[t4] = i3[t4];
        return e4;
      }
      function kt(e4) {
        return e4 instanceof Number || e4 instanceof String || e4 instanceof Boolean ? e4.valueOf() : e4;
      }
      function Ot(e4) {
        if (Array.isArray(e4))
          return e4.map(Ot);
        if (e4 instanceof Object && !(e4 instanceof Number || e4 instanceof String || e4 instanceof Boolean)) {
          const t3 = {};
          for (const i3 in e4)
            t3[i3] = Ot(e4[i3]);
          return t3;
        }
        return kt(e4);
      }
      class Bt extends Error {
        constructor(e4, t3) {
          super(t3), this.message = t3, this.key = e4;
        }
      }
      var Ft = Bt;
      class Nt {
        constructor(e4, t3 = []) {
          this.parent = e4, this.bindings = {};
          for (const [e5, i3] of t3)
            this.bindings[e5] = i3;
        }
        concat(e4) {
          return new Nt(this, e4);
        }
        get(e4) {
          if (this.bindings[e4])
            return this.bindings[e4];
          if (this.parent)
            return this.parent.get(e4);
          throw new Error(`${e4} not found in scope.`);
        }
        has(e4) {
          return !!this.bindings[e4] || !!this.parent && this.parent.has(e4);
        }
      }
      var Ut = Nt;
      const Vt = { kind: "null" }, jt = { kind: "number" }, Gt = { kind: "string" }, qt = { kind: "boolean" }, Zt = { kind: "color" }, $t = { kind: "object" }, Wt = { kind: "value" }, Ht = { kind: "collator" }, Xt = { kind: "formatted" }, Yt = { kind: "resolvedImage" };
      function Kt(e4, t3) {
        return { kind: "array", itemType: e4, N: t3 };
      }
      function Jt(e4) {
        if ("array" === e4.kind) {
          const t3 = Jt(e4.itemType);
          return "number" == typeof e4.N ? `array<${t3}, ${e4.N}>` : "value" === e4.itemType.kind ? "array" : `array<${t3}>`;
        }
        return e4.kind;
      }
      const Qt = [Vt, jt, Gt, qt, Zt, Xt, $t, Kt(Wt), Yt];
      function ei(e4, t3) {
        if ("error" === t3.kind)
          return null;
        if ("array" === e4.kind) {
          if ("array" === t3.kind && (0 === t3.N && "value" === t3.itemType.kind || !ei(e4.itemType, t3.itemType)) && ("number" != typeof e4.N || e4.N === t3.N))
            return null;
        } else {
          if (e4.kind === t3.kind)
            return null;
          if ("value" === e4.kind) {
            for (const e5 of Qt)
              if (!ei(e5, t3))
                return null;
          }
        }
        return `Expected ${Jt(e4)} but found ${Jt(t3)} instead.`;
      }
      function ti(e4, t3) {
        return t3.some((t4) => t4.kind === e4.kind);
      }
      function ii(e4, t3) {
        return t3.some((t4) => "null" === t4 ? null === e4 : "array" === t4 ? Array.isArray(e4) : "object" === t4 ? e4 && !Array.isArray(e4) && "object" == typeof e4 : t4 === typeof e4);
      }
      var ri, ni = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
      function oi(e4) {
        return (e4 = Math.round(e4)) < 0 ? 0 : e4 > 255 ? 255 : e4;
      }
      function si(e4) {
        return oi("%" === e4[e4.length - 1] ? parseFloat(e4) / 100 * 255 : parseInt(e4));
      }
      function ai(e4) {
        return (t3 = "%" === e4[e4.length - 1] ? parseFloat(e4) / 100 : parseFloat(e4)) < 0 ? 0 : t3 > 1 ? 1 : t3;
        var t3;
      }
      function li(e4, t3, i3) {
        return i3 < 0 ? i3 += 1 : i3 > 1 && (i3 -= 1), 6 * i3 < 1 ? e4 + (t3 - e4) * i3 * 6 : 2 * i3 < 1 ? t3 : 3 * i3 < 2 ? e4 + (t3 - e4) * (2 / 3 - i3) * 6 : e4;
      }
      try {
        ri = {}.parseCSSColor = function(e4) {
          var t3, i3 = e4.replace(/ /g, "").toLowerCase();
          if (i3 in ni)
            return ni[i3].slice();
          if ("#" === i3[0])
            return 4 === i3.length ? (t3 = parseInt(i3.substr(1), 16)) >= 0 && t3 <= 4095 ? [(3840 & t3) >> 4 | (3840 & t3) >> 8, 240 & t3 | (240 & t3) >> 4, 15 & t3 | (15 & t3) << 4, 1] : null : 7 === i3.length && (t3 = parseInt(i3.substr(1), 16)) >= 0 && t3 <= 16777215 ? [(16711680 & t3) >> 16, (65280 & t3) >> 8, 255 & t3, 1] : null;
          var r3 = i3.indexOf("("), n4 = i3.indexOf(")");
          if (-1 !== r3 && n4 + 1 === i3.length) {
            var o3 = i3.substr(0, r3), s6 = i3.substr(r3 + 1, n4 - (r3 + 1)).split(","), a3 = 1;
            switch (o3) {
              case "rgba":
                if (4 !== s6.length)
                  return null;
                a3 = ai(s6.pop());
              case "rgb":
                return 3 !== s6.length ? null : [si(s6[0]), si(s6[1]), si(s6[2]), a3];
              case "hsla":
                if (4 !== s6.length)
                  return null;
                a3 = ai(s6.pop());
              case "hsl":
                if (3 !== s6.length)
                  return null;
                var l3 = (parseFloat(s6[0]) % 360 + 360) % 360 / 360, c3 = ai(s6[1]), h3 = ai(s6[2]), u3 = h3 <= 0.5 ? h3 * (c3 + 1) : h3 + c3 - h3 * c3, d3 = 2 * h3 - u3;
                return [oi(255 * li(d3, u3, l3 + 1 / 3)), oi(255 * li(d3, u3, l3)), oi(255 * li(d3, u3, l3 - 1 / 3)), a3];
              default:
                return null;
            }
          }
          return null;
        };
      } catch (e4) {
      }
      class ci {
        constructor(e4, t3, i3, r3 = 1) {
          this.r = e4, this.g = t3, this.b = i3, this.a = r3;
        }
        static parse(e4) {
          if (!e4)
            return;
          if (e4 instanceof ci)
            return e4;
          if ("string" != typeof e4)
            return;
          const t3 = ri(e4);
          return t3 ? new ci(t3[0] / 255 * t3[3], t3[1] / 255 * t3[3], t3[2] / 255 * t3[3], t3[3]) : void 0;
        }
        toString() {
          const [e4, t3, i3, r3] = this.toArray();
          return `rgba(${Math.round(e4)},${Math.round(t3)},${Math.round(i3)},${r3})`;
        }
        toArray() {
          const { r: e4, g: t3, b: i3, a: r3 } = this;
          return 0 === r3 ? [0, 0, 0, 0] : [255 * e4 / r3, 255 * t3 / r3, 255 * i3 / r3, r3];
        }
        toArray01() {
          const { r: e4, g: t3, b: i3, a: r3 } = this;
          return 0 === r3 ? [0, 0, 0, 0] : [e4 / r3, t3 / r3, i3 / r3, r3];
        }
        toArray01Scaled(e4) {
          const { r: t3, g: i3, b: r3, a: n4 } = this;
          return 0 === n4 ? [0, 0, 0] : [t3 / n4 * e4, i3 / n4 * e4, r3 / n4 * e4];
        }
        toArray01PremultipliedAlpha() {
          const { r: e4, g: t3, b: i3, a: r3 } = this;
          return [e4, t3, i3, r3];
        }
        toArray01Linear() {
          const { r: e4, g: t3, b: i3, a: r3 } = this;
          return 0 === r3 ? [0, 0, 0, 0] : [Math.pow(e4 / r3, 2.2), Math.pow(t3 / r3, 2.2), Math.pow(i3 / r3, 2.2), r3];
        }
      }
      ci.black = new ci(0, 0, 0, 1), ci.white = new ci(1, 1, 1, 1), ci.transparent = new ci(0, 0, 0, 0), ci.red = new ci(1, 0, 0, 1), ci.blue = new ci(0, 0, 1, 1);
      var hi = ci;
      class ui {
        constructor(e4, t3, i3) {
          this.sensitivity = e4 ? t3 ? "variant" : "case" : t3 ? "accent" : "base", this.locale = i3, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e4, t3) {
          return this.collator.compare(e4, t3);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class di {
        constructor(e4, t3, i3, r3, n4) {
          this.text = e4.normalize ? e4.normalize() : e4, this.image = t3, this.scale = i3, this.fontStack = r3, this.textColor = n4;
        }
      }
      class pi {
        constructor(e4) {
          this.sections = e4;
        }
        static fromString(e4) {
          return new pi([new di(e4, null, null, null, null)]);
        }
        isEmpty() {
          return 0 === this.sections.length || !this.sections.some((e4) => 0 !== e4.text.length || e4.image && 0 !== e4.image.namePrimary.length);
        }
        static factory(e4) {
          return e4 instanceof pi ? e4 : pi.fromString(e4);
        }
        toString() {
          return 0 === this.sections.length ? "" : this.sections.map((e4) => e4.text).join("");
        }
        serialize() {
          const e4 = ["format"];
          for (const t3 of this.sections) {
            if (t3.image) {
              e4.push(["image", t3.image.namePrimary]);
              continue;
            }
            e4.push(t3.text);
            const i3 = {};
            t3.fontStack && (i3["text-font"] = ["literal", t3.fontStack.split(",")]), t3.scale && (i3["font-scale"] = t3.scale), t3.textColor && (i3["text-color"] = ["rgba"].concat(t3.textColor.toArray())), e4.push(i3);
          }
          return e4;
        }
      }
      class fi {
        constructor(e4) {
          this.namePrimary = e4.namePrimary, e4.nameSecondary && (this.nameSecondary = e4.nameSecondary), this.available = e4.available;
        }
        toString() {
          return this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
        }
        static fromString(e4, t3) {
          return e4 ? new fi({ namePrimary: e4, nameSecondary: t3, available: false }) : null;
        }
        serialize() {
          return this.nameSecondary ? ["image", this.namePrimary, this.nameSecondary] : ["image", this.namePrimary];
        }
      }
      function mi(e4, t3, i3, r3) {
        return "number" == typeof e4 && e4 >= 0 && e4 <= 255 && "number" == typeof t3 && t3 >= 0 && t3 <= 255 && "number" == typeof i3 && i3 >= 0 && i3 <= 255 ? void 0 === r3 || "number" == typeof r3 && r3 >= 0 && r3 <= 1 ? null : `Invalid rgba value [${[e4, t3, i3, r3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof r3 ? [e4, t3, i3, r3] : [e4, t3, i3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function _i(e4) {
        if (null === e4)
          return true;
        if ("string" == typeof e4)
          return true;
        if ("boolean" == typeof e4)
          return true;
        if ("number" == typeof e4)
          return true;
        if (e4 instanceof hi)
          return true;
        if (e4 instanceof ui)
          return true;
        if (e4 instanceof pi)
          return true;
        if (e4 instanceof fi)
          return true;
        if (Array.isArray(e4)) {
          for (const t3 of e4)
            if (!_i(t3))
              return false;
          return true;
        }
        if ("object" == typeof e4) {
          for (const t3 in e4)
            if (!_i(e4[t3]))
              return false;
          return true;
        }
        return false;
      }
      function gi(e4) {
        if (null === e4)
          return Vt;
        if ("string" == typeof e4)
          return Gt;
        if ("boolean" == typeof e4)
          return qt;
        if ("number" == typeof e4)
          return jt;
        if (e4 instanceof hi)
          return Zt;
        if (e4 instanceof ui)
          return Ht;
        if (e4 instanceof pi)
          return Xt;
        if (e4 instanceof fi)
          return Yt;
        if (Array.isArray(e4)) {
          const t3 = e4.length;
          let i3;
          for (const t4 of e4) {
            const e5 = gi(t4);
            if (i3) {
              if (i3 === e5)
                continue;
              i3 = Wt;
              break;
            }
            i3 = e5;
          }
          return Kt(i3 || Wt, t3);
        }
        return $t;
      }
      function yi(e4) {
        const t3 = typeof e4;
        return null === e4 ? "" : "string" === t3 || "number" === t3 || "boolean" === t3 ? String(e4) : e4 instanceof hi || e4 instanceof pi || e4 instanceof fi ? e4.toString() : JSON.stringify(e4);
      }
      class xi {
        constructor(e4, t3) {
          this.type = e4, this.value = t3;
        }
        static parse(e4, t3) {
          if (2 !== e4.length)
            return t3.error(`'literal' expression requires exactly one argument, but found ${e4.length - 1} instead.`);
          if (!_i(e4[1]))
            return t3.error("invalid value");
          const i3 = e4[1];
          let r3 = gi(i3);
          const n4 = t3.expectedType;
          return "array" !== r3.kind || 0 !== r3.N || !n4 || "array" !== n4.kind || "number" == typeof n4.N && 0 !== n4.N || (r3 = n4), new xi(r3, i3);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof hi ? ["rgba"].concat(this.value.toArray()) : this.value instanceof pi ? this.value.serialize() : this.value;
        }
      }
      var vi = xi, bi = class {
        constructor(e4) {
          this.name = "ExpressionEvaluationError", this.message = e4;
        }
        toJSON() {
          return this.message;
        }
      };
      const wi = { string: Gt, number: jt, boolean: qt, object: $t };
      class Ti {
        constructor(e4, t3) {
          this.type = e4, this.args = t3;
        }
        static parse(e4, t3) {
          if (e4.length < 2)
            return t3.error("Expected at least one argument.");
          let i3, r3 = 1;
          const n4 = e4[0];
          if ("array" === n4) {
            let n5, o4;
            if (e4.length > 2) {
              const i4 = e4[1];
              if ("string" != typeof i4 || !(i4 in wi) || "object" === i4)
                return t3.error('The item type argument of "array" must be one of string, number, boolean', 1);
              n5 = wi[i4], r3++;
            } else
              n5 = Wt;
            if (e4.length > 3) {
              if (null !== e4[2] && ("number" != typeof e4[2] || e4[2] < 0 || e4[2] !== Math.floor(e4[2])))
                return t3.error('The length argument to "array" must be a positive integer literal', 2);
              o4 = e4[2], r3++;
            }
            i3 = Kt(n5, o4);
          } else
            i3 = wi[n4];
          const o3 = [];
          for (; r3 < e4.length; r3++) {
            const i4 = t3.parse(e4[r3], r3, Wt);
            if (!i4)
              return null;
            o3.push(i4);
          }
          return new Ti(i3, o3);
        }
        evaluate(e4) {
          for (let t3 = 0; t3 < this.args.length; t3++) {
            const i3 = this.args[t3].evaluate(e4);
            if (!ei(this.type, gi(i3)))
              return i3;
            if (t3 === this.args.length - 1)
              throw new bi(`Expected value to be of type ${Jt(this.type)}, but found ${Jt(gi(i3))} instead.`);
          }
          return null;
        }
        eachChild(e4) {
          this.args.forEach(e4);
        }
        outputDefined() {
          return this.args.every((e4) => e4.outputDefined());
        }
        serialize() {
          const e4 = this.type, t3 = [e4.kind];
          if ("array" === e4.kind) {
            const i3 = e4.itemType;
            if ("string" === i3.kind || "number" === i3.kind || "boolean" === i3.kind) {
              t3.push(i3.kind);
              const r3 = e4.N;
              ("number" == typeof r3 || this.args.length > 1) && t3.push(r3);
            }
          }
          return t3.concat(this.args.map((e5) => e5.serialize()));
        }
      }
      var Ei = Ti;
      class Mi {
        constructor(e4) {
          this.type = Xt, this.sections = e4;
        }
        static parse(e4, t3) {
          if (e4.length < 2)
            return t3.error("Expected at least one argument.");
          const i3 = e4[1];
          if (!Array.isArray(i3) && "object" == typeof i3)
            return t3.error("First argument must be an image or text section.");
          const r3 = [];
          let n4 = false;
          for (let i4 = 1; i4 <= e4.length - 1; ++i4) {
            const o3 = e4[i4];
            if (n4 && "object" == typeof o3 && !Array.isArray(o3)) {
              n4 = false;
              let e5 = null;
              if (o3["font-scale"] && (e5 = t3.parse(o3["font-scale"], 1, jt), !e5))
                return null;
              let i5 = null;
              if (o3["text-font"] && (i5 = t3.parse(o3["text-font"], 1, Kt(Gt)), !i5))
                return null;
              let s6 = null;
              if (o3["text-color"] && (s6 = t3.parse(o3["text-color"], 1, Zt), !s6))
                return null;
              const a3 = r3[r3.length - 1];
              a3.scale = e5, a3.font = i5, a3.textColor = s6;
            } else {
              const o4 = t3.parse(e4[i4], 1, Wt);
              if (!o4)
                return null;
              const s6 = o4.type.kind;
              if ("string" !== s6 && "value" !== s6 && "null" !== s6 && "resolvedImage" !== s6)
                return t3.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              n4 = true, r3.push({ content: o4, scale: null, font: null, textColor: null });
            }
          }
          return new Mi(r3);
        }
        evaluate(e4) {
          return new pi(this.sections.map((t3) => {
            const i3 = t3.content.evaluate(e4);
            return gi(i3) === Yt ? new di("", i3, null, null, null) : new di(yi(i3), null, t3.scale ? t3.scale.evaluate(e4) : null, t3.font ? t3.font.evaluate(e4).join(",") : null, t3.textColor ? t3.textColor.evaluate(e4) : null);
          }));
        }
        eachChild(e4) {
          for (const t3 of this.sections)
            e4(t3.content), t3.scale && e4(t3.scale), t3.font && e4(t3.font), t3.textColor && e4(t3.textColor);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const e4 = ["format"];
          for (const t3 of this.sections) {
            e4.push(t3.content.serialize());
            const i3 = {};
            t3.scale && (i3["font-scale"] = t3.scale.serialize()), t3.font && (i3["text-font"] = t3.font.serialize()), t3.textColor && (i3["text-color"] = t3.textColor.serialize()), e4.push(i3);
          }
          return e4;
        }
      }
      class Ai {
        constructor(e4, t3) {
          this.type = Yt, this.inputPrimary = e4, this.inputSecondary = t3;
        }
        static parse(e4, t3) {
          if (e4.length < 2)
            return t3.error("Expected two or more arguments.");
          const i3 = t3.parse(e4[1], 1, Gt);
          if (!i3)
            return t3.error("No image name provided.");
          if (2 === e4.length)
            return new Ai(i3);
          const r3 = t3.parse(e4[2], 1, Gt);
          return r3 ? new Ai(i3, r3) : t3.error("Secondary image variant is not a string.");
        }
        evaluate(e4) {
          const t3 = fi.fromString(this.inputPrimary.evaluate(e4), this.inputSecondary ? this.inputSecondary.evaluate(e4) : void 0);
          return t3 && e4.availableImages && (t3.available = e4.availableImages.indexOf(t3.namePrimary) > -1, t3.nameSecondary && t3.available && e4.availableImages && (t3.available = e4.availableImages.indexOf(t3.nameSecondary) > -1)), t3;
        }
        eachChild(e4) {
          e4(this.inputPrimary), this.inputSecondary && e4(this.inputSecondary);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return this.inputSecondary ? ["image", this.inputPrimary.serialize(), this.inputSecondary.serialize()] : ["image", this.inputPrimary.serialize()];
        }
      }
      function Si(e4) {
        return e4 instanceof Number ? "number" : e4 instanceof String ? "string" : e4 instanceof Boolean ? "boolean" : Array.isArray(e4) ? "array" : null === e4 ? "null" : typeof e4;
      }
      const Ii = { "to-boolean": qt, "to-color": Zt, "to-number": jt, "to-string": Gt };
      class Ci {
        constructor(e4, t3) {
          this.type = e4, this.args = t3;
        }
        static parse(e4, t3) {
          if (e4.length < 2)
            return t3.error("Expected at least one argument.");
          const i3 = e4[0], r3 = [];
          let n4 = Vt;
          if ("to-array" === i3) {
            if (!Array.isArray(e4[1]))
              return null;
            const i4 = e4[1].length;
            if (t3.expectedType) {
              if ("array" !== t3.expectedType.kind)
                return t3.error(`Expected ${t3.expectedType.kind} but found array.`);
              n4 = Kt(t3.expectedType.itemType, i4);
            } else {
              if (!(i4 > 0 && _i(e4[1][0])))
                return null;
              n4 = Kt(gi(e4[1][0]), i4);
            }
            for (let o3 = 0; o3 < i4; o3++) {
              const i5 = e4[1][o3];
              let s6;
              if ("array" === Si(i5))
                s6 = t3.parse(i5, void 0, n4.itemType);
              else {
                const e5 = Si(i5);
                if (e5 !== n4.itemType.kind)
                  return t3.error(`Expected ${n4.itemType.kind} but found ${e5}.`);
                s6 = t3.registry.literal.parse(["literal", void 0 === i5 ? null : i5], t3);
              }
              if (!s6)
                return null;
              r3.push(s6);
            }
          } else {
            if (("to-boolean" === i3 || "to-string" === i3) && 2 !== e4.length)
              return t3.error("Expected one argument.");
            n4 = Ii[i3];
            for (let i4 = 1; i4 < e4.length; i4++) {
              const n5 = t3.parse(e4[i4], i4, Wt);
              if (!n5)
                return null;
              r3.push(n5);
            }
          }
          return new Ci(n4, r3);
        }
        evaluate(e4) {
          if ("boolean" === this.type.kind)
            return Boolean(this.args[0].evaluate(e4));
          if ("color" === this.type.kind) {
            let t3, i3;
            for (const r3 of this.args) {
              if (t3 = r3.evaluate(e4), i3 = null, t3 instanceof hi)
                return t3;
              if ("string" == typeof t3) {
                const i4 = e4.parseColor(t3);
                if (i4)
                  return i4;
              } else if (Array.isArray(t3) && (i3 = t3.length < 3 || t3.length > 4 ? `Invalid rbga value ${JSON.stringify(t3)}: expected an array containing either three or four numeric values.` : mi(t3[0], t3[1], t3[2], t3[3]), !i3))
                return new hi(t3[0] / 255, t3[1] / 255, t3[2] / 255, t3[3]);
            }
            throw new bi(i3 || `Could not parse color from value '${"string" == typeof t3 ? t3 : String(JSON.stringify(t3))}'`);
          }
          if ("number" === this.type.kind) {
            let t3 = null;
            for (const i3 of this.args) {
              if (t3 = i3.evaluate(e4), null === t3)
                return 0;
              const r3 = Number(t3);
              if (!isNaN(r3))
                return r3;
            }
            throw new bi(`Could not convert ${JSON.stringify(t3)} to number.`);
          }
          return "formatted" === this.type.kind ? pi.fromString(yi(this.args[0].evaluate(e4))) : "resolvedImage" === this.type.kind ? fi.fromString(yi(this.args[0].evaluate(e4))) : "array" === this.type.kind ? this.args.map((t3) => t3.evaluate(e4)) : yi(this.args[0].evaluate(e4));
        }
        eachChild(e4) {
          this.args.forEach(e4);
        }
        outputDefined() {
          return this.args.every((e4) => e4.outputDefined());
        }
        serialize() {
          if ("formatted" === this.type.kind)
            return new Mi([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if ("resolvedImage" === this.type.kind)
            return new Ai(this.args[0]).serialize();
          const e4 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
          return this.eachChild((t3) => {
            e4.push(t3.serialize());
          }), e4;
        }
      }
      var zi = Ci;
      const Pi = ["Unknown", "Point", "LineString", "Polygon"];
      var Di = class {
        constructor(e4) {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.options = e4;
        }
        id() {
          return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? "number" == typeof this.feature.type ? Pi[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        measureLight(e4) {
          return this.globals.brightness || 0;
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const e4 = this.featureDistanceData.center, t3 = this.featureDistanceData.scale, { x: i3, y: r3 } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (i3 * t3 - e4[0]) + this.featureDistanceData.bearing[1] * (r3 * t3 - e4[1]);
          }
          return 0;
        }
        parseColor(e4) {
          let t3 = this._parseColorCache[e4];
          return t3 || (t3 = this._parseColorCache[e4] = hi.parse(e4)), t3;
        }
        getConfig(e4) {
          return this.options ? this.options.get(e4) : null;
        }
      };
      class Ri {
        constructor(e4, t3, i3, r3, n4) {
          this.name = e4, this.type = t3, this._evaluate = i3, this.args = r3, this._overloadIndex = n4;
        }
        evaluate(e4) {
          if (!this._evaluate) {
            const e5 = Ri.definitions[this.name];
            this._evaluate = Array.isArray(e5) ? e5[2] : e5.overloads[this._overloadIndex][1];
          }
          return this._evaluate(e4, this.args);
        }
        eachChild(e4) {
          this.args.forEach(e4);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return [this.name].concat(this.args.map((e4) => e4.serialize()));
        }
        static parse(e4, t3) {
          const i3 = e4[0], r3 = Ri.definitions[i3];
          if (!r3)
            return t3.error(`Unknown expression "${i3}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const n4 = Array.isArray(r3) ? r3[0] : r3.type, o3 = Array.isArray(r3) ? [[r3[1], r3[2]]] : r3.overloads, s6 = [];
          let a3 = null, l3 = -1;
          for (const [r4, c3] of o3) {
            if (Array.isArray(r4) && r4.length !== e4.length - 1)
              continue;
            s6.push(r4), l3++, a3 = new $r(t3.registry, t3.path, null, t3.scope, void 0, t3.options);
            const o4 = [];
            let h3 = false;
            for (let t4 = 1; t4 < e4.length; t4++) {
              const i4 = e4[t4], n5 = Array.isArray(r4) ? r4[t4 - 1] : r4.type, s7 = a3.parse(i4, 1 + o4.length, n5);
              if (!s7) {
                h3 = true;
                break;
              }
              o4.push(s7);
            }
            if (!h3)
              if (Array.isArray(r4) && r4.length !== o4.length)
                a3.error(`Expected ${r4.length} arguments, but found ${o4.length} instead.`);
              else {
                for (let e5 = 0; e5 < o4.length; e5++) {
                  const t4 = Array.isArray(r4) ? r4[e5] : r4.type, i4 = o4[e5];
                  a3.concat(e5 + 1).checkSubtype(t4, i4.type);
                }
                if (0 === a3.errors.length)
                  return new Ri(i3, n4, c3, o4, l3);
              }
          }
          if (1 === s6.length)
            t3.errors.push(...a3.errors);
          else {
            const i4 = (s6.length ? s6 : o3.map(([e5]) => e5)).map(Li).join(" | "), r4 = [];
            for (let i5 = 1; i5 < e4.length; i5++) {
              const n5 = t3.parse(e4[i5], 1 + r4.length);
              if (!n5)
                return null;
              r4.push(Jt(n5.type));
            }
            t3.error(`Expected arguments of type ${i4}, but found (${r4.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e4, t3) {
          Ri.definitions = t3;
          for (const i3 in t3)
            e4[i3] = Ri;
        }
      }
      function Li(e4) {
        return Array.isArray(e4) ? `(${e4.map(Jt).join(", ")})` : `(${Jt(e4.type)}...)`;
      }
      var ki = Ri;
      class Oi {
        constructor(e4, t3, i3) {
          this.type = Ht, this.locale = i3, this.caseSensitive = e4, this.diacriticSensitive = t3;
        }
        static parse(e4, t3) {
          if (2 !== e4.length)
            return t3.error("Expected one argument.");
          const i3 = e4[1];
          if ("object" != typeof i3 || Array.isArray(i3))
            return t3.error("Collator options argument must be an object.");
          const r3 = t3.parse(void 0 !== i3["case-sensitive"] && i3["case-sensitive"], 1, qt);
          if (!r3)
            return null;
          const n4 = t3.parse(void 0 !== i3["diacritic-sensitive"] && i3["diacritic-sensitive"], 1, qt);
          if (!n4)
            return null;
          let o3 = null;
          return i3.locale && (o3 = t3.parse(i3.locale, 1, Gt), !o3) ? null : new Oi(r3, n4, o3);
        }
        evaluate(e4) {
          return new ui(this.caseSensitive.evaluate(e4), this.diacriticSensitive.evaluate(e4), this.locale ? this.locale.evaluate(e4) : null);
        }
        eachChild(e4) {
          e4(this.caseSensitive), e4(this.diacriticSensitive), this.locale && e4(this.locale);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const e4 = {};
          return e4["case-sensitive"] = this.caseSensitive.serialize(), e4["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e4.locale = this.locale.serialize()), ["collator", e4];
        }
      }
      var Bi = { exports: {} };
      Bi.exports = function() {
        function e4(i4, r3, n4, o3, s6) {
          for (; o3 > n4; ) {
            if (o3 - n4 > 600) {
              var a3 = o3 - n4 + 1, l3 = r3 - n4 + 1, c3 = Math.log(a3), h3 = 0.5 * Math.exp(2 * c3 / 3), u3 = 0.5 * Math.sqrt(c3 * h3 * (a3 - h3) / a3) * (l3 - a3 / 2 < 0 ? -1 : 1);
              e4(i4, r3, Math.max(n4, Math.floor(r3 - l3 * h3 / a3 + u3)), Math.min(o3, Math.floor(r3 + (a3 - l3) * h3 / a3 + u3)), s6);
            }
            var d3 = i4[r3], p3 = n4, f3 = o3;
            for (t3(i4, n4, r3), s6(i4[o3], d3) > 0 && t3(i4, n4, o3); p3 < f3; ) {
              for (t3(i4, p3, f3), p3++, f3--; s6(i4[p3], d3) < 0; )
                p3++;
              for (; s6(i4[f3], d3) > 0; )
                f3--;
            }
            0 === s6(i4[n4], d3) ? t3(i4, n4, f3) : t3(i4, ++f3, o3), f3 <= r3 && (n4 = f3 + 1), r3 <= f3 && (o3 = f3 - 1);
          }
        }
        function t3(e5, t4, i4) {
          var r3 = e5[t4];
          e5[t4] = e5[i4], e5[i4] = r3;
        }
        function i3(e5, t4) {
          return e5 < t4 ? -1 : e5 > t4 ? 1 : 0;
        }
        return function(t4, r3, n4, o3, s6) {
          e4(t4, r3, n4 || 0, o3 || t4.length - 1, s6 || i3);
        };
      }();
      var Fi = d2(Bi.exports);
      function Ni(e4) {
        let t3 = 0;
        for (let i3, r3, n4 = 0, o3 = e4.length, s6 = o3 - 1; n4 < o3; s6 = n4++)
          i3 = e4[n4], r3 = e4[s6], t3 += (r3.x - i3.x) * (i3.y + r3.y);
        return t3;
      }
      function Ui(e4, t3) {
        e4[0] = Math.min(e4[0], t3[0]), e4[1] = Math.min(e4[1], t3[1]), e4[2] = Math.max(e4[2], t3[0]), e4[3] = Math.max(e4[3], t3[1]);
      }
      function Vi(e4, t3) {
        return !(e4[0] <= t3[0] || e4[2] >= t3[2] || e4[1] <= t3[1] || e4[3] >= t3[3]);
      }
      function ji(e4, t3, i3) {
        const r3 = e4[0] - t3[0], n4 = e4[1] - t3[1], o3 = e4[0] - i3[0], s6 = e4[1] - i3[1];
        return r3 * s6 - o3 * n4 == 0 && r3 * o3 <= 0 && n4 * s6 <= 0;
      }
      function Gi(e4, t3, i3 = false) {
        let r3 = false;
        for (let a3 = 0, l3 = t3.length; a3 < l3; a3++) {
          const l4 = t3[a3];
          for (let t4 = 0, a4 = l4.length, c3 = a4 - 1; t4 < a4; c3 = t4++) {
            const a5 = l4[c3], h3 = l4[t4];
            if (ji(e4, a5, h3))
              return i3;
            (o3 = a5)[1] > (n4 = e4)[1] != (s6 = h3)[1] > n4[1] && n4[0] < (s6[0] - o3[0]) * (n4[1] - o3[1]) / (s6[1] - o3[1]) + o3[0] && (r3 = !r3);
          }
        }
        var n4, o3, s6;
        return r3;
      }
      function qi(e4, t3, i3, r3) {
        const n4 = r3[0] - i3[0], o3 = r3[1] - i3[1], s6 = (e4[0] - i3[0]) * o3 - n4 * (e4[1] - i3[1]), a3 = (t3[0] - i3[0]) * o3 - n4 * (t3[1] - i3[1]);
        return s6 > 0 && a3 < 0 || s6 < 0 && a3 > 0;
      }
      function Zi(e4, t3, i3, r3) {
        return 0 != (n4 = [r3[0] - i3[0], r3[1] - i3[1]])[0] * (o3 = [t3[0] - e4[0], t3[1] - e4[1]])[1] - n4[1] * o3[0] && !(!qi(e4, t3, i3, r3) || !qi(i3, r3, e4, t3));
        var n4, o3;
      }
      const $i = 8192;
      function Wi(e4, t3) {
        const i3 = (180 + e4[0]) / 360, r3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e4[1] * Math.PI / 360))) / 360, n4 = Math.pow(2, t3.z);
        return [Math.round(i3 * n4 * $i), Math.round(r3 * n4 * $i)];
      }
      function Hi(e4, t3) {
        for (let i3 = 0; i3 < t3.length; i3++)
          if (Gi(e4, t3[i3]))
            return true;
        return false;
      }
      function Xi(e4, t3, i3) {
        for (const r3 of i3)
          for (let i4 = 0, n4 = r3.length, o3 = n4 - 1; i4 < n4; o3 = i4++)
            if (Zi(e4, t3, r3[o3], r3[i4]))
              return true;
        return false;
      }
      function Yi(e4, t3) {
        for (let i3 = 0; i3 < e4.length; ++i3)
          if (!Gi(e4[i3], t3))
            return false;
        for (let i3 = 0; i3 < e4.length - 1; ++i3)
          if (Xi(e4[i3], e4[i3 + 1], t3))
            return false;
        return true;
      }
      function Ki(e4, t3) {
        for (let i3 = 0; i3 < t3.length; i3++)
          if (Yi(e4, t3[i3]))
            return true;
        return false;
      }
      function Ji(e4, t3, i3) {
        const r3 = [];
        for (let n4 = 0; n4 < e4.length; n4++) {
          const o3 = [];
          for (let r4 = 0; r4 < e4[n4].length; r4++) {
            const s6 = Wi(e4[n4][r4], i3);
            Ui(t3, s6), o3.push(s6);
          }
          r3.push(o3);
        }
        return r3;
      }
      function Qi(e4, t3, i3) {
        const r3 = [];
        for (let n4 = 0; n4 < e4.length; n4++) {
          const o3 = Ji(e4[n4], t3, i3);
          r3.push(o3);
        }
        return r3;
      }
      function er(e4, t3, i3, r3) {
        if (e4[0] < i3[0] || e4[0] > i3[2]) {
          const t4 = 0.5 * r3;
          let n4 = e4[0] - i3[0] > t4 ? -r3 : i3[0] - e4[0] > t4 ? r3 : 0;
          0 === n4 && (n4 = e4[0] - i3[2] > t4 ? -r3 : i3[2] - e4[0] > t4 ? r3 : 0), e4[0] += n4;
        }
        Ui(t3, e4);
      }
      function tr(e4, t3, i3, r3) {
        const n4 = Math.pow(2, r3.z) * $i, o3 = [r3.x * $i, r3.y * $i], s6 = [];
        if (!e4)
          return s6;
        for (const r4 of e4)
          for (const e5 of r4) {
            const r5 = [e5.x + o3[0], e5.y + o3[1]];
            er(r5, t3, i3, n4), s6.push(r5);
          }
        return s6;
      }
      function ir(e4, t3, i3, r3) {
        const n4 = Math.pow(2, r3.z) * $i, o3 = [r3.x * $i, r3.y * $i], s6 = [];
        if (!e4)
          return s6;
        for (const i4 of e4) {
          const e5 = [];
          for (const r4 of i4) {
            const i5 = [r4.x + o3[0], r4.y + o3[1]];
            Ui(t3, i5), e5.push(i5);
          }
          s6.push(e5);
        }
        if (t3[2] - t3[0] <= n4 / 2) {
          (a3 = t3)[0] = a3[1] = 1 / 0, a3[2] = a3[3] = -1 / 0;
          for (const e5 of s6)
            for (const r4 of e5)
              er(r4, t3, i3, n4);
        }
        var a3;
        return s6;
      }
      class rr {
        constructor(e4, t3) {
          this.type = qt, this.geojson = e4, this.geometries = t3;
        }
        static parse(e4, t3) {
          if (2 !== e4.length)
            return t3.error(`'within' expression requires exactly one argument, but found ${e4.length - 1} instead.`);
          if (_i(e4[1])) {
            const t4 = e4[1];
            if ("FeatureCollection" === t4.type)
              for (let e5 = 0; e5 < t4.features.length; ++e5) {
                const i3 = t4.features[e5].geometry.type;
                if ("Polygon" === i3 || "MultiPolygon" === i3)
                  return new rr(t4, t4.features[e5].geometry);
              }
            else if ("Feature" === t4.type) {
              const e5 = t4.geometry.type;
              if ("Polygon" === e5 || "MultiPolygon" === e5)
                return new rr(t4, t4.geometry);
            } else if ("Polygon" === t4.type || "MultiPolygon" === t4.type)
              return new rr(t4, t4);
          }
          return t3.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e4) {
          if (null != e4.geometry() && null != e4.canonicalID()) {
            if ("Point" === e4.geometryType())
              return function(e5, t3) {
                const i3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n4 = e5.canonicalID();
                if (!n4)
                  return false;
                if ("Polygon" === t3.type) {
                  const o3 = Ji(t3.coordinates, r3, n4), s6 = tr(e5.geometry(), i3, r3, n4);
                  if (!Vi(i3, r3))
                    return false;
                  for (const e6 of s6)
                    if (!Gi(e6, o3))
                      return false;
                }
                if ("MultiPolygon" === t3.type) {
                  const o3 = Qi(t3.coordinates, r3, n4), s6 = tr(e5.geometry(), i3, r3, n4);
                  if (!Vi(i3, r3))
                    return false;
                  for (const e6 of s6)
                    if (!Hi(e6, o3))
                      return false;
                }
                return true;
              }(e4, this.geometries);
            if ("LineString" === e4.geometryType())
              return function(e5, t3) {
                const i3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n4 = e5.canonicalID();
                if (!n4)
                  return false;
                if ("Polygon" === t3.type) {
                  const o3 = Ji(t3.coordinates, r3, n4), s6 = ir(e5.geometry(), i3, r3, n4);
                  if (!Vi(i3, r3))
                    return false;
                  for (const e6 of s6)
                    if (!Yi(e6, o3))
                      return false;
                }
                if ("MultiPolygon" === t3.type) {
                  const o3 = Qi(t3.coordinates, r3, n4), s6 = ir(e5.geometry(), i3, r3, n4);
                  if (!Vi(i3, r3))
                    return false;
                  for (const e6 of s6)
                    if (!Ki(e6, o3))
                      return false;
                }
                return true;
              }(e4, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      var nr = rr, or = { exports: {} };
      or.exports = function() {
        var e4 = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, t3 = 1 / 298.257223563, i3 = t3 * (2 - t3), r3 = Math.PI / 180, n4 = function(t4, n5) {
          if (void 0 === t4)
            throw new Error("No latitude given.");
          if (n5 && !e4[n5])
            throw new Error("Unknown unit " + n5 + ". Use one of: " + Object.keys(e4).join(", "));
          var o4 = 6378.137 * r3 * (n5 ? e4[n5] : 1), s7 = Math.cos(t4 * r3), a4 = 1 / (1 - i3 * (1 - s7 * s7)), l4 = Math.sqrt(a4);
          this.kx = o4 * l4 * s7, this.ky = o4 * l4 * a4 * (1 - i3);
        }, o3 = { units: { configurable: true } };
        function s6(e5, t4) {
          return e5[0] === t4[0] && e5[1] === t4[1];
        }
        function a3(e5, t4, i4) {
          var r4 = l3(t4[0] - e5[0]);
          return [e5[0] + r4 * i4, e5[1] + (t4[1] - e5[1]) * i4];
        }
        function l3(e5) {
          for (; e5 < -180; )
            e5 += 360;
          for (; e5 > 180; )
            e5 -= 360;
          return e5;
        }
        return n4.fromTile = function(e5, t4, i4) {
          var o4 = Math.PI * (1 - 2 * (e5 + 0.5) / Math.pow(2, t4)), s7 = Math.atan(0.5 * (Math.exp(o4) - Math.exp(-o4))) / r3;
          return new n4(s7, i4);
        }, o3.units.get = function() {
          return e4;
        }, n4.prototype.distance = function(e5, t4) {
          var i4 = l3(e5[0] - t4[0]) * this.kx, r4 = (e5[1] - t4[1]) * this.ky;
          return Math.sqrt(i4 * i4 + r4 * r4);
        }, n4.prototype.bearing = function(e5, t4) {
          var i4 = l3(t4[0] - e5[0]) * this.kx;
          return Math.atan2(i4, (t4[1] - e5[1]) * this.ky) / r3;
        }, n4.prototype.destination = function(e5, t4, i4) {
          var n5 = i4 * r3;
          return this.offset(e5, Math.sin(n5) * t4, Math.cos(n5) * t4);
        }, n4.prototype.offset = function(e5, t4, i4) {
          return [e5[0] + t4 / this.kx, e5[1] + i4 / this.ky];
        }, n4.prototype.lineDistance = function(e5) {
          for (var t4 = 0, i4 = 0; i4 < e5.length - 1; i4++)
            t4 += this.distance(e5[i4], e5[i4 + 1]);
          return t4;
        }, n4.prototype.area = function(e5) {
          for (var t4 = 0, i4 = 0; i4 < e5.length; i4++)
            for (var r4 = e5[i4], n5 = 0, o4 = r4.length, s7 = o4 - 1; n5 < o4; s7 = n5++)
              t4 += l3(r4[n5][0] - r4[s7][0]) * (r4[n5][1] + r4[s7][1]) * (i4 ? -1 : 1);
          return Math.abs(t4) / 2 * this.kx * this.ky;
        }, n4.prototype.along = function(e5, t4) {
          var i4 = 0;
          if (t4 <= 0)
            return e5[0];
          for (var r4 = 0; r4 < e5.length - 1; r4++) {
            var n5 = e5[r4], o4 = e5[r4 + 1], s7 = this.distance(n5, o4);
            if ((i4 += s7) > t4)
              return a3(n5, o4, (t4 - (i4 - s7)) / s7);
          }
          return e5[e5.length - 1];
        }, n4.prototype.pointToSegmentDistance = function(e5, t4, i4) {
          var r4 = t4[0], n5 = t4[1], o4 = l3(i4[0] - r4) * this.kx, s7 = (i4[1] - n5) * this.ky, a4 = 0;
          return 0 === o4 && 0 === s7 || ((a4 = (l3(e5[0] - r4) * this.kx * o4 + (e5[1] - n5) * this.ky * s7) / (o4 * o4 + s7 * s7)) > 1 ? (r4 = i4[0], n5 = i4[1]) : a4 > 0 && (r4 += o4 / this.kx * a4, n5 += s7 / this.ky * a4)), o4 = l3(e5[0] - r4) * this.kx, s7 = (e5[1] - n5) * this.ky, Math.sqrt(o4 * o4 + s7 * s7);
        }, n4.prototype.pointOnLine = function(e5, t4) {
          for (var i4, r4, n5, o4, s7 = 1 / 0, a4 = 0; a4 < e5.length - 1; a4++) {
            var c3 = e5[a4][0], h3 = e5[a4][1], u3 = l3(e5[a4 + 1][0] - c3) * this.kx, d3 = (e5[a4 + 1][1] - h3) * this.ky, p3 = 0;
            0 === u3 && 0 === d3 || ((p3 = (l3(t4[0] - c3) * this.kx * u3 + (t4[1] - h3) * this.ky * d3) / (u3 * u3 + d3 * d3)) > 1 ? (c3 = e5[a4 + 1][0], h3 = e5[a4 + 1][1]) : p3 > 0 && (c3 += u3 / this.kx * p3, h3 += d3 / this.ky * p3));
            var f3 = (u3 = l3(t4[0] - c3) * this.kx) * u3 + (d3 = (t4[1] - h3) * this.ky) * d3;
            f3 < s7 && (s7 = f3, i4 = c3, r4 = h3, n5 = a4, o4 = p3);
          }
          return { point: [i4, r4], index: n5, t: Math.max(0, Math.min(1, o4)) };
        }, n4.prototype.lineSlice = function(e5, t4, i4) {
          var r4 = this.pointOnLine(i4, e5), n5 = this.pointOnLine(i4, t4);
          if (r4.index > n5.index || r4.index === n5.index && r4.t > n5.t) {
            var o4 = r4;
            r4 = n5, n5 = o4;
          }
          var a4 = [r4.point], l4 = r4.index + 1, c3 = n5.index;
          !s6(i4[l4], a4[0]) && l4 <= c3 && a4.push(i4[l4]);
          for (var h3 = l4 + 1; h3 <= c3; h3++)
            a4.push(i4[h3]);
          return s6(i4[c3], n5.point) || a4.push(n5.point), a4;
        }, n4.prototype.lineSliceAlong = function(e5, t4, i4) {
          for (var r4 = 0, n5 = [], o4 = 0; o4 < i4.length - 1; o4++) {
            var s7 = i4[o4], l4 = i4[o4 + 1], c3 = this.distance(s7, l4);
            if ((r4 += c3) > e5 && 0 === n5.length && n5.push(a3(s7, l4, (e5 - (r4 - c3)) / c3)), r4 >= t4)
              return n5.push(a3(s7, l4, (t4 - (r4 - c3)) / c3)), n5;
            r4 > e5 && n5.push(l4);
          }
          return n5;
        }, n4.prototype.bufferPoint = function(e5, t4) {
          var i4 = t4 / this.ky, r4 = t4 / this.kx;
          return [e5[0] - r4, e5[1] - i4, e5[0] + r4, e5[1] + i4];
        }, n4.prototype.bufferBBox = function(e5, t4) {
          var i4 = t4 / this.ky, r4 = t4 / this.kx;
          return [e5[0] - r4, e5[1] - i4, e5[2] + r4, e5[3] + i4];
        }, n4.prototype.insideBBox = function(e5, t4) {
          return l3(e5[0] - t4[0]) >= 0 && l3(e5[0] - t4[2]) <= 0 && e5[1] >= t4[1] && e5[1] <= t4[3];
        }, Object.defineProperties(n4, o3), n4;
      }();
      var sr = d2(or.exports), ar = { exports: {} };
      ar.exports = function() {
        var e4 = function(e5, i3) {
          if (void 0 === e5 && (e5 = []), void 0 === i3 && (i3 = t3), this.data = e5, this.length = this.data.length, this.compare = i3, this.length > 0)
            for (var r3 = (this.length >> 1) - 1; r3 >= 0; r3--)
              this._down(r3);
        };
        function t3(e5, t4) {
          return e5 < t4 ? -1 : e5 > t4 ? 1 : 0;
        }
        return e4.prototype.push = function(e5) {
          this.data.push(e5), this.length++, this._up(this.length - 1);
        }, e4.prototype.pop = function() {
          if (0 !== this.length) {
            var e5 = this.data[0], t4 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = t4, this._down(0)), e5;
          }
        }, e4.prototype.peek = function() {
          return this.data[0];
        }, e4.prototype._up = function(e5) {
          for (var t4 = this.data, i3 = this.compare, r3 = t4[e5]; e5 > 0; ) {
            var n4 = e5 - 1 >> 1, o3 = t4[n4];
            if (i3(r3, o3) >= 0)
              break;
            t4[e5] = o3, e5 = n4;
          }
          t4[e5] = r3;
        }, e4.prototype._down = function(e5) {
          for (var t4 = this.data, i3 = this.compare, r3 = this.length >> 1, n4 = t4[e5]; e5 < r3; ) {
            var o3 = 1 + (e5 << 1), s6 = t4[o3], a3 = o3 + 1;
            if (a3 < this.length && i3(t4[a3], s6) < 0 && (o3 = a3, s6 = t4[a3]), i3(s6, n4) >= 0)
              break;
            t4[e5] = s6, e5 = o3;
          }
          t4[e5] = n4;
        }, e4;
      }();
      var lr = d2(ar.exports), cr = 8192;
      function hr(e4, t3) {
        return t3.dist - e4.dist;
      }
      const ur = 100, dr = 50;
      function pr(e4) {
        const t3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (t3.length !== e4.length)
          return false;
        for (let i3 = 0; i3 < t3.length; i3++)
          if (t3[i3] !== e4[i3])
            return false;
        return true;
      }
      function fr(e4) {
        return e4[1] - e4[0] + 1;
      }
      function mr(e4, t3) {
        const i3 = e4[1] >= e4[0] && e4[1] < t3;
        return i3 || console.warn("Distance Expression: Index is out of range"), i3;
      }
      function _r(e4, t3) {
        if (e4[0] > e4[1])
          return [null, null];
        const i3 = fr(e4);
        if (t3) {
          if (2 === i3)
            return [e4, null];
          const t4 = Math.floor(i3 / 2);
          return [[e4[0], e4[0] + t4], [e4[0] + t4, e4[1]]];
        }
        {
          if (1 === i3)
            return [e4, null];
          const t4 = Math.floor(i3 / 2) - 1;
          return [[e4[0], e4[0] + t4], [e4[0] + t4 + 1, e4[1]]];
        }
      }
      function gr(e4, t3) {
        const i3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (!mr(t3, e4.length))
          return i3;
        for (let r3 = t3[0]; r3 <= t3[1]; ++r3)
          Ui(i3, e4[r3]);
        return i3;
      }
      function yr(e4) {
        const t3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let i3 = 0; i3 < e4.length; ++i3)
          for (let r3 = 0; r3 < e4[i3].length; ++r3)
            Ui(t3, e4[i3][r3]);
        return t3;
      }
      function xr(e4, t3, i3) {
        if (pr(e4) || pr(t3))
          return NaN;
        let r3 = 0, n4 = 0;
        return e4[2] < t3[0] && (r3 = t3[0] - e4[2]), e4[0] > t3[2] && (r3 = e4[0] - t3[2]), e4[1] > t3[3] && (n4 = e4[1] - t3[3]), e4[3] < t3[1] && (n4 = t3[1] - e4[3]), i3.distance([0, 0], [r3, n4]);
      }
      function vr(e4, t3) {
        const i3 = Math.pow(2, t3.z);
        return [(n4 = (e4.x / cr + t3.x) / i3, 360 * n4 - 180), (r3 = (e4.y / cr + t3.y) / i3, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r3) * Math.PI / 180)) - 90)];
        var r3, n4;
      }
      function br(e4, t3) {
        const i3 = [];
        for (let r3 = 0; r3 < e4.length; ++r3)
          i3.push(vr(e4[r3], t3));
        return i3;
      }
      function wr(e4, t3, i3) {
        const r3 = i3.pointOnLine(t3, e4).point;
        return i3.distance(e4, r3);
      }
      function Tr(e4, t3, i3, r3, n4) {
        const o3 = i3.slice(r3[0], r3[1] + 1);
        let s6 = 1 / 0;
        for (let i4 = t3[0]; i4 <= t3[1]; ++i4)
          if (0 === (s6 = Math.min(s6, wr(e4[i4], o3, n4))))
            return 0;
        return s6;
      }
      function Er(e4, t3, i3, r3, n4) {
        const o3 = Math.min(n4.pointToSegmentDistance(e4, i3, r3), n4.pointToSegmentDistance(t3, i3, r3)), s6 = Math.min(n4.pointToSegmentDistance(i3, e4, t3), n4.pointToSegmentDistance(r3, e4, t3));
        return Math.min(o3, s6);
      }
      function Mr(e4, t3, i3, r3, n4) {
        if (!mr(t3, e4.length) || !mr(r3, i3.length))
          return NaN;
        let o3 = 1 / 0;
        for (let s6 = t3[0]; s6 < t3[1]; ++s6)
          for (let t4 = r3[0]; t4 < r3[1]; ++t4) {
            if (Zi(e4[s6], e4[s6 + 1], i3[t4], i3[t4 + 1]))
              return 0;
            o3 = Math.min(o3, Er(e4[s6], e4[s6 + 1], i3[t4], i3[t4 + 1], n4));
          }
        return o3;
      }
      function Ar(e4, t3, i3, r3, n4) {
        if (!mr(t3, e4.length) || !mr(r3, i3.length))
          return NaN;
        let o3 = 1 / 0;
        for (let s6 = t3[0]; s6 <= t3[1]; ++s6)
          for (let t4 = r3[0]; t4 <= r3[1]; ++t4)
            if (0 === (o3 = Math.min(o3, n4.distance(e4[s6], i3[t4]))))
              return o3;
        return o3;
      }
      function Sr(e4, t3, i3) {
        if (Gi(e4, t3, true))
          return 0;
        let r3 = 1 / 0;
        for (const n4 of t3) {
          const t4 = n4.length;
          if (t4 < 2)
            return console.warn("Distance Expression: Invalid polygon!"), NaN;
          if (n4[0] !== n4[t4 - 1] && 0 === (r3 = Math.min(r3, i3.pointToSegmentDistance(e4, n4[t4 - 1], n4[0]))))
            return r3;
          if (0 === (r3 = Math.min(r3, wr(e4, n4, i3))))
            return r3;
        }
        return r3;
      }
      function Ir(e4, t3, i3, r3) {
        if (!mr(t3, e4.length))
          return NaN;
        for (let r4 = t3[0]; r4 <= t3[1]; ++r4)
          if (Gi(e4[r4], i3, true))
            return 0;
        let n4 = 1 / 0;
        for (let o3 = t3[0]; o3 < t3[1]; ++o3)
          for (const t4 of i3)
            for (let i4 = 0, s6 = t4.length, a3 = s6 - 1; i4 < s6; a3 = i4++) {
              if (Zi(e4[o3], e4[o3 + 1], t4[a3], t4[i4]))
                return 0;
              n4 = Math.min(n4, Er(e4[o3], e4[o3 + 1], t4[a3], t4[i4], r3));
            }
        return n4;
      }
      function Cr(e4, t3) {
        for (const i3 of e4)
          for (let e5 = 0; e5 <= i3.length - 1; ++e5)
            if (Gi(i3[e5], t3, true))
              return true;
        return false;
      }
      function zr(e4, t3, i3, r3 = 1 / 0) {
        const n4 = yr(e4), o3 = yr(t3);
        if (r3 !== 1 / 0 && xr(n4, o3, i3) >= r3)
          return r3;
        if (Vi(n4, o3)) {
          if (Cr(e4, t3))
            return 0;
        } else if (Cr(t3, e4))
          return 0;
        let s6 = r3;
        for (const r4 of e4)
          for (let e5 = 0, n5 = r4.length, o4 = n5 - 1; e5 < n5; o4 = e5++)
            for (const n6 of t3)
              for (let t4 = 0, a3 = n6.length, l3 = a3 - 1; t4 < a3; l3 = t4++) {
                if (Zi(r4[o4], r4[e5], n6[l3], n6[t4]))
                  return 0;
                s6 = Math.min(s6, Er(r4[o4], r4[e5], n6[l3], n6[t4], i3));
              }
        return s6;
      }
      function Pr(e4, t3, i3, r3, n4, o3, s6) {
        if (null === o3 || null === s6)
          return;
        const a3 = xr(gr(r3, o3), gr(n4, s6), i3);
        a3 < t3 && e4.push({ dist: a3, range1: o3, range2: s6 });
      }
      function Dr(e4, t3, i3, r3, n4 = 1 / 0) {
        let o3 = Math.min(r3.distance(e4[0], i3[0][0]), n4);
        if (0 === o3)
          return o3;
        const s6 = new lr([{ dist: 0, range1: [0, e4.length - 1], range2: [0, 0] }], hr), a3 = t3 ? dr : ur, l3 = yr(i3);
        for (; s6.length; ) {
          const n5 = s6.pop();
          if (n5.dist >= o3)
            continue;
          const c3 = n5.range1;
          if (fr(c3) <= a3) {
            if (!mr(c3, e4.length))
              return NaN;
            if (t3) {
              const t4 = Ir(e4, c3, i3, r3);
              if (0 === (o3 = Math.min(o3, t4)))
                return o3;
            } else
              for (let t4 = c3[0]; t4 <= c3[1]; ++t4) {
                const n6 = Sr(e4[t4], i3, r3);
                if (0 === (o3 = Math.min(o3, n6)))
                  return o3;
              }
          } else {
            const i4 = _r(c3, t3);
            if (null !== i4[0]) {
              const t4 = xr(gr(e4, i4[0]), l3, r3);
              t4 < o3 && s6.push({ dist: t4, range1: i4[0], range2: [0, 0] });
            }
            if (null !== i4[1]) {
              const t4 = xr(gr(e4, i4[1]), l3, r3);
              t4 < o3 && s6.push({ dist: t4, range1: i4[1], range2: [0, 0] });
            }
          }
        }
        return o3;
      }
      function Rr(e4, t3, i3, r3, n4, o3 = 1 / 0) {
        let s6 = Math.min(o3, n4.distance(e4[0], i3[0]));
        if (0 === s6)
          return s6;
        const a3 = new lr([{ dist: 0, range1: [0, e4.length - 1], range2: [0, i3.length - 1] }], hr), l3 = t3 ? dr : ur, c3 = r3 ? dr : ur;
        for (; a3.length; ) {
          const o4 = a3.pop();
          if (o4.dist >= s6)
            continue;
          const h3 = o4.range1, u3 = o4.range2;
          if (fr(h3) <= l3 && fr(u3) <= c3) {
            if (!mr(h3, e4.length) || !mr(u3, i3.length))
              return NaN;
            if (t3 && r3 ? s6 = Math.min(s6, Mr(e4, h3, i3, u3, n4)) : t3 || r3 ? t3 && !r3 ? s6 = Math.min(s6, Tr(i3, u3, e4, h3, n4)) : !t3 && r3 && (s6 = Math.min(s6, Tr(e4, h3, i3, u3, n4))) : s6 = Math.min(s6, Ar(e4, h3, i3, u3, n4)), 0 === s6)
              return s6;
          } else {
            const o5 = _r(h3, t3), l4 = _r(u3, r3);
            Pr(a3, s6, n4, e4, i3, o5[0], l4[0]), Pr(a3, s6, n4, e4, i3, o5[0], l4[1]), Pr(a3, s6, n4, e4, i3, o5[1], l4[0]), Pr(a3, s6, n4, e4, i3, o5[1], l4[1]);
          }
        }
        return s6;
      }
      function Lr(e4, t3, i3, r3, n4 = 1 / 0) {
        let o3 = n4;
        const s6 = gr(e4, [0, e4.length - 1]);
        for (const n5 of i3)
          if (!(o3 !== 1 / 0 && xr(s6, gr(n5, [0, n5.length - 1]), r3) >= o3) && (o3 = Math.min(o3, Rr(e4, t3, n5, true, r3, o3)), 0 === o3))
            return o3;
        return o3;
      }
      function kr(e4, t3, i3, r3, n4 = 1 / 0) {
        let o3 = n4;
        const s6 = gr(e4, [0, e4.length - 1]);
        for (const n5 of i3) {
          if (o3 !== 1 / 0 && xr(s6, yr(n5), r3) >= o3)
            continue;
          const i4 = Dr(e4, t3, n5, r3, o3);
          if (isNaN(i4))
            return i4;
          if (0 === (o3 = Math.min(o3, i4)))
            return o3;
        }
        return o3;
      }
      function Or(e4) {
        return "Point" === e4 || "MultiPoint" === e4 || "LineString" === e4 || "MultiLineString" === e4 || "Polygon" === e4 || "MultiPolygon" === e4;
      }
      class Br {
        constructor(e4, t3) {
          this.type = jt, this.geojson = e4, this.geometries = t3;
        }
        static parse(e4, t3) {
          if (2 !== e4.length)
            return t3.error(`'distance' expression requires either one argument, but found ' ${e4.length - 1} instead.`);
          if (_i(e4[1])) {
            const t4 = e4[1];
            if ("FeatureCollection" === t4.type) {
              for (let e5 = 0; e5 < t4.features.length; ++e5)
                if (Or(t4.features[e5].geometry.type))
                  return new Br(t4, t4.features[e5].geometry);
            } else if ("Feature" === t4.type) {
              if (Or(t4.geometry.type))
                return new Br(t4, t4.geometry);
            } else if (Or(t4.type))
              return new Br(t4, t4);
          }
          return t3.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
        }
        evaluate(e4) {
          const t3 = e4.geometry(), i3 = e4.canonicalID();
          if (null != t3 && null != i3) {
            if ("Point" === e4.geometryType())
              return function(e5, t4, i4) {
                const r3 = [];
                for (const i5 of e5)
                  for (const e6 of i5)
                    r3.push(vr(e6, t4));
                const n4 = new sr(r3[0][1], "meters");
                return "Point" === i4.type || "MultiPoint" === i4.type || "LineString" === i4.type ? Rr(r3, false, "Point" === i4.type ? [i4.coordinates] : i4.coordinates, "LineString" === i4.type, n4) : "MultiLineString" === i4.type ? Lr(r3, false, i4.coordinates, n4) : "Polygon" === i4.type || "MultiPolygon" === i4.type ? kr(r3, false, "Polygon" === i4.type ? [i4.coordinates] : i4.coordinates, n4) : null;
              }(t3, i3, this.geometries);
            if ("LineString" === e4.geometryType())
              return function(e5, t4, i4) {
                const r3 = [];
                for (const i5 of e5) {
                  const e6 = [];
                  for (const r4 of i5)
                    e6.push(vr(r4, t4));
                  r3.push(e6);
                }
                const n4 = new sr(r3[0][0][1], "meters");
                if ("Point" === i4.type || "MultiPoint" === i4.type || "LineString" === i4.type)
                  return Lr("Point" === i4.type ? [i4.coordinates] : i4.coordinates, "LineString" === i4.type, r3, n4);
                if ("MultiLineString" === i4.type) {
                  let e6 = 1 / 0;
                  for (let t5 = 0; t5 < i4.coordinates.length; t5++) {
                    const o3 = Lr(i4.coordinates[t5], true, r3, n4, e6);
                    if (isNaN(o3))
                      return o3;
                    if (0 === (e6 = Math.min(e6, o3)))
                      return e6;
                  }
                  return e6;
                }
                if ("Polygon" === i4.type || "MultiPolygon" === i4.type) {
                  let e6 = 1 / 0;
                  for (let t5 = 0; t5 < r3.length; t5++) {
                    const o3 = kr(r3[t5], true, "Polygon" === i4.type ? [i4.coordinates] : i4.coordinates, n4, e6);
                    if (isNaN(o3))
                      return o3;
                    if (0 === (e6 = Math.min(e6, o3)))
                      return e6;
                  }
                  return e6;
                }
                return null;
              }(t3, i3, this.geometries);
            if ("Polygon" === e4.geometryType())
              return function(e5, t4, i4) {
                const r3 = [];
                for (const i5 of function(e6, t5) {
                  const i6 = e6.length;
                  if (i6 <= 1)
                    return [e6];
                  const r4 = [];
                  let n5, o3;
                  for (let t6 = 0; t6 < i6; t6++) {
                    const i7 = Ni(e6[t6]);
                    0 !== i7 && (e6[t6].area = Math.abs(i7), void 0 === o3 && (o3 = i7 < 0), o3 === i7 < 0 ? (n5 && r4.push(n5), n5 = [e6[t6]]) : n5.push(e6[t6]));
                  }
                  return n5 && r4.push(n5), r4;
                }(e5)) {
                  const e6 = [];
                  for (let r4 = 0; r4 < i5.length; ++r4)
                    e6.push(br(i5[r4], t4));
                  r3.push(e6);
                }
                const n4 = new sr(r3[0][0][0][1], "meters");
                if ("Point" === i4.type || "MultiPoint" === i4.type || "LineString" === i4.type)
                  return kr("Point" === i4.type ? [i4.coordinates] : i4.coordinates, "LineString" === i4.type, r3, n4);
                if ("MultiLineString" === i4.type) {
                  let e6 = 1 / 0;
                  for (let t5 = 0; t5 < i4.coordinates.length; t5++) {
                    const o3 = kr(i4.coordinates[t5], true, r3, n4, e6);
                    if (isNaN(o3))
                      return o3;
                    if (0 === (e6 = Math.min(e6, o3)))
                      return e6;
                  }
                  return e6;
                }
                return "Polygon" === i4.type || "MultiPolygon" === i4.type ? function(e6, t5, i5) {
                  let r4 = 1 / 0;
                  for (const n5 of e6)
                    for (const e7 of t5) {
                      const t6 = zr(n5, e7, i5, r4);
                      if (isNaN(t6))
                        return t6;
                      if (0 === (r4 = Math.min(r4, t6)))
                        return r4;
                    }
                  return r4;
                }("Polygon" === i4.type ? [i4.coordinates] : i4.coordinates, r3, n4) : null;
              }(t3, i3, this.geometries);
            console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
          } else
            console.warn("Distance Expression: requirs valid feature and canonical information.");
          return null;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["distance", this.geojson];
        }
      }
      var Fr = Br;
      function Nr(e4) {
        if (e4 instanceof ki) {
          if ("get" === e4.name && 1 === e4.args.length)
            return false;
          if ("feature-state" === e4.name)
            return false;
          if ("has" === e4.name && 1 === e4.args.length)
            return false;
          if ("properties" === e4.name || "geometry-type" === e4.name || "id" === e4.name)
            return false;
          if (/^filter-/.test(e4.name))
            return false;
        }
        if (e4 instanceof nr)
          return false;
        if (e4 instanceof Fr)
          return false;
        let t3 = true;
        return e4.eachChild((e5) => {
          t3 && !Nr(e5) && (t3 = false);
        }), t3;
      }
      function Ur(e4) {
        if (e4 instanceof ki && "feature-state" === e4.name)
          return false;
        let t3 = true;
        return e4.eachChild((e5) => {
          t3 && !Ur(e5) && (t3 = false);
        }), t3;
      }
      function Vr(e4) {
        if (e4 instanceof ki && "config" === e4.name)
          return false;
        let t3 = true;
        return e4.eachChild((e5) => {
          t3 && !Vr(e5) && (t3 = false);
        }), t3;
      }
      function jr(e4, t3) {
        if (e4 instanceof ki && t3.indexOf(e4.name) >= 0)
          return false;
        let i3 = true;
        return e4.eachChild((e5) => {
          i3 && !jr(e5, t3) && (i3 = false);
        }), i3;
      }
      class Gr {
        constructor(e4, t3) {
          this.type = t3.type, this.name = e4, this.boundExpression = t3;
        }
        static parse(e4, t3) {
          if (2 !== e4.length || "string" != typeof e4[1])
            return t3.error("'var' expression requires exactly one string literal argument.");
          const i3 = e4[1];
          return t3.scope.has(i3) ? new Gr(i3, t3.scope.get(i3)) : t3.error(`Unknown variable "${i3}". Make sure "${i3}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e4) {
          return this.boundExpression.evaluate(e4);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      var qr = Gr;
      class Zr {
        constructor(e4, t3 = [], i3, r3 = new Ut(), n4 = [], o3) {
          this.registry = e4, this.path = t3, this.key = t3.map((e5) => `[${e5}]`).join(""), this.scope = r3, this.errors = n4, this.expectedType = i3, this.options = o3;
        }
        parse(e4, t3, i3, r3, n4 = {}) {
          return t3 || i3 ? this.concat(t3, i3, r3)._parse(e4, n4) : this._parse(e4, n4);
        }
        _parse(e4, t3) {
          function i3(e5, t4, i4) {
            return "assert" === i4 ? new Ei(t4, [e5]) : "coerce" === i4 ? new zi(t4, [e5]) : e5;
          }
          if (null !== e4 && "string" != typeof e4 && "boolean" != typeof e4 && "number" != typeof e4 || (e4 = ["literal", e4]), Array.isArray(e4)) {
            if (0 === e4.length)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const r3 = "string" == typeof e4[0] ? this.registry[e4[0]] : void 0;
            if (r3) {
              let n4 = r3.parse(e4, this);
              if (!n4)
                return null;
              if (this.expectedType) {
                const e5 = this.expectedType, r4 = n4.type;
                if ("string" !== e5.kind && "number" !== e5.kind && "boolean" !== e5.kind && "object" !== e5.kind && "array" !== e5.kind || "value" !== r4.kind)
                  if ("color" !== e5.kind && "formatted" !== e5.kind && "resolvedImage" !== e5.kind || "value" !== r4.kind && "string" !== r4.kind) {
                    if (this.checkSubtype(e5, r4))
                      return null;
                  } else
                    n4 = i3(n4, e5, t3.typeAnnotation || "coerce");
                else
                  n4 = i3(n4, e5, t3.typeAnnotation || "assert");
              }
              if (!(n4 instanceof vi) && "resolvedImage" !== n4.type.kind && Wr(n4)) {
                const e5 = new Di(this.options);
                try {
                  n4 = new vi(n4.type, n4.evaluate(e5));
                } catch (e6) {
                  return this.error(e6.message), null;
                }
              }
              return n4;
            }
            return zi.parse(["to-array", e4], this);
          }
          return this.error(void 0 === e4 ? "'undefined' value invalid. Use null instead." : "object" == typeof e4 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e4} instead.`);
        }
        concat(e4, t3, i3) {
          const r3 = "number" == typeof e4 ? this.path.concat(e4) : this.path, n4 = i3 ? this.scope.concat(i3) : this.scope;
          return new Zr(this.registry, r3, t3 || null, n4, this.errors, this.options);
        }
        error(e4, ...t3) {
          const i3 = `${this.key}${t3.map((e5) => `[${e5}]`).join("")}`;
          this.errors.push(new Ft(i3, e4));
        }
        checkSubtype(e4, t3) {
          const i3 = ei(e4, t3);
          return i3 && this.error(i3), i3;
        }
      }
      var $r = Zr;
      function Wr(e4) {
        if (e4 instanceof qr)
          return Wr(e4.boundExpression);
        if (e4 instanceof ki && "error" === e4.name)
          return false;
        if (e4 instanceof ki && "config" === e4.name)
          return false;
        if (e4 instanceof Oi)
          return false;
        if (e4 instanceof nr)
          return false;
        if (e4 instanceof Fr)
          return false;
        const t3 = e4 instanceof zi || e4 instanceof Ei;
        let i3 = true;
        return e4.eachChild((e5) => {
          i3 = t3 ? i3 && Wr(e5) : i3 && e5 instanceof vi;
        }), !!i3 && Nr(e4) && jr(e4, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light"]);
      }
      function Hr(e4, t3) {
        const i3 = e4.length - 1;
        let r3, n4, o3 = 0, s6 = i3, a3 = 0;
        for (; o3 <= s6; )
          if (a3 = Math.floor((o3 + s6) / 2), r3 = e4[a3], n4 = e4[a3 + 1], r3 <= t3) {
            if (a3 === i3 || t3 < n4)
              return a3;
            o3 = a3 + 1;
          } else {
            if (!(r3 > t3))
              throw new bi("Input is not a number.");
            s6 = a3 - 1;
          }
        return 0;
      }
      class Xr {
        constructor(e4, t3, i3) {
          this.type = e4, this.input = t3, this.labels = [], this.outputs = [];
          for (const [e5, t4] of i3)
            this.labels.push(e5), this.outputs.push(t4);
        }
        static parse(e4, t3) {
          if (e4.length - 1 < 4)
            return t3.error(`Expected at least 4 arguments, but found only ${e4.length - 1}.`);
          if ((e4.length - 1) % 2 != 0)
            return t3.error("Expected an even number of arguments.");
          const i3 = t3.parse(e4[1], 1, jt);
          if (!i3)
            return null;
          const r3 = [];
          let n4 = null;
          t3.expectedType && "value" !== t3.expectedType.kind && (n4 = t3.expectedType);
          for (let i4 = 1; i4 < e4.length; i4 += 2) {
            const o3 = 1 === i4 ? -1 / 0 : e4[i4], s6 = e4[i4 + 1], a3 = i4, l3 = i4 + 1;
            if ("number" != typeof o3)
              return t3.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a3);
            if (r3.length && r3[r3.length - 1][0] >= o3)
              return t3.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a3);
            const c3 = t3.parse(s6, l3, n4);
            if (!c3)
              return null;
            n4 = n4 || c3.type, r3.push([o3, c3]);
          }
          return new Xr(n4, i3, r3);
        }
        evaluate(e4) {
          const t3 = this.labels, i3 = this.outputs;
          if (1 === t3.length)
            return i3[0].evaluate(e4);
          const r3 = this.input.evaluate(e4);
          if (r3 <= t3[0])
            return i3[0].evaluate(e4);
          const n4 = t3.length;
          return r3 >= t3[n4 - 1] ? i3[n4 - 1].evaluate(e4) : i3[Hr(t3, r3)].evaluate(e4);
        }
        eachChild(e4) {
          e4(this.input);
          for (const t3 of this.outputs)
            e4(t3);
        }
        outputDefined() {
          return this.outputs.every((e4) => e4.outputDefined());
        }
        serialize() {
          const e4 = ["step", this.input.serialize()];
          for (let t3 = 0; t3 < this.labels.length; t3++)
            t3 > 0 && e4.push(this.labels[t3]), e4.push(this.outputs[t3].serialize());
          return e4;
        }
      }
      var Yr = Xr;
      function Kr(e4, t3, i3) {
        return e4 * (1 - i3) + t3 * i3;
      }
      function Jr(e4, t3, i3) {
        return e4.map((e5, r3) => Kr(e5, t3[r3], i3));
      }
      var Qr = Object.freeze({ __proto__: null, array: Jr, color: function(e4, t3, i3) {
        return new hi(Kr(e4.r, t3.r, i3), Kr(e4.g, t3.g, i3), Kr(e4.b, t3.b, i3), Kr(e4.a, t3.a, i3));
      }, number: Kr });
      const en = 0.95047, tn = 1.08883, rn = 4 / 29, nn = 6 / 29, on = 3 * nn * nn, sn = nn * nn * nn, an = Math.PI / 180, ln = 180 / Math.PI;
      function cn(e4) {
        return e4 > sn ? Math.pow(e4, 1 / 3) : e4 / on + rn;
      }
      function hn(e4) {
        return e4 > nn ? e4 * e4 * e4 : on * (e4 - rn);
      }
      function un(e4) {
        return 255 * (e4 <= 31308e-7 ? 12.92 * e4 : 1.055 * Math.pow(e4, 1 / 2.4) - 0.055);
      }
      function dn(e4) {
        return (e4 /= 255) <= 0.04045 ? e4 / 12.92 : Math.pow((e4 + 0.055) / 1.055, 2.4);
      }
      function pn(e4) {
        const t3 = dn(e4.r), i3 = dn(e4.g), r3 = dn(e4.b), n4 = cn((0.4124564 * t3 + 0.3575761 * i3 + 0.1804375 * r3) / en), o3 = cn((0.2126729 * t3 + 0.7151522 * i3 + 0.072175 * r3) / 1);
        return { l: 116 * o3 - 16, a: 500 * (n4 - o3), b: 200 * (o3 - cn((0.0193339 * t3 + 0.119192 * i3 + 0.9503041 * r3) / tn)), alpha: e4.a };
      }
      function fn(e4) {
        let t3 = (e4.l + 16) / 116, i3 = isNaN(e4.a) ? t3 : t3 + e4.a / 500, r3 = isNaN(e4.b) ? t3 : t3 - e4.b / 200;
        return t3 = 1 * hn(t3), i3 = en * hn(i3), r3 = tn * hn(r3), new hi(un(3.2404542 * i3 - 1.5371385 * t3 - 0.4985314 * r3), un(-0.969266 * i3 + 1.8760108 * t3 + 0.041556 * r3), un(0.0556434 * i3 - 0.2040259 * t3 + 1.0572252 * r3), e4.alpha);
      }
      function mn(e4, t3, i3) {
        const r3 = t3 - e4;
        return e4 + i3 * (r3 > 180 || r3 < -180 ? r3 - 360 * Math.round(r3 / 360) : r3);
      }
      const _n = { forward: pn, reverse: fn, interpolate: function(e4, t3, i3) {
        return { l: Kr(e4.l, t3.l, i3), a: Kr(e4.a, t3.a, i3), b: Kr(e4.b, t3.b, i3), alpha: Kr(e4.alpha, t3.alpha, i3) };
      } }, gn = { forward: function(e4) {
        const { l: t3, a: i3, b: r3 } = pn(e4), n4 = Math.atan2(r3, i3) * ln;
        return { h: n4 < 0 ? n4 + 360 : n4, c: Math.sqrt(i3 * i3 + r3 * r3), l: t3, alpha: e4.a };
      }, reverse: function(e4) {
        const t3 = e4.h * an, i3 = e4.c;
        return fn({ l: e4.l, a: Math.cos(t3) * i3, b: Math.sin(t3) * i3, alpha: e4.alpha });
      }, interpolate: function(e4, t3, i3) {
        return { h: mn(e4.h, t3.h, i3), c: Kr(e4.c, t3.c, i3), l: Kr(e4.l, t3.l, i3), alpha: Kr(e4.alpha, t3.alpha, i3) };
      } };
      var yn = Object.freeze({ __proto__: null, hcl: gn, lab: _n });
      class xn {
        constructor(e4, t3, i3, r3, n4) {
          this.type = e4, this.operator = t3, this.interpolation = i3, this.input = r3, this.labels = [], this.outputs = [];
          for (const [e5, t4] of n4)
            this.labels.push(e5), this.outputs.push(t4);
        }
        static interpolationFactor(e4, t3, i3, r3) {
          let n4 = 0;
          if ("exponential" === e4.name)
            n4 = vn(t3, e4.base, i3, r3);
          else if ("linear" === e4.name)
            n4 = vn(t3, 1, i3, r3);
          else if ("cubic-bezier" === e4.name) {
            const o3 = e4.controlPoints;
            n4 = new m2(o3[0], o3[1], o3[2], o3[3]).solve(vn(t3, 1, i3, r3));
          }
          return n4;
        }
        static parse(e4, t3) {
          let [i3, r3, n4, ...o3] = e4;
          if (!Array.isArray(r3) || 0 === r3.length)
            return t3.error("Expected an interpolation type expression.", 1);
          if ("linear" === r3[0])
            r3 = { name: "linear" };
          else if ("exponential" === r3[0]) {
            const e5 = r3[1];
            if ("number" != typeof e5)
              return t3.error("Exponential interpolation requires a numeric base.", 1, 1);
            r3 = { name: "exponential", base: e5 };
          } else {
            if ("cubic-bezier" !== r3[0])
              return t3.error(`Unknown interpolation type ${String(r3[0])}`, 1, 0);
            {
              const e5 = r3.slice(1);
              if (4 !== e5.length || e5.some((e6) => "number" != typeof e6 || e6 < 0 || e6 > 1))
                return t3.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              r3 = { name: "cubic-bezier", controlPoints: e5 };
            }
          }
          if (e4.length - 1 < 4)
            return t3.error(`Expected at least 4 arguments, but found only ${e4.length - 1}.`);
          if ((e4.length - 1) % 2 != 0)
            return t3.error("Expected an even number of arguments.");
          if (n4 = t3.parse(n4, 2, jt), !n4)
            return null;
          const s6 = [];
          let a3 = null;
          "interpolate-hcl" === i3 || "interpolate-lab" === i3 ? a3 = Zt : t3.expectedType && "value" !== t3.expectedType.kind && (a3 = t3.expectedType);
          for (let e5 = 0; e5 < o3.length; e5 += 2) {
            const i4 = o3[e5], r4 = o3[e5 + 1], n5 = e5 + 3, l3 = e5 + 4;
            if ("number" != typeof i4)
              return t3.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', n5);
            if (s6.length && s6[s6.length - 1][0] >= i4)
              return t3.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', n5);
            const c3 = t3.parse(r4, l3, a3);
            if (!c3)
              return null;
            a3 = a3 || c3.type, s6.push([i4, c3]);
          }
          return "number" === a3.kind || "color" === a3.kind || "array" === a3.kind && "number" === a3.itemType.kind && "number" == typeof a3.N ? new xn(a3, i3, r3, n4, s6) : t3.error(`Type ${Jt(a3)} is not interpolatable.`);
        }
        evaluate(e4) {
          const t3 = this.labels, i3 = this.outputs;
          if (1 === t3.length)
            return i3[0].evaluate(e4);
          const r3 = this.input.evaluate(e4);
          if (r3 <= t3[0])
            return i3[0].evaluate(e4);
          const n4 = t3.length;
          if (r3 >= t3[n4 - 1])
            return i3[n4 - 1].evaluate(e4);
          const o3 = Hr(t3, r3), s6 = xn.interpolationFactor(this.interpolation, r3, t3[o3], t3[o3 + 1]), a3 = i3[o3].evaluate(e4), l3 = i3[o3 + 1].evaluate(e4);
          return "interpolate" === this.operator ? Qr[this.type.kind.toLowerCase()](a3, l3, s6) : "interpolate-hcl" === this.operator ? gn.reverse(gn.interpolate(gn.forward(a3), gn.forward(l3), s6)) : _n.reverse(_n.interpolate(_n.forward(a3), _n.forward(l3), s6));
        }
        eachChild(e4) {
          e4(this.input);
          for (const t3 of this.outputs)
            e4(t3);
        }
        outputDefined() {
          return this.outputs.every((e4) => e4.outputDefined());
        }
        serialize() {
          let e4;
          e4 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const t3 = [this.operator, e4, this.input.serialize()];
          for (let e5 = 0; e5 < this.labels.length; e5++)
            t3.push(this.labels[e5], this.outputs[e5].serialize());
          return t3;
        }
      }
      function vn(e4, t3, i3, r3) {
        const n4 = r3 - i3, o3 = e4 - i3;
        return 0 === n4 ? 0 : 1 === t3 ? o3 / n4 : (Math.pow(t3, o3) - 1) / (Math.pow(t3, n4) - 1);
      }
      var bn = xn;
      class wn {
        constructor(e4, t3) {
          this.type = e4, this.args = t3;
        }
        static parse(e4, t3) {
          if (e4.length < 2)
            return t3.error("Expectected at least one argument.");
          let i3 = null;
          const r3 = t3.expectedType;
          r3 && "value" !== r3.kind && (i3 = r3);
          const n4 = [];
          for (const r4 of e4.slice(1)) {
            const e5 = t3.parse(r4, 1 + n4.length, i3, void 0, { typeAnnotation: "omit" });
            if (!e5)
              return null;
            i3 = i3 || e5.type, n4.push(e5);
          }
          const o3 = r3 && n4.some((e5) => ei(r3, e5.type));
          return new wn(o3 ? Wt : i3, n4);
        }
        evaluate(e4) {
          let t3, i3 = null, r3 = 0;
          for (const n4 of this.args) {
            if (r3++, i3 = n4.evaluate(e4), i3 && i3 instanceof fi && !i3.available && (t3 || (t3 = i3), i3 = null, r3 === this.args.length))
              return t3;
            if (null !== i3)
              break;
          }
          return i3;
        }
        eachChild(e4) {
          this.args.forEach(e4);
        }
        outputDefined() {
          return this.args.every((e4) => e4.outputDefined());
        }
        serialize() {
          const e4 = ["coalesce"];
          return this.eachChild((t3) => {
            e4.push(t3.serialize());
          }), e4;
        }
      }
      var Tn = wn;
      class En {
        constructor(e4, t3) {
          this.type = t3.type, this.bindings = [].concat(e4), this.result = t3;
        }
        evaluate(e4) {
          return this.result.evaluate(e4);
        }
        eachChild(e4) {
          for (const t3 of this.bindings)
            e4(t3[1]);
          e4(this.result);
        }
        static parse(e4, t3) {
          if (e4.length < 4)
            return t3.error(`Expected at least 3 arguments, but found ${e4.length - 1} instead.`);
          const i3 = [];
          for (let r4 = 1; r4 < e4.length - 1; r4 += 2) {
            const n4 = e4[r4];
            if ("string" != typeof n4)
              return t3.error(`Expected string, but found ${typeof n4} instead.`, r4);
            if (/[^a-zA-Z0-9_]/.test(n4))
              return t3.error("Variable names must contain only alphanumeric characters or '_'.", r4);
            const o3 = t3.parse(e4[r4 + 1], r4 + 1);
            if (!o3)
              return null;
            i3.push([n4, o3]);
          }
          const r3 = t3.parse(e4[e4.length - 1], e4.length - 1, t3.expectedType, i3);
          return r3 ? new En(i3, r3) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const e4 = ["let"];
          for (const [t3, i3] of this.bindings)
            e4.push(t3, i3.serialize());
          return e4.push(this.result.serialize()), e4;
        }
      }
      var Mn = En;
      class An {
        constructor(e4, t3, i3) {
          this.type = e4, this.index = t3, this.input = i3;
        }
        static parse(e4, t3) {
          if (3 !== e4.length)
            return t3.error(`Expected 2 arguments, but found ${e4.length - 1} instead.`);
          const i3 = t3.parse(e4[1], 1, jt), r3 = t3.parse(e4[2], 2, Kt(t3.expectedType || Wt));
          return i3 && r3 ? new An(r3.type.itemType, i3, r3) : null;
        }
        evaluate(e4) {
          const t3 = this.index.evaluate(e4), i3 = this.input.evaluate(e4);
          if (t3 < 0)
            throw new bi(`Array index out of bounds: ${t3} < 0.`);
          if (t3 >= i3.length)
            throw new bi(`Array index out of bounds: ${t3} > ${i3.length - 1}.`);
          if (t3 !== Math.floor(t3))
            throw new bi(`Array index must be an integer, but found ${t3} instead.`);
          return i3[t3];
        }
        eachChild(e4) {
          e4(this.index), e4(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      var Sn = An;
      class In {
        constructor(e4, t3) {
          this.type = qt, this.needle = e4, this.haystack = t3;
        }
        static parse(e4, t3) {
          if (3 !== e4.length)
            return t3.error(`Expected 2 arguments, but found ${e4.length - 1} instead.`);
          const i3 = t3.parse(e4[1], 1, Wt), r3 = t3.parse(e4[2], 2, Wt);
          return i3 && r3 ? ti(i3.type, [qt, Gt, jt, Vt, Wt]) ? new In(i3, r3) : t3.error(`Expected first argument to be of type boolean, string, number or null, but found ${Jt(i3.type)} instead`) : null;
        }
        evaluate(e4) {
          const t3 = this.needle.evaluate(e4), i3 = this.haystack.evaluate(e4);
          if (null == i3)
            return false;
          if (!ii(t3, ["boolean", "string", "number", "null"]))
            throw new bi(`Expected first argument to be of type boolean, string, number or null, but found ${Jt(gi(t3))} instead.`);
          if (!ii(i3, ["string", "array"]))
            throw new bi(`Expected second argument to be of type array or string, but found ${Jt(gi(i3))} instead.`);
          return i3.indexOf(t3) >= 0;
        }
        eachChild(e4) {
          e4(this.needle), e4(this.haystack);
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var Cn = In;
      class zn {
        constructor(e4, t3, i3) {
          this.type = jt, this.needle = e4, this.haystack = t3, this.fromIndex = i3;
        }
        static parse(e4, t3) {
          if (e4.length <= 2 || e4.length >= 5)
            return t3.error(`Expected 3 or 4 arguments, but found ${e4.length - 1} instead.`);
          const i3 = t3.parse(e4[1], 1, Wt), r3 = t3.parse(e4[2], 2, Wt);
          if (!i3 || !r3)
            return null;
          if (!ti(i3.type, [qt, Gt, jt, Vt, Wt]))
            return t3.error(`Expected first argument to be of type boolean, string, number or null, but found ${Jt(i3.type)} instead`);
          if (4 === e4.length) {
            const n4 = t3.parse(e4[3], 3, jt);
            return n4 ? new zn(i3, r3, n4) : null;
          }
          return new zn(i3, r3);
        }
        evaluate(e4) {
          const t3 = this.needle.evaluate(e4), i3 = this.haystack.evaluate(e4);
          if (!ii(t3, ["boolean", "string", "number", "null"]))
            throw new bi(`Expected first argument to be of type boolean, string, number or null, but found ${Jt(gi(t3))} instead.`);
          if (!ii(i3, ["string", "array"]))
            throw new bi(`Expected second argument to be of type array or string, but found ${Jt(gi(i3))} instead.`);
          if (this.fromIndex) {
            const r3 = this.fromIndex.evaluate(e4);
            return i3.indexOf(t3, r3);
          }
          return i3.indexOf(t3);
        }
        eachChild(e4) {
          e4(this.needle), e4(this.haystack), this.fromIndex && e4(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.fromIndex && void 0 !== this.fromIndex) {
            const e4 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), e4];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var Pn = zn;
      class Dn {
        constructor(e4, t3, i3, r3, n4, o3) {
          this.inputType = e4, this.type = t3, this.input = i3, this.cases = r3, this.outputs = n4, this.otherwise = o3;
        }
        static parse(e4, t3) {
          if (e4.length < 5)
            return t3.error(`Expected at least 4 arguments, but found only ${e4.length - 1}.`);
          if (e4.length % 2 != 1)
            return t3.error("Expected an even number of arguments.");
          let i3, r3;
          t3.expectedType && "value" !== t3.expectedType.kind && (r3 = t3.expectedType);
          const n4 = {}, o3 = [];
          for (let s7 = 2; s7 < e4.length - 1; s7 += 2) {
            let a4 = e4[s7];
            const l3 = e4[s7 + 1];
            Array.isArray(a4) || (a4 = [a4]);
            const c3 = t3.concat(s7);
            if (0 === a4.length)
              return c3.error("Expected at least one branch label.");
            for (const e5 of a4) {
              if ("number" != typeof e5 && "string" != typeof e5)
                return c3.error("Branch labels must be numbers or strings.");
              if ("number" == typeof e5 && Math.abs(e5) > Number.MAX_SAFE_INTEGER)
                return c3.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if ("number" == typeof e5 && Math.floor(e5) !== e5)
                return c3.error("Numeric branch labels must be integer values.");
              if (i3) {
                if (c3.checkSubtype(i3, gi(e5)))
                  return null;
              } else
                i3 = gi(e5);
              if (void 0 !== n4[String(e5)])
                return c3.error("Branch labels must be unique.");
              n4[String(e5)] = o3.length;
            }
            const h3 = t3.parse(l3, s7, r3);
            if (!h3)
              return null;
            r3 = r3 || h3.type, o3.push(h3);
          }
          const s6 = t3.parse(e4[1], 1, Wt);
          if (!s6)
            return null;
          const a3 = t3.parse(e4[e4.length - 1], e4.length - 1, r3);
          return a3 ? "value" !== s6.type.kind && t3.concat(1).checkSubtype(i3, s6.type) ? null : new Dn(i3, r3, s6, n4, o3, a3) : null;
        }
        evaluate(e4) {
          const t3 = this.input.evaluate(e4);
          return (gi(t3) === this.inputType && this.outputs[this.cases[t3]] || this.otherwise).evaluate(e4);
        }
        eachChild(e4) {
          e4(this.input), this.outputs.forEach(e4), e4(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e4) => e4.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e4 = ["match", this.input.serialize()], t3 = Object.keys(this.cases).sort(), i3 = [], r3 = {};
          for (const e5 of t3) {
            const t4 = r3[this.cases[e5]];
            void 0 === t4 ? (r3[this.cases[e5]] = i3.length, i3.push([this.cases[e5], [e5]])) : i3[t4][1].push(e5);
          }
          const n4 = (e5) => "number" === this.inputType.kind ? Number(e5) : e5;
          for (const [t4, r4] of i3)
            e4.push(1 === r4.length ? n4(r4[0]) : r4.map(n4)), e4.push(this.outputs[t4].serialize());
          return e4.push(this.otherwise.serialize()), e4;
        }
      }
      var Rn = Dn;
      class Ln {
        constructor(e4, t3, i3) {
          this.type = e4, this.branches = t3, this.otherwise = i3;
        }
        static parse(e4, t3) {
          if (e4.length < 4)
            return t3.error(`Expected at least 3 arguments, but found only ${e4.length - 1}.`);
          if (e4.length % 2 != 0)
            return t3.error("Expected an odd number of arguments.");
          let i3;
          t3.expectedType && "value" !== t3.expectedType.kind && (i3 = t3.expectedType);
          const r3 = [];
          for (let n5 = 1; n5 < e4.length - 1; n5 += 2) {
            const o3 = t3.parse(e4[n5], n5, qt);
            if (!o3)
              return null;
            const s6 = t3.parse(e4[n5 + 1], n5 + 1, i3);
            if (!s6)
              return null;
            r3.push([o3, s6]), i3 = i3 || s6.type;
          }
          const n4 = t3.parse(e4[e4.length - 1], e4.length - 1, i3);
          return n4 ? new Ln(i3, r3, n4) : null;
        }
        evaluate(e4) {
          for (const [t3, i3] of this.branches)
            if (t3.evaluate(e4))
              return i3.evaluate(e4);
          return this.otherwise.evaluate(e4);
        }
        eachChild(e4) {
          for (const [t3, i3] of this.branches)
            e4(t3), e4(i3);
          e4(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e4, t3]) => t3.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e4 = ["case"];
          return this.eachChild((t3) => {
            e4.push(t3.serialize());
          }), e4;
        }
      }
      var kn = Ln;
      class On {
        constructor(e4, t3, i3, r3) {
          this.type = e4, this.input = t3, this.beginIndex = i3, this.endIndex = r3;
        }
        static parse(e4, t3) {
          if (e4.length <= 2 || e4.length >= 5)
            return t3.error(`Expected 3 or 4 arguments, but found ${e4.length - 1} instead.`);
          const i3 = t3.parse(e4[1], 1, Wt), r3 = t3.parse(e4[2], 2, jt);
          if (!i3 || !r3)
            return null;
          if (!ti(i3.type, [Kt(Wt), Gt, Wt]))
            return t3.error(`Expected first argument to be of type array or string, but found ${Jt(i3.type)} instead`);
          if (4 === e4.length) {
            const n4 = t3.parse(e4[3], 3, jt);
            return n4 ? new On(i3.type, i3, r3, n4) : null;
          }
          return new On(i3.type, i3, r3);
        }
        evaluate(e4) {
          const t3 = this.input.evaluate(e4), i3 = this.beginIndex.evaluate(e4);
          if (!ii(t3, ["string", "array"]))
            throw new bi(`Expected first argument to be of type array or string, but found ${Jt(gi(t3))} instead.`);
          if (this.endIndex) {
            const r3 = this.endIndex.evaluate(e4);
            return t3.slice(i3, r3);
          }
          return t3.slice(i3);
        }
        eachChild(e4) {
          e4(this.input), e4(this.beginIndex), this.endIndex && e4(this.endIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.endIndex && void 0 !== this.endIndex) {
            const e4 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), e4];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      var Bn = On;
      function Fn(e4, t3) {
        return "==" === e4 || "!=" === e4 ? "boolean" === t3.kind || "string" === t3.kind || "number" === t3.kind || "null" === t3.kind || "value" === t3.kind : "string" === t3.kind || "number" === t3.kind || "value" === t3.kind;
      }
      function Nn(e4, t3, i3, r3) {
        return 0 === r3.compare(t3, i3);
      }
      function Un(e4, t3, i3) {
        const r3 = "==" !== e4 && "!=" !== e4;
        return class n4 {
          constructor(e5, t4, i4) {
            this.type = qt, this.lhs = e5, this.rhs = t4, this.collator = i4, this.hasUntypedArgument = "value" === e5.type.kind || "value" === t4.type.kind;
          }
          static parse(e5, t4) {
            if (3 !== e5.length && 4 !== e5.length)
              return t4.error("Expected two or three arguments.");
            const i4 = e5[0];
            let o3 = t4.parse(e5[1], 1, Wt);
            if (!o3)
              return null;
            if (!Fn(i4, o3.type))
              return t4.concat(1).error(`"${i4}" comparisons are not supported for type '${Jt(o3.type)}'.`);
            let s6 = t4.parse(e5[2], 2, Wt);
            if (!s6)
              return null;
            if (!Fn(i4, s6.type))
              return t4.concat(2).error(`"${i4}" comparisons are not supported for type '${Jt(s6.type)}'.`);
            if (o3.type.kind !== s6.type.kind && "value" !== o3.type.kind && "value" !== s6.type.kind)
              return t4.error(`Cannot compare types '${Jt(o3.type)}' and '${Jt(s6.type)}'.`);
            r3 && ("value" === o3.type.kind && "value" !== s6.type.kind ? o3 = new Ei(s6.type, [o3]) : "value" !== o3.type.kind && "value" === s6.type.kind && (s6 = new Ei(o3.type, [s6])));
            let a3 = null;
            if (4 === e5.length) {
              if ("string" !== o3.type.kind && "string" !== s6.type.kind && "value" !== o3.type.kind && "value" !== s6.type.kind)
                return t4.error("Cannot use collator to compare non-string types.");
              if (a3 = t4.parse(e5[3], 3, Ht), !a3)
                return null;
            }
            return new n4(o3, s6, a3);
          }
          evaluate(n5) {
            const o3 = this.lhs.evaluate(n5), s6 = this.rhs.evaluate(n5);
            if (r3 && this.hasUntypedArgument) {
              const t4 = gi(o3), i4 = gi(s6);
              if (t4.kind !== i4.kind || "string" !== t4.kind && "number" !== t4.kind)
                throw new bi(`Expected arguments for "${e4}" to be (string, string) or (number, number), but found (${t4.kind}, ${i4.kind}) instead.`);
            }
            if (this.collator && !r3 && this.hasUntypedArgument) {
              const e5 = gi(o3), i4 = gi(s6);
              if ("string" !== e5.kind || "string" !== i4.kind)
                return t3(n5, o3, s6);
            }
            return this.collator ? i3(n5, o3, s6, this.collator.evaluate(n5)) : t3(n5, o3, s6);
          }
          eachChild(e5) {
            e5(this.lhs), e5(this.rhs), this.collator && e5(this.collator);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            const t4 = [e4];
            return this.eachChild((e5) => {
              t4.push(e5.serialize());
            }), t4;
          }
        };
      }
      const Vn = Un("==", function(e4, t3, i3) {
        return t3 === i3;
      }, Nn), jn = Un("!=", function(e4, t3, i3) {
        return t3 !== i3;
      }, function(e4, t3, i3, r3) {
        return !Nn(0, t3, i3, r3);
      }), Gn = Un("<", function(e4, t3, i3) {
        return t3 < i3;
      }, function(e4, t3, i3, r3) {
        return r3.compare(t3, i3) < 0;
      }), qn = Un(">", function(e4, t3, i3) {
        return t3 > i3;
      }, function(e4, t3, i3, r3) {
        return r3.compare(t3, i3) > 0;
      }), Zn = Un("<=", function(e4, t3, i3) {
        return t3 <= i3;
      }, function(e4, t3, i3, r3) {
        return r3.compare(t3, i3) <= 0;
      }), $n = Un(">=", function(e4, t3, i3) {
        return t3 >= i3;
      }, function(e4, t3, i3, r3) {
        return r3.compare(t3, i3) >= 0;
      });
      class Wn {
        constructor(e4, t3, i3, r3, n4, o3) {
          this.type = Gt, this.number = e4, this.locale = t3, this.currency = i3, this.unit = r3, this.minFractionDigits = n4, this.maxFractionDigits = o3;
        }
        static parse(e4, t3) {
          if (3 !== e4.length)
            return t3.error("Expected two arguments.");
          const i3 = t3.parse(e4[1], 1, jt);
          if (!i3)
            return null;
          const r3 = e4[2];
          if ("object" != typeof r3 || Array.isArray(r3))
            return t3.error("NumberFormat options argument must be an object.");
          let n4 = null;
          if (r3.locale && (n4 = t3.parse(r3.locale, 1, Gt), !n4))
            return null;
          let o3 = null;
          if (r3.currency && (o3 = t3.parse(r3.currency, 1, Gt), !o3))
            return null;
          let s6 = null;
          if (r3.unit && (s6 = t3.parse(r3.unit, 1, Gt), !s6))
            return null;
          let a3 = null;
          if (r3["min-fraction-digits"] && (a3 = t3.parse(r3["min-fraction-digits"], 1, jt), !a3))
            return null;
          let l3 = null;
          return r3["max-fraction-digits"] && (l3 = t3.parse(r3["max-fraction-digits"], 1, jt), !l3) ? null : new Wn(i3, n4, o3, s6, a3, l3);
        }
        evaluate(e4) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e4) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e4) : void 0, unit: this.unit ? this.unit.evaluate(e4) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e4) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e4) : void 0 }).format(this.number.evaluate(e4));
        }
        eachChild(e4) {
          e4(this.number), this.locale && e4(this.locale), this.currency && e4(this.currency), this.unit && e4(this.unit), this.minFractionDigits && e4(this.minFractionDigits), this.maxFractionDigits && e4(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const e4 = {};
          return this.locale && (e4.locale = this.locale.serialize()), this.currency && (e4.currency = this.currency.serialize()), this.unit && (e4.unit = this.unit.serialize()), this.minFractionDigits && (e4["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e4["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e4];
        }
      }
      class Hn {
        constructor(e4) {
          this.type = jt, this.input = e4;
        }
        static parse(e4, t3) {
          if (2 !== e4.length)
            return t3.error(`Expected 1 argument, but found ${e4.length - 1} instead.`);
          const i3 = t3.parse(e4[1], 1);
          return i3 ? "array" !== i3.type.kind && "string" !== i3.type.kind && "value" !== i3.type.kind ? t3.error(`Expected argument of type string or array, but found ${Jt(i3.type)} instead.`) : new Hn(i3) : null;
        }
        evaluate(e4) {
          const t3 = this.input.evaluate(e4);
          if ("string" == typeof t3)
            return t3.length;
          if (Array.isArray(t3))
            return t3.length;
          throw new bi(`Expected value to be of type string or array, but found ${Jt(gi(t3))} instead.`);
        }
        eachChild(e4) {
          e4(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const e4 = ["length"];
          return this.eachChild((t3) => {
            e4.push(t3.serialize());
          }), e4;
        }
      }
      function Xn(e4) {
        return function() {
          e4 = 1831565813 + (e4 |= 0) | 0;
          let t3 = Math.imul(e4 ^ e4 >>> 15, 1 | e4);
          return t3 = t3 + Math.imul(t3 ^ t3 >>> 7, 61 | t3) ^ t3, ((t3 ^ t3 >>> 14) >>> 0) / 4294967296;
        };
      }
      const Yn = { "==": Vn, "!=": jn, ">": qn, "<": Gn, ">=": $n, "<=": Zn, array: Ei, at: Sn, boolean: Ei, case: kn, coalesce: Tn, collator: Oi, format: Mi, image: Ai, in: Cn, "index-of": Pn, interpolate: bn, "interpolate-hcl": bn, "interpolate-lab": bn, length: Hn, let: Mn, literal: vi, match: Rn, number: Ei, "number-format": Wn, object: Ei, slice: Bn, step: Yr, string: Ei, "to-boolean": zi, "to-color": zi, "to-number": zi, "to-string": zi, var: qr, within: nr, distance: Fr };
      function Kn(e4, [t3, i3, r3, n4]) {
        t3 = t3.evaluate(e4), i3 = i3.evaluate(e4), r3 = r3.evaluate(e4);
        const o3 = n4 ? n4.evaluate(e4) : 1, s6 = mi(t3, i3, r3, o3);
        if (s6)
          throw new bi(s6);
        return new hi(t3 / 255 * o3, i3 / 255 * o3, r3 / 255 * o3, o3);
      }
      function Jn(e4, [t3, i3, r3, n4]) {
        t3 = t3.evaluate(e4), i3 = i3.evaluate(e4), r3 = r3.evaluate(e4);
        const o3 = n4 ? n4.evaluate(e4) : 1, s6 = function(e5, t4, i4, r4) {
          return "number" == typeof e5 && e5 >= 0 && e5 <= 360 ? "number" == typeof t4 && t4 >= 0 && t4 <= 100 && "number" == typeof i4 && i4 >= 0 && i4 <= 100 ? void 0 === r4 || "number" == typeof r4 && r4 >= 0 && r4 <= 1 ? null : `Invalid hsla value [${[e5, t4, i4, r4].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof r4 ? [e5, t4, i4, r4] : [e5, t4, i4]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof r4 ? [e5, t4, i4, r4] : [e5, t4, i4]).join(", ")}]: 'h' must be between 0 and 360.`;
        }(t3, i3, r3, o3);
        if (s6)
          throw new bi(s6);
        const a3 = `hsla(${t3}, ${i3}%, ${r3}%, ${o3})`, l3 = hi.parse(a3);
        if (!l3)
          throw new bi(`Failed to parse HSLA color: ${a3}`);
        return l3;
      }
      function Qn(e4, t3) {
        return e4 in t3;
      }
      function eo(e4, t3) {
        const i3 = t3[e4];
        return void 0 === i3 ? null : i3;
      }
      function to(e4, t3) {
        switch (e4) {
          case "string":
            return String(t3);
          case "number":
            return +t3;
          case "boolean":
            return !!t3;
          case "color":
            return hi.parse(t3);
        }
        return t3;
      }
      function io(e4, t3, i3, r3) {
        return void 0 !== r3 && (e4 = r3 * Math.round(e4 / r3)), void 0 !== t3 && e4 < t3 && (e4 = t3), void 0 !== i3 && e4 > i3 && (e4 = i3), e4;
      }
      function ro(e4, t3, i3) {
        i3.length && (t3 += `${i3}`);
        const r3 = e4.getConfig(t3);
        if (!r3)
          return null;
        const { type: n4, value: o3, values: s6, minValue: a3, maxValue: l3, stepValue: c3 } = r3, h3 = r3.default.evaluate(e4);
        let u3 = o3 ? o3.evaluate(e4) : h3;
        return n4 && (u3 = to(n4, u3)), void 0 !== o3 && void 0 !== u3 && s6 && !s6.includes(u3) && (u3 = h3, n4 && (u3 = to(n4, u3))), void 0 === u3 || void 0 === a3 && void 0 === l3 && void 0 === c3 || ("number" == typeof u3 ? u3 = io(u3, a3, l3, c3) : Array.isArray(u3) && (u3 = u3.map((e5) => "number" == typeof e5 ? io(e5, a3, l3, c3) : e5))), u3;
      }
      function no(e4) {
        return { type: e4 };
      }
      ki.register(Yn, { error: [{ kind: "error" }, [Gt], (e4, [t3]) => {
        throw new bi(t3.evaluate(e4));
      }], typeof: [Gt, [Wt], (e4, [t3]) => Jt(gi(t3.evaluate(e4)))], "to-rgba": [Kt(jt, 4), [Zt], (e4, [t3]) => t3.evaluate(e4).toArray()], rgb: [Zt, [jt, jt, jt], Kn], rgba: [Zt, [jt, jt, jt, jt], Kn], hsl: [Zt, [jt, jt, jt], Jn], hsla: [Zt, [jt, jt, jt, jt], Jn], has: { type: qt, overloads: [[[Gt], (e4, [t3]) => Qn(t3.evaluate(e4), e4.properties())], [[Gt, $t], (e4, [t3, i3]) => Qn(t3.evaluate(e4), i3.evaluate(e4))]] }, get: { type: Wt, overloads: [[[Gt], (e4, [t3]) => eo(t3.evaluate(e4), e4.properties())], [[Gt, $t], (e4, [t3, i3]) => eo(t3.evaluate(e4), i3.evaluate(e4))]] }, config: { type: Wt, overloads: [[[Gt], (e4, [t3]) => ro(e4, t3.evaluate(e4), "")], [[Gt, Gt], (e4, [t3, i3]) => ro(e4, t3.evaluate(e4), i3.evaluate(e4))]] }, "feature-state": [Wt, [Gt], (e4, [t3]) => eo(t3.evaluate(e4), e4.featureState || {})], properties: [$t, [], (e4) => e4.properties()], "geometry-type": [Gt, [], (e4) => e4.geometryType()], id: [Wt, [], (e4) => e4.id()], zoom: [jt, [], (e4) => e4.globals.zoom], pitch: [jt, [], (e4) => e4.globals.pitch || 0], "distance-from-center": [jt, [], (e4) => e4.distanceFromCenter()], "measure-light": [jt, [Gt], (e4, [t3]) => e4.measureLight(t3.evaluate(e4))], "heatmap-density": [jt, [], (e4) => e4.globals.heatmapDensity || 0], "line-progress": [jt, [], (e4) => e4.globals.lineProgress || 0], "raster-value": [jt, [], (e4) => e4.globals.rasterValue || 0], "sky-radial-progress": [jt, [], (e4) => e4.globals.skyRadialProgress || 0], accumulated: [Wt, [], (e4) => void 0 === e4.globals.accumulated ? null : e4.globals.accumulated], "+": [jt, no(jt), (e4, t3) => {
        let i3 = 0;
        for (const r3 of t3)
          i3 += r3.evaluate(e4);
        return i3;
      }], "*": [jt, no(jt), (e4, t3) => {
        let i3 = 1;
        for (const r3 of t3)
          i3 *= r3.evaluate(e4);
        return i3;
      }], "-": { type: jt, overloads: [[[jt, jt], (e4, [t3, i3]) => t3.evaluate(e4) - i3.evaluate(e4)], [[jt], (e4, [t3]) => -t3.evaluate(e4)]] }, "/": [jt, [jt, jt], (e4, [t3, i3]) => t3.evaluate(e4) / i3.evaluate(e4)], "%": [jt, [jt, jt], (e4, [t3, i3]) => t3.evaluate(e4) % i3.evaluate(e4)], ln2: [jt, [], () => Math.LN2], pi: [jt, [], () => Math.PI], e: [jt, [], () => Math.E], "^": [jt, [jt, jt], (e4, [t3, i3]) => Math.pow(t3.evaluate(e4), i3.evaluate(e4))], sqrt: [jt, [jt], (e4, [t3]) => Math.sqrt(t3.evaluate(e4))], log10: [jt, [jt], (e4, [t3]) => Math.log(t3.evaluate(e4)) / Math.LN10], ln: [jt, [jt], (e4, [t3]) => Math.log(t3.evaluate(e4))], log2: [jt, [jt], (e4, [t3]) => Math.log(t3.evaluate(e4)) / Math.LN2], sin: [jt, [jt], (e4, [t3]) => Math.sin(t3.evaluate(e4))], cos: [jt, [jt], (e4, [t3]) => Math.cos(t3.evaluate(e4))], tan: [jt, [jt], (e4, [t3]) => Math.tan(t3.evaluate(e4))], asin: [jt, [jt], (e4, [t3]) => Math.asin(t3.evaluate(e4))], acos: [jt, [jt], (e4, [t3]) => Math.acos(t3.evaluate(e4))], atan: [jt, [jt], (e4, [t3]) => Math.atan(t3.evaluate(e4))], min: [jt, no(jt), (e4, t3) => Math.min(...t3.map((t4) => t4.evaluate(e4)))], max: [jt, no(jt), (e4, t3) => Math.max(...t3.map((t4) => t4.evaluate(e4)))], abs: [jt, [jt], (e4, [t3]) => Math.abs(t3.evaluate(e4))], round: [jt, [jt], (e4, [t3]) => {
        const i3 = t3.evaluate(e4);
        return i3 < 0 ? -Math.round(-i3) : Math.round(i3);
      }], floor: [jt, [jt], (e4, [t3]) => Math.floor(t3.evaluate(e4))], ceil: [jt, [jt], (e4, [t3]) => Math.ceil(t3.evaluate(e4))], "filter-==": [qt, [Gt, Wt], (e4, [t3, i3]) => e4.properties()[t3.value] === i3.value], "filter-id-==": [qt, [Wt], (e4, [t3]) => e4.id() === t3.value], "filter-type-==": [qt, [Gt], (e4, [t3]) => e4.geometryType() === t3.value], "filter-<": [qt, [Gt, Wt], (e4, [t3, i3]) => {
        const r3 = e4.properties()[t3.value], n4 = i3.value;
        return typeof r3 == typeof n4 && r3 < n4;
      }], "filter-id-<": [qt, [Wt], (e4, [t3]) => {
        const i3 = e4.id(), r3 = t3.value;
        return typeof i3 == typeof r3 && i3 < r3;
      }], "filter->": [qt, [Gt, Wt], (e4, [t3, i3]) => {
        const r3 = e4.properties()[t3.value], n4 = i3.value;
        return typeof r3 == typeof n4 && r3 > n4;
      }], "filter-id->": [qt, [Wt], (e4, [t3]) => {
        const i3 = e4.id(), r3 = t3.value;
        return typeof i3 == typeof r3 && i3 > r3;
      }], "filter-<=": [qt, [Gt, Wt], (e4, [t3, i3]) => {
        const r3 = e4.properties()[t3.value], n4 = i3.value;
        return typeof r3 == typeof n4 && r3 <= n4;
      }], "filter-id-<=": [qt, [Wt], (e4, [t3]) => {
        const i3 = e4.id(), r3 = t3.value;
        return typeof i3 == typeof r3 && i3 <= r3;
      }], "filter->=": [qt, [Gt, Wt], (e4, [t3, i3]) => {
        const r3 = e4.properties()[t3.value], n4 = i3.value;
        return typeof r3 == typeof n4 && r3 >= n4;
      }], "filter-id->=": [qt, [Wt], (e4, [t3]) => {
        const i3 = e4.id(), r3 = t3.value;
        return typeof i3 == typeof r3 && i3 >= r3;
      }], "filter-has": [qt, [Wt], (e4, [t3]) => t3.value in e4.properties()], "filter-has-id": [qt, [], (e4) => null !== e4.id() && void 0 !== e4.id()], "filter-type-in": [qt, [Kt(Gt)], (e4, [t3]) => t3.value.indexOf(e4.geometryType()) >= 0], "filter-id-in": [qt, [Kt(Wt)], (e4, [t3]) => t3.value.indexOf(e4.id()) >= 0], "filter-in-small": [qt, [Gt, Kt(Wt)], (e4, [t3, i3]) => i3.value.indexOf(e4.properties()[t3.value]) >= 0], "filter-in-large": [qt, [Gt, Kt(Wt)], (e4, [t3, i3]) => function(e5, t4, i4, r3) {
        for (; i4 <= r3; ) {
          const n4 = i4 + r3 >> 1;
          if (t4[n4] === e5)
            return true;
          t4[n4] > e5 ? r3 = n4 - 1 : i4 = n4 + 1;
        }
        return false;
      }(e4.properties()[t3.value], i3.value, 0, i3.value.length - 1)], all: { type: qt, overloads: [[[qt, qt], (e4, [t3, i3]) => t3.evaluate(e4) && i3.evaluate(e4)], [no(qt), (e4, t3) => {
        for (const i3 of t3)
          if (!i3.evaluate(e4))
            return false;
        return true;
      }]] }, any: { type: qt, overloads: [[[qt, qt], (e4, [t3, i3]) => t3.evaluate(e4) || i3.evaluate(e4)], [no(qt), (e4, t3) => {
        for (const i3 of t3)
          if (i3.evaluate(e4))
            return true;
        return false;
      }]] }, "!": [qt, [qt], (e4, [t3]) => !t3.evaluate(e4)], "is-supported-script": [qt, [Gt], (e4, [t3]) => {
        const i3 = e4.globals && e4.globals.isSupportedScript;
        return !i3 || i3(t3.evaluate(e4));
      }], upcase: [Gt, [Gt], (e4, [t3]) => t3.evaluate(e4).toUpperCase()], downcase: [Gt, [Gt], (e4, [t3]) => t3.evaluate(e4).toLowerCase()], concat: [Gt, no(Wt), (e4, t3) => t3.map((t4) => yi(t4.evaluate(e4))).join("")], "resolved-locale": [Gt, [Ht], (e4, [t3]) => t3.evaluate(e4).resolvedLocale()], random: [jt, [jt, jt, Wt], (e4, t3) => {
        const [i3, r3, n4] = t3.map((t4) => t4.evaluate(e4));
        if (i3 > r3)
          return i3;
        if (i3 === r3)
          return i3;
        let o3;
        if ("string" == typeof n4)
          o3 = function(e5) {
            let t4 = 0;
            if (0 === e5.length)
              return t4;
            for (let i4 = 0; i4 < e5.length; i4++)
              t4 = (t4 << 5) - t4 + e5.charCodeAt(i4), t4 &= t4;
            return t4;
          }(n4);
        else {
          if ("number" != typeof n4)
            throw new bi(`Invalid seed input: ${n4}`);
          o3 = n4;
        }
        return i3 + Xn(o3)() * (r3 - i3);
      }] });
      var oo = Yn;
      function so(e4) {
        return { result: "success", value: e4 };
      }
      function ao(e4) {
        return { result: "error", value: e4 };
      }
      function lo(e4, t3) {
        return !!e4 && !!e4.parameters && e4.parameters.indexOf(t3) > -1;
      }
      function co(e4) {
        return "data-driven" === e4["property-type"];
      }
      function ho(e4) {
        return lo(e4.expression, "measure-light");
      }
      function uo(e4) {
        return lo(e4.expression, "zoom");
      }
      function po(e4) {
        return !!e4.expression && e4.expression.interpolated;
      }
      function fo(e4) {
        return "object" == typeof e4 && null !== e4 && !Array.isArray(e4);
      }
      function mo(e4) {
        return e4;
      }
      function _o(e4, t3) {
        const i3 = "color" === t3.type, r3 = e4.stops && "object" == typeof e4.stops[0][0], n4 = r3 || !(r3 || void 0 !== e4.property), o3 = e4.type || (po(t3) ? "exponential" : "interval");
        if (i3 && ((e4 = Lt({}, e4)).stops && (e4.stops = e4.stops.map((e5) => [e5[0], hi.parse(e5[1])])), e4.default = hi.parse(e4.default ? e4.default : t3.default)), e4.colorSpace && "rgb" !== e4.colorSpace && !yn[e4.colorSpace])
          throw new Error(`Unknown color space: ${e4.colorSpace}`);
        let s6, a3, l3;
        if ("exponential" === o3)
          s6 = vo;
        else if ("interval" === o3)
          s6 = xo;
        else if ("categorical" === o3) {
          s6 = yo, a3 = /* @__PURE__ */ Object.create(null);
          for (const t4 of e4.stops)
            a3[t4[0]] = t4[1];
          l3 = typeof e4.stops[0][0];
        } else {
          if ("identity" !== o3)
            throw new Error(`Unknown function type "${o3}"`);
          s6 = bo;
        }
        if (r3) {
          const i4 = {}, r4 = [];
          for (let t4 = 0; t4 < e4.stops.length; t4++) {
            const n6 = e4.stops[t4], o5 = n6[0].zoom;
            void 0 === i4[o5] && (i4[o5] = { zoom: o5, type: e4.type, property: e4.property, default: e4.default, stops: [] }, r4.push(o5)), i4[o5].stops.push([n6[0].value, n6[1]]);
          }
          const n5 = [];
          for (const e5 of r4)
            n5.push([i4[e5].zoom, _o(i4[e5], t3)]);
          const o4 = { name: "linear" };
          return { kind: "composite", interpolationType: o4, interpolationFactor: bn.interpolationFactor.bind(void 0, o4), zoomStops: n5.map((e5) => e5[0]), evaluate: ({ zoom: i5 }, r5) => vo({ stops: n5, base: e4.base }, t3, i5).evaluate(i5, r5) };
        }
        if (n4) {
          const i4 = "exponential" === o3 ? { name: "exponential", base: void 0 !== e4.base ? e4.base : 1 } : null;
          return { kind: "camera", interpolationType: i4, interpolationFactor: bn.interpolationFactor.bind(void 0, i4), zoomStops: e4.stops.map((e5) => e5[0]), evaluate: ({ zoom: i5 }) => s6(e4, t3, i5, a3, l3) };
        }
        return { kind: "source", evaluate(i4, r4) {
          const n5 = r4 && r4.properties ? r4.properties[e4.property] : void 0;
          return void 0 === n5 ? go(e4.default, t3.default) : s6(e4, t3, n5, a3, l3);
        } };
      }
      function go(e4, t3, i3) {
        return void 0 !== e4 ? e4 : void 0 !== t3 ? t3 : void 0 !== i3 ? i3 : void 0;
      }
      function yo(e4, t3, i3, r3, n4) {
        return go(typeof i3 === n4 ? r3[i3] : void 0, e4.default, t3.default);
      }
      function xo(e4, t3, i3) {
        if ("number" !== Si(i3))
          return go(e4.default, t3.default);
        const r3 = e4.stops.length;
        if (1 === r3)
          return e4.stops[0][1];
        if (i3 <= e4.stops[0][0])
          return e4.stops[0][1];
        if (i3 >= e4.stops[r3 - 1][0])
          return e4.stops[r3 - 1][1];
        const n4 = Hr(e4.stops.map((e5) => e5[0]), i3);
        return e4.stops[n4][1];
      }
      function vo(e4, t3, i3) {
        const r3 = void 0 !== e4.base ? e4.base : 1;
        if ("number" !== Si(i3))
          return go(e4.default, t3.default);
        const n4 = e4.stops.length;
        if (1 === n4)
          return e4.stops[0][1];
        if (i3 <= e4.stops[0][0])
          return e4.stops[0][1];
        if (i3 >= e4.stops[n4 - 1][0])
          return e4.stops[n4 - 1][1];
        const o3 = Hr(e4.stops.map((e5) => e5[0]), i3), s6 = function(e5, t4, i4, r4) {
          const n5 = r4 - i4, o4 = e5 - i4;
          return 0 === n5 ? 0 : 1 === t4 ? o4 / n5 : (Math.pow(t4, o4) - 1) / (Math.pow(t4, n5) - 1);
        }(i3, r3, e4.stops[o3][0], e4.stops[o3 + 1][0]), a3 = e4.stops[o3][1], l3 = e4.stops[o3 + 1][1];
        let c3 = Qr[t3.type] || mo;
        if (e4.colorSpace && "rgb" !== e4.colorSpace) {
          const t4 = yn[e4.colorSpace];
          c3 = (e5, i4) => t4.reverse(t4.interpolate(t4.forward(e5), t4.forward(i4), s6));
        }
        return "function" == typeof a3.evaluate ? { evaluate(...e5) {
          const t4 = a3.evaluate.apply(void 0, e5), i4 = l3.evaluate.apply(void 0, e5);
          if (void 0 !== t4 && void 0 !== i4)
            return c3(t4, i4, s6);
        } } : c3(a3, l3, s6);
      }
      function bo(e4, t3, i3) {
        return "color" === t3.type ? i3 = hi.parse(i3) : "formatted" === t3.type ? i3 = pi.fromString(i3.toString()) : "resolvedImage" === t3.type ? i3 = fi.fromString(i3.toString()) : Si(i3) === t3.type || "enum" === t3.type && t3.values[i3] || (i3 = void 0), go(i3, e4.default, t3.default);
      }
      class wo {
        constructor(e4, t3, i3) {
          this.expression = e4, this._warningHistory = {}, this._evaluator = new Di(i3), this._defaultValue = t3 ? function(e5) {
            return "color" === e5.type && (fo(e5.default) || Array.isArray(e5.default)) ? new hi(0, 0, 0, 0) : "color" === e5.type ? hi.parse(e5.default) || null : void 0 === e5.default ? null : e5.default;
          }(t3) : null, this._enumValues = t3 && "enum" === t3.type ? t3.values : null;
        }
        evaluateWithoutErrorHandling(e4, t3, i3, r3, n4, o3, s6, a3) {
          return this._evaluator.globals = e4, this._evaluator.feature = t3, this._evaluator.featureState = i3, this._evaluator.canonical = r3 || null, this._evaluator.availableImages = n4 || null, this._evaluator.formattedSection = o3, this._evaluator.featureTileCoord = s6 || null, this._evaluator.featureDistanceData = a3 || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(e4, t3, i3, r3, n4, o3, s6, a3) {
          this._evaluator.globals = e4, this._evaluator.feature = t3 || null, this._evaluator.featureState = i3 || null, this._evaluator.canonical = r3 || null, this._evaluator.availableImages = n4 || null, this._evaluator.formattedSection = o3 || null, this._evaluator.featureTileCoord = s6 || null, this._evaluator.featureDistanceData = a3 || null;
          try {
            const e5 = this.expression.evaluate(this._evaluator);
            if (null == e5 || "number" == typeof e5 && e5 != e5)
              return this._defaultValue;
            if (this._enumValues && !(e5 in this._enumValues))
              throw new bi(`Expected value to be one of ${Object.keys(this._enumValues).map((e6) => JSON.stringify(e6)).join(", ")}, but found ${JSON.stringify(e5)} instead.`);
            return e5;
          } catch (e5) {
            return this._warningHistory[e5.message] || (this._warningHistory[e5.message] = true, "undefined" != typeof console && console.warn(e5.message)), this._defaultValue;
          }
        }
      }
      function To(e4) {
        return Array.isArray(e4) && e4.length > 0 && "string" == typeof e4[0] && e4[0] in oo;
      }
      function Eo(e4, t3, i3) {
        const r3 = new $r(oo, [], t3 ? function(e5) {
          const t4 = { color: Zt, string: Gt, number: jt, enum: Gt, boolean: qt, formatted: Xt, resolvedImage: Yt };
          return "array" === e5.type ? Kt(t4[e5.value] || Wt, e5.length) : t4[e5.type];
        }(t3) : void 0, void 0, void 0, i3), n4 = r3.parse(e4, void 0, void 0, void 0, t3 && "string" === t3.type ? { typeAnnotation: "coerce" } : void 0);
        return n4 ? so(new wo(n4, t3, i3)) : ao(r3.errors);
      }
      class Mo {
        constructor(e4, t3, i3) {
          this.kind = e4, this._styleExpression = t3, this.isLightConstant = i3, this.isStateDependent = "constant" !== e4 && !Ur(t3.expression), this.isConfigDependent = !Vr(t3.expression);
        }
        evaluateWithoutErrorHandling(e4, t3, i3, r3, n4, o3) {
          return this._styleExpression.evaluateWithoutErrorHandling(e4, t3, i3, r3, n4, o3);
        }
        evaluate(e4, t3, i3, r3, n4, o3) {
          return this._styleExpression.evaluate(e4, t3, i3, r3, n4, o3);
        }
      }
      class Ao {
        constructor(e4, t3, i3, r3, n4) {
          this.kind = e4, this.zoomStops = i3, this._styleExpression = t3, this.isStateDependent = "camera" !== e4 && !Ur(t3.expression), this.isLightConstant = n4, this.isConfigDependent = !Vr(t3.expression), this.interpolationType = r3;
        }
        evaluateWithoutErrorHandling(e4, t3, i3, r3, n4, o3) {
          return this._styleExpression.evaluateWithoutErrorHandling(e4, t3, i3, r3, n4, o3);
        }
        evaluate(e4, t3, i3, r3, n4, o3) {
          return this._styleExpression.evaluate(e4, t3, i3, r3, n4, o3);
        }
        interpolationFactor(e4, t3, i3) {
          return this.interpolationType ? bn.interpolationFactor(this.interpolationType, e4, t3, i3) : 0;
        }
      }
      function So(e4, t3, i3) {
        if ("error" === (e4 = Eo(e4, t3, i3)).result)
          return e4;
        const r3 = e4.value.expression, n4 = Nr(r3);
        if (!n4 && !co(t3))
          return ao([new Ft("", "data expressions not supported")]);
        const o3 = jr(r3, ["zoom", "pitch", "distance-from-center"]);
        if (!o3 && !uo(t3))
          return ao([new Ft("", "zoom expressions not supported")]);
        const s6 = jr(r3, ["measure-light"]);
        if (!s6 && !ho(t3))
          return ao([new Ft("", "measure-light expression not supported")]);
        const a3 = t3.expression && t3.expression.relaxZoomRestriction, l3 = Co(r3);
        return l3 || o3 || a3 ? l3 instanceof Ft ? ao([l3]) : l3 instanceof bn && !po(t3) ? ao([new Ft("", '"interpolate" expressions cannot be used with this property')]) : so(l3 ? new Ao(n4 ? "camera" : "composite", e4.value, l3.labels, l3 instanceof bn ? l3.interpolation : void 0, s6) : new Mo(n4 ? "constant" : "source", e4.value, s6)) : ao([new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
      }
      class Io {
        constructor(e4, t3) {
          this._parameters = e4, this._specification = t3, Lt(this, _o(this._parameters, this._specification));
        }
        static deserialize(e4) {
          return new Io(e4._parameters, e4._specification);
        }
        static serialize(e4) {
          return { _parameters: e4._parameters, _specification: e4._specification };
        }
      }
      function Co(e4) {
        let t3 = null;
        if (e4 instanceof Mn)
          t3 = Co(e4.result);
        else if (e4 instanceof Tn) {
          for (const i3 of e4.args)
            if (t3 = Co(i3), t3)
              break;
        } else
          (e4 instanceof Yr || e4 instanceof bn) && e4.input instanceof ki && "zoom" === e4.input.name && (t3 = e4);
        return t3 instanceof Ft || e4.eachChild((e5) => {
          const i3 = Co(e5);
          i3 instanceof Ft ? t3 = i3 : t3 && i3 && t3 !== i3 && (t3 = new Ft("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), t3;
      }
      function zo(e4) {
        const t3 = e4.key, i3 = e4.value, r3 = e4.valueSpec || {}, n4 = e4.objectElementValidators || {}, o3 = e4.style, s6 = e4.styleSpec;
        let a3 = [];
        const l3 = Si(i3);
        if ("object" !== l3)
          return [new Dt(t3, i3, `object expected, ${l3} found`)];
        for (const e5 in i3) {
          const l4 = e5.split(".")[0];
          let c3;
          n4[l4] ? c3 = n4[l4] : r3[l4] ? c3 = ds : n4["*"] ? c3 = n4["*"] : r3["*"] && (c3 = ds), c3 ? a3 = a3.concat(c3({ key: (t3 ? `${t3}.` : t3) + e5, value: i3[e5], valueSpec: r3[l4] || r3["*"], style: o3, styleSpec: s6, object: i3, objectKey: e5 }, i3)) : a3.push(new Rt(t3, i3[e5], `unknown property "${e5}"`));
        }
        for (const e5 in r3)
          n4[e5] || r3[e5].required && void 0 === r3[e5].default && void 0 === i3[e5] && a3.push(new Dt(t3, i3, `missing required property "${e5}"`));
        return a3;
      }
      function Po(e4) {
        const t3 = e4.value, i3 = e4.valueSpec, r3 = e4.style, n4 = e4.styleSpec, o3 = e4.key, s6 = e4.arrayElementValidator || ds;
        if ("array" !== Si(t3))
          return [new Dt(o3, t3, `array expected, ${Si(t3)} found`)];
        if (i3.length && t3.length !== i3.length)
          return [new Dt(o3, t3, `array length ${i3.length} expected, length ${t3.length} found`)];
        if (i3["min-length"] && t3.length < i3["min-length"])
          return [new Dt(o3, t3, `array length at least ${i3["min-length"]} expected, length ${t3.length} found`)];
        let a3 = { type: i3.value, values: i3.values, minimum: i3.minimum, maximum: i3.maximum, function: void 0 };
        n4.$version < 7 && (a3.function = i3.function), "object" === Si(i3.value) && (a3 = i3.value);
        let l3 = [];
        for (let e5 = 0; e5 < t3.length; e5++)
          l3 = l3.concat(s6({ array: t3, arrayIndex: e5, value: t3[e5], valueSpec: a3, style: r3, styleSpec: n4, key: `${o3}[${e5}]` }, true));
        return l3;
      }
      function Do(e4) {
        const t3 = e4.key, i3 = e4.value, r3 = e4.valueSpec;
        let n4 = Si(i3);
        if ("number" === n4 && i3 != i3 && (n4 = "NaN"), "number" !== n4)
          return [new Dt(t3, i3, `number expected, ${n4} found`)];
        if ("minimum" in r3) {
          let n5 = r3.minimum;
          if ("array" === Si(r3.minimum) && (n5 = r3.minimum[e4.arrayIndex]), i3 < n5)
            return [new Dt(t3, i3, `${i3} is less than the minimum value ${n5}`)];
        }
        if ("maximum" in r3) {
          let n5 = r3.maximum;
          if ("array" === Si(r3.maximum) && (n5 = r3.maximum[e4.arrayIndex]), i3 > n5)
            return [new Dt(t3, i3, `${i3} is greater than the maximum value ${n5}`)];
        }
        return [];
      }
      function Ro(e4) {
        const t3 = e4.valueSpec, i3 = kt(e4.value.type);
        let r3, n4, o3, s6 = {};
        const a3 = "categorical" !== i3 && void 0 === e4.value.property, l3 = !a3, c3 = "array" === Si(e4.value.stops) && "array" === Si(e4.value.stops[0]) && "object" === Si(e4.value.stops[0][0]), h3 = zo({ key: e4.key, value: e4.value, valueSpec: e4.styleSpec.function, style: e4.style, styleSpec: e4.styleSpec, objectElementValidators: { stops: function(e5) {
          if ("identity" === i3)
            return [new Dt(e5.key, e5.value, 'identity function may not have a "stops" property')];
          let t4 = [];
          const r4 = e5.value;
          return t4 = t4.concat(Po({ key: e5.key, value: r4, valueSpec: e5.valueSpec, style: e5.style, styleSpec: e5.styleSpec, arrayElementValidator: u3 })), "array" === Si(r4) && 0 === r4.length && t4.push(new Dt(e5.key, r4, "array must have at least one stop")), t4;
        }, default: function(e5) {
          return ds({ key: e5.key, value: e5.value, valueSpec: t3, style: e5.style, styleSpec: e5.styleSpec });
        } } });
        return "identity" === i3 && a3 && h3.push(new Dt(e4.key, e4.value, 'missing required property "property"')), "identity" === i3 || e4.value.stops || h3.push(new Dt(e4.key, e4.value, 'missing required property "stops"')), "exponential" === i3 && e4.valueSpec.expression && !po(e4.valueSpec) && h3.push(new Dt(e4.key, e4.value, "exponential functions not supported")), e4.styleSpec.$version >= 8 && (l3 && !co(e4.valueSpec) ? h3.push(new Dt(e4.key, e4.value, "property functions not supported")) : a3 && !uo(e4.valueSpec) && h3.push(new Dt(e4.key, e4.value, "zoom functions not supported"))), "categorical" !== i3 && !c3 || void 0 !== e4.value.property || h3.push(new Dt(e4.key, e4.value, '"property" property is required')), h3;
        function u3(e5) {
          let i4 = [];
          const r4 = e5.value, a4 = e5.key;
          if ("array" !== Si(r4))
            return [new Dt(a4, r4, `array expected, ${Si(r4)} found`)];
          if (2 !== r4.length)
            return [new Dt(a4, r4, `array length 2 expected, length ${r4.length} found`)];
          if (c3) {
            if ("object" !== Si(r4[0]))
              return [new Dt(a4, r4, `object expected, ${Si(r4[0])} found`)];
            if (void 0 === r4[0].zoom)
              return [new Dt(a4, r4, "object stop key must have zoom")];
            if (void 0 === r4[0].value)
              return [new Dt(a4, r4, "object stop key must have value")];
            const t4 = kt(r4[0].zoom);
            if ("number" != typeof t4)
              return [new Dt(a4, r4[0].zoom, "stop zoom values must be numbers")];
            if (o3 && o3 > t4)
              return [new Dt(a4, r4[0].zoom, "stop zoom values must appear in ascending order")];
            t4 !== o3 && (o3 = t4, n4 = void 0, s6 = {}), i4 = i4.concat(zo({ key: `${a4}[0]`, value: r4[0], valueSpec: { zoom: {} }, style: e5.style, styleSpec: e5.styleSpec, objectElementValidators: { zoom: Do, value: d3 } }));
          } else
            i4 = i4.concat(d3({ key: `${a4}[0]`, value: r4[0], valueSpec: {}, style: e5.style, styleSpec: e5.styleSpec }, r4));
          return To(Ot(r4[1])) ? i4.concat([new Dt(`${a4}[1]`, r4[1], "expressions are not allowed in function stops.")]) : i4.concat(ds({ key: `${a4}[1]`, value: r4[1], valueSpec: t3, style: e5.style, styleSpec: e5.styleSpec }));
        }
        function d3(e5, o4) {
          const a4 = Si(e5.value), l4 = kt(e5.value), c4 = null !== e5.value ? e5.value : o4;
          if (r3) {
            if (a4 !== r3)
              return [new Dt(e5.key, c4, `${a4} stop domain type must match previous stop domain type ${r3}`)];
          } else
            r3 = a4;
          if ("number" !== a4 && "string" !== a4 && "boolean" !== a4 && "number" != typeof l4 && "string" != typeof l4 && "boolean" != typeof l4)
            return [new Dt(e5.key, c4, "stop domain value must be a number, string, or boolean")];
          if ("number" !== a4 && "categorical" !== i3) {
            let r4 = `number expected, ${a4} found`;
            return co(t3) && void 0 === i3 && (r4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Dt(e5.key, c4, r4)];
          }
          return "categorical" !== i3 || "number" !== a4 || "number" == typeof l4 && isFinite(l4) && Math.floor(l4) === l4 ? "categorical" !== i3 && "number" === a4 && "number" == typeof l4 && "number" == typeof n4 && void 0 !== n4 && l4 < n4 ? [new Dt(e5.key, c4, "stop domain values must appear in ascending order")] : (n4 = l4, "categorical" === i3 && l4 in s6 ? [new Dt(e5.key, c4, "stop domain values must be unique")] : (s6[l4] = true, [])) : [new Dt(e5.key, c4, `integer expected, found ${String(l4)}`)];
        }
      }
      function Lo(e4) {
        const t3 = ("property" === e4.expressionContext ? So : Eo)(Ot(e4.value), e4.valueSpec);
        if ("error" === t3.result)
          return t3.value.map((t4) => new Dt(`${e4.key}${t4.key}`, e4.value, t4.message));
        const i3 = t3.value.expression || t3.value._styleExpression.expression;
        if ("property" === e4.expressionContext && "text-font" === e4.propertyKey && !i3.outputDefined())
          return [new Dt(e4.key, e4.value, `Invalid data expression for "${e4.propertyKey}". Output values must be contained as literals within the expression.`)];
        if ("property" === e4.expressionContext && "layout" === e4.propertyType && !Ur(i3))
          return [new Dt(e4.key, e4.value, '"feature-state" data expressions are not supported with layout properties.')];
        if ("filter" === e4.expressionContext)
          return ko(i3, e4);
        if (e4.expressionContext && 0 === e4.expressionContext.indexOf("cluster")) {
          if (!jr(i3, ["zoom", "feature-state"]))
            return [new Dt(e4.key, e4.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if ("cluster-initial" === e4.expressionContext && !Nr(i3))
            return [new Dt(e4.key, e4.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function ko(e4, t3) {
        const i3 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (t3.valueSpec && t3.valueSpec.expression)
          for (const e5 of t3.valueSpec.expression.parameters)
            i3.delete(e5);
        if (0 === i3.size)
          return [];
        const r3 = [];
        return e4 instanceof ki && i3.has(e4.name) ? [new Dt(t3.key, t3.value, `["${e4.name}"] expression is not supported in a filter for a ${t3.object.type} layer with id: ${t3.object.id}`)] : (e4.eachChild((e5) => {
          r3.push(...ko(e5, t3));
        }), r3);
      }
      function Oo(e4) {
        const t3 = e4.key, i3 = e4.value, r3 = e4.valueSpec, n4 = [];
        return Array.isArray(r3.values) ? -1 === r3.values.indexOf(kt(i3)) && n4.push(new Dt(t3, i3, `expected one of [${r3.values.join(", ")}], ${JSON.stringify(i3)} found`)) : -1 === Object.keys(r3.values).indexOf(kt(i3)) && n4.push(new Dt(t3, i3, `expected one of [${Object.keys(r3.values).join(", ")}], ${JSON.stringify(i3)} found`)), n4;
      }
      function Bo(e4) {
        if (true === e4 || false === e4)
          return true;
        if (!Array.isArray(e4) || 0 === e4.length)
          return false;
        switch (e4[0]) {
          case "has":
            return e4.length >= 2 && "$id" !== e4[1] && "$type" !== e4[1];
          case "in":
            return e4.length >= 3 && ("string" != typeof e4[1] || Array.isArray(e4[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return 3 !== e4.length || Array.isArray(e4[1]) || Array.isArray(e4[2]);
          case "any":
          case "all":
            for (const t3 of e4.slice(1))
              if (!Bo(t3) && "boolean" != typeof t3)
                return false;
            return true;
          default:
            return true;
        }
      }
      function Fo(e4, t3 = "fill") {
        if (null == e4)
          return { filter: () => true, needGeometry: false, needFeature: false };
        Bo(e4) || (e4 = Zo(e4));
        const i3 = e4;
        let r3 = true;
        try {
          r3 = function(e5) {
            if (!Vo(e5))
              return e5;
            let t4 = Ot(e5);
            return Uo(t4), t4 = No(t4), t4;
          }(i3);
        } catch (e5) {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(i3, null, 2)}
        `);
        }
        const n4 = Pt[`filter_${t3}`], o3 = Eo(r3, n4);
        let s6 = null;
        if ("error" === o3.result)
          throw new Error(o3.value.map((e5) => `${e5.key}: ${e5.message}`).join(", "));
        s6 = (e5, t4, i4) => o3.value.evaluate(e5, t4, {}, i4);
        let a3 = null, l3 = null;
        if (r3 !== i3) {
          const e5 = Eo(i3, n4);
          if ("error" === e5.result)
            throw new Error(e5.value.map((e6) => `${e6.key}: ${e6.message}`).join(", "));
          a3 = (t4, i4, r4, n5, o4) => e5.value.evaluate(t4, i4, {}, r4, void 0, void 0, n5, o4), l3 = !Nr(e5.value.expression);
        }
        return { filter: s6, dynamicFilter: a3 || void 0, needGeometry: qo(r3), needFeature: !!l3 };
      }
      function No(e4) {
        if (!Array.isArray(e4))
          return e4;
        const t3 = function(e5) {
          if (jo.has(e5[0])) {
            for (let t4 = 1; t4 < e5.length; t4++)
              if (Vo(e5[t4]))
                return true;
          }
          return e5;
        }(e4);
        return true === t3 ? t3 : t3.map((e5) => No(e5));
      }
      function Uo(e4) {
        let t3 = false;
        const i3 = [];
        if ("case" === e4[0]) {
          for (let r3 = 1; r3 < e4.length - 1; r3 += 2)
            t3 = t3 || Vo(e4[r3]), i3.push(e4[r3 + 1]);
          i3.push(e4[e4.length - 1]);
        } else if ("match" === e4[0]) {
          t3 = t3 || Vo(e4[1]);
          for (let t4 = 2; t4 < e4.length - 1; t4 += 2)
            i3.push(e4[t4 + 1]);
          i3.push(e4[e4.length - 1]);
        } else if ("step" === e4[0]) {
          t3 = t3 || Vo(e4[1]);
          for (let t4 = 1; t4 < e4.length - 1; t4 += 2)
            i3.push(e4[t4 + 1]);
        }
        t3 && (e4.length = 0, e4.push("any", ...i3));
        for (let t4 = 1; t4 < e4.length; t4++)
          Uo(e4[t4]);
      }
      function Vo(e4) {
        if (!Array.isArray(e4))
          return false;
        if ("pitch" === (t3 = e4[0]) || "distance-from-center" === t3)
          return true;
        var t3;
        for (let t4 = 1; t4 < e4.length; t4++)
          if (Vo(e4[t4]))
            return true;
        return false;
      }
      const jo = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function Go(e4, t3) {
        return e4 < t3 ? -1 : e4 > t3 ? 1 : 0;
      }
      function qo(e4) {
        if (!Array.isArray(e4))
          return false;
        if ("within" === e4[0] || "distance" === e4[0])
          return true;
        for (let t3 = 1; t3 < e4.length; t3++)
          if (qo(e4[t3]))
            return true;
        return false;
      }
      function Zo(e4) {
        if (!e4)
          return true;
        const t3 = e4[0];
        return e4.length <= 1 ? "any" !== t3 : "==" === t3 ? $o(e4[1], e4[2], "==") : "!=" === t3 ? Xo($o(e4[1], e4[2], "==")) : "<" === t3 || ">" === t3 || "<=" === t3 || ">=" === t3 ? $o(e4[1], e4[2], t3) : "any" === t3 ? (i3 = e4.slice(1), ["any"].concat(i3.map(Zo))) : "all" === t3 ? ["all"].concat(e4.slice(1).map(Zo)) : "none" === t3 ? ["all"].concat(e4.slice(1).map(Zo).map(Xo)) : "in" === t3 ? Wo(e4[1], e4.slice(2)) : "!in" === t3 ? Xo(Wo(e4[1], e4.slice(2))) : "has" === t3 ? Ho(e4[1]) : "!has" !== t3 || Xo(Ho(e4[1]));
        var i3;
      }
      function $o(e4, t3, i3) {
        switch (e4) {
          case "$type":
            return [`filter-type-${i3}`, t3];
          case "$id":
            return [`filter-id-${i3}`, t3];
          default:
            return [`filter-${i3}`, e4, t3];
        }
      }
      function Wo(e4, t3) {
        if (0 === t3.length)
          return false;
        switch (e4) {
          case "$type":
            return ["filter-type-in", ["literal", t3]];
          case "$id":
            return ["filter-id-in", ["literal", t3]];
          default:
            return t3.length > 200 && !t3.some((e5) => typeof e5 != typeof t3[0]) ? ["filter-in-large", e4, ["literal", t3.sort(Go)]] : ["filter-in-small", e4, ["literal", t3]];
        }
      }
      function Ho(e4) {
        switch (e4) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", e4];
        }
      }
      function Xo(e4) {
        return ["!", e4];
      }
      function Yo(e4) {
        return Bo(Ot(e4.value)) ? Lo(Lt({}, e4, { expressionContext: "filter", valueSpec: e4.styleSpec[`filter_${e4.layerType || "fill"}`] })) : Ko(e4);
      }
      function Ko(e4) {
        const t3 = e4.value, i3 = e4.key;
        if ("array" !== Si(t3))
          return [new Dt(i3, t3, `array expected, ${Si(t3)} found`)];
        const r3 = e4.styleSpec;
        let n4, o3 = [];
        if (t3.length < 1)
          return [new Dt(i3, t3, "filter array must have at least 1 element")];
        switch (o3 = o3.concat(Oo({ key: `${i3}[0]`, value: t3[0], valueSpec: r3.filter_operator, style: e4.style, styleSpec: e4.styleSpec })), kt(t3[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            t3.length >= 2 && "$type" === kt(t3[1]) && o3.push(new Dt(i3, t3, `"$type" cannot be use with operator "${t3[0]}"`));
          case "==":
          case "!=":
            3 !== t3.length && o3.push(new Dt(i3, t3, `filter array for operator "${t3[0]}" must have 3 elements`));
          case "in":
          case "!in":
            t3.length >= 2 && (n4 = Si(t3[1]), "string" !== n4 && o3.push(new Dt(`${i3}[1]`, t3[1], `string expected, ${n4} found`)));
            for (let s6 = 2; s6 < t3.length; s6++)
              n4 = Si(t3[s6]), "$type" === kt(t3[1]) ? o3 = o3.concat(Oo({ key: `${i3}[${s6}]`, value: t3[s6], valueSpec: r3.geometry_type, style: e4.style, styleSpec: e4.styleSpec })) : "string" !== n4 && "number" !== n4 && "boolean" !== n4 && o3.push(new Dt(`${i3}[${s6}]`, t3[s6], `string, number, or boolean expected, ${n4} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let r4 = 1; r4 < t3.length; r4++)
              o3 = o3.concat(Ko({ key: `${i3}[${r4}]`, value: t3[r4], style: e4.style, styleSpec: e4.styleSpec }));
            break;
          case "has":
          case "!has":
            n4 = Si(t3[1]), 2 !== t3.length ? o3.push(new Dt(i3, t3, `filter array for "${t3[0]}" operator must have 2 elements`)) : "string" !== n4 && o3.push(new Dt(`${i3}[1]`, t3[1], `string expected, ${n4} found`));
        }
        return o3;
      }
      function Jo(e4, t3) {
        const i3 = e4.key, r3 = e4.style, n4 = e4.layer, o3 = e4.styleSpec, s6 = e4.value, a3 = e4.objectKey, l3 = o3[`${t3}_${e4.layerType}`];
        if (!l3)
          return [];
        const c3 = a3.match(/^(.*)-transition$/);
        if ("paint" === t3 && c3 && l3[c3[1]] && l3[c3[1]].transition)
          return ds({ key: i3, value: s6, valueSpec: o3.transition, style: r3, styleSpec: o3 });
        const h3 = e4.valueSpec || l3[a3];
        if (!h3)
          return [new Rt(i3, s6, `unknown property "${a3}"`)];
        let u3;
        if ("string" === Si(s6) && co(h3) && !h3.tokens && (u3 = /^{([^}]+)}$/.exec(s6))) {
          const e5 = `\`{ "type": "identity", "property": ${u3 ? JSON.stringify(u3[1]) : '"_"'} }\``;
          return [new Dt(i3, s6, `"${a3}" does not support interpolation syntax
Use an identity property function instead: ${e5}.`)];
        }
        const d3 = [];
        if ("symbol" === e4.layerType)
          "text-field" !== a3 || !r3 || r3.glyphs || r3.imports || d3.push(new Dt(i3, s6, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a3 && fo(Ot(s6)) && "identity" === kt(s6.type) && d3.push(new Dt(i3, s6, '"text-font" does not support identity functions'));
        else if ("model" === e4.layerType && "paint" === t3 && n4 && n4.layout && n4.layout.hasOwnProperty("model-id") && co(h3) && (ho(h3) || uo(h3))) {
          const e5 = So(Ot(s6), h3), t4 = e5.value.expression || e5.value._styleExpression.expression;
          t4 && !jr(t4, ["measure-light"]) && ("model-emissive-strength" === a3 && Nr(t4) && Ur(t4) || d3.push(new Dt(i3, s6, `${a3} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
        }
        return d3.concat(ds({ key: e4.key, value: s6, valueSpec: h3, style: r3, styleSpec: o3, expressionContext: "property", propertyType: t3, propertyKey: a3 }));
      }
      function Qo(e4) {
        return Jo(e4, "paint");
      }
      function es(e4) {
        return Jo(e4, "layout");
      }
      function ts(e4) {
        let t3 = [];
        const i3 = e4.value, r3 = e4.key, n4 = e4.style, o3 = e4.styleSpec;
        i3.type || i3.ref || t3.push(new Dt(r3, i3, 'either "type" or "ref" is required'));
        let s6 = kt(i3.type);
        const a3 = kt(i3.ref);
        if (i3.id) {
          const o4 = kt(i3.id);
          for (let s7 = 0; s7 < e4.arrayIndex; s7++) {
            const e5 = n4.layers[s7];
            kt(e5.id) === o4 && t3.push(new Dt(r3, i3.id, `duplicate layer id "${i3.id}", previously used at line ${e5.id.__line__}`));
          }
        }
        if ("ref" in i3) {
          let e5;
          ["type", "source", "source-layer", "filter", "layout"].forEach((e6) => {
            e6 in i3 && t3.push(new Dt(r3, i3[e6], `"${e6}" is prohibited for ref layers`));
          }), n4.layers.forEach((t4) => {
            kt(t4.id) === a3 && (e5 = t4);
          }), e5 ? e5.ref ? t3.push(new Dt(r3, i3.ref, "ref cannot reference another ref layer")) : s6 = kt(e5.type) : "string" == typeof a3 && t3.push(new Dt(r3, i3.ref, `ref layer "${a3}" not found`));
        } else if ("background" !== s6 && "sky" !== s6 && "slot" !== s6)
          if (i3.source) {
            const e5 = n4.sources && n4.sources[i3.source], o4 = e5 && kt(e5.type);
            e5 ? "vector" === o4 && "raster" === s6 ? t3.push(new Dt(r3, i3.source, `layer "${i3.id}" requires a raster source`)) : "raster" === o4 && "raster" !== s6 ? t3.push(new Dt(r3, i3.source, `layer "${i3.id}" requires a vector source`)) : "vector" !== o4 || i3["source-layer"] ? "raster-dem" === o4 && "hillshade" !== s6 ? t3.push(new Dt(r3, i3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s6 || !i3.paint || !i3.paint["line-gradient"] && !i3.paint["line-trim-offset"] || "geojson" === o4 && e5.lineMetrics || t3.push(new Dt(r3, i3, `layer "${i3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t3.push(new Dt(r3, i3, `layer "${i3.id}" must specify a "source-layer"`)) : t3.push(new Dt(r3, i3.source, `source "${i3.source}" not found`));
          } else
            t3.push(new Dt(r3, i3, 'missing required property "source"'));
        return t3 = t3.concat(zo({ key: r3, value: i3, valueSpec: o3.layer, style: e4.style, styleSpec: e4.styleSpec, objectElementValidators: { "*": () => [], type: () => ds({ key: `${r3}.type`, value: i3.type, valueSpec: o3.layer.type, style: e4.style, styleSpec: e4.styleSpec, object: i3, objectKey: "type" }), filter: (e5) => Yo(Lt({ layerType: s6 }, e5)), layout: (e5) => zo({ layer: i3, key: e5.key, value: e5.value, valueSpec: {}, style: e5.style, styleSpec: e5.styleSpec, objectElementValidators: { "*": (e6) => es(Lt({ layerType: s6 }, e6)) } }), paint: (e5) => zo({ layer: i3, key: e5.key, value: e5.value, valueSpec: {}, style: e5.style, styleSpec: e5.styleSpec, objectElementValidators: { "*": (e6) => Qo(Lt({ layerType: s6, layer: i3 }, e6)) } }) } })), t3;
      }
      function is(e4) {
        const t3 = e4.value, i3 = e4.key, r3 = Si(t3);
        return "string" !== r3 ? [new Dt(i3, t3, `string expected, ${r3} found`)] : [];
      }
      const rs = { promoteId: function({ key: e4, value: t3 }) {
        if ("string" === Si(t3))
          return is({ key: e4, value: t3 });
        {
          const i3 = [];
          for (const r3 in t3)
            i3.push(...is({ key: `${e4}.${r3}`, value: t3[r3] }));
          return i3;
        }
      } };
      function ns(e4) {
        const t3 = e4.value, i3 = e4.key, r3 = e4.styleSpec, n4 = e4.style;
        if (!t3.type)
          return [new Dt(i3, t3, '"type" is required')];
        const o3 = kt(t3.type);
        let s6 = [];
        switch (["vector", "raster", "raster-dem"].includes(o3) && (t3.url || t3.tiles || s6.push(new Dt(i3, t3, 'Either "url" or "tiles" is required.'))), o3) {
          case "vector":
          case "raster":
          case "raster-dem":
            return s6 = s6.concat(zo({ key: i3, value: t3, valueSpec: r3[`source_${o3.replace("-", "_")}`], style: e4.style, styleSpec: r3, objectElementValidators: rs })), s6;
          case "geojson":
            if (s6 = zo({ key: i3, value: t3, valueSpec: r3.source_geojson, style: n4, styleSpec: r3, objectElementValidators: rs }), t3.cluster)
              for (const e5 in t3.clusterProperties) {
                const [r4, n5] = t3.clusterProperties[e5], o4 = "string" == typeof r4 ? [r4, ["accumulated"], ["get", e5]] : r4;
                s6.push(...Lo({ key: `${i3}.${e5}.map`, value: n5, expressionContext: "cluster-map" })), s6.push(...Lo({ key: `${i3}.${e5}.reduce`, value: o4, expressionContext: "cluster-reduce" }));
              }
            return s6;
          case "video":
            return zo({ key: i3, value: t3, valueSpec: r3.source_video, style: n4, styleSpec: r3 });
          case "image":
            return zo({ key: i3, value: t3, valueSpec: r3.source_image, style: n4, styleSpec: r3 });
          case "canvas":
            return [new Dt(i3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Oo({ key: `${i3}.type`, value: t3.type, valueSpec: { values: os(r3) }, style: n4, styleSpec: r3 });
        }
      }
      function os(e4) {
        return e4.source.reduce((t3, i3) => {
          const r3 = e4[i3];
          return "enum" === r3.type.type && (t3 = t3.concat(Object.keys(r3.type.values))), t3;
        }, []);
      }
      function ss(e4) {
        const t3 = e4.value;
        let i3 = [];
        if (!t3)
          return i3;
        const r3 = Si(t3);
        return "string" !== r3 ? (i3 = i3.concat([new Dt(e4.key, t3, `string expected, "${r3}" found`)]), i3) : (function(e5) {
          const t4 = -1 === e5.indexOf("://");
          try {
            return new URL(e5, t4 ? "http://example.com" : void 0), true;
          } catch (e6) {
            return false;
          }
        }(t3) || (i3 = i3.concat([new Dt(e4.key, t3, `invalid url "${t3}"`)])), i3);
      }
      function as(e4) {
        const t3 = e4.value, i3 = e4.styleSpec, r3 = i3.light, n4 = e4.style;
        let o3 = [];
        const s6 = Si(t3);
        if (void 0 === t3)
          return o3;
        if ("object" !== s6)
          return o3 = o3.concat([new Dt("light", t3, `object expected, ${s6} found`)]), o3;
        for (const e5 in t3) {
          const s7 = e5.match(/^(.*)-transition$/);
          o3 = o3.concat(s7 && r3[s7[1]] && r3[s7[1]].transition ? ds({ key: e5, value: t3[e5], valueSpec: i3.transition, style: n4, styleSpec: i3 }) : r3[e5] ? ds({ key: e5, value: t3[e5], valueSpec: r3[e5], style: n4, styleSpec: i3 }) : [new Dt(e5, t3[e5], `unknown property "${e5}"`)]);
        }
        return o3;
      }
      function ls(e4) {
        const t3 = e4.value;
        let i3 = [];
        if (!t3)
          return i3;
        const r3 = Si(t3);
        if ("object" !== r3)
          return i3 = i3.concat([new Dt("light-3d", t3, `object expected, ${r3} found`)]), i3;
        const n4 = e4.styleSpec, o3 = n4["light-3d"], s6 = e4.key, a3 = e4.style, l3 = e4.style.lights;
        for (const e5 of ["type", "id"])
          if (!(e5 in t3))
            return i3 = i3.concat([new Dt("light-3d", t3, `missing property ${e5} on light`)]), i3;
        if (t3.type && l3)
          for (let r4 = 0; r4 < e4.arrayIndex; r4++) {
            const e5 = kt(t3.type), n5 = l3[r4];
            kt(n5.type) === e5 && i3.push(new Dt(s6, t3.id, `duplicate light type "${t3.type}", previously defined at line ${n5.id.__line__}`));
          }
        const c3 = `properties_light_${t3.type}`;
        if (!(c3 in n4))
          return i3 = i3.concat([new Dt("light-3d", t3, `Invalid light type ${t3.type}`)]), i3;
        const h3 = n4[c3];
        for (const r4 in t3)
          if ("properties" === r4) {
            const o4 = t3[r4], s7 = Si(o4);
            if ("object" !== s7)
              return i3 = i3.concat([new Dt("properties", o4, `object expected, ${s7} found`)]), i3;
            for (const t4 in o4)
              i3 = i3.concat(h3[t4] ? ds({ key: t4, value: o4[t4], valueSpec: h3[t4], style: a3, styleSpec: n4 }) : [new Rt(e4.key, o4[t4], `unknown property "${t4}"`)]);
          } else {
            const e5 = r4.match(/^(.*)-transition$/);
            i3 = i3.concat(e5 && o3[e5[1]] && o3[e5[1]].transition ? ds({ key: r4, value: t3[r4], valueSpec: n4.transition, style: a3, styleSpec: n4 }) : o3[r4] ? ds({ key: r4, value: t3[r4], valueSpec: o3[r4], style: a3, styleSpec: n4 }) : [new Rt(r4, t3[r4], `unknown property "${r4}"`)]);
          }
        return i3;
      }
      function cs(e4) {
        const t3 = e4.value, i3 = e4.key, r3 = e4.style, n4 = e4.styleSpec, o3 = n4.terrain;
        let s6 = [];
        const a3 = Si(t3);
        if (void 0 === t3)
          return s6;
        if ("null" === a3)
          return s6;
        if ("object" !== a3)
          return s6 = s6.concat([new Dt("terrain", t3, `object expected, ${a3} found`)]), s6;
        for (const e5 in t3) {
          const i4 = e5.match(/^(.*)-transition$/);
          s6 = s6.concat(i4 && o3[i4[1]] && o3[i4[1]].transition ? ds({ key: e5, value: t3[e5], valueSpec: n4.transition, style: r3, styleSpec: n4 }) : o3[e5] ? ds({ key: e5, value: t3[e5], valueSpec: o3[e5], style: r3, styleSpec: n4 }) : [new Rt(e5, t3[e5], `unknown property "${e5}"`)]);
        }
        if (t3.source) {
          const e5 = r3.sources && r3.sources[t3.source], n5 = e5 && kt(e5.type);
          e5 ? "raster-dem" !== n5 && s6.push(new Dt(i3, t3.source, `terrain cannot be used with a source of type ${String(n5)}, it only be used with a "raster-dem" source type`)) : s6.push(new Dt(i3, t3.source, `source "${t3.source}" not found`));
        } else
          s6.push(new Dt(i3, t3, 'terrain is missing required property "source"'));
        return s6;
      }
      function hs(e4) {
        const t3 = e4.value, i3 = e4.style, r3 = e4.styleSpec, n4 = r3.fog;
        let o3 = [];
        const s6 = Si(t3);
        if (void 0 === t3)
          return o3;
        if ("object" !== s6)
          return o3 = o3.concat([new Dt("fog", t3, `object expected, ${s6} found`)]), o3;
        for (const e5 in t3) {
          const s7 = e5.match(/^(.*)-transition$/);
          o3 = o3.concat(s7 && n4[s7[1]] && n4[s7[1]].transition ? ds({ key: e5, value: t3[e5], valueSpec: r3.transition, style: i3, styleSpec: r3 }) : n4[e5] ? ds({ key: e5, value: t3[e5], valueSpec: n4[e5], style: i3, styleSpec: r3 }) : [new Rt(e5, t3[e5], `unknown property "${e5}"`)]);
        }
        return o3;
      }
      const us = { "*": () => [], array: Po, boolean: function(e4) {
        const t3 = e4.value, i3 = e4.key, r3 = Si(t3);
        return "boolean" !== r3 ? [new Dt(i3, t3, `boolean expected, ${r3} found`)] : [];
      }, number: Do, color: function(e4) {
        const t3 = e4.key, i3 = e4.value, r3 = Si(i3);
        return "string" !== r3 ? [new Dt(t3, i3, `color expected, ${r3} found`)] : null === ri(i3) ? [new Dt(t3, i3, `color expected, "${i3}" found`)] : [];
      }, enum: Oo, filter: Yo, function: Ro, layer: ts, object: zo, source: ns, model: ss, light: as, "light-3d": ls, terrain: cs, fog: hs, string: is, formatted: function(e4) {
        return 0 === is(e4).length ? [] : Lo(e4);
      }, resolvedImage: function(e4) {
        return 0 === is(e4).length ? [] : Lo(e4);
      }, projection: function(e4) {
        const t3 = e4.value, i3 = e4.styleSpec, r3 = i3.projection, n4 = e4.style;
        let o3 = [];
        const s6 = Si(t3);
        if ("object" === s6)
          for (const e5 in t3)
            o3 = o3.concat(ds({ key: e5, value: t3[e5], valueSpec: r3[e5], style: n4, styleSpec: i3 }));
        else
          "string" !== s6 && (o3 = o3.concat([new Dt("projection", t3, `object or string expected, ${s6} found`)]));
        return o3;
      }, import: function(e4) {
        const { value: t3, styleSpec: i3 } = e4, { data: r3, ...n4 } = t3;
        Object.defineProperty(n4, "__line__", { value: t3.__line__, enumerable: false });
        let o3 = zo(Lt({}, e4, { value: n4, valueSpec: i3.import }));
        return "" === kt(n4.id) && o3.push(new Dt(`${e4.key}.id`, n4, "import id can't be an empty string")), r3 && (o3 = o3.concat(fs(r3, i3, { key: `${e4.key}.data` }))), o3;
      } };
      function ds(e4, t3 = false) {
        const i3 = e4.value, r3 = e4.valueSpec, n4 = e4.styleSpec;
        if (r3.expression && fo(kt(i3)))
          return Ro(e4);
        if (r3.expression && To(Ot(i3)))
          return Lo(e4);
        if (r3.type && us[r3.type]) {
          const i4 = us[r3.type](e4);
          return true === t3 && i4.length > 0 && "array" === Si(e4.value) ? Lo(e4) : i4;
        }
        return zo(Lt({}, e4, { valueSpec: r3.type ? n4[r3.type] : r3 }));
      }
      function ps(e4) {
        const t3 = e4.value, i3 = e4.key, r3 = is(e4);
        return r3.length || (-1 === t3.indexOf("{fontstack}") && r3.push(new Dt(i3, t3, '"glyphs" url must include a "{fontstack}" token')), -1 === t3.indexOf("{range}") && r3.push(new Dt(i3, t3, '"glyphs" url must include a "{range}" token'))), r3;
      }
      function fs(e4, t3 = Pt, i3 = {}) {
        return ds({ key: i3.key || "", value: e4, valueSpec: t3.$root, styleSpec: t3, style: e4, objectElementValidators: { glyphs: ps, "*": () => [] } });
      }
      function ms(e4, t3 = Pt) {
        return As(fs(e4, t3));
      }
      const _s = (e4) => As(ns(e4)), gs = (e4) => As(as(e4)), ys = (e4) => As(ls(e4)), xs = (e4) => As(cs(e4)), vs = (e4) => As(hs(e4)), bs = (e4) => As(ts(e4)), ws = (e4) => As(Yo(e4)), Ts = (e4) => As(Qo(e4)), Es = (e4) => As(es(e4)), Ms = (e4) => As(ss(e4));
      function As(e4) {
        return e4.slice().sort((e5, t3) => e5.line && t3.line ? e5.line - t3.line : 0);
      }
      function Ss(e4, t3) {
        let i3 = false;
        if (t3 && t3.length)
          for (const r3 of t3)
            r3 instanceof Rt ? H2(r3.message) : (e4.fire(new Ct(new Error(r3.message))), i3 = true);
        return i3;
      }
      var Is = zs, Cs = 3;
      function zs(e4, t3, i3) {
        var r3 = this.cells = [];
        if (e4 instanceof ArrayBuffer) {
          this.arrayBuffer = e4;
          var n4 = new Int32Array(this.arrayBuffer);
          e4 = n4[0], this.d = (t3 = n4[1]) + 2 * (i3 = n4[2]);
          for (var o3 = 0; o3 < this.d * this.d; o3++) {
            var s6 = n4[Cs + o3], a3 = n4[Cs + o3 + 1];
            r3.push(s6 === a3 ? null : n4.subarray(s6, a3));
          }
          var l3 = n4[Cs + r3.length + 1];
          this.keys = n4.subarray(n4[Cs + r3.length], l3), this.bboxes = n4.subarray(l3), this.insert = this._insertReadonly;
        } else {
          this.d = t3 + 2 * i3;
          for (var c3 = 0; c3 < this.d * this.d; c3++)
            r3.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = t3, this.extent = e4, this.padding = i3, this.scale = t3 / e4, this.uid = 0;
        var h3 = i3 / t3 * e4;
        this.min = -h3, this.max = e4 + h3;
      }
      zs.prototype.insert = function(e4, t3, i3, r3, n4) {
        this._forEachCell(t3, i3, r3, n4, this._insertCell, this.uid++), this.keys.push(e4), this.bboxes.push(t3), this.bboxes.push(i3), this.bboxes.push(r3), this.bboxes.push(n4);
      }, zs.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, zs.prototype._insertCell = function(e4, t3, i3, r3, n4, o3) {
        this.cells[n4].push(o3);
      }, zs.prototype.query = function(e4, t3, i3, r3, n4) {
        var o3 = this.min, s6 = this.max;
        if (e4 <= o3 && t3 <= o3 && s6 <= i3 && s6 <= r3 && !n4)
          return Array.prototype.slice.call(this.keys);
        var a3 = [];
        return this._forEachCell(e4, t3, i3, r3, this._queryCell, a3, {}, n4), a3;
      }, zs.prototype._queryCell = function(e4, t3, i3, r3, n4, o3, s6, a3) {
        var l3 = this.cells[n4];
        if (null !== l3)
          for (var c3 = this.keys, h3 = this.bboxes, u3 = 0; u3 < l3.length; u3++) {
            var d3 = l3[u3];
            if (void 0 === s6[d3]) {
              var p3 = 4 * d3;
              (a3 ? a3(h3[p3 + 0], h3[p3 + 1], h3[p3 + 2], h3[p3 + 3]) : e4 <= h3[p3 + 2] && t3 <= h3[p3 + 3] && i3 >= h3[p3 + 0] && r3 >= h3[p3 + 1]) ? (s6[d3] = true, o3.push(c3[d3])) : s6[d3] = false;
            }
          }
      }, zs.prototype._forEachCell = function(e4, t3, i3, r3, n4, o3, s6, a3) {
        for (var l3 = this._convertToCellCoord(e4), c3 = this._convertToCellCoord(t3), h3 = this._convertToCellCoord(i3), u3 = this._convertToCellCoord(r3), d3 = l3; d3 <= h3; d3++)
          for (var p3 = c3; p3 <= u3; p3++) {
            var f3 = this.d * p3 + d3;
            if ((!a3 || a3(this._convertFromCellCoord(d3), this._convertFromCellCoord(p3), this._convertFromCellCoord(d3 + 1), this._convertFromCellCoord(p3 + 1))) && n4.call(this, e4, t3, i3, r3, f3, o3, s6, a3))
              return;
          }
      }, zs.prototype._convertFromCellCoord = function(e4) {
        return (e4 - this.padding) / this.scale;
      }, zs.prototype._convertToCellCoord = function(e4) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(e4 * this.scale) + this.padding));
      }, zs.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var e4 = this.cells, t3 = Cs + this.cells.length + 1 + 1, i3 = 0, r3 = 0; r3 < this.cells.length; r3++)
          i3 += this.cells[r3].length;
        var n4 = new Int32Array(t3 + i3 + this.keys.length + this.bboxes.length);
        n4[0] = this.extent, n4[1] = this.n, n4[2] = this.padding;
        for (var o3 = t3, s6 = 0; s6 < e4.length; s6++) {
          var a3 = e4[s6];
          n4[Cs + s6] = o3, n4.set(a3, o3), o3 += a3.length;
        }
        return n4[Cs + e4.length] = o3, n4.set(this.keys, o3), n4[Cs + e4.length + 1] = o3 += this.keys.length, n4.set(this.bboxes, o3), o3 += this.bboxes.length, n4.buffer;
      };
      var Ps = d2(Is);
      const Ds = {};
      function Rs(e4, t3, i3 = {}) {
        Object.defineProperty(e4, "_classRegistryKey", { value: t3, writeable: false }), Ds[t3] = { klass: e4, omit: i3.omit || [] };
      }
      Rs(Object, "Object"), Ps.serialize = function(e4, t3) {
        const i3 = e4.toArrayBuffer();
        return t3 && t3.add(i3), { buffer: i3 };
      }, Ps.deserialize = function(e4) {
        return new Ps(e4.buffer);
      }, Object.defineProperty(Ps, "name", { value: "Grid" }), Rs(Ps, "Grid"), Rs(hi, "Color"), Rs(Error, "Error"), Rs(xe, "AJAXError"), Rs(fi, "ResolvedImage"), Rs(Io, "StylePropertyFunction"), Rs(wo, "StyleExpression", { omit: ["_evaluator"] }), Rs(Ao, "ZoomDependentExpression"), Rs(Mo, "ZoomConstantExpression"), Rs(ki, "CompoundExpression", { omit: ["_evaluate"] });
      for (const e4 in oo)
        Ds[oo[e4]._classRegistryKey] || Rs(oo[e4], `Expression${e4}`);
      function Ls(e4) {
        return e4 && "undefined" != typeof ArrayBuffer && (e4 instanceof ArrayBuffer || e4.constructor && "ArrayBuffer" === e4.constructor.name);
      }
      function ks(e4) {
        return t2.ImageBitmap && e4 instanceof t2.ImageBitmap;
      }
      function Os(e4, i3) {
        if (null == e4 || "boolean" == typeof e4 || "number" == typeof e4 || "string" == typeof e4 || e4 instanceof Boolean || e4 instanceof Number || e4 instanceof String || e4 instanceof Date || e4 instanceof RegExp)
          return e4;
        if (Ls(e4) || ks(e4))
          return i3 && i3.add(e4), e4;
        if (ArrayBuffer.isView(e4)) {
          const t3 = e4;
          return i3 && i3.add(t3.buffer), t3;
        }
        if (e4 instanceof t2.ImageData)
          return i3 && i3.add(e4.data.buffer), e4;
        if (Array.isArray(e4)) {
          const t3 = [];
          for (const r3 of e4)
            t3.push(Os(r3, i3));
          return t3;
        }
        if (e4 instanceof Map) {
          const t3 = { $name: "Map" };
          for (const [i4, r3] of e4.entries())
            t3[i4] = Os(r3);
          return t3;
        }
        if ("object" == typeof e4) {
          const t3 = e4.constructor, r3 = t3._classRegistryKey;
          if (!r3)
            throw new Error(`can't serialize object of unregistered class ${r3}`);
          const n4 = t3.serialize ? t3.serialize(e4, i3) : {};
          if (!t3.serialize) {
            for (const t4 in e4)
              e4.hasOwnProperty(t4) && (Ds[r3].omit.indexOf(t4) >= 0 || (n4[t4] = Os(e4[t4], i3)));
            e4 instanceof Error && (n4.message = e4.message);
          }
          if (n4.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== r3 && (n4.$name = r3), n4;
        }
        throw new Error("can't serialize object of type " + typeof e4);
      }
      function Bs(e4) {
        if (null == e4 || "boolean" == typeof e4 || "number" == typeof e4 || "string" == typeof e4 || e4 instanceof Boolean || e4 instanceof Number || e4 instanceof String || e4 instanceof Date || e4 instanceof RegExp || Ls(e4) || ks(e4) || ArrayBuffer.isView(e4) || e4 instanceof t2.ImageData)
          return e4;
        if (Array.isArray(e4))
          return e4.map(Bs);
        if ("object" == typeof e4) {
          const t3 = e4.$name || "Object";
          if ("Map" === t3) {
            const t4 = /* @__PURE__ */ new Map();
            for (const i4 of Object.keys(e4))
              "$name" !== i4 && t4.set(i4, Bs(e4[i4]));
            return t4;
          }
          const { klass: i3 } = Ds[t3];
          if (!i3)
            throw new Error(`can't deserialize unregistered class ${t3}`);
          if (i3.deserialize)
            return i3.deserialize(e4);
          const r3 = Object.create(i3.prototype);
          for (const t4 of Object.keys(e4))
            "$name" !== t4 && (r3[t4] = Bs(e4[t4]));
          return r3;
        }
        throw new Error("can't deserialize object of type " + typeof e4);
      }
      const Fs = { "Latin-1 Supplement": (e4) => e4 >= 128 && e4 <= 255, Arabic: (e4) => e4 >= 1536 && e4 <= 1791, "Arabic Supplement": (e4) => e4 >= 1872 && e4 <= 1919, "Arabic Extended-A": (e4) => e4 >= 2208 && e4 <= 2303, "Hangul Jamo": (e4) => e4 >= 4352 && e4 <= 4607, "Unified Canadian Aboriginal Syllabics": (e4) => e4 >= 5120 && e4 <= 5759, Khmer: (e4) => e4 >= 6016 && e4 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (e4) => e4 >= 6320 && e4 <= 6399, "General Punctuation": (e4) => e4 >= 8192 && e4 <= 8303, "Letterlike Symbols": (e4) => e4 >= 8448 && e4 <= 8527, "Number Forms": (e4) => e4 >= 8528 && e4 <= 8591, "Miscellaneous Technical": (e4) => e4 >= 8960 && e4 <= 9215, "Control Pictures": (e4) => e4 >= 9216 && e4 <= 9279, "Optical Character Recognition": (e4) => e4 >= 9280 && e4 <= 9311, "Enclosed Alphanumerics": (e4) => e4 >= 9312 && e4 <= 9471, "Geometric Shapes": (e4) => e4 >= 9632 && e4 <= 9727, "Miscellaneous Symbols": (e4) => e4 >= 9728 && e4 <= 9983, "Miscellaneous Symbols and Arrows": (e4) => e4 >= 11008 && e4 <= 11263, "CJK Radicals Supplement": (e4) => e4 >= 11904 && e4 <= 12031, "Kangxi Radicals": (e4) => e4 >= 12032 && e4 <= 12255, "Ideographic Description Characters": (e4) => e4 >= 12272 && e4 <= 12287, "CJK Symbols and Punctuation": (e4) => e4 >= 12288 && e4 <= 12351, Hiragana: (e4) => e4 >= 12352 && e4 <= 12447, Katakana: (e4) => e4 >= 12448 && e4 <= 12543, Bopomofo: (e4) => e4 >= 12544 && e4 <= 12591, "Hangul Compatibility Jamo": (e4) => e4 >= 12592 && e4 <= 12687, Kanbun: (e4) => e4 >= 12688 && e4 <= 12703, "Bopomofo Extended": (e4) => e4 >= 12704 && e4 <= 12735, "CJK Strokes": (e4) => e4 >= 12736 && e4 <= 12783, "Katakana Phonetic Extensions": (e4) => e4 >= 12784 && e4 <= 12799, "Enclosed CJK Letters and Months": (e4) => e4 >= 12800 && e4 <= 13055, "CJK Compatibility": (e4) => e4 >= 13056 && e4 <= 13311, "CJK Unified Ideographs Extension A": (e4) => e4 >= 13312 && e4 <= 19903, "Yijing Hexagram Symbols": (e4) => e4 >= 19904 && e4 <= 19967, "CJK Unified Ideographs": (e4) => e4 >= 19968 && e4 <= 40959, "Yi Syllables": (e4) => e4 >= 40960 && e4 <= 42127, "Yi Radicals": (e4) => e4 >= 42128 && e4 <= 42191, "Hangul Jamo Extended-A": (e4) => e4 >= 43360 && e4 <= 43391, "Hangul Syllables": (e4) => e4 >= 44032 && e4 <= 55215, "Hangul Jamo Extended-B": (e4) => e4 >= 55216 && e4 <= 55295, "Private Use Area": (e4) => e4 >= 57344 && e4 <= 63743, "CJK Compatibility Ideographs": (e4) => e4 >= 63744 && e4 <= 64255, "Arabic Presentation Forms-A": (e4) => e4 >= 64336 && e4 <= 65023, "Vertical Forms": (e4) => e4 >= 65040 && e4 <= 65055, "CJK Compatibility Forms": (e4) => e4 >= 65072 && e4 <= 65103, "Small Form Variants": (e4) => e4 >= 65104 && e4 <= 65135, "Arabic Presentation Forms-B": (e4) => e4 >= 65136 && e4 <= 65279, "Halfwidth and Fullwidth Forms": (e4) => e4 >= 65280 && e4 <= 65519, "CJK Unified Ideographs Extension B": (e4) => e4 >= 131072 && e4 <= 173791 };
      function Ns(e4) {
        for (const t3 of e4)
          if (js(t3.charCodeAt(0)))
            return true;
        return false;
      }
      function Us(e4) {
        for (const t3 of e4)
          if (!Vs(t3.charCodeAt(0)))
            return false;
        return true;
      }
      function Vs(e4) {
        return !(Fs.Arabic(e4) || Fs["Arabic Supplement"](e4) || Fs["Arabic Extended-A"](e4) || Fs["Arabic Presentation Forms-A"](e4) || Fs["Arabic Presentation Forms-B"](e4));
      }
      function js(e4) {
        return !(746 !== e4 && 747 !== e4 && (e4 < 4352 || !(Fs["Bopomofo Extended"](e4) || Fs.Bopomofo(e4) || Fs["CJK Compatibility Forms"](e4) && !(e4 >= 65097 && e4 <= 65103) || Fs["CJK Compatibility Ideographs"](e4) || Fs["CJK Compatibility"](e4) || Fs["CJK Radicals Supplement"](e4) || Fs["CJK Strokes"](e4) || !(!Fs["CJK Symbols and Punctuation"](e4) || e4 >= 12296 && e4 <= 12305 || e4 >= 12308 && e4 <= 12319 || 12336 === e4) || Fs["CJK Unified Ideographs Extension A"](e4) || Fs["CJK Unified Ideographs"](e4) || Fs["Enclosed CJK Letters and Months"](e4) || Fs["Hangul Compatibility Jamo"](e4) || Fs["Hangul Jamo Extended-A"](e4) || Fs["Hangul Jamo Extended-B"](e4) || Fs["Hangul Jamo"](e4) || Fs["Hangul Syllables"](e4) || Fs.Hiragana(e4) || Fs["Ideographic Description Characters"](e4) || Fs.Kanbun(e4) || Fs["Kangxi Radicals"](e4) || Fs["Katakana Phonetic Extensions"](e4) || Fs.Katakana(e4) && 12540 !== e4 || !(!Fs["Halfwidth and Fullwidth Forms"](e4) || 65288 === e4 || 65289 === e4 || 65293 === e4 || e4 >= 65306 && e4 <= 65310 || 65339 === e4 || 65341 === e4 || 65343 === e4 || e4 >= 65371 && e4 <= 65503 || 65507 === e4 || e4 >= 65512 && e4 <= 65519) || !(!Fs["Small Form Variants"](e4) || e4 >= 65112 && e4 <= 65118 || e4 >= 65123 && e4 <= 65126) || Fs["Unified Canadian Aboriginal Syllabics"](e4) || Fs["Unified Canadian Aboriginal Syllabics Extended"](e4) || Fs["Vertical Forms"](e4) || Fs["Yijing Hexagram Symbols"](e4) || Fs["Yi Syllables"](e4) || Fs["Yi Radicals"](e4))));
      }
      function Gs(e4) {
        return !(js(e4) || function(e5) {
          return !!(Fs["Latin-1 Supplement"](e5) && (167 === e5 || 169 === e5 || 174 === e5 || 177 === e5 || 188 === e5 || 189 === e5 || 190 === e5 || 215 === e5 || 247 === e5) || Fs["General Punctuation"](e5) && (8214 === e5 || 8224 === e5 || 8225 === e5 || 8240 === e5 || 8241 === e5 || 8251 === e5 || 8252 === e5 || 8258 === e5 || 8263 === e5 || 8264 === e5 || 8265 === e5 || 8273 === e5) || Fs["Letterlike Symbols"](e5) || Fs["Number Forms"](e5) || Fs["Miscellaneous Technical"](e5) && (e5 >= 8960 && e5 <= 8967 || e5 >= 8972 && e5 <= 8991 || e5 >= 8996 && e5 <= 9e3 || 9003 === e5 || e5 >= 9085 && e5 <= 9114 || e5 >= 9150 && e5 <= 9165 || 9167 === e5 || e5 >= 9169 && e5 <= 9179 || e5 >= 9186 && e5 <= 9215) || Fs["Control Pictures"](e5) && 9251 !== e5 || Fs["Optical Character Recognition"](e5) || Fs["Enclosed Alphanumerics"](e5) || Fs["Geometric Shapes"](e5) || Fs["Miscellaneous Symbols"](e5) && !(e5 >= 9754 && e5 <= 9759) || Fs["Miscellaneous Symbols and Arrows"](e5) && (e5 >= 11026 && e5 <= 11055 || e5 >= 11088 && e5 <= 11097 || e5 >= 11192 && e5 <= 11243) || Fs["CJK Symbols and Punctuation"](e5) || Fs.Katakana(e5) || Fs["Private Use Area"](e5) || Fs["CJK Compatibility Forms"](e5) || Fs["Small Form Variants"](e5) || Fs["Halfwidth and Fullwidth Forms"](e5) || 8734 === e5 || 8756 === e5 || 8757 === e5 || e5 >= 9984 && e5 <= 10087 || e5 >= 10102 && e5 <= 10131 || 65532 === e5 || 65533 === e5);
        }(e4));
      }
      function qs(e4) {
        return e4 >= 1424 && e4 <= 2303 || Fs["Arabic Presentation Forms-A"](e4) || Fs["Arabic Presentation Forms-B"](e4);
      }
      function Zs(e4, t3) {
        return !(!t3 && qs(e4) || e4 >= 2304 && e4 <= 3583 || e4 >= 3840 && e4 <= 4255 || Fs.Khmer(e4));
      }
      function $s(e4) {
        for (const t3 of e4)
          if (qs(t3.charCodeAt(0)))
            return true;
        return false;
      }
      const Ws = "deferred", Hs = "loading", Xs = "loaded";
      let Ys = null, Ks = "unavailable", Js = null;
      const Qs = function(e4) {
        e4 && "string" == typeof e4 && e4.indexOf("NetworkError") > -1 && (Ks = "error"), Ys && Ys(e4);
      };
      function ea() {
        ta.fire(new It("pluginStateChange", { pluginStatus: Ks, pluginURL: Js }));
      }
      const ta = new zt(), ia = function() {
        return Ks;
      }, ra = function() {
        if (Ks !== Ws || !Js)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        Ks = Hs, ea(), Js && Te({ url: Js }, (e4) => {
          e4 ? Qs(e4) : (Ks = Xs, ea());
        });
      }, na = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Ks === Xs || null != na.applyArabicShaping, isLoading: () => Ks === Hs, setState(e4) {
        Ks = e4.pluginStatus, Js = e4.pluginURL;
      }, isParsed: () => null != na.applyArabicShaping && null != na.processBidirectionalText && null != na.processStyledBidirectionalText, getPluginURL: () => Js };
      class oa {
        constructor(e4, t3) {
          this.zoom = e4, t3 ? (this.now = t3.now, this.fadeDuration = t3.fadeDuration, this.transition = t3.transition, this.pitch = t3.pitch, this.brightness = t3.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
        }
        isSupportedScript(e4) {
          return function(e5, t3) {
            for (const i3 of e5)
              if (!Zs(i3.charCodeAt(0), t3))
                return false;
            return true;
          }(e4, na.isLoaded());
        }
      }
      class sa {
        constructor(e4, t3, i3) {
          this.property = e4, this.value = t3, this.expression = function(e5, t4, i4) {
            if (fo(e5))
              return new Io(e5, t4);
            if (To(e5) || Array.isArray(e5) && e5.length > 0) {
              const r3 = So(e5, t4, i4);
              if ("error" === r3.result)
                throw new Error(r3.value.map((e6) => `${e6.key}: ${e6.message}`).join(", "));
              return r3.value;
            }
            {
              let i5 = e5;
              return "string" == typeof e5 && "color" === t4.type && (i5 = hi.parse(e5)), { kind: "constant", isConfigDependent: false, evaluate: () => i5 };
            }
          }(void 0 === t3 ? e4.specification.default : t3, e4.specification, i3);
        }
        isDataDriven() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }
        possiblyEvaluate(e4, t3, i3) {
          return this.property.possiblyEvaluate(this, e4, t3, i3);
        }
      }
      class aa {
        constructor(e4, t3) {
          this.property = e4, this.value = new sa(e4, void 0, t3);
        }
        transitioned(e4, t3) {
          return new ca(this.property, this.value, t3, k2({}, e4.transition, this.transition), e4.now);
        }
        untransitioned() {
          return new ca(this.property, this.value, null, {}, 0);
        }
      }
      class la {
        constructor(e4, t3) {
          this._properties = e4, this._values = Object.create(e4.defaultTransitionablePropertyValues), this._options = t3, this.isConfigDependent = false;
        }
        getValue(e4) {
          return $2(this._values[e4].value.value);
        }
        setValue(e4, t3) {
          this._values.hasOwnProperty(e4) || (this._values[e4] = new aa(this._values[e4].property, this._options)), this._values[e4].value = new sa(this._values[e4].property, null === t3 ? void 0 : $2(t3), this._options), this.isConfigDependent = this.isConfigDependent || this._values[e4].value.expression.isConfigDependent;
        }
        setTransitionOrValue(e4, t3) {
          t3 && (this._options = t3);
          const i3 = this._properties.properties;
          if (e4)
            for (const t4 in e4) {
              const r3 = e4[t4];
              if (G(t4, "-transition")) {
                const e5 = t4.slice(0, -11);
                i3[e5] && this.setTransition(e5, r3);
              } else
                i3[t4] && this.setValue(t4, r3);
            }
        }
        getTransition(e4) {
          return $2(this._values[e4].transition);
        }
        setTransition(e4, t3) {
          this._values.hasOwnProperty(e4) || (this._values[e4] = new aa(this._values[e4].property)), this._values[e4].transition = $2(t3) || void 0;
        }
        serialize() {
          const e4 = {};
          for (const t3 of Object.keys(this._values)) {
            const i3 = this.getValue(t3);
            void 0 !== i3 && (e4[t3] = i3);
            const r3 = this.getTransition(t3);
            void 0 !== r3 && (e4[`${t3}-transition`] = r3);
          }
          return e4;
        }
        transitioned(e4, t3) {
          const i3 = new ha(this._properties);
          for (const r3 of Object.keys(this._values))
            i3._values[r3] = this._values[r3].transitioned(e4, t3._values[r3]);
          return i3;
        }
        untransitioned() {
          const e4 = new ha(this._properties);
          for (const t3 of Object.keys(this._values))
            e4._values[t3] = this._values[t3].untransitioned();
          return e4;
        }
      }
      class ca {
        constructor(e4, t3, i3, r3, n4) {
          const o3 = r3.delay || 0, s6 = r3.duration || 0;
          n4 = n4 || 0, this.property = e4, this.value = t3, this.begin = n4 + o3, this.end = this.begin + s6, e4.specification.transition && (r3.delay || r3.duration) && (this.prior = i3);
        }
        possiblyEvaluate(e4, t3, i3) {
          const r3 = e4.now || 0, n4 = this.value.possiblyEvaluate(e4, t3, i3), o3 = this.prior;
          if (o3) {
            if (r3 > this.end)
              return this.prior = null, n4;
            if (this.value.isDataDriven())
              return this.prior = null, n4;
            if (r3 < this.begin)
              return o3.possiblyEvaluate(e4, t3, i3);
            {
              const s6 = (r3 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(o3.possiblyEvaluate(e4, t3, i3), n4, M2(s6));
            }
          }
          return n4;
        }
      }
      class ha {
        constructor(e4) {
          this._properties = e4, this._values = Object.create(e4.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e4, t3, i3) {
          const r3 = new pa(this._properties);
          for (const n4 of Object.keys(this._values))
            r3._values[n4] = this._values[n4].possiblyEvaluate(e4, t3, i3);
          return r3;
        }
        hasTransition() {
          for (const e4 of Object.keys(this._values))
            if (this._values[e4].prior)
              return true;
          return false;
        }
      }
      class ua {
        constructor(e4, t3) {
          this._properties = e4, this._values = Object.create(e4.defaultPropertyValues), this._options = t3, this.isConfigDependent = false;
        }
        getValue(e4) {
          return $2(this._values[e4].value);
        }
        setValue(e4, t3) {
          this._values[e4] = new sa(this._values[e4].property, null === t3 ? void 0 : $2(t3), this._options), this.isConfigDependent = this.isConfigDependent || this._values[e4].expression.isConfigDependent;
        }
        serialize() {
          const e4 = {};
          for (const t3 of Object.keys(this._values)) {
            const i3 = this.getValue(t3);
            void 0 !== i3 && (e4[t3] = i3);
          }
          return e4;
        }
        possiblyEvaluate(e4, t3, i3) {
          const r3 = new pa(this._properties);
          for (const n4 of Object.keys(this._values))
            r3._values[n4] = this._values[n4].possiblyEvaluate(e4, t3, i3);
          return r3;
        }
      }
      class da {
        constructor(e4, t3, i3) {
          this.property = e4, this.value = t3, this.parameters = i3;
        }
        isConstant() {
          return "constant" === this.value.kind;
        }
        constantOr(e4) {
          return "constant" === this.value.kind ? this.value.value : e4;
        }
        evaluate(e4, t3, i3, r3) {
          return this.property.evaluate(this.value, this.parameters, e4, t3, i3, r3);
        }
      }
      class pa {
        constructor(e4) {
          this._properties = e4, this._values = Object.create(e4.defaultPossiblyEvaluatedValues);
        }
        get(e4) {
          return this._values[e4];
        }
      }
      class fa {
        constructor(e4) {
          this.specification = e4;
        }
        possiblyEvaluate(e4, t3) {
          return e4.expression.evaluate(t3);
        }
        interpolate(e4, t3, i3) {
          const r3 = Qr[this.specification.type];
          return r3 ? r3(e4, t3, i3) : e4;
        }
      }
      class ma {
        constructor(e4, t3) {
          this.specification = e4, this.overrides = t3;
        }
        possiblyEvaluate(e4, t3, i3, r3) {
          return new da(this, "constant" === e4.expression.kind || "camera" === e4.expression.kind ? { kind: "constant", value: e4.expression.evaluate(t3, null, {}, i3, r3) } : e4.expression, t3);
        }
        interpolate(e4, t3, i3) {
          if ("constant" !== e4.value.kind || "constant" !== t3.value.kind)
            return e4;
          if (void 0 === e4.value.value || void 0 === t3.value.value)
            return new da(this, { kind: "constant", value: void 0 }, e4.parameters);
          const r3 = Qr[this.specification.type];
          return r3 ? new da(this, { kind: "constant", value: r3(e4.value.value, t3.value.value, i3) }, e4.parameters) : e4;
        }
        evaluate(e4, t3, i3, r3, n4, o3) {
          return "constant" === e4.kind ? e4.value : e4.evaluate(t3, i3, r3, n4, o3);
        }
      }
      class _a2 {
        constructor(e4) {
          this.specification = e4;
        }
        possiblyEvaluate(e4, t3, i3, r3) {
          return !!e4.expression.evaluate(t3, null, {}, i3, r3);
        }
        interpolate() {
          return false;
        }
      }
      class ga {
        constructor(e4) {
          this.properties = e4, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const t3 = new oa(0, {});
          for (const i3 in e4) {
            const r3 = e4[i3];
            r3.specification.overridable && this.overridableProperties.push(i3);
            const n4 = this.defaultPropertyValues[i3] = new sa(r3, void 0), o3 = this.defaultTransitionablePropertyValues[i3] = new aa(r3);
            this.defaultTransitioningPropertyValues[i3] = o3.untransitioned(), this.defaultPossiblyEvaluatedValues[i3] = n4.possiblyEvaluate(t3);
          }
        }
      }
      Rs(ma, "DataDrivenProperty"), Rs(fa, "DataConstantProperty"), Rs(_a2, "ColorRampProperty");
      const ya = "";
      function xa(e4) {
        return e4.indexOf(ya) >= 0;
      }
      function va(e4, t3) {
        return t3 ? `${e4}${ya}${t3}` : e4;
      }
      function ba(e4) {
        const t3 = e4.indexOf(ya);
        return t3 >= 0 ? e4.slice(0, t3) : e4;
      }
      const wa = "-transition";
      class Ta extends zt {
        constructor(e4, t3, i3) {
          if (super(), this.id = e4.id, this.type = e4.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.isConfigDependent = false, "custom" !== e4.type && (this.metadata = e4.metadata, this.minzoom = e4.minzoom, this.maxzoom = e4.maxzoom, "background" !== e4.type && "sky" !== e4.type && "slot" !== e4.type && (this.source = e4.source, this.sourceLayer = e4["source-layer"], this.filter = e4.filter), this.options = i3, e4.slot && (this.slot = e4.slot), t3.layout && (this._unevaluatedLayout = new ua(t3.layout, i3), this.isConfigDependent = this.isConfigDependent || this._unevaluatedLayout.isConfigDependent), t3.paint)) {
            this._transitionablePaint = new la(t3.paint, i3);
            for (const t4 in e4.paint)
              this.setPaintProperty(t4, e4.paint[t4], { validate: false });
            for (const t4 in e4.layout)
              this.setLayoutProperty(t4, e4.layout[t4], { validate: false });
            this.isConfigDependent = this.isConfigDependent || this._transitionablePaint.isConfigDependent, this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new pa(t3.paint);
          }
        }
        setScope(e4) {
          this.scope = e4, this.fqid = va(this.id, e4);
        }
        getLayoutProperty(e4) {
          return "visibility" === e4 ? this.visibility : this._unevaluatedLayout.getValue(e4);
        }
        setLayoutProperty(e4, t3, i3 = {}) {
          if (null != t3 && this._validate(Es, `layers.${this.id}.layout.${e4}`, e4, t3, i3))
            return;
          if ("custom" === this.type && "visibility" === e4)
            return void (this.visibility = t3);
          const r3 = this._unevaluatedLayout;
          r3._properties.properties[e4] && (r3.setValue(e4, t3), this.isConfigDependent = this.isConfigDependent || r3.isConfigDependent, "visibility" === e4 && this.possiblyEvaluateVisibility());
        }
        possiblyEvaluateVisibility() {
          this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 });
        }
        getPaintProperty(e4) {
          return G(e4, wa) ? this._transitionablePaint.getTransition(e4.slice(0, -11)) : this._transitionablePaint.getValue(e4);
        }
        setPaintProperty(e4, t3, i3 = {}) {
          if (null != t3 && this._validate(Ts, `layers.${this.id}.paint.${e4}`, e4, t3, i3))
            return false;
          const r3 = this._transitionablePaint, n4 = r3._properties.properties;
          if (G(e4, wa)) {
            const i4 = e4.slice(0, -11);
            return n4[i4] && r3.setTransition(i4, t3 || void 0), false;
          }
          if (!n4[e4])
            return false;
          const o3 = r3._values[e4], s6 = o3.value.isDataDriven(), a3 = o3.value;
          r3.setValue(e4, t3), this.isConfigDependent = this.isConfigDependent || r3.isConfigDependent, this._handleSpecialPaintPropertyUpdate(e4);
          const l3 = r3._values[e4].value, c3 = l3.isDataDriven(), h3 = G(e4, "pattern") || "line-dasharray" === e4;
          return c3 || s6 || h3 || this._handleOverridablePaintPropertyUpdate(e4, a3, l3);
        }
        _handleSpecialPaintPropertyUpdate(e4) {
        }
        getProgramIds() {
          return null;
        }
        getDefaultProgramParams(e4, t3) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(e4, t3, i3) {
          return false;
        }
        isHidden(e4) {
          return !!(this.minzoom && e4 < this.minzoom) || !!(this.maxzoom && e4 >= this.maxzoom) || "none" === this.visibility;
        }
        updateTransitions(e4) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e4, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e4, t3) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e4, void 0, t3)), this.paint = this._transitioningPaint.possiblyEvaluate(e4, void 0, t3);
        }
        serialize() {
          return Z2({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (e4, t3) => !(void 0 === e4 || "layout" === t3 && !Object.keys(e4).length || "paint" === t3 && !Object.keys(e4).length));
        }
        _validate(e4, t3, i3, r3, n4 = {}) {
          return (!n4 || false !== n4.validate) && Ss(this, e4.call(ms, { key: t3, layerType: this.type, objectKey: i3, value: r3, styleSpec: Pt, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isSky() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        hasShadowPass() {
          return false;
        }
        canCastShadows() {
          return false;
        }
        hasLightBeamPass() {
          return false;
        }
        cutoffRange() {
          return 0;
        }
        resize() {
        }
        isStateDependent() {
          for (const e4 in this.paint._values) {
            const t3 = this.paint.get(e4);
            if (t3 instanceof da && co(t3.property.specification) && ("source" === t3.value.kind || "composite" === t3.value.kind) && t3.value.isStateDependent)
              return true;
          }
          return false;
        }
        compileFilter() {
          this._filterCompiled || (this._featureFilter = Fo(this.filter), this._filterCompiled = true);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = false;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
        getLayerRenderingStats() {
          return this._stats;
        }
        resetLayerRenderingStats() {
          this._stats && (this._stats.numRenderedVerticesInShadowPass = 0, this._stats.numRenderedVerticesInTransparentPass = 0);
        }
      }
      class Ea {
        constructor() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
        }
        isDirty() {
          return this._changed;
        }
        setDirty() {
          this._changed = true;
        }
        getUpdatedSourceCaches() {
          return this._updatedSourceCaches;
        }
        updateSourceCache(e4, t3) {
          this._updatedSourceCaches[e4] = t3, this.setDirty();
        }
        discardSourceCacheUpdate(e4) {
          delete this._updatedSourceCaches[e4];
        }
        updateLayer(e4) {
          const t3 = e4.scope;
          this._updatedLayers[t3] = this._updatedLayers[t3] || /* @__PURE__ */ new Set(), this._updatedLayers[t3].add(e4.id), this.setDirty();
        }
        removeLayer(e4) {
          const t3 = e4.scope;
          this._removedLayers[t3] = this._removedLayers[t3] || {}, this._updatedLayers[t3] = this._updatedLayers[t3] || /* @__PURE__ */ new Set(), this._removedLayers[t3][e4.id] = e4, this._updatedLayers[t3].delete(e4.id), this._updatedPaintProps.delete(e4.fqid), this.setDirty();
        }
        getRemovedLayer(e4) {
          return this._removedLayers[e4.scope] ? this._removedLayers[e4.scope][e4.id] : null;
        }
        discardLayerRemoval(e4) {
          this._removedLayers[e4.scope] && delete this._removedLayers[e4.scope][e4.id];
        }
        getLayerUpdatesByScope() {
          const e4 = {};
          for (const t3 in this._updatedLayers)
            e4[t3] = e4[t3] || {}, e4[t3].updatedIds = Array.from(this._updatedLayers[t3].values());
          for (const t3 in this._removedLayers)
            e4[t3] = e4[t3] || {}, e4[t3].removedIds = Object.keys(this._removedLayers[t3]);
          return e4;
        }
        getUpdatedPaintProperties() {
          return this._updatedPaintProps;
        }
        updatePaintProperties(e4) {
          this._updatedPaintProps.add(e4.fqid), this.setDirty();
        }
        getUpdatedImages() {
          return Array.from(this._updatedImages.values());
        }
        updateImage(e4) {
          this._updatedImages.add(e4), this.setDirty();
        }
        resetUpdatedImages() {
          this._updatedImages.clear();
        }
        reset() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
        }
      }
      const Ma = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Aa {
        constructor(e4, t3) {
          this._structArray = e4, this._pos1 = t3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class Sa {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(e4, t3) {
          return e4._trim(), t3 && (e4.isTransferred = true, t3.add(e4.arrayBuffer)), { length: e4.length, arrayBuffer: e4.arrayBuffer };
        }
        static deserialize(e4) {
          const t3 = Object.create(this.prototype);
          return t3.arrayBuffer = e4.arrayBuffer, t3.length = e4.length, t3.capacity = e4.arrayBuffer.byteLength / t3.bytesPerElement, t3._refreshViews(), t3;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e4) {
          this.reserve(e4), this.length = e4;
        }
        reserve(e4) {
          if (e4 > this.capacity) {
            this.capacity = Math.max(e4, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const t3 = this.uint8;
            this._refreshViews(), t3 && this.uint8.set(t3);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function Ia(e4, t3 = 1) {
        let i3 = 0, r3 = 0;
        return { members: e4.map((e5) => {
          const n4 = Ma[e5.type].BYTES_PER_ELEMENT, o3 = i3 = Ca(i3, Math.max(t3, n4)), s6 = e5.components || 1;
          return r3 = Math.max(r3, n4), i3 += n4 * s6, { name: e5.name, type: e5.type, components: s6, offset: o3 };
        }), size: Ca(i3, Math.max(r3, t3)), alignment: t3 };
      }
      function Ca(e4, t3) {
        return Math.ceil(e4 / t3) * t3;
      }
      class za extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3) {
          const i3 = this.length;
          return this.resize(i3 + 1), this.emplace(i3, e4, t3);
        }
        emplace(e4, t3, i3) {
          const r3 = 2 * e4;
          return this.int16[r3 + 0] = t3, this.int16[r3 + 1] = i3, e4;
        }
      }
      za.prototype.bytesPerElement = 4, Rs(za, "StructArrayLayout2i4");
      class Pa extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, e4, t3, i3);
        }
        emplace(e4, t3, i3, r3) {
          const n4 = 3 * e4;
          return this.int16[n4 + 0] = t3, this.int16[n4 + 1] = i3, this.int16[n4 + 2] = r3, e4;
        }
      }
      Pa.prototype.bytesPerElement = 6, Rs(Pa, "StructArrayLayout3i6");
      class Da extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3) {
          const n4 = this.length;
          return this.resize(n4 + 1), this.emplace(n4, e4, t3, i3, r3);
        }
        emplace(e4, t3, i3, r3, n4) {
          const o3 = 4 * e4;
          return this.int16[o3 + 0] = t3, this.int16[o3 + 1] = i3, this.int16[o3 + 2] = r3, this.int16[o3 + 3] = n4, e4;
        }
      }
      Da.prototype.bytesPerElement = 8, Rs(Da, "StructArrayLayout4i8");
      class Ra extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4) {
          const o3 = this.length;
          return this.resize(o3 + 1), this.emplace(o3, e4, t3, i3, r3, n4);
        }
        emplace(e4, t3, i3, r3, n4, o3) {
          const s6 = 5 * e4;
          return this.int16[s6 + 0] = t3, this.int16[s6 + 1] = i3, this.int16[s6 + 2] = r3, this.int16[s6 + 3] = n4, this.int16[s6 + 4] = o3, e4;
        }
      }
      Ra.prototype.bytesPerElement = 10, Rs(Ra, "StructArrayLayout5i10");
      class La extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.length;
          return this.resize(a3 + 1), this.emplace(a3, e4, t3, i3, r3, n4, o3, s6);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = 6 * e4, c3 = 12 * e4, h3 = 3 * e4;
          return this.int16[l3 + 0] = t3, this.int16[l3 + 1] = i3, this.uint8[c3 + 4] = r3, this.uint8[c3 + 5] = n4, this.uint8[c3 + 6] = o3, this.uint8[c3 + 7] = s6, this.float32[h3 + 2] = a3, e4;
        }
      }
      La.prototype.bytesPerElement = 12, Rs(La, "StructArrayLayout2i4ub1f12");
      class ka extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3) {
          const n4 = this.length;
          return this.resize(n4 + 1), this.emplace(n4, e4, t3, i3, r3);
        }
        emplace(e4, t3, i3, r3, n4) {
          const o3 = 4 * e4;
          return this.float32[o3 + 0] = t3, this.float32[o3 + 1] = i3, this.float32[o3 + 2] = r3, this.float32[o3 + 3] = n4, e4;
        }
      }
      ka.prototype.bytesPerElement = 16, Rs(ka, "StructArrayLayout4f16");
      class Oa extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4) {
          const o3 = this.length;
          return this.resize(o3 + 1), this.emplace(o3, e4, t3, i3, r3, n4);
        }
        emplace(e4, t3, i3, r3, n4, o3) {
          const s6 = 6 * e4, a3 = 3 * e4;
          return this.uint16[s6 + 0] = t3, this.uint16[s6 + 1] = i3, this.uint16[s6 + 2] = r3, this.uint16[s6 + 3] = n4, this.float32[a3 + 2] = o3, e4;
        }
      }
      Oa.prototype.bytesPerElement = 12, Rs(Oa, "StructArrayLayout4ui1f12");
      class Ba extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3) {
          const n4 = this.length;
          return this.resize(n4 + 1), this.emplace(n4, e4, t3, i3, r3);
        }
        emplace(e4, t3, i3, r3, n4) {
          const o3 = 4 * e4;
          return this.uint16[o3 + 0] = t3, this.uint16[o3 + 1] = i3, this.uint16[o3 + 2] = r3, this.uint16[o3 + 3] = n4, e4;
        }
      }
      Ba.prototype.bytesPerElement = 8, Rs(Ba, "StructArrayLayout4ui8");
      class Fa extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3) {
          const s6 = this.length;
          return this.resize(s6 + 1), this.emplace(s6, e4, t3, i3, r3, n4, o3);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = 6 * e4;
          return this.int16[a3 + 0] = t3, this.int16[a3 + 1] = i3, this.int16[a3 + 2] = r3, this.int16[a3 + 3] = n4, this.int16[a3 + 4] = o3, this.int16[a3 + 5] = s6, e4;
        }
      }
      Fa.prototype.bytesPerElement = 12, Rs(Fa, "StructArrayLayout6i12");
      class Na extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3) {
          const d3 = this.length;
          return this.resize(d3 + 1), this.emplace(d3, e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3) {
          const p3 = 12 * e4;
          return this.int16[p3 + 0] = t3, this.int16[p3 + 1] = i3, this.int16[p3 + 2] = r3, this.int16[p3 + 3] = n4, this.uint16[p3 + 4] = o3, this.uint16[p3 + 5] = s6, this.uint16[p3 + 6] = a3, this.uint16[p3 + 7] = l3, this.int16[p3 + 8] = c3, this.int16[p3 + 9] = h3, this.int16[p3 + 10] = u3, this.int16[p3 + 11] = d3, e4;
        }
      }
      Na.prototype.bytesPerElement = 24, Rs(Na, "StructArrayLayout4i4ui4i24");
      class Ua extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3) {
          const s6 = this.length;
          return this.resize(s6 + 1), this.emplace(s6, e4, t3, i3, r3, n4, o3);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = 10 * e4, l3 = 5 * e4;
          return this.int16[a3 + 0] = t3, this.int16[a3 + 1] = i3, this.int16[a3 + 2] = r3, this.float32[l3 + 2] = n4, this.float32[l3 + 3] = o3, this.float32[l3 + 4] = s6, e4;
        }
      }
      Ua.prototype.bytesPerElement = 20, Rs(Ua, "StructArrayLayout3i3f20");
      class Va extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e4) {
          const t3 = this.length;
          return this.resize(t3 + 1), this.emplace(t3, e4);
        }
        emplace(e4, t3) {
          return this.uint32[1 * e4 + 0] = t3, e4;
        }
      }
      Va.prototype.bytesPerElement = 4, Rs(Va, "StructArrayLayout1ul4");
      class ja extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3) {
          const i3 = this.length;
          return this.resize(i3 + 1), this.emplace(i3, e4, t3);
        }
        emplace(e4, t3, i3) {
          const r3 = 2 * e4;
          return this.uint16[r3 + 0] = t3, this.uint16[r3 + 1] = i3, e4;
        }
      }
      ja.prototype.bytesPerElement = 4, Rs(ja, "StructArrayLayout2ui4");
      class Ga extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3) {
          const p3 = this.length;
          return this.resize(p3 + 1), this.emplace(p3, e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3) {
          const f3 = 20 * e4, m3 = 10 * e4;
          return this.int16[f3 + 0] = t3, this.int16[f3 + 1] = i3, this.int16[f3 + 2] = r3, this.int16[f3 + 3] = n4, this.int16[f3 + 4] = o3, this.float32[m3 + 3] = s6, this.float32[m3 + 4] = a3, this.float32[m3 + 5] = l3, this.float32[m3 + 6] = c3, this.int16[f3 + 14] = h3, this.uint32[m3 + 8] = u3, this.uint16[f3 + 18] = d3, this.uint16[f3 + 19] = p3, e4;
        }
      }
      Ga.prototype.bytesPerElement = 40, Rs(Ga, "StructArrayLayout5i4f1i1ul2ui40");
      class qa extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.length;
          return this.resize(a3 + 1), this.emplace(a3, e4, t3, i3, r3, n4, o3, s6);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = 8 * e4;
          return this.int16[l3 + 0] = t3, this.int16[l3 + 1] = i3, this.int16[l3 + 2] = r3, this.int16[l3 + 4] = n4, this.int16[l3 + 5] = o3, this.int16[l3 + 6] = s6, this.int16[l3 + 7] = a3, e4;
        }
      }
      qa.prototype.bytesPerElement = 16, Rs(qa, "StructArrayLayout3i2i2i16");
      class Za extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4) {
          const o3 = this.length;
          return this.resize(o3 + 1), this.emplace(o3, e4, t3, i3, r3, n4);
        }
        emplace(e4, t3, i3, r3, n4, o3) {
          const s6 = 4 * e4, a3 = 8 * e4;
          return this.float32[s6 + 0] = t3, this.float32[s6 + 1] = i3, this.float32[s6 + 2] = r3, this.int16[a3 + 6] = n4, this.int16[a3 + 7] = o3, e4;
        }
      }
      Za.prototype.bytesPerElement = 16, Rs(Za, "StructArrayLayout2f1f2i16");
      class $a extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3) {
          const n4 = this.length;
          return this.resize(n4 + 1), this.emplace(n4, e4, t3, i3, r3);
        }
        emplace(e4, t3, i3, r3, n4) {
          const o3 = 12 * e4, s6 = 3 * e4;
          return this.uint8[o3 + 0] = t3, this.uint8[o3 + 1] = i3, this.float32[s6 + 1] = r3, this.float32[s6 + 2] = n4, e4;
        }
      }
      $a.prototype.bytesPerElement = 12, Rs($a, "StructArrayLayout2ub2f12");
      class Wa extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, e4, t3, i3);
        }
        emplace(e4, t3, i3, r3) {
          const n4 = 3 * e4;
          return this.uint16[n4 + 0] = t3, this.uint16[n4 + 1] = i3, this.uint16[n4 + 2] = r3, e4;
        }
      }
      Wa.prototype.bytesPerElement = 6, Rs(Wa, "StructArrayLayout3ui6");
      class Ha extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3, x3, v3) {
          const b3 = this.length;
          return this.resize(b3 + 1), this.emplace(b3, e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3, x3, v3);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3, x3, v3, b3) {
          const w3 = 30 * e4, T3 = 15 * e4, E3 = 60 * e4;
          return this.int16[w3 + 0] = t3, this.int16[w3 + 1] = i3, this.int16[w3 + 2] = r3, this.float32[T3 + 2] = n4, this.float32[T3 + 3] = o3, this.uint16[w3 + 8] = s6, this.uint16[w3 + 9] = a3, this.uint32[T3 + 5] = l3, this.uint32[T3 + 6] = c3, this.uint32[T3 + 7] = h3, this.uint16[w3 + 16] = u3, this.uint16[w3 + 17] = d3, this.uint16[w3 + 18] = p3, this.float32[T3 + 10] = f3, this.float32[T3 + 11] = m3, this.uint8[E3 + 48] = _3, this.uint8[E3 + 49] = g3, this.uint8[E3 + 50] = y3, this.uint32[T3 + 13] = x3, this.int16[w3 + 28] = v3, this.uint8[E3 + 58] = b3, e4;
        }
      }
      Ha.prototype.bytesPerElement = 60, Rs(Ha, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class Xa extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3, x3, v3, b3, w3, T3, E3, M3, A3, S3, I3, C3, z2, P3) {
          const D2 = this.length;
          return this.resize(D2 + 1), this.emplace(D2, e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3, x3, v3, b3, w3, T3, E3, M3, A3, S3, I3, C3, z2, P3);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3, x3, v3, b3, w3, T3, E3, M3, A3, S3, I3, C3, z2, P3, D2) {
          const R3 = 20 * e4, L3 = 40 * e4, k3 = 80 * e4;
          return this.float32[R3 + 0] = t3, this.float32[R3 + 1] = i3, this.int16[L3 + 4] = r3, this.int16[L3 + 5] = n4, this.int16[L3 + 6] = o3, this.int16[L3 + 7] = s6, this.int16[L3 + 8] = a3, this.int16[L3 + 9] = l3, this.int16[L3 + 10] = c3, this.int16[L3 + 11] = h3, this.int16[L3 + 12] = u3, this.uint16[L3 + 13] = d3, this.uint16[L3 + 14] = p3, this.uint16[L3 + 15] = f3, this.uint16[L3 + 16] = m3, this.uint16[L3 + 17] = _3, this.uint16[L3 + 18] = g3, this.uint16[L3 + 19] = y3, this.uint16[L3 + 20] = x3, this.uint16[L3 + 21] = v3, this.uint16[L3 + 22] = b3, this.uint16[L3 + 23] = w3, this.uint16[L3 + 24] = T3, this.uint16[L3 + 25] = E3, this.uint16[L3 + 26] = M3, this.uint16[L3 + 27] = A3, this.uint32[R3 + 14] = S3, this.float32[R3 + 15] = I3, this.float32[R3 + 16] = C3, this.float32[R3 + 17] = z2, this.float32[R3 + 18] = P3, this.uint8[k3 + 76] = D2, e4;
        }
      }
      Xa.prototype.bytesPerElement = 80, Rs(Xa, "StructArrayLayout2f9i15ui1ul4f1ub80");
      class Ya extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4) {
          const t3 = this.length;
          return this.resize(t3 + 1), this.emplace(t3, e4);
        }
        emplace(e4, t3) {
          return this.float32[1 * e4 + 0] = t3, e4;
        }
      }
      Ya.prototype.bytesPerElement = 4, Rs(Ya, "StructArrayLayout1f4");
      class Ka extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4) {
          const o3 = this.length;
          return this.resize(o3 + 1), this.emplace(o3, e4, t3, i3, r3, n4);
        }
        emplace(e4, t3, i3, r3, n4, o3) {
          const s6 = 5 * e4;
          return this.float32[s6 + 0] = t3, this.float32[s6 + 1] = i3, this.float32[s6 + 2] = r3, this.float32[s6 + 3] = n4, this.float32[s6 + 4] = o3, e4;
        }
      }
      Ka.prototype.bytesPerElement = 20, Rs(Ka, "StructArrayLayout5f20");
      class Ja extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.length;
          return this.resize(a3 + 1), this.emplace(a3, e4, t3, i3, r3, n4, o3, s6);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = 7 * e4;
          return this.float32[l3 + 0] = t3, this.float32[l3 + 1] = i3, this.float32[l3 + 2] = r3, this.float32[l3 + 3] = n4, this.float32[l3 + 4] = o3, this.float32[l3 + 5] = s6, this.float32[l3 + 6] = a3, e4;
        }
      }
      Ja.prototype.bytesPerElement = 28, Rs(Ja, "StructArrayLayout7f28");
      class Qa extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3) {
          const n4 = this.length;
          return this.resize(n4 + 1), this.emplace(n4, e4, t3, i3, r3);
        }
        emplace(e4, t3, i3, r3, n4) {
          const o3 = 6 * e4;
          return this.uint32[3 * e4 + 0] = t3, this.uint16[o3 + 2] = i3, this.uint16[o3 + 3] = r3, this.uint16[o3 + 4] = n4, e4;
        }
      }
      Qa.prototype.bytesPerElement = 12, Rs(Qa, "StructArrayLayout1ul3ui12");
      class el extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e4) {
          const t3 = this.length;
          return this.resize(t3 + 1), this.emplace(t3, e4);
        }
        emplace(e4, t3) {
          return this.uint16[1 * e4 + 0] = t3, e4;
        }
      }
      el.prototype.bytesPerElement = 2, Rs(el, "StructArrayLayout1ui2");
      class tl extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3) {
          const r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, e4, t3, i3);
        }
        emplace(e4, t3, i3, r3) {
          const n4 = 3 * e4;
          return this.float32[n4 + 0] = t3, this.float32[n4 + 1] = i3, this.float32[n4 + 2] = r3, e4;
        }
      }
      tl.prototype.bytesPerElement = 12, Rs(tl, "StructArrayLayout3f12");
      class il extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3) {
          const i3 = this.length;
          return this.resize(i3 + 1), this.emplace(i3, e4, t3);
        }
        emplace(e4, t3, i3) {
          const r3 = 2 * e4;
          return this.float32[r3 + 0] = t3, this.float32[r3 + 1] = i3, e4;
        }
      }
      il.prototype.bytesPerElement = 8, Rs(il, "StructArrayLayout2f8");
      class rl extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3) {
          const _3 = this.length;
          return this.resize(_3 + 1), this.emplace(_3, e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3) {
          const g3 = 16 * e4;
          return this.float32[g3 + 0] = t3, this.float32[g3 + 1] = i3, this.float32[g3 + 2] = r3, this.float32[g3 + 3] = n4, this.float32[g3 + 4] = o3, this.float32[g3 + 5] = s6, this.float32[g3 + 6] = a3, this.float32[g3 + 7] = l3, this.float32[g3 + 8] = c3, this.float32[g3 + 9] = h3, this.float32[g3 + 10] = u3, this.float32[g3 + 11] = d3, this.float32[g3 + 12] = p3, this.float32[g3 + 13] = f3, this.float32[g3 + 14] = m3, this.float32[g3 + 15] = _3, e4;
        }
      }
      rl.prototype.bytesPerElement = 64, Rs(rl, "StructArrayLayout16f64");
      class nl extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.length;
          return this.resize(a3 + 1), this.emplace(a3, e4, t3, i3, r3, n4, o3, s6);
        }
        emplace(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = 10 * e4, c3 = 5 * e4;
          return this.uint16[l3 + 0] = t3, this.uint16[l3 + 1] = i3, this.uint16[l3 + 2] = r3, this.uint16[l3 + 3] = n4, this.float32[c3 + 2] = o3, this.float32[c3 + 3] = s6, this.float32[c3 + 4] = a3, e4;
        }
      }
      nl.prototype.bytesPerElement = 20, Rs(nl, "StructArrayLayout4ui3f20");
      class ol extends Sa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
        }
        emplaceBack(e4) {
          const t3 = this.length;
          return this.resize(t3 + 1), this.emplace(t3, e4);
        }
        emplace(e4, t3) {
          return this.uint8[1 * e4 + 0] = t3, e4;
        }
      }
      ol.prototype.bytesPerElement = 1, Rs(ol, "StructArrayLayout1ub1");
      class sl extends Aa {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      sl.prototype.size = 40;
      class al extends Ga {
        get(e4) {
          return new sl(this, e4);
        }
      }
      Rs(al, "CollisionBoxArray");
      class ll extends Aa {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(e4) {
          this._structArray.uint8[this._pos1 + 49] = e4;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(e4) {
          this._structArray.uint8[this._pos1 + 50] = e4;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(e4) {
          this._structArray.uint32[this._pos4 + 13] = e4;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(e4) {
          this._structArray.uint8[this._pos1 + 58] = e4;
        }
      }
      ll.prototype.size = 60;
      class cl extends Ha {
        get(e4) {
          return new ll(this, e4);
        }
      }
      Rs(cl, "PlacedSymbolArray");
      class hl extends Aa {
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 0];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 14];
        }
        set crossTileID(e4) {
          this._structArray.uint32[this._pos4 + 14] = e4;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 15];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get zOffset() {
          return this._structArray.float32[this._pos4 + 18];
        }
        set zOffset(e4) {
          this._structArray.float32[this._pos4 + 18] = e4;
        }
        get hasIconTextFit() {
          return this._structArray.uint8[this._pos1 + 76];
        }
      }
      hl.prototype.size = 80;
      class ul extends Xa {
        get(e4) {
          return new hl(this, e4);
        }
      }
      Rs(ul, "SymbolInstanceArray");
      class dl extends Ya {
        getoffsetX(e4) {
          return this.float32[1 * e4 + 0];
        }
      }
      Rs(dl, "GlyphOffsetArray");
      class pl extends za {
        getx(e4) {
          return this.int16[2 * e4 + 0];
        }
        gety(e4) {
          return this.int16[2 * e4 + 1];
        }
      }
      Rs(pl, "SymbolLineVertexArray");
      class fl extends Aa {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      fl.prototype.size = 12;
      class ml extends Qa {
        get(e4) {
          return new fl(this, e4);
        }
      }
      Rs(ml, "FeatureIndexArray");
      class _l extends ja {
        geta_centroid_pos0(e4) {
          return this.uint16[2 * e4 + 0];
        }
        geta_centroid_pos1(e4) {
          return this.uint16[2 * e4 + 1];
        }
      }
      Rs(_l, "FillExtrusionCentroidArray");
      const gl = Ia([{ name: "a_pos", components: 2, type: "Int16" }], 4), yl = Ia([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class xl {
        constructor(e4 = []) {
          this.segments = e4;
        }
        _prepareSegment(e4, t3, i3, r3) {
          let n4 = this.segments[this.segments.length - 1];
          return e4 > xl.MAX_VERTEX_ARRAY_LENGTH && H2(`Max vertices per segment is ${xl.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e4}`), (!n4 || n4.vertexLength + e4 > xl.MAX_VERTEX_ARRAY_LENGTH || n4.sortKey !== r3) && (n4 = { vertexOffset: t3, primitiveOffset: i3, vertexLength: 0, primitiveLength: 0 }, void 0 !== r3 && (n4.sortKey = r3), this.segments.push(n4)), n4;
        }
        prepareSegment(e4, t3, i3, r3) {
          return this._prepareSegment(e4, t3.length, i3.length, r3);
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const e4 of this.segments)
            for (const t3 in e4.vaos)
              e4.vaos[t3].destroy();
        }
        static simpleSegment(e4, t3, i3, r3) {
          return new xl([{ vertexOffset: e4, primitiveOffset: t3, vertexLength: i3, primitiveLength: r3, vaos: {}, sortKey: 0 }]);
        }
      }
      function vl(e4, t3) {
        return 256 * (e4 = z(Math.floor(e4), 0, 255)) + z(Math.floor(t3), 0, 255);
      }
      xl.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Rs(xl, "SegmentVector");
      const bl = Ia([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), wl = Ia([{ name: "a_dash", components: 4, type: "Uint16" }]);
      var Tl = { exports: {} }, El = { exports: {} };
      !function(e4) {
        e4.exports = function(e5, t3) {
          var i3, r3, n4, o3, s6, a3, l3, c3;
          for (r3 = e5.length - (i3 = 3 & e5.length), n4 = t3, s6 = 3432918353, a3 = 461845907, c3 = 0; c3 < r3; )
            l3 = 255 & e5.charCodeAt(c3) | (255 & e5.charCodeAt(++c3)) << 8 | (255 & e5.charCodeAt(++c3)) << 16 | (255 & e5.charCodeAt(++c3)) << 24, ++c3, n4 = 27492 + (65535 & (o3 = 5 * (65535 & (n4 = (n4 ^= l3 = (65535 & (l3 = (l3 = (65535 & l3) * s6 + (((l3 >>> 16) * s6 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * a3 + (((l3 >>> 16) * a3 & 65535) << 16) & 4294967295) << 13 | n4 >>> 19)) + ((5 * (n4 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (o3 >>> 16) & 65535) << 16);
          switch (l3 = 0, i3) {
            case 3:
              l3 ^= (255 & e5.charCodeAt(c3 + 2)) << 16;
            case 2:
              l3 ^= (255 & e5.charCodeAt(c3 + 1)) << 8;
            case 1:
              n4 ^= l3 = (65535 & (l3 = (l3 = (65535 & (l3 ^= 255 & e5.charCodeAt(c3))) * s6 + (((l3 >>> 16) * s6 & 65535) << 16) & 4294967295) << 15 | l3 >>> 17)) * a3 + (((l3 >>> 16) * a3 & 65535) << 16) & 4294967295;
          }
          return n4 ^= e5.length, n4 = 2246822507 * (65535 & (n4 ^= n4 >>> 16)) + ((2246822507 * (n4 >>> 16) & 65535) << 16) & 4294967295, n4 = 3266489909 * (65535 & (n4 ^= n4 >>> 13)) + ((3266489909 * (n4 >>> 16) & 65535) << 16) & 4294967295, (n4 ^= n4 >>> 16) >>> 0;
        };
      }(El);
      var Ml = El.exports, Al = { exports: {} };
      !function(e4) {
        e4.exports = function(e5, t3) {
          for (var i3, r3 = e5.length, n4 = t3 ^ r3, o3 = 0; r3 >= 4; )
            i3 = 1540483477 * (65535 & (i3 = 255 & e5.charCodeAt(o3) | (255 & e5.charCodeAt(++o3)) << 8 | (255 & e5.charCodeAt(++o3)) << 16 | (255 & e5.charCodeAt(++o3)) << 24)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), n4 = 1540483477 * (65535 & n4) + ((1540483477 * (n4 >>> 16) & 65535) << 16) ^ (i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 24)) + ((1540483477 * (i3 >>> 16) & 65535) << 16)), r3 -= 4, ++o3;
          switch (r3) {
            case 3:
              n4 ^= (255 & e5.charCodeAt(o3 + 2)) << 16;
            case 2:
              n4 ^= (255 & e5.charCodeAt(o3 + 1)) << 8;
            case 1:
              n4 = 1540483477 * (65535 & (n4 ^= 255 & e5.charCodeAt(o3))) + ((1540483477 * (n4 >>> 16) & 65535) << 16);
          }
          return n4 = 1540483477 * (65535 & (n4 ^= n4 >>> 13)) + ((1540483477 * (n4 >>> 16) & 65535) << 16), (n4 ^= n4 >>> 15) >>> 0;
        };
      }(Al);
      var Sl = Ml, Il = Al.exports;
      Tl.exports = Sl, Tl.exports.murmur3 = Sl, Tl.exports.murmur2 = Il;
      var Cl = d2(Tl.exports);
      class zl {
        constructor() {
          this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
        }
        add(e4, t3, i3, r3) {
          this.ids.push(Pl(e4)), this.positions.push(t3, i3, r3);
        }
        eachPosition(e4, t3) {
          const i3 = Pl(e4);
          let r3 = 0, n4 = this.ids.length - 1;
          for (; r3 < n4; ) {
            const e5 = r3 + n4 >> 1;
            this.ids[e5] >= i3 ? n4 = e5 : r3 = e5 + 1;
          }
          for (; this.ids[r3] === i3; )
            t3(this.positions[3 * r3], this.positions[3 * r3 + 1], this.positions[3 * r3 + 2]), r3++;
        }
        static serialize(e4, t3) {
          const i3 = new Float64Array(e4.ids), r3 = new Uint32Array(e4.positions);
          return Dl(i3, r3, 0, i3.length - 1), t3 && (t3.add(i3.buffer), t3.add(r3.buffer)), { ids: i3, positions: r3 };
        }
        static deserialize(e4) {
          const t3 = new zl();
          let i3;
          t3.ids = e4.ids, t3.positions = e4.positions;
          for (const e5 of t3.ids)
            e5 !== i3 && t3.uniqueIds.push(e5), i3 = e5;
          return t3.indexed = true, t3;
        }
      }
      function Pl(e4) {
        const t3 = +e4;
        return !isNaN(t3) && Number.MIN_SAFE_INTEGER <= t3 && t3 <= Number.MAX_SAFE_INTEGER ? t3 : Cl(String(e4));
      }
      function Dl(e4, t3, i3, r3) {
        for (; i3 < r3; ) {
          const n4 = e4[i3 + r3 >> 1];
          let o3 = i3 - 1, s6 = r3 + 1;
          for (; ; ) {
            do {
              o3++;
            } while (e4[o3] < n4);
            do {
              s6--;
            } while (e4[s6] > n4);
            if (o3 >= s6)
              break;
            Rl(e4, o3, s6), Rl(t3, 3 * o3, 3 * s6), Rl(t3, 3 * o3 + 1, 3 * s6 + 1), Rl(t3, 3 * o3 + 2, 3 * s6 + 2);
          }
          s6 - i3 < r3 - s6 ? (Dl(e4, t3, i3, s6), i3 = s6 + 1) : (Dl(e4, t3, s6 + 1, r3), r3 = s6);
        }
      }
      function Rl(e4, t3, i3) {
        const r3 = e4[t3];
        e4[t3] = e4[i3], e4[i3] = r3;
      }
      Rs(zl, "FeaturePositionMap");
      class Ll {
        constructor(e4) {
          this.gl = e4.gl, this.initialized = false;
        }
        fetchUniformLocation(e4, t3) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e4, t3), this.initialized = true), !!this.location;
        }
      }
      class kl extends Ll {
        constructor(e4) {
          super(e4), this.current = 0;
        }
        set(e4, t3, i3) {
          this.fetchUniformLocation(e4, t3) && this.current !== i3 && (this.current = i3, this.gl.uniform1i(this.location, i3));
        }
      }
      class Ol extends Ll {
        constructor(e4) {
          super(e4), this.current = 0;
        }
        set(e4, t3, i3) {
          this.fetchUniformLocation(e4, t3) && this.current !== i3 && (this.current = i3, this.gl.uniform1f(this.location, i3));
        }
      }
      class Bl extends Ll {
        constructor(e4) {
          super(e4), this.current = [0, 0];
        }
        set(e4, t3, i3) {
          this.fetchUniformLocation(e4, t3) && (i3[0] === this.current[0] && i3[1] === this.current[1] || (this.current = i3, this.gl.uniform2f(this.location, i3[0], i3[1])));
        }
      }
      class Fl extends Ll {
        constructor(e4) {
          super(e4), this.current = [0, 0, 0];
        }
        set(e4, t3, i3) {
          this.fetchUniformLocation(e4, t3) && (i3[0] === this.current[0] && i3[1] === this.current[1] && i3[2] === this.current[2] || (this.current = i3, this.gl.uniform3f(this.location, i3[0], i3[1], i3[2])));
        }
      }
      class Nl extends Ll {
        constructor(e4) {
          super(e4), this.current = [0, 0, 0, 0];
        }
        set(e4, t3, i3) {
          this.fetchUniformLocation(e4, t3) && (i3[0] === this.current[0] && i3[1] === this.current[1] && i3[2] === this.current[2] && i3[3] === this.current[3] || (this.current = i3, this.gl.uniform4f(this.location, i3[0], i3[1], i3[2], i3[3])));
        }
      }
      class Ul extends Ll {
        constructor(e4) {
          super(e4), this.current = hi.transparent;
        }
        set(e4, t3, i3) {
          this.fetchUniformLocation(e4, t3) && (i3.r === this.current.r && i3.g === this.current.g && i3.b === this.current.b && i3.a === this.current.a || (this.current = i3, this.gl.uniform4f(this.location, i3.r, i3.g, i3.b, i3.a)));
        }
      }
      const Vl = new Float32Array(16);
      class jl extends Ll {
        constructor(e4) {
          super(e4), this.current = Vl;
        }
        set(e4, t3, i3) {
          if (this.fetchUniformLocation(e4, t3)) {
            if (i3[12] !== this.current[12] || i3[0] !== this.current[0])
              return this.current = i3, void this.gl.uniformMatrix4fv(this.location, false, i3);
            for (let e5 = 1; e5 < 16; e5++)
              if (i3[e5] !== this.current[e5]) {
                this.current = i3, this.gl.uniformMatrix4fv(this.location, false, i3);
                break;
              }
          }
        }
      }
      const Gl = new Float32Array(9);
      class ql extends Ll {
        constructor(e4) {
          super(e4), this.current = Gl;
        }
        set(e4, t3, i3) {
          if (this.fetchUniformLocation(e4, t3)) {
            for (let e5 = 0; e5 < 9; e5++)
              if (i3[e5] !== this.current[e5]) {
                this.current = i3, this.gl.uniformMatrix3fv(this.location, false, i3);
                break;
              }
          }
        }
      }
      const Zl = new Float32Array(4);
      class $l extends Ll {
        constructor(e4) {
          super(e4), this.current = Zl;
        }
        set(e4, t3, i3) {
          if (this.fetchUniformLocation(e4, t3)) {
            for (let e5 = 0; e5 < 4; e5++)
              if (i3[e5] !== this.current[e5]) {
                this.current = i3, this.gl.uniformMatrix2fv(this.location, false, i3);
                break;
              }
          }
        }
      }
      function Wl(e4) {
        return [vl(255 * e4.r, 255 * e4.g), vl(255 * e4.b, 255 * e4.a)];
      }
      class Hl {
        constructor(e4, t3, i3) {
          this.value = e4, this.uniformNames = t3.map((e5) => `u_${e5}`), this.type = i3;
        }
        setUniform(e4, t3, i3, r3, n4) {
          t3.set(e4, n4, r3.constantOr(this.value));
        }
        getBinding(e4, t3) {
          return "color" === this.type ? new Ul(e4) : new Ol(e4);
        }
      }
      class Xl {
        constructor(e4, t3) {
          this.uniformNames = t3.map((e5) => `u_${e5}`), this.pattern = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(e4) {
          this.pixelRatio = e4.pixelRatio || 1, this.pattern = e4.tl.concat(e4.br);
        }
        setUniform(e4, t3, i3, r3, n4) {
          const o3 = "u_pattern" === n4 || "u_dash" === n4 ? this.pattern : "u_pixel_ratio" === n4 ? this.pixelRatio : null;
          o3 && t3.set(e4, n4, o3);
        }
        getBinding(e4, t3) {
          return "u_pattern" === t3 || "u_dash" === t3 ? new Nl(e4) : new Ol(e4);
        }
      }
      class Yl {
        constructor(e4, t3, i3, r3) {
          this.expression = e4, this.type = i3, this.maxValue = 0, this.paintVertexAttributes = t3.map((e5) => ({ name: `a_${e5}`, type: "Float32", components: "color" === i3 ? 2 : 1, offset: 0 })), this.paintVertexArray = new r3();
        }
        populatePaintArray(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.paintVertexArray.length, l3 = this.expression.evaluate(new oa(0, { brightness: o3 }), t3, {}, n4, r3, s6);
          this.paintVertexArray.resize(e4), this._setPaintValue(a3, e4, l3);
        }
        updatePaintArray(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.expression.evaluate({ zoom: 0, brightness: s6 }, i3, r3, void 0, n4);
          this._setPaintValue(e4, t3, a3);
        }
        _setPaintValue(e4, t3, i3) {
          if ("color" === this.type) {
            const r3 = Wl(i3);
            for (let i4 = e4; i4 < t3; i4++)
              this.paintVertexArray.emplace(i4, r3[0], r3[1]);
          } else {
            for (let r3 = e4; r3 < t3; r3++)
              this.paintVertexArray.emplace(r3, i3);
            this.maxValue = Math.max(this.maxValue, Math.abs(i3));
          }
        }
        upload(e4) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Kl {
        constructor(e4, t3, i3, r3, n4, o3) {
          this.expression = e4, this.uniformNames = t3.map((e5) => `u_${e5}_t`), this.type = i3, this.useIntegerZoom = r3, this.zoom = n4, this.maxValue = 0, this.paintVertexAttributes = t3.map((e5) => ({ name: `a_${e5}`, type: "Float32", components: "color" === i3 ? 4 : 2, offset: 0 })), this.paintVertexArray = new o3();
        }
        populatePaintArray(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.expression.evaluate(new oa(this.zoom, { brightness: o3 }), t3, {}, n4, r3, s6), l3 = this.expression.evaluate(new oa(this.zoom + 1, { brightness: o3 }), t3, {}, n4, r3, s6), c3 = this.paintVertexArray.length;
          this.paintVertexArray.resize(e4), this._setPaintValue(c3, e4, a3, l3);
        }
        updatePaintArray(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.expression.evaluate({ zoom: this.zoom, brightness: s6 }, i3, r3, void 0, n4), l3 = this.expression.evaluate({ zoom: this.zoom + 1, brightness: s6 }, i3, r3, void 0, n4);
          this._setPaintValue(e4, t3, a3, l3);
        }
        _setPaintValue(e4, t3, i3, r3) {
          if ("color" === this.type) {
            const n4 = Wl(i3), o3 = Wl(r3);
            for (let i4 = e4; i4 < t3; i4++)
              this.paintVertexArray.emplace(i4, n4[0], n4[1], o3[0], o3[1]);
          } else {
            for (let n4 = e4; n4 < t3; n4++)
              this.paintVertexArray.emplace(n4, i3, r3);
            this.maxValue = Math.max(this.maxValue, Math.abs(i3), Math.abs(r3));
          }
        }
        upload(e4) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e4, t3, i3, r3, n4) {
          const o3 = this.useIntegerZoom ? Math.floor(i3.zoom) : i3.zoom, s6 = z(this.expression.interpolationFactor(o3, this.zoom, this.zoom + 1), 0, 1);
          t3.set(e4, n4, s6);
        }
        getBinding(e4, t3) {
          return new Ol(e4);
        }
      }
      class Jl {
        constructor(e4, t3, i3, r3, n4) {
          this.expression = e4, this.layerId = n4, this.paintVertexAttributes = ("array" === i3 ? wl : bl).members;
          for (let e5 = 0; e5 < t3.length; ++e5)
            ;
          this.paintVertexArray = new r3();
        }
        populatePaintArray(e4, t3, i3) {
          const r3 = this.paintVertexArray.length;
          this.paintVertexArray.resize(e4), this._setPaintValues(r3, e4, t3.patterns && t3.patterns[this.layerId], i3);
        }
        updatePaintArray(e4, t3, i3, r3, n4, o3, s6) {
          this._setPaintValues(e4, t3, i3.patterns && i3.patterns[this.layerId], o3);
        }
        _setPaintValues(e4, t3, i3, r3) {
          if (!r3 || !i3)
            return;
          const n4 = r3[i3];
          if (!n4)
            return;
          const { tl: o3, br: s6, pixelRatio: a3 } = n4;
          for (let i4 = e4; i4 < t3; i4++)
            this.paintVertexArray.emplace(i4, o3[0], o3[1], s6[0], s6[1], a3);
        }
        upload(e4) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Ql {
        constructor(e4, t3, i3 = () => true) {
          this.binders = {}, this._buffers = [];
          const r3 = [];
          for (const n4 in e4.paint._values) {
            const o3 = e4.paint.get(n4);
            if (!i3(n4))
              continue;
            if (!(o3 instanceof da && co(o3.property.specification)))
              continue;
            const s6 = ic(n4, e4.type), a3 = o3.value, l3 = o3.property.specification.type, c3 = !!o3.property.useIntegerZoom, h3 = "line-dasharray" === n4 || n4.endsWith("pattern"), u3 = "line-dasharray" === n4 && "constant" !== e4.layout.get("line-cap").value.kind;
            if ("constant" !== a3.kind || u3)
              if ("source" === a3.kind || u3 || h3) {
                const t4 = oc(n4, l3, "source");
                this.binders[n4] = h3 ? new Jl(a3, s6, l3, t4, e4.id) : new Yl(a3, s6, l3, t4), r3.push(`/a_${n4}`);
              } else {
                const e5 = oc(n4, l3, "composite");
                this.binders[n4] = new Kl(a3, s6, l3, c3, t3, e5), r3.push(`/z_${n4}`);
              }
            else
              this.binders[n4] = h3 ? new Xl(a3.value, s6) : new Hl(a3.value, s6, l3), r3.push(`/u_${n4}`);
          }
          this.cacheKey = r3.sort().join("");
        }
        getMaxValue(e4) {
          const t3 = this.binders[e4];
          return t3 instanceof Yl || t3 instanceof Kl ? t3.maxValue : 0;
        }
        populatePaintArrays(e4, t3, i3, r3, n4, o3, s6) {
          for (const a3 in this.binders) {
            const l3 = this.binders[a3];
            (l3 instanceof Yl || l3 instanceof Kl || l3 instanceof Jl) && l3.populatePaintArray(e4, t3, i3, r3, n4, o3, s6);
          }
        }
        setConstantPatternPositions(e4) {
          for (const t3 in this.binders) {
            const i3 = this.binders[t3];
            i3 instanceof Xl && i3.setConstantPatternPositions(e4);
          }
        }
        updatePaintArrays(e4, t3, i3, r3, n4, o3, s6, a3) {
          let l3 = false;
          const c3 = Object.keys(e4), h3 = 0 !== c3.length, u3 = h3 ? c3 : t3.uniqueIds;
          for (const c4 in this.binders) {
            const d3 = this.binders[c4];
            if ((d3 instanceof Yl || d3 instanceof Kl || d3 instanceof Jl) && (true === d3.expression.isStateDependent || false === d3.expression.isLightConstant)) {
              const p3 = n4.paint.get(c4);
              d3.expression = p3.value;
              for (const i4 of u3) {
                const n5 = e4[i4.toString()];
                t3.eachPosition(i4, (e5, t4, i5) => {
                  const l4 = r3.feature(e5);
                  d3.updatePaintArray(t4, i5, l4, n5, o3, s6, a3);
                });
              }
              if (!h3)
                for (const t4 of i3.uniqueIds) {
                  const n5 = e4[t4.toString()];
                  i3.eachPosition(t4, (e5, t5, i4) => {
                    const l4 = r3.feature(e5);
                    d3.updatePaintArray(t5, i4, l4, n5, o3, s6, a3);
                  });
                }
              l3 = true;
            }
          }
          return l3;
        }
        defines() {
          const e4 = [];
          for (const t3 in this.binders) {
            const i3 = this.binders[t3];
            (i3 instanceof Hl || i3 instanceof Xl) && e4.push(...i3.uniformNames.map((e5) => `#define HAS_UNIFORM_${e5}`));
          }
          return e4;
        }
        getBinderAttributes() {
          const e4 = [];
          for (const t3 in this.binders) {
            const i3 = this.binders[t3];
            if (i3 instanceof Yl || i3 instanceof Kl || i3 instanceof Jl)
              for (let t4 = 0; t4 < i3.paintVertexAttributes.length; t4++)
                e4.push(i3.paintVertexAttributes[t4].name);
          }
          return e4;
        }
        getBinderUniforms() {
          const e4 = [];
          for (const t3 in this.binders) {
            const i3 = this.binders[t3];
            if (i3 instanceof Hl || i3 instanceof Xl || i3 instanceof Kl)
              for (const t4 of i3.uniformNames)
                e4.push(t4);
          }
          return e4;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e4) {
          const t3 = [];
          for (const i3 in this.binders) {
            const r3 = this.binders[i3];
            if (r3 instanceof Hl || r3 instanceof Xl || r3 instanceof Kl)
              for (const n4 of r3.uniformNames)
                t3.push({ name: n4, property: i3, binding: r3.getBinding(e4, n4) });
          }
          return t3;
        }
        setUniforms(e4, t3, i3, r3, n4) {
          for (const { name: t4, property: o3, binding: s6 } of i3)
            this.binders[o3].setUniform(e4, s6, n4, r3.get(o3), t4);
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const e4 in this.binders) {
            const t3 = this.binders[e4];
            (t3 instanceof Yl || t3 instanceof Kl || t3 instanceof Jl) && t3.paintVertexBuffer && this._buffers.push(t3.paintVertexBuffer);
          }
        }
        upload(e4) {
          for (const t3 in this.binders) {
            const i3 = this.binders[t3];
            (i3 instanceof Yl || i3 instanceof Kl || i3 instanceof Jl) && i3.upload(e4);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const e4 in this.binders) {
            const t3 = this.binders[e4];
            (t3 instanceof Yl || t3 instanceof Kl || t3 instanceof Jl) && t3.destroy();
          }
        }
      }
      class ec {
        constructor(e4, t3, i3 = () => true) {
          this.programConfigurations = {};
          for (const r3 of e4)
            this.programConfigurations[r3.id] = new Ql(r3, t3, i3);
          this.needsUpload = false, this._featureMap = new zl(), this._featureMapWithoutIds = new zl(), this._bufferOffset = 0, this._idlessCounter = 0;
        }
        populatePaintArrays(e4, t3, i3, r3, n4, o3, s6, a3) {
          for (const i4 in this.programConfigurations)
            this.programConfigurations[i4].populatePaintArrays(e4, t3, r3, n4, o3, s6, a3);
          void 0 !== t3.id ? this._featureMap.add(t3.id, i3, this._bufferOffset, e4) : (this._featureMapWithoutIds.add(this._idlessCounter, i3, this._bufferOffset, e4), this._idlessCounter += 1), this._bufferOffset = e4, this.needsUpload = true;
        }
        updatePaintArrays(e4, t3, i3, r3, n4, o3) {
          for (const s6 of i3)
            this.needsUpload = this.programConfigurations[s6.id].updatePaintArrays(e4, this._featureMap, this._featureMapWithoutIds, t3, s6, r3, n4, o3 || 0) || this.needsUpload;
        }
        get(e4) {
          return this.programConfigurations[e4];
        }
        upload(e4) {
          if (this.needsUpload) {
            for (const t3 in this.programConfigurations)
              this.programConfigurations[t3].upload(e4);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const e4 in this.programConfigurations)
            this.programConfigurations[e4].destroy();
        }
      }
      const tc = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
      function ic(e4, t3) {
        return tc[e4] || [e4.replace(`${t3}-`, "").replace(/-/g, "_")];
      }
      const rc = { "line-pattern": { source: Oa, composite: Oa }, "fill-pattern": { source: Oa, composite: Oa }, "fill-extrusion-pattern": { source: Oa, composite: Oa }, "line-dasharray": { source: Ba, composite: Ba } }, nc = { color: { source: il, composite: ka }, number: { source: Ya, composite: il } };
      function oc(e4, t3, i3) {
        const r3 = rc[e4];
        return r3 && r3[i3] || nc[t3][i3];
      }
      Rs(Hl, "ConstantBinder"), Rs(Xl, "PatternConstantBinder"), Rs(Yl, "SourceExpressionBinder"), Rs(Jl, "PatternCompositeBinder"), Rs(Kl, "CompositeExpressionBinder"), Rs(Ql, "ProgramConfiguration", { omit: ["_buffers"] }), Rs(ec, "ProgramConfigurationSet");
      class sc {
        constructor(e4, t3) {
          e4 && (t3 ? this.setSouthWest(e4).setNorthEast(t3) : 4 === e4.length ? this.setSouthWest([e4[0], e4[1]]).setNorthEast([e4[2], e4[3]]) : this.setSouthWest(e4[0]).setNorthEast(e4[1]));
        }
        setNorthEast(e4) {
          return this._ne = e4 instanceof Wd ? new Wd(e4.lng, e4.lat) : Wd.convert(e4), this;
        }
        setSouthWest(e4) {
          return this._sw = e4 instanceof Wd ? new Wd(e4.lng, e4.lat) : Wd.convert(e4), this;
        }
        extend(e4) {
          const t3 = this._sw, i3 = this._ne;
          let r3, n4;
          if (e4 instanceof Wd)
            r3 = e4, n4 = e4;
          else {
            if (!(e4 instanceof sc))
              return Array.isArray(e4) ? 4 === e4.length || e4.every(Array.isArray) ? this.extend(sc.convert(e4)) : this.extend(Wd.convert(e4)) : "object" == typeof e4 && null !== e4 && e4.hasOwnProperty("lat") && (e4.hasOwnProperty("lon") || e4.hasOwnProperty("lng")) ? this.extend(Wd.convert(e4)) : this;
            if (r3 = e4._sw, n4 = e4._ne, !r3 || !n4)
              return this;
          }
          return t3 || i3 ? (t3.lng = Math.min(r3.lng, t3.lng), t3.lat = Math.min(r3.lat, t3.lat), i3.lng = Math.max(n4.lng, i3.lng), i3.lat = Math.max(n4.lat, i3.lat)) : (this._sw = new Wd(r3.lng, r3.lat), this._ne = new Wd(n4.lng, n4.lat)), this;
        }
        getCenter() {
          return new Wd((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new Wd(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new Wd(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e4) {
          const { lng: t3, lat: i3 } = Wd.convert(e4);
          let r3 = this._sw.lng <= t3 && t3 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (r3 = this._sw.lng >= t3 && t3 >= this._ne.lng), this._sw.lat <= i3 && i3 <= this._ne.lat && r3;
        }
        static convert(e4) {
          return !e4 || e4 instanceof sc ? e4 : new sc(e4);
        }
      }
      var ac = {}, lc = {};
      Object.defineProperty(lc, "__esModule", { value: true }), lc.setMatrixArrayType = function(e4) {
        lc.ARRAY_TYPE = hc = e4;
      }, lc.toRadian = function(e4) {
        return e4 * dc;
      }, lc.equals = function(e4, t3) {
        return Math.abs(e4 - t3) <= cc * Math.max(1, Math.abs(e4), Math.abs(t3));
      }, lc.RANDOM = lc.ARRAY_TYPE = lc.EPSILON = void 0;
      var cc = 1e-6;
      lc.EPSILON = cc;
      var hc = "undefined" != typeof Float32Array ? Float32Array : Array;
      lc.ARRAY_TYPE = hc;
      var uc = Math.random;
      lc.RANDOM = uc;
      var dc = Math.PI / 180;
      Math.hypot || (Math.hypot = function() {
        for (var e4 = 0, t3 = arguments.length; t3--; )
          e4 += arguments[t3] * arguments[t3];
        return Math.sqrt(e4);
      });
      var pc = {};
      function fc(e4) {
        return fc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, fc(e4);
      }
      Object.defineProperty(pc, "__esModule", { value: true }), pc.create = function() {
        var e4 = new mc.ARRAY_TYPE(4);
        return mc.ARRAY_TYPE != Float32Array && (e4[1] = 0, e4[2] = 0), e4[0] = 1, e4[3] = 1, e4;
      }, pc.clone = function(e4) {
        var t3 = new mc.ARRAY_TYPE(4);
        return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3;
      }, pc.copy = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4;
      }, pc.identity = function(e4) {
        return e4[0] = 1, e4[1] = 0, e4[2] = 0, e4[3] = 1, e4;
      }, pc.fromValues = function(e4, t3, i3, r3) {
        var n4 = new mc.ARRAY_TYPE(4);
        return n4[0] = e4, n4[1] = t3, n4[2] = i3, n4[3] = r3, n4;
      }, pc.set = function(e4, t3, i3, r3, n4) {
        return e4[0] = t3, e4[1] = i3, e4[2] = r3, e4[3] = n4, e4;
      }, pc.transpose = function(e4, t3) {
        if (e4 === t3) {
          var i3 = t3[1];
          e4[1] = t3[2], e4[2] = i3;
        } else
          e4[0] = t3[0], e4[1] = t3[2], e4[2] = t3[1], e4[3] = t3[3];
        return e4;
      }, pc.invert = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = i3 * o3 - n4 * r3;
        return s6 ? (e4[0] = o3 * (s6 = 1 / s6), e4[1] = -r3 * s6, e4[2] = -n4 * s6, e4[3] = i3 * s6, e4) : null;
      }, pc.adjoint = function(e4, t3) {
        var i3 = t3[0];
        return e4[0] = t3[3], e4[1] = -t3[1], e4[2] = -t3[2], e4[3] = i3, e4;
      }, pc.determinant = function(e4) {
        return e4[0] * e4[3] - e4[2] * e4[1];
      }, pc.multiply = gc, pc.rotate = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = Math.sin(i3), l3 = Math.cos(i3);
        return e4[0] = r3 * l3 + o3 * a3, e4[1] = n4 * l3 + s6 * a3, e4[2] = r3 * -a3 + o3 * l3, e4[3] = n4 * -a3 + s6 * l3, e4;
      }, pc.scale = function(e4, t3, i3) {
        var r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = i3[0], a3 = i3[1];
        return e4[0] = t3[0] * s6, e4[1] = r3 * s6, e4[2] = n4 * a3, e4[3] = o3 * a3, e4;
      }, pc.fromRotation = function(e4, t3) {
        var i3 = Math.sin(t3), r3 = Math.cos(t3);
        return e4[0] = r3, e4[1] = i3, e4[2] = -i3, e4[3] = r3, e4;
      }, pc.fromScaling = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = 0, e4[2] = 0, e4[3] = t3[1], e4;
      }, pc.str = function(e4) {
        return "mat2(" + e4[0] + ", " + e4[1] + ", " + e4[2] + ", " + e4[3] + ")";
      }, pc.frob = function(e4) {
        return Math.hypot(e4[0], e4[1], e4[2], e4[3]);
      }, pc.LDU = function(e4, t3, i3, r3) {
        return e4[2] = r3[2] / r3[0], i3[0] = r3[0], i3[1] = r3[1], i3[3] = r3[3] - e4[2] * i3[1], [e4, t3, i3];
      }, pc.add = function(e4, t3, i3) {
        return e4[0] = t3[0] + i3[0], e4[1] = t3[1] + i3[1], e4[2] = t3[2] + i3[2], e4[3] = t3[3] + i3[3], e4;
      }, pc.subtract = yc, pc.exactEquals = function(e4, t3) {
        return e4[0] === t3[0] && e4[1] === t3[1] && e4[2] === t3[2] && e4[3] === t3[3];
      }, pc.equals = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = e4[2], o3 = e4[3], s6 = t3[0], a3 = t3[1], l3 = t3[2], c3 = t3[3];
        return Math.abs(i3 - s6) <= mc.EPSILON * Math.max(1, Math.abs(i3), Math.abs(s6)) && Math.abs(r3 - a3) <= mc.EPSILON * Math.max(1, Math.abs(r3), Math.abs(a3)) && Math.abs(n4 - l3) <= mc.EPSILON * Math.max(1, Math.abs(n4), Math.abs(l3)) && Math.abs(o3 - c3) <= mc.EPSILON * Math.max(1, Math.abs(o3), Math.abs(c3));
      }, pc.multiplyScalar = function(e4, t3, i3) {
        return e4[0] = t3[0] * i3, e4[1] = t3[1] * i3, e4[2] = t3[2] * i3, e4[3] = t3[3] * i3, e4;
      }, pc.multiplyScalarAndAdd = function(e4, t3, i3, r3) {
        return e4[0] = t3[0] + i3[0] * r3, e4[1] = t3[1] + i3[1] * r3, e4[2] = t3[2] + i3[2] * r3, e4[3] = t3[3] + i3[3] * r3, e4;
      }, pc.sub = pc.mul = void 0;
      var mc = function(e4, t3) {
        if (e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== fc(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = _c(void 0);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }(lc);
      function _c(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (_c = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function gc(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = i3[0], l3 = i3[1], c3 = i3[2], h3 = i3[3];
        return e4[0] = r3 * a3 + o3 * l3, e4[1] = n4 * a3 + s6 * l3, e4[2] = r3 * c3 + o3 * h3, e4[3] = n4 * c3 + s6 * h3, e4;
      }
      function yc(e4, t3, i3) {
        return e4[0] = t3[0] - i3[0], e4[1] = t3[1] - i3[1], e4[2] = t3[2] - i3[2], e4[3] = t3[3] - i3[3], e4;
      }
      pc.mul = gc, pc.sub = yc;
      var xc = {};
      function vc(e4) {
        return vc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, vc(e4);
      }
      Object.defineProperty(xc, "__esModule", { value: true }), xc.create = function() {
        var e4 = new bc.ARRAY_TYPE(6);
        return bc.ARRAY_TYPE != Float32Array && (e4[1] = 0, e4[2] = 0, e4[4] = 0, e4[5] = 0), e4[0] = 1, e4[3] = 1, e4;
      }, xc.clone = function(e4) {
        var t3 = new bc.ARRAY_TYPE(6);
        return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3;
      }, xc.copy = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4;
      }, xc.identity = function(e4) {
        return e4[0] = 1, e4[1] = 0, e4[2] = 0, e4[3] = 1, e4[4] = 0, e4[5] = 0, e4;
      }, xc.fromValues = function(e4, t3, i3, r3, n4, o3) {
        var s6 = new bc.ARRAY_TYPE(6);
        return s6[0] = e4, s6[1] = t3, s6[2] = i3, s6[3] = r3, s6[4] = n4, s6[5] = o3, s6;
      }, xc.set = function(e4, t3, i3, r3, n4, o3, s6) {
        return e4[0] = t3, e4[1] = i3, e4[2] = r3, e4[3] = n4, e4[4] = o3, e4[5] = s6, e4;
      }, xc.invert = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = t3[4], a3 = t3[5], l3 = i3 * o3 - r3 * n4;
        return l3 ? (e4[0] = o3 * (l3 = 1 / l3), e4[1] = -r3 * l3, e4[2] = -n4 * l3, e4[3] = i3 * l3, e4[4] = (n4 * a3 - o3 * s6) * l3, e4[5] = (r3 * s6 - i3 * a3) * l3, e4) : null;
      }, xc.determinant = function(e4) {
        return e4[0] * e4[3] - e4[1] * e4[2];
      }, xc.multiply = Tc, xc.rotate = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = Math.sin(i3), h3 = Math.cos(i3);
        return e4[0] = r3 * h3 + o3 * c3, e4[1] = n4 * h3 + s6 * c3, e4[2] = r3 * -c3 + o3 * h3, e4[3] = n4 * -c3 + s6 * h3, e4[4] = a3, e4[5] = l3, e4;
      }, xc.scale = function(e4, t3, i3) {
        var r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = t3[4], a3 = t3[5], l3 = i3[0], c3 = i3[1];
        return e4[0] = t3[0] * l3, e4[1] = r3 * l3, e4[2] = n4 * c3, e4[3] = o3 * c3, e4[4] = s6, e4[5] = a3, e4;
      }, xc.translate = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = i3[0], h3 = i3[1];
        return e4[0] = r3, e4[1] = n4, e4[2] = o3, e4[3] = s6, e4[4] = r3 * c3 + o3 * h3 + a3, e4[5] = n4 * c3 + s6 * h3 + l3, e4;
      }, xc.fromRotation = function(e4, t3) {
        var i3 = Math.sin(t3), r3 = Math.cos(t3);
        return e4[0] = r3, e4[1] = i3, e4[2] = -i3, e4[3] = r3, e4[4] = 0, e4[5] = 0, e4;
      }, xc.fromScaling = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = 0, e4[2] = 0, e4[3] = t3[1], e4[4] = 0, e4[5] = 0, e4;
      }, xc.fromTranslation = function(e4, t3) {
        return e4[0] = 1, e4[1] = 0, e4[2] = 0, e4[3] = 1, e4[4] = t3[0], e4[5] = t3[1], e4;
      }, xc.str = function(e4) {
        return "mat2d(" + e4[0] + ", " + e4[1] + ", " + e4[2] + ", " + e4[3] + ", " + e4[4] + ", " + e4[5] + ")";
      }, xc.frob = function(e4) {
        return Math.hypot(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], 1);
      }, xc.add = function(e4, t3, i3) {
        return e4[0] = t3[0] + i3[0], e4[1] = t3[1] + i3[1], e4[2] = t3[2] + i3[2], e4[3] = t3[3] + i3[3], e4[4] = t3[4] + i3[4], e4[5] = t3[5] + i3[5], e4;
      }, xc.subtract = Ec, xc.multiplyScalar = function(e4, t3, i3) {
        return e4[0] = t3[0] * i3, e4[1] = t3[1] * i3, e4[2] = t3[2] * i3, e4[3] = t3[3] * i3, e4[4] = t3[4] * i3, e4[5] = t3[5] * i3, e4;
      }, xc.multiplyScalarAndAdd = function(e4, t3, i3, r3) {
        return e4[0] = t3[0] + i3[0] * r3, e4[1] = t3[1] + i3[1] * r3, e4[2] = t3[2] + i3[2] * r3, e4[3] = t3[3] + i3[3] * r3, e4[4] = t3[4] + i3[4] * r3, e4[5] = t3[5] + i3[5] * r3, e4;
      }, xc.exactEquals = function(e4, t3) {
        return e4[0] === t3[0] && e4[1] === t3[1] && e4[2] === t3[2] && e4[3] === t3[3] && e4[4] === t3[4] && e4[5] === t3[5];
      }, xc.equals = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = e4[2], o3 = e4[3], s6 = e4[4], a3 = e4[5], l3 = t3[0], c3 = t3[1], h3 = t3[2], u3 = t3[3], d3 = t3[4], p3 = t3[5];
        return Math.abs(i3 - l3) <= bc.EPSILON * Math.max(1, Math.abs(i3), Math.abs(l3)) && Math.abs(r3 - c3) <= bc.EPSILON * Math.max(1, Math.abs(r3), Math.abs(c3)) && Math.abs(n4 - h3) <= bc.EPSILON * Math.max(1, Math.abs(n4), Math.abs(h3)) && Math.abs(o3 - u3) <= bc.EPSILON * Math.max(1, Math.abs(o3), Math.abs(u3)) && Math.abs(s6 - d3) <= bc.EPSILON * Math.max(1, Math.abs(s6), Math.abs(d3)) && Math.abs(a3 - p3) <= bc.EPSILON * Math.max(1, Math.abs(a3), Math.abs(p3));
      }, xc.sub = xc.mul = void 0;
      var bc = function(e4, t3) {
        if (e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== vc(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = wc(void 0);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }(lc);
      function wc(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (wc = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function Tc(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = i3[0], h3 = i3[1], u3 = i3[2], d3 = i3[3], p3 = i3[4], f3 = i3[5];
        return e4[0] = r3 * c3 + o3 * h3, e4[1] = n4 * c3 + s6 * h3, e4[2] = r3 * u3 + o3 * d3, e4[3] = n4 * u3 + s6 * d3, e4[4] = r3 * p3 + o3 * f3 + a3, e4[5] = n4 * p3 + s6 * f3 + l3, e4;
      }
      function Ec(e4, t3, i3) {
        return e4[0] = t3[0] - i3[0], e4[1] = t3[1] - i3[1], e4[2] = t3[2] - i3[2], e4[3] = t3[3] - i3[3], e4[4] = t3[4] - i3[4], e4[5] = t3[5] - i3[5], e4;
      }
      xc.mul = Tc, xc.sub = Ec;
      var Mc = {};
      function Ac(e4) {
        return Ac = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, Ac(e4);
      }
      Object.defineProperty(Mc, "__esModule", { value: true }), Mc.create = function() {
        var e4 = new Sc.ARRAY_TYPE(9);
        return Sc.ARRAY_TYPE != Float32Array && (e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[5] = 0, e4[6] = 0, e4[7] = 0), e4[0] = 1, e4[4] = 1, e4[8] = 1, e4;
      }, Mc.fromMat4 = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[4], e4[4] = t3[5], e4[5] = t3[6], e4[6] = t3[8], e4[7] = t3[9], e4[8] = t3[10], e4;
      }, Mc.clone = function(e4) {
        var t3 = new Sc.ARRAY_TYPE(9);
        return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3[6] = e4[6], t3[7] = e4[7], t3[8] = e4[8], t3;
      }, Mc.copy = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4[6] = t3[6], e4[7] = t3[7], e4[8] = t3[8], e4;
      }, Mc.fromValues = function(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        var c3 = new Sc.ARRAY_TYPE(9);
        return c3[0] = e4, c3[1] = t3, c3[2] = i3, c3[3] = r3, c3[4] = n4, c3[5] = o3, c3[6] = s6, c3[7] = a3, c3[8] = l3, c3;
      }, Mc.set = function(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3) {
        return e4[0] = t3, e4[1] = i3, e4[2] = r3, e4[3] = n4, e4[4] = o3, e4[5] = s6, e4[6] = a3, e4[7] = l3, e4[8] = c3, e4;
      }, Mc.identity = function(e4) {
        return e4[0] = 1, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 1, e4[5] = 0, e4[6] = 0, e4[7] = 0, e4[8] = 1, e4;
      }, Mc.transpose = function(e4, t3) {
        if (e4 === t3) {
          var i3 = t3[1], r3 = t3[2], n4 = t3[5];
          e4[1] = t3[3], e4[2] = t3[6], e4[3] = i3, e4[5] = t3[7], e4[6] = r3, e4[7] = n4;
        } else
          e4[0] = t3[0], e4[1] = t3[3], e4[2] = t3[6], e4[3] = t3[1], e4[4] = t3[4], e4[5] = t3[7], e4[6] = t3[2], e4[7] = t3[5], e4[8] = t3[8];
        return e4;
      }, Mc.invert = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = t3[4], a3 = t3[5], l3 = t3[6], c3 = t3[7], h3 = t3[8], u3 = h3 * s6 - a3 * c3, d3 = -h3 * o3 + a3 * l3, p3 = c3 * o3 - s6 * l3, f3 = i3 * u3 + r3 * d3 + n4 * p3;
        return f3 ? (e4[0] = u3 * (f3 = 1 / f3), e4[1] = (-h3 * r3 + n4 * c3) * f3, e4[2] = (a3 * r3 - n4 * s6) * f3, e4[3] = d3 * f3, e4[4] = (h3 * i3 - n4 * l3) * f3, e4[5] = (-a3 * i3 + n4 * o3) * f3, e4[6] = p3 * f3, e4[7] = (-c3 * i3 + r3 * l3) * f3, e4[8] = (s6 * i3 - r3 * o3) * f3, e4) : null;
      }, Mc.adjoint = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = t3[4], a3 = t3[5], l3 = t3[6], c3 = t3[7], h3 = t3[8];
        return e4[0] = s6 * h3 - a3 * c3, e4[1] = n4 * c3 - r3 * h3, e4[2] = r3 * a3 - n4 * s6, e4[3] = a3 * l3 - o3 * h3, e4[4] = i3 * h3 - n4 * l3, e4[5] = n4 * o3 - i3 * a3, e4[6] = o3 * c3 - s6 * l3, e4[7] = r3 * l3 - i3 * c3, e4[8] = i3 * s6 - r3 * o3, e4;
      }, Mc.determinant = function(e4) {
        var t3 = e4[3], i3 = e4[4], r3 = e4[5], n4 = e4[6], o3 = e4[7], s6 = e4[8];
        return e4[0] * (s6 * i3 - r3 * o3) + e4[1] * (-s6 * t3 + r3 * n4) + e4[2] * (o3 * t3 - i3 * n4);
      }, Mc.multiply = Cc, Mc.translate = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = t3[8], d3 = i3[0], p3 = i3[1];
        return e4[0] = r3, e4[1] = n4, e4[2] = o3, e4[3] = s6, e4[4] = a3, e4[5] = l3, e4[6] = d3 * r3 + p3 * s6 + c3, e4[7] = d3 * n4 + p3 * a3 + h3, e4[8] = d3 * o3 + p3 * l3 + u3, e4;
      }, Mc.rotate = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = t3[8], d3 = Math.sin(i3), p3 = Math.cos(i3);
        return e4[0] = p3 * r3 + d3 * s6, e4[1] = p3 * n4 + d3 * a3, e4[2] = p3 * o3 + d3 * l3, e4[3] = p3 * s6 - d3 * r3, e4[4] = p3 * a3 - d3 * n4, e4[5] = p3 * l3 - d3 * o3, e4[6] = c3, e4[7] = h3, e4[8] = u3, e4;
      }, Mc.scale = function(e4, t3, i3) {
        var r3 = i3[0], n4 = i3[1];
        return e4[0] = r3 * t3[0], e4[1] = r3 * t3[1], e4[2] = r3 * t3[2], e4[3] = n4 * t3[3], e4[4] = n4 * t3[4], e4[5] = n4 * t3[5], e4[6] = t3[6], e4[7] = t3[7], e4[8] = t3[8], e4;
      }, Mc.fromTranslation = function(e4, t3) {
        return e4[0] = 1, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 1, e4[5] = 0, e4[6] = t3[0], e4[7] = t3[1], e4[8] = 1, e4;
      }, Mc.fromRotation = function(e4, t3) {
        var i3 = Math.sin(t3), r3 = Math.cos(t3);
        return e4[0] = r3, e4[1] = i3, e4[2] = 0, e4[3] = -i3, e4[4] = r3, e4[5] = 0, e4[6] = 0, e4[7] = 0, e4[8] = 1, e4;
      }, Mc.fromScaling = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = t3[1], e4[5] = 0, e4[6] = 0, e4[7] = 0, e4[8] = 1, e4;
      }, Mc.fromMat2d = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = 0, e4[3] = t3[2], e4[4] = t3[3], e4[5] = 0, e4[6] = t3[4], e4[7] = t3[5], e4[8] = 1, e4;
      }, Mc.fromQuat = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = i3 + i3, a3 = r3 + r3, l3 = n4 + n4, c3 = i3 * s6, h3 = r3 * s6, u3 = r3 * a3, d3 = n4 * s6, p3 = n4 * a3, f3 = n4 * l3, m3 = o3 * s6, _3 = o3 * a3, g3 = o3 * l3;
        return e4[0] = 1 - u3 - f3, e4[3] = h3 - g3, e4[6] = d3 + _3, e4[1] = h3 + g3, e4[4] = 1 - c3 - f3, e4[7] = p3 - m3, e4[2] = d3 - _3, e4[5] = p3 + m3, e4[8] = 1 - c3 - u3, e4;
      }, Mc.normalFromMat4 = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = t3[4], a3 = t3[5], l3 = t3[6], c3 = t3[7], h3 = t3[8], u3 = t3[9], d3 = t3[10], p3 = t3[11], f3 = t3[12], m3 = t3[13], _3 = t3[14], g3 = t3[15], y3 = i3 * a3 - r3 * s6, x3 = i3 * l3 - n4 * s6, v3 = i3 * c3 - o3 * s6, b3 = r3 * l3 - n4 * a3, w3 = r3 * c3 - o3 * a3, T3 = n4 * c3 - o3 * l3, E3 = h3 * m3 - u3 * f3, M3 = h3 * _3 - d3 * f3, A3 = h3 * g3 - p3 * f3, S3 = u3 * _3 - d3 * m3, I3 = u3 * g3 - p3 * m3, C3 = d3 * g3 - p3 * _3, z2 = y3 * C3 - x3 * I3 + v3 * S3 + b3 * A3 - w3 * M3 + T3 * E3;
        return z2 ? (e4[0] = (a3 * C3 - l3 * I3 + c3 * S3) * (z2 = 1 / z2), e4[1] = (l3 * A3 - s6 * C3 - c3 * M3) * z2, e4[2] = (s6 * I3 - a3 * A3 + c3 * E3) * z2, e4[3] = (n4 * I3 - r3 * C3 - o3 * S3) * z2, e4[4] = (i3 * C3 - n4 * A3 + o3 * M3) * z2, e4[5] = (r3 * A3 - i3 * I3 - o3 * E3) * z2, e4[6] = (m3 * T3 - _3 * w3 + g3 * b3) * z2, e4[7] = (_3 * v3 - f3 * T3 - g3 * x3) * z2, e4[8] = (f3 * w3 - m3 * v3 + g3 * y3) * z2, e4) : null;
      }, Mc.projection = function(e4, t3, i3) {
        return e4[0] = 2 / t3, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = -2 / i3, e4[5] = 0, e4[6] = -1, e4[7] = 1, e4[8] = 1, e4;
      }, Mc.str = function(e4) {
        return "mat3(" + e4[0] + ", " + e4[1] + ", " + e4[2] + ", " + e4[3] + ", " + e4[4] + ", " + e4[5] + ", " + e4[6] + ", " + e4[7] + ", " + e4[8] + ")";
      }, Mc.frob = function(e4) {
        return Math.hypot(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6], e4[7], e4[8]);
      }, Mc.add = function(e4, t3, i3) {
        return e4[0] = t3[0] + i3[0], e4[1] = t3[1] + i3[1], e4[2] = t3[2] + i3[2], e4[3] = t3[3] + i3[3], e4[4] = t3[4] + i3[4], e4[5] = t3[5] + i3[5], e4[6] = t3[6] + i3[6], e4[7] = t3[7] + i3[7], e4[8] = t3[8] + i3[8], e4;
      }, Mc.subtract = zc, Mc.multiplyScalar = function(e4, t3, i3) {
        return e4[0] = t3[0] * i3, e4[1] = t3[1] * i3, e4[2] = t3[2] * i3, e4[3] = t3[3] * i3, e4[4] = t3[4] * i3, e4[5] = t3[5] * i3, e4[6] = t3[6] * i3, e4[7] = t3[7] * i3, e4[8] = t3[8] * i3, e4;
      }, Mc.multiplyScalarAndAdd = function(e4, t3, i3, r3) {
        return e4[0] = t3[0] + i3[0] * r3, e4[1] = t3[1] + i3[1] * r3, e4[2] = t3[2] + i3[2] * r3, e4[3] = t3[3] + i3[3] * r3, e4[4] = t3[4] + i3[4] * r3, e4[5] = t3[5] + i3[5] * r3, e4[6] = t3[6] + i3[6] * r3, e4[7] = t3[7] + i3[7] * r3, e4[8] = t3[8] + i3[8] * r3, e4;
      }, Mc.exactEquals = function(e4, t3) {
        return e4[0] === t3[0] && e4[1] === t3[1] && e4[2] === t3[2] && e4[3] === t3[3] && e4[4] === t3[4] && e4[5] === t3[5] && e4[6] === t3[6] && e4[7] === t3[7] && e4[8] === t3[8];
      }, Mc.equals = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = e4[2], o3 = e4[3], s6 = e4[4], a3 = e4[5], l3 = e4[6], c3 = e4[7], h3 = e4[8], u3 = t3[0], d3 = t3[1], p3 = t3[2], f3 = t3[3], m3 = t3[4], _3 = t3[5], g3 = t3[6], y3 = t3[7], x3 = t3[8];
        return Math.abs(i3 - u3) <= Sc.EPSILON * Math.max(1, Math.abs(i3), Math.abs(u3)) && Math.abs(r3 - d3) <= Sc.EPSILON * Math.max(1, Math.abs(r3), Math.abs(d3)) && Math.abs(n4 - p3) <= Sc.EPSILON * Math.max(1, Math.abs(n4), Math.abs(p3)) && Math.abs(o3 - f3) <= Sc.EPSILON * Math.max(1, Math.abs(o3), Math.abs(f3)) && Math.abs(s6 - m3) <= Sc.EPSILON * Math.max(1, Math.abs(s6), Math.abs(m3)) && Math.abs(a3 - _3) <= Sc.EPSILON * Math.max(1, Math.abs(a3), Math.abs(_3)) && Math.abs(l3 - g3) <= Sc.EPSILON * Math.max(1, Math.abs(l3), Math.abs(g3)) && Math.abs(c3 - y3) <= Sc.EPSILON * Math.max(1, Math.abs(c3), Math.abs(y3)) && Math.abs(h3 - x3) <= Sc.EPSILON * Math.max(1, Math.abs(h3), Math.abs(x3));
      }, Mc.sub = Mc.mul = void 0;
      var Sc = function(e4, t3) {
        if (e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== Ac(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = Ic(void 0);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }(lc);
      function Ic(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (Ic = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function Cc(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = t3[8], d3 = i3[0], p3 = i3[1], f3 = i3[2], m3 = i3[3], _3 = i3[4], g3 = i3[5], y3 = i3[6], x3 = i3[7], v3 = i3[8];
        return e4[0] = d3 * r3 + p3 * s6 + f3 * c3, e4[1] = d3 * n4 + p3 * a3 + f3 * h3, e4[2] = d3 * o3 + p3 * l3 + f3 * u3, e4[3] = m3 * r3 + _3 * s6 + g3 * c3, e4[4] = m3 * n4 + _3 * a3 + g3 * h3, e4[5] = m3 * o3 + _3 * l3 + g3 * u3, e4[6] = y3 * r3 + x3 * s6 + v3 * c3, e4[7] = y3 * n4 + x3 * a3 + v3 * h3, e4[8] = y3 * o3 + x3 * l3 + v3 * u3, e4;
      }
      function zc(e4, t3, i3) {
        return e4[0] = t3[0] - i3[0], e4[1] = t3[1] - i3[1], e4[2] = t3[2] - i3[2], e4[3] = t3[3] - i3[3], e4[4] = t3[4] - i3[4], e4[5] = t3[5] - i3[5], e4[6] = t3[6] - i3[6], e4[7] = t3[7] - i3[7], e4[8] = t3[8] - i3[8], e4;
      }
      Mc.mul = Cc, Mc.sub = zc;
      var Pc = {};
      function Dc(e4) {
        return Dc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, Dc(e4);
      }
      Object.defineProperty(Pc, "__esModule", { value: true }), Pc.create = function() {
        var e4 = new Rc.ARRAY_TYPE(16);
        return Rc.ARRAY_TYPE != Float32Array && (e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0), e4[0] = 1, e4[5] = 1, e4[10] = 1, e4[15] = 1, e4;
      }, Pc.clone = function(e4) {
        var t3 = new Rc.ARRAY_TYPE(16);
        return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3[6] = e4[6], t3[7] = e4[7], t3[8] = e4[8], t3[9] = e4[9], t3[10] = e4[10], t3[11] = e4[11], t3[12] = e4[12], t3[13] = e4[13], t3[14] = e4[14], t3[15] = e4[15], t3;
      }, Pc.copy = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4[6] = t3[6], e4[7] = t3[7], e4[8] = t3[8], e4[9] = t3[9], e4[10] = t3[10], e4[11] = t3[11], e4[12] = t3[12], e4[13] = t3[13], e4[14] = t3[14], e4[15] = t3[15], e4;
      }, Pc.fromValues = function(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3) {
        var _3 = new Rc.ARRAY_TYPE(16);
        return _3[0] = e4, _3[1] = t3, _3[2] = i3, _3[3] = r3, _3[4] = n4, _3[5] = o3, _3[6] = s6, _3[7] = a3, _3[8] = l3, _3[9] = c3, _3[10] = h3, _3[11] = u3, _3[12] = d3, _3[13] = p3, _3[14] = f3, _3[15] = m3, _3;
      }, Pc.set = function(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3) {
        return e4[0] = t3, e4[1] = i3, e4[2] = r3, e4[3] = n4, e4[4] = o3, e4[5] = s6, e4[6] = a3, e4[7] = l3, e4[8] = c3, e4[9] = h3, e4[10] = u3, e4[11] = d3, e4[12] = p3, e4[13] = f3, e4[14] = m3, e4[15] = _3, e4;
      }, Pc.identity = kc, Pc.transpose = function(e4, t3) {
        if (e4 === t3) {
          var i3 = t3[1], r3 = t3[2], n4 = t3[3], o3 = t3[6], s6 = t3[7], a3 = t3[11];
          e4[1] = t3[4], e4[2] = t3[8], e4[3] = t3[12], e4[4] = i3, e4[6] = t3[9], e4[7] = t3[13], e4[8] = r3, e4[9] = o3, e4[11] = t3[14], e4[12] = n4, e4[13] = s6, e4[14] = a3;
        } else
          e4[0] = t3[0], e4[1] = t3[4], e4[2] = t3[8], e4[3] = t3[12], e4[4] = t3[1], e4[5] = t3[5], e4[6] = t3[9], e4[7] = t3[13], e4[8] = t3[2], e4[9] = t3[6], e4[10] = t3[10], e4[11] = t3[14], e4[12] = t3[3], e4[13] = t3[7], e4[14] = t3[11], e4[15] = t3[15];
        return e4;
      }, Pc.invert = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = t3[4], a3 = t3[5], l3 = t3[6], c3 = t3[7], h3 = t3[8], u3 = t3[9], d3 = t3[10], p3 = t3[11], f3 = t3[12], m3 = t3[13], _3 = t3[14], g3 = t3[15], y3 = i3 * a3 - r3 * s6, x3 = i3 * l3 - n4 * s6, v3 = i3 * c3 - o3 * s6, b3 = r3 * l3 - n4 * a3, w3 = r3 * c3 - o3 * a3, T3 = n4 * c3 - o3 * l3, E3 = h3 * m3 - u3 * f3, M3 = h3 * _3 - d3 * f3, A3 = h3 * g3 - p3 * f3, S3 = u3 * _3 - d3 * m3, I3 = u3 * g3 - p3 * m3, C3 = d3 * g3 - p3 * _3, z2 = y3 * C3 - x3 * I3 + v3 * S3 + b3 * A3 - w3 * M3 + T3 * E3;
        return z2 ? (e4[0] = (a3 * C3 - l3 * I3 + c3 * S3) * (z2 = 1 / z2), e4[1] = (n4 * I3 - r3 * C3 - o3 * S3) * z2, e4[2] = (m3 * T3 - _3 * w3 + g3 * b3) * z2, e4[3] = (d3 * w3 - u3 * T3 - p3 * b3) * z2, e4[4] = (l3 * A3 - s6 * C3 - c3 * M3) * z2, e4[5] = (i3 * C3 - n4 * A3 + o3 * M3) * z2, e4[6] = (_3 * v3 - f3 * T3 - g3 * x3) * z2, e4[7] = (h3 * T3 - d3 * v3 + p3 * x3) * z2, e4[8] = (s6 * I3 - a3 * A3 + c3 * E3) * z2, e4[9] = (r3 * A3 - i3 * I3 - o3 * E3) * z2, e4[10] = (f3 * w3 - m3 * v3 + g3 * y3) * z2, e4[11] = (u3 * v3 - h3 * w3 - p3 * y3) * z2, e4[12] = (a3 * M3 - s6 * S3 - l3 * E3) * z2, e4[13] = (i3 * S3 - r3 * M3 + n4 * E3) * z2, e4[14] = (m3 * x3 - f3 * b3 - _3 * y3) * z2, e4[15] = (h3 * b3 - u3 * x3 + d3 * y3) * z2, e4) : null;
      }, Pc.adjoint = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = t3[4], a3 = t3[5], l3 = t3[6], c3 = t3[7], h3 = t3[8], u3 = t3[9], d3 = t3[10], p3 = t3[11], f3 = t3[12], m3 = t3[13], _3 = t3[14], g3 = t3[15];
        return e4[0] = a3 * (d3 * g3 - p3 * _3) - u3 * (l3 * g3 - c3 * _3) + m3 * (l3 * p3 - c3 * d3), e4[1] = -(r3 * (d3 * g3 - p3 * _3) - u3 * (n4 * g3 - o3 * _3) + m3 * (n4 * p3 - o3 * d3)), e4[2] = r3 * (l3 * g3 - c3 * _3) - a3 * (n4 * g3 - o3 * _3) + m3 * (n4 * c3 - o3 * l3), e4[3] = -(r3 * (l3 * p3 - c3 * d3) - a3 * (n4 * p3 - o3 * d3) + u3 * (n4 * c3 - o3 * l3)), e4[4] = -(s6 * (d3 * g3 - p3 * _3) - h3 * (l3 * g3 - c3 * _3) + f3 * (l3 * p3 - c3 * d3)), e4[5] = i3 * (d3 * g3 - p3 * _3) - h3 * (n4 * g3 - o3 * _3) + f3 * (n4 * p3 - o3 * d3), e4[6] = -(i3 * (l3 * g3 - c3 * _3) - s6 * (n4 * g3 - o3 * _3) + f3 * (n4 * c3 - o3 * l3)), e4[7] = i3 * (l3 * p3 - c3 * d3) - s6 * (n4 * p3 - o3 * d3) + h3 * (n4 * c3 - o3 * l3), e4[8] = s6 * (u3 * g3 - p3 * m3) - h3 * (a3 * g3 - c3 * m3) + f3 * (a3 * p3 - c3 * u3), e4[9] = -(i3 * (u3 * g3 - p3 * m3) - h3 * (r3 * g3 - o3 * m3) + f3 * (r3 * p3 - o3 * u3)), e4[10] = i3 * (a3 * g3 - c3 * m3) - s6 * (r3 * g3 - o3 * m3) + f3 * (r3 * c3 - o3 * a3), e4[11] = -(i3 * (a3 * p3 - c3 * u3) - s6 * (r3 * p3 - o3 * u3) + h3 * (r3 * c3 - o3 * a3)), e4[12] = -(s6 * (u3 * _3 - d3 * m3) - h3 * (a3 * _3 - l3 * m3) + f3 * (a3 * d3 - l3 * u3)), e4[13] = i3 * (u3 * _3 - d3 * m3) - h3 * (r3 * _3 - n4 * m3) + f3 * (r3 * d3 - n4 * u3), e4[14] = -(i3 * (a3 * _3 - l3 * m3) - s6 * (r3 * _3 - n4 * m3) + f3 * (r3 * l3 - n4 * a3)), e4[15] = i3 * (a3 * d3 - l3 * u3) - s6 * (r3 * d3 - n4 * u3) + h3 * (r3 * l3 - n4 * a3), e4;
      }, Pc.determinant = function(e4) {
        var t3 = e4[0], i3 = e4[1], r3 = e4[2], n4 = e4[3], o3 = e4[4], s6 = e4[5], a3 = e4[6], l3 = e4[7], c3 = e4[8], h3 = e4[9], u3 = e4[10], d3 = e4[11], p3 = e4[12], f3 = e4[13], m3 = e4[14], _3 = e4[15];
        return (t3 * s6 - i3 * o3) * (u3 * _3 - d3 * m3) - (t3 * a3 - r3 * o3) * (h3 * _3 - d3 * f3) + (t3 * l3 - n4 * o3) * (h3 * m3 - u3 * f3) + (i3 * a3 - r3 * s6) * (c3 * _3 - d3 * p3) - (i3 * l3 - n4 * s6) * (c3 * m3 - u3 * p3) + (r3 * l3 - n4 * a3) * (c3 * f3 - h3 * p3);
      }, Pc.multiply = Oc, Pc.translate = function(e4, t3, i3) {
        var r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3 = i3[0], _3 = i3[1], g3 = i3[2];
        return t3 === e4 ? (e4[12] = t3[0] * m3 + t3[4] * _3 + t3[8] * g3 + t3[12], e4[13] = t3[1] * m3 + t3[5] * _3 + t3[9] * g3 + t3[13], e4[14] = t3[2] * m3 + t3[6] * _3 + t3[10] * g3 + t3[14], e4[15] = t3[3] * m3 + t3[7] * _3 + t3[11] * g3 + t3[15]) : (n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = t3[8], d3 = t3[9], p3 = t3[10], f3 = t3[11], e4[0] = r3 = t3[0], e4[1] = n4, e4[2] = o3, e4[3] = s6, e4[4] = a3, e4[5] = l3, e4[6] = c3, e4[7] = h3, e4[8] = u3, e4[9] = d3, e4[10] = p3, e4[11] = f3, e4[12] = r3 * m3 + a3 * _3 + u3 * g3 + t3[12], e4[13] = n4 * m3 + l3 * _3 + d3 * g3 + t3[13], e4[14] = o3 * m3 + c3 * _3 + p3 * g3 + t3[14], e4[15] = s6 * m3 + h3 * _3 + f3 * g3 + t3[15]), e4;
      }, Pc.scale = function(e4, t3, i3) {
        var r3 = i3[0], n4 = i3[1], o3 = i3[2];
        return e4[0] = t3[0] * r3, e4[1] = t3[1] * r3, e4[2] = t3[2] * r3, e4[3] = t3[3] * r3, e4[4] = t3[4] * n4, e4[5] = t3[5] * n4, e4[6] = t3[6] * n4, e4[7] = t3[7] * n4, e4[8] = t3[8] * o3, e4[9] = t3[9] * o3, e4[10] = t3[10] * o3, e4[11] = t3[11] * o3, e4[12] = t3[12], e4[13] = t3[13], e4[14] = t3[14], e4[15] = t3[15], e4;
      }, Pc.rotate = function(e4, t3, i3, r3) {
        var n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3, x3, v3, b3, w3, T3, E3, M3, A3, S3, I3 = r3[0], C3 = r3[1], z2 = r3[2], P3 = Math.hypot(I3, C3, z2);
        return P3 < Rc.EPSILON ? null : (I3 *= P3 = 1 / P3, C3 *= P3, z2 *= P3, n4 = Math.sin(i3), o3 = Math.cos(i3), l3 = t3[1], c3 = t3[2], h3 = t3[3], d3 = t3[5], p3 = t3[6], f3 = t3[7], _3 = t3[9], g3 = t3[10], y3 = t3[11], w3 = I3 * C3 * (s6 = 1 - o3) - z2 * n4, T3 = C3 * C3 * s6 + o3, E3 = z2 * C3 * s6 + I3 * n4, M3 = I3 * z2 * s6 + C3 * n4, A3 = C3 * z2 * s6 - I3 * n4, S3 = z2 * z2 * s6 + o3, e4[0] = (a3 = t3[0]) * (x3 = I3 * I3 * s6 + o3) + (u3 = t3[4]) * (v3 = C3 * I3 * s6 + z2 * n4) + (m3 = t3[8]) * (b3 = z2 * I3 * s6 - C3 * n4), e4[1] = l3 * x3 + d3 * v3 + _3 * b3, e4[2] = c3 * x3 + p3 * v3 + g3 * b3, e4[3] = h3 * x3 + f3 * v3 + y3 * b3, e4[4] = a3 * w3 + u3 * T3 + m3 * E3, e4[5] = l3 * w3 + d3 * T3 + _3 * E3, e4[6] = c3 * w3 + p3 * T3 + g3 * E3, e4[7] = h3 * w3 + f3 * T3 + y3 * E3, e4[8] = a3 * M3 + u3 * A3 + m3 * S3, e4[9] = l3 * M3 + d3 * A3 + _3 * S3, e4[10] = c3 * M3 + p3 * A3 + g3 * S3, e4[11] = h3 * M3 + f3 * A3 + y3 * S3, t3 !== e4 && (e4[12] = t3[12], e4[13] = t3[13], e4[14] = t3[14], e4[15] = t3[15]), e4);
      }, Pc.rotateX = function(e4, t3, i3) {
        var r3 = Math.sin(i3), n4 = Math.cos(i3), o3 = t3[4], s6 = t3[5], a3 = t3[6], l3 = t3[7], c3 = t3[8], h3 = t3[9], u3 = t3[10], d3 = t3[11];
        return t3 !== e4 && (e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[12] = t3[12], e4[13] = t3[13], e4[14] = t3[14], e4[15] = t3[15]), e4[4] = o3 * n4 + c3 * r3, e4[5] = s6 * n4 + h3 * r3, e4[6] = a3 * n4 + u3 * r3, e4[7] = l3 * n4 + d3 * r3, e4[8] = c3 * n4 - o3 * r3, e4[9] = h3 * n4 - s6 * r3, e4[10] = u3 * n4 - a3 * r3, e4[11] = d3 * n4 - l3 * r3, e4;
      }, Pc.rotateY = function(e4, t3, i3) {
        var r3 = Math.sin(i3), n4 = Math.cos(i3), o3 = t3[0], s6 = t3[1], a3 = t3[2], l3 = t3[3], c3 = t3[8], h3 = t3[9], u3 = t3[10], d3 = t3[11];
        return t3 !== e4 && (e4[4] = t3[4], e4[5] = t3[5], e4[6] = t3[6], e4[7] = t3[7], e4[12] = t3[12], e4[13] = t3[13], e4[14] = t3[14], e4[15] = t3[15]), e4[0] = o3 * n4 - c3 * r3, e4[1] = s6 * n4 - h3 * r3, e4[2] = a3 * n4 - u3 * r3, e4[3] = l3 * n4 - d3 * r3, e4[8] = o3 * r3 + c3 * n4, e4[9] = s6 * r3 + h3 * n4, e4[10] = a3 * r3 + u3 * n4, e4[11] = l3 * r3 + d3 * n4, e4;
      }, Pc.rotateZ = function(e4, t3, i3) {
        var r3 = Math.sin(i3), n4 = Math.cos(i3), o3 = t3[0], s6 = t3[1], a3 = t3[2], l3 = t3[3], c3 = t3[4], h3 = t3[5], u3 = t3[6], d3 = t3[7];
        return t3 !== e4 && (e4[8] = t3[8], e4[9] = t3[9], e4[10] = t3[10], e4[11] = t3[11], e4[12] = t3[12], e4[13] = t3[13], e4[14] = t3[14], e4[15] = t3[15]), e4[0] = o3 * n4 + c3 * r3, e4[1] = s6 * n4 + h3 * r3, e4[2] = a3 * n4 + u3 * r3, e4[3] = l3 * n4 + d3 * r3, e4[4] = c3 * n4 - o3 * r3, e4[5] = h3 * n4 - s6 * r3, e4[6] = u3 * n4 - a3 * r3, e4[7] = d3 * n4 - l3 * r3, e4;
      }, Pc.fromTranslation = function(e4, t3) {
        return e4[0] = 1, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = 1, e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[10] = 1, e4[11] = 0, e4[12] = t3[0], e4[13] = t3[1], e4[14] = t3[2], e4[15] = 1, e4;
      }, Pc.fromScaling = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = t3[1], e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[10] = t3[2], e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, e4;
      }, Pc.fromRotation = function(e4, t3, i3) {
        var r3, n4, o3, s6 = i3[0], a3 = i3[1], l3 = i3[2], c3 = Math.hypot(s6, a3, l3);
        return c3 < Rc.EPSILON ? null : (s6 *= c3 = 1 / c3, a3 *= c3, l3 *= c3, r3 = Math.sin(t3), n4 = Math.cos(t3), e4[0] = s6 * s6 * (o3 = 1 - n4) + n4, e4[1] = a3 * s6 * o3 + l3 * r3, e4[2] = l3 * s6 * o3 - a3 * r3, e4[3] = 0, e4[4] = s6 * a3 * o3 - l3 * r3, e4[5] = a3 * a3 * o3 + n4, e4[6] = l3 * a3 * o3 + s6 * r3, e4[7] = 0, e4[8] = s6 * l3 * o3 + a3 * r3, e4[9] = a3 * l3 * o3 - s6 * r3, e4[10] = l3 * l3 * o3 + n4, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, e4);
      }, Pc.fromXRotation = function(e4, t3) {
        var i3 = Math.sin(t3), r3 = Math.cos(t3);
        return e4[0] = 1, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = r3, e4[6] = i3, e4[7] = 0, e4[8] = 0, e4[9] = -i3, e4[10] = r3, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, e4;
      }, Pc.fromYRotation = function(e4, t3) {
        var i3 = Math.sin(t3), r3 = Math.cos(t3);
        return e4[0] = r3, e4[1] = 0, e4[2] = -i3, e4[3] = 0, e4[4] = 0, e4[5] = 1, e4[6] = 0, e4[7] = 0, e4[8] = i3, e4[9] = 0, e4[10] = r3, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, e4;
      }, Pc.fromZRotation = function(e4, t3) {
        var i3 = Math.sin(t3), r3 = Math.cos(t3);
        return e4[0] = r3, e4[1] = i3, e4[2] = 0, e4[3] = 0, e4[4] = -i3, e4[5] = r3, e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[10] = 1, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, e4;
      }, Pc.fromRotationTranslation = Bc, Pc.fromQuat2 = function(e4, t3) {
        var i3 = new Rc.ARRAY_TYPE(3), r3 = -t3[0], n4 = -t3[1], o3 = -t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = r3 * r3 + n4 * n4 + o3 * o3 + s6 * s6;
        return u3 > 0 ? (i3[0] = 2 * (a3 * s6 + h3 * r3 + l3 * o3 - c3 * n4) / u3, i3[1] = 2 * (l3 * s6 + h3 * n4 + c3 * r3 - a3 * o3) / u3, i3[2] = 2 * (c3 * s6 + h3 * o3 + a3 * n4 - l3 * r3) / u3) : (i3[0] = 2 * (a3 * s6 + h3 * r3 + l3 * o3 - c3 * n4), i3[1] = 2 * (l3 * s6 + h3 * n4 + c3 * r3 - a3 * o3), i3[2] = 2 * (c3 * s6 + h3 * o3 + a3 * n4 - l3 * r3)), Bc(e4, t3, i3), e4;
      }, Pc.getTranslation = function(e4, t3) {
        return e4[0] = t3[12], e4[1] = t3[13], e4[2] = t3[14], e4;
      }, Pc.getScaling = Fc, Pc.getRotation = function(e4, t3) {
        var i3 = new Rc.ARRAY_TYPE(3);
        Fc(i3, t3);
        var r3 = 1 / i3[0], n4 = 1 / i3[1], o3 = 1 / i3[2], s6 = t3[0] * r3, a3 = t3[1] * n4, l3 = t3[2] * o3, c3 = t3[4] * r3, h3 = t3[5] * n4, u3 = t3[6] * o3, d3 = t3[8] * r3, p3 = t3[9] * n4, f3 = t3[10] * o3, m3 = s6 + h3 + f3, _3 = 0;
        return m3 > 0 ? (_3 = 2 * Math.sqrt(m3 + 1), e4[3] = 0.25 * _3, e4[0] = (u3 - p3) / _3, e4[1] = (d3 - l3) / _3, e4[2] = (a3 - c3) / _3) : s6 > h3 && s6 > f3 ? (_3 = 2 * Math.sqrt(1 + s6 - h3 - f3), e4[3] = (u3 - p3) / _3, e4[0] = 0.25 * _3, e4[1] = (a3 + c3) / _3, e4[2] = (d3 + l3) / _3) : h3 > f3 ? (_3 = 2 * Math.sqrt(1 + h3 - s6 - f3), e4[3] = (d3 - l3) / _3, e4[0] = (a3 + c3) / _3, e4[1] = 0.25 * _3, e4[2] = (u3 + p3) / _3) : (_3 = 2 * Math.sqrt(1 + f3 - s6 - h3), e4[3] = (a3 - c3) / _3, e4[0] = (d3 + l3) / _3, e4[1] = (u3 + p3) / _3, e4[2] = 0.25 * _3), e4;
      }, Pc.fromRotationTranslationScale = function(e4, t3, i3, r3) {
        var n4 = t3[0], o3 = t3[1], s6 = t3[2], a3 = t3[3], l3 = n4 + n4, c3 = o3 + o3, h3 = s6 + s6, u3 = n4 * l3, d3 = n4 * c3, p3 = n4 * h3, f3 = o3 * c3, m3 = o3 * h3, _3 = s6 * h3, g3 = a3 * l3, y3 = a3 * c3, x3 = a3 * h3, v3 = r3[0], b3 = r3[1], w3 = r3[2];
        return e4[0] = (1 - (f3 + _3)) * v3, e4[1] = (d3 + x3) * v3, e4[2] = (p3 - y3) * v3, e4[3] = 0, e4[4] = (d3 - x3) * b3, e4[5] = (1 - (u3 + _3)) * b3, e4[6] = (m3 + g3) * b3, e4[7] = 0, e4[8] = (p3 + y3) * w3, e4[9] = (m3 - g3) * w3, e4[10] = (1 - (u3 + f3)) * w3, e4[11] = 0, e4[12] = i3[0], e4[13] = i3[1], e4[14] = i3[2], e4[15] = 1, e4;
      }, Pc.fromRotationTranslationScaleOrigin = function(e4, t3, i3, r3, n4) {
        var o3 = t3[0], s6 = t3[1], a3 = t3[2], l3 = t3[3], c3 = o3 + o3, h3 = s6 + s6, u3 = a3 + a3, d3 = o3 * c3, p3 = o3 * h3, f3 = o3 * u3, m3 = s6 * h3, _3 = s6 * u3, g3 = a3 * u3, y3 = l3 * c3, x3 = l3 * h3, v3 = l3 * u3, b3 = r3[0], w3 = r3[1], T3 = r3[2], E3 = n4[0], M3 = n4[1], A3 = n4[2], S3 = (1 - (m3 + g3)) * b3, I3 = (p3 + v3) * b3, C3 = (f3 - x3) * b3, z2 = (p3 - v3) * w3, P3 = (1 - (d3 + g3)) * w3, D2 = (_3 + y3) * w3, R3 = (f3 + x3) * T3, L3 = (_3 - y3) * T3, k3 = (1 - (d3 + m3)) * T3;
        return e4[0] = S3, e4[1] = I3, e4[2] = C3, e4[3] = 0, e4[4] = z2, e4[5] = P3, e4[6] = D2, e4[7] = 0, e4[8] = R3, e4[9] = L3, e4[10] = k3, e4[11] = 0, e4[12] = i3[0] + E3 - (S3 * E3 + z2 * M3 + R3 * A3), e4[13] = i3[1] + M3 - (I3 * E3 + P3 * M3 + L3 * A3), e4[14] = i3[2] + A3 - (C3 * E3 + D2 * M3 + k3 * A3), e4[15] = 1, e4;
      }, Pc.fromQuat = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = i3 + i3, a3 = r3 + r3, l3 = n4 + n4, c3 = i3 * s6, h3 = r3 * s6, u3 = r3 * a3, d3 = n4 * s6, p3 = n4 * a3, f3 = n4 * l3, m3 = o3 * s6, _3 = o3 * a3, g3 = o3 * l3;
        return e4[0] = 1 - u3 - f3, e4[1] = h3 + g3, e4[2] = d3 - _3, e4[3] = 0, e4[4] = h3 - g3, e4[5] = 1 - c3 - f3, e4[6] = p3 + m3, e4[7] = 0, e4[8] = d3 + _3, e4[9] = p3 - m3, e4[10] = 1 - c3 - u3, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, e4;
      }, Pc.frustum = function(e4, t3, i3, r3, n4, o3, s6) {
        var a3 = 1 / (i3 - t3), l3 = 1 / (n4 - r3), c3 = 1 / (o3 - s6);
        return e4[0] = 2 * o3 * a3, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = 2 * o3 * l3, e4[6] = 0, e4[7] = 0, e4[8] = (i3 + t3) * a3, e4[9] = (n4 + r3) * l3, e4[10] = (s6 + o3) * c3, e4[11] = -1, e4[12] = 0, e4[13] = 0, e4[14] = s6 * o3 * 2 * c3, e4[15] = 0, e4;
      }, Pc.perspectiveNO = Nc, Pc.perspectiveZO = function(e4, t3, i3, r3, n4) {
        var o3, s6 = 1 / Math.tan(t3 / 2);
        return e4[0] = s6 / i3, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = s6, e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[11] = -1, e4[12] = 0, e4[13] = 0, e4[15] = 0, null != n4 && n4 !== 1 / 0 ? (e4[10] = n4 * (o3 = 1 / (r3 - n4)), e4[14] = n4 * r3 * o3) : (e4[10] = -1, e4[14] = -r3), e4;
      }, Pc.perspectiveFromFieldOfView = function(e4, t3, i3, r3) {
        var n4 = Math.tan(t3.upDegrees * Math.PI / 180), o3 = Math.tan(t3.downDegrees * Math.PI / 180), s6 = Math.tan(t3.leftDegrees * Math.PI / 180), a3 = Math.tan(t3.rightDegrees * Math.PI / 180), l3 = 2 / (s6 + a3), c3 = 2 / (n4 + o3);
        return e4[0] = l3, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = c3, e4[6] = 0, e4[7] = 0, e4[8] = -(s6 - a3) * l3 * 0.5, e4[9] = (n4 - o3) * c3 * 0.5, e4[10] = r3 / (i3 - r3), e4[11] = -1, e4[12] = 0, e4[13] = 0, e4[14] = r3 * i3 / (i3 - r3), e4[15] = 0, e4;
      }, Pc.orthoNO = Uc, Pc.orthoZO = function(e4, t3, i3, r3, n4, o3, s6) {
        var a3 = 1 / (t3 - i3), l3 = 1 / (r3 - n4), c3 = 1 / (o3 - s6);
        return e4[0] = -2 * a3, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = -2 * l3, e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[10] = c3, e4[11] = 0, e4[12] = (t3 + i3) * a3, e4[13] = (n4 + r3) * l3, e4[14] = o3 * c3, e4[15] = 1, e4;
      }, Pc.lookAt = function(e4, t3, i3, r3) {
        var n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3 = t3[0], m3 = t3[1], _3 = t3[2], g3 = r3[0], y3 = r3[1], x3 = r3[2], v3 = i3[0], b3 = i3[1], w3 = i3[2];
        return Math.abs(f3 - v3) < Rc.EPSILON && Math.abs(m3 - b3) < Rc.EPSILON && Math.abs(_3 - w3) < Rc.EPSILON ? kc(e4) : (h3 = f3 - v3, u3 = m3 - b3, d3 = _3 - w3, n4 = y3 * (d3 *= p3 = 1 / Math.hypot(h3, u3, d3)) - x3 * (u3 *= p3), o3 = x3 * (h3 *= p3) - g3 * d3, s6 = g3 * u3 - y3 * h3, (p3 = Math.hypot(n4, o3, s6)) ? (n4 *= p3 = 1 / p3, o3 *= p3, s6 *= p3) : (n4 = 0, o3 = 0, s6 = 0), a3 = u3 * s6 - d3 * o3, l3 = d3 * n4 - h3 * s6, c3 = h3 * o3 - u3 * n4, (p3 = Math.hypot(a3, l3, c3)) ? (a3 *= p3 = 1 / p3, l3 *= p3, c3 *= p3) : (a3 = 0, l3 = 0, c3 = 0), e4[0] = n4, e4[1] = a3, e4[2] = h3, e4[3] = 0, e4[4] = o3, e4[5] = l3, e4[6] = u3, e4[7] = 0, e4[8] = s6, e4[9] = c3, e4[10] = d3, e4[11] = 0, e4[12] = -(n4 * f3 + o3 * m3 + s6 * _3), e4[13] = -(a3 * f3 + l3 * m3 + c3 * _3), e4[14] = -(h3 * f3 + u3 * m3 + d3 * _3), e4[15] = 1, e4);
      }, Pc.targetTo = function(e4, t3, i3, r3) {
        var n4 = t3[0], o3 = t3[1], s6 = t3[2], a3 = r3[0], l3 = r3[1], c3 = r3[2], h3 = n4 - i3[0], u3 = o3 - i3[1], d3 = s6 - i3[2], p3 = h3 * h3 + u3 * u3 + d3 * d3;
        p3 > 0 && (h3 *= p3 = 1 / Math.sqrt(p3), u3 *= p3, d3 *= p3);
        var f3 = l3 * d3 - c3 * u3, m3 = c3 * h3 - a3 * d3, _3 = a3 * u3 - l3 * h3;
        return (p3 = f3 * f3 + m3 * m3 + _3 * _3) > 0 && (f3 *= p3 = 1 / Math.sqrt(p3), m3 *= p3, _3 *= p3), e4[0] = f3, e4[1] = m3, e4[2] = _3, e4[3] = 0, e4[4] = u3 * _3 - d3 * m3, e4[5] = d3 * f3 - h3 * _3, e4[6] = h3 * m3 - u3 * f3, e4[7] = 0, e4[8] = h3, e4[9] = u3, e4[10] = d3, e4[11] = 0, e4[12] = n4, e4[13] = o3, e4[14] = s6, e4[15] = 1, e4;
      }, Pc.str = function(e4) {
        return "mat4(" + e4[0] + ", " + e4[1] + ", " + e4[2] + ", " + e4[3] + ", " + e4[4] + ", " + e4[5] + ", " + e4[6] + ", " + e4[7] + ", " + e4[8] + ", " + e4[9] + ", " + e4[10] + ", " + e4[11] + ", " + e4[12] + ", " + e4[13] + ", " + e4[14] + ", " + e4[15] + ")";
      }, Pc.frob = function(e4) {
        return Math.hypot(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6], e4[7], e4[8], e4[9], e4[10], e4[11], e4[12], e4[13], e4[14], e4[15]);
      }, Pc.add = function(e4, t3, i3) {
        return e4[0] = t3[0] + i3[0], e4[1] = t3[1] + i3[1], e4[2] = t3[2] + i3[2], e4[3] = t3[3] + i3[3], e4[4] = t3[4] + i3[4], e4[5] = t3[5] + i3[5], e4[6] = t3[6] + i3[6], e4[7] = t3[7] + i3[7], e4[8] = t3[8] + i3[8], e4[9] = t3[9] + i3[9], e4[10] = t3[10] + i3[10], e4[11] = t3[11] + i3[11], e4[12] = t3[12] + i3[12], e4[13] = t3[13] + i3[13], e4[14] = t3[14] + i3[14], e4[15] = t3[15] + i3[15], e4;
      }, Pc.subtract = Vc, Pc.multiplyScalar = function(e4, t3, i3) {
        return e4[0] = t3[0] * i3, e4[1] = t3[1] * i3, e4[2] = t3[2] * i3, e4[3] = t3[3] * i3, e4[4] = t3[4] * i3, e4[5] = t3[5] * i3, e4[6] = t3[6] * i3, e4[7] = t3[7] * i3, e4[8] = t3[8] * i3, e4[9] = t3[9] * i3, e4[10] = t3[10] * i3, e4[11] = t3[11] * i3, e4[12] = t3[12] * i3, e4[13] = t3[13] * i3, e4[14] = t3[14] * i3, e4[15] = t3[15] * i3, e4;
      }, Pc.multiplyScalarAndAdd = function(e4, t3, i3, r3) {
        return e4[0] = t3[0] + i3[0] * r3, e4[1] = t3[1] + i3[1] * r3, e4[2] = t3[2] + i3[2] * r3, e4[3] = t3[3] + i3[3] * r3, e4[4] = t3[4] + i3[4] * r3, e4[5] = t3[5] + i3[5] * r3, e4[6] = t3[6] + i3[6] * r3, e4[7] = t3[7] + i3[7] * r3, e4[8] = t3[8] + i3[8] * r3, e4[9] = t3[9] + i3[9] * r3, e4[10] = t3[10] + i3[10] * r3, e4[11] = t3[11] + i3[11] * r3, e4[12] = t3[12] + i3[12] * r3, e4[13] = t3[13] + i3[13] * r3, e4[14] = t3[14] + i3[14] * r3, e4[15] = t3[15] + i3[15] * r3, e4;
      }, Pc.exactEquals = function(e4, t3) {
        return e4[0] === t3[0] && e4[1] === t3[1] && e4[2] === t3[2] && e4[3] === t3[3] && e4[4] === t3[4] && e4[5] === t3[5] && e4[6] === t3[6] && e4[7] === t3[7] && e4[8] === t3[8] && e4[9] === t3[9] && e4[10] === t3[10] && e4[11] === t3[11] && e4[12] === t3[12] && e4[13] === t3[13] && e4[14] === t3[14] && e4[15] === t3[15];
      }, Pc.equals = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = e4[2], o3 = e4[3], s6 = e4[4], a3 = e4[5], l3 = e4[6], c3 = e4[7], h3 = e4[8], u3 = e4[9], d3 = e4[10], p3 = e4[11], f3 = e4[12], m3 = e4[13], _3 = e4[14], g3 = e4[15], y3 = t3[0], x3 = t3[1], v3 = t3[2], b3 = t3[3], w3 = t3[4], T3 = t3[5], E3 = t3[6], M3 = t3[7], A3 = t3[8], S3 = t3[9], I3 = t3[10], C3 = t3[11], z2 = t3[12], P3 = t3[13], D2 = t3[14], R3 = t3[15];
        return Math.abs(i3 - y3) <= Rc.EPSILON * Math.max(1, Math.abs(i3), Math.abs(y3)) && Math.abs(r3 - x3) <= Rc.EPSILON * Math.max(1, Math.abs(r3), Math.abs(x3)) && Math.abs(n4 - v3) <= Rc.EPSILON * Math.max(1, Math.abs(n4), Math.abs(v3)) && Math.abs(o3 - b3) <= Rc.EPSILON * Math.max(1, Math.abs(o3), Math.abs(b3)) && Math.abs(s6 - w3) <= Rc.EPSILON * Math.max(1, Math.abs(s6), Math.abs(w3)) && Math.abs(a3 - T3) <= Rc.EPSILON * Math.max(1, Math.abs(a3), Math.abs(T3)) && Math.abs(l3 - E3) <= Rc.EPSILON * Math.max(1, Math.abs(l3), Math.abs(E3)) && Math.abs(c3 - M3) <= Rc.EPSILON * Math.max(1, Math.abs(c3), Math.abs(M3)) && Math.abs(h3 - A3) <= Rc.EPSILON * Math.max(1, Math.abs(h3), Math.abs(A3)) && Math.abs(u3 - S3) <= Rc.EPSILON * Math.max(1, Math.abs(u3), Math.abs(S3)) && Math.abs(d3 - I3) <= Rc.EPSILON * Math.max(1, Math.abs(d3), Math.abs(I3)) && Math.abs(p3 - C3) <= Rc.EPSILON * Math.max(1, Math.abs(p3), Math.abs(C3)) && Math.abs(f3 - z2) <= Rc.EPSILON * Math.max(1, Math.abs(f3), Math.abs(z2)) && Math.abs(m3 - P3) <= Rc.EPSILON * Math.max(1, Math.abs(m3), Math.abs(P3)) && Math.abs(_3 - D2) <= Rc.EPSILON * Math.max(1, Math.abs(_3), Math.abs(D2)) && Math.abs(g3 - R3) <= Rc.EPSILON * Math.max(1, Math.abs(g3), Math.abs(R3));
      }, Pc.sub = Pc.mul = Pc.ortho = Pc.perspective = void 0;
      var Rc = function(e4, t3) {
        if (e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== Dc(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = Lc(void 0);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }(lc);
      function Lc(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (Lc = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function kc(e4) {
        return e4[0] = 1, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = 1, e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[10] = 1, e4[11] = 0, e4[12] = 0, e4[13] = 0, e4[14] = 0, e4[15] = 1, e4;
      }
      function Oc(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = t3[8], d3 = t3[9], p3 = t3[10], f3 = t3[11], m3 = t3[12], _3 = t3[13], g3 = t3[14], y3 = t3[15], x3 = i3[0], v3 = i3[1], b3 = i3[2], w3 = i3[3];
        return e4[0] = x3 * r3 + v3 * a3 + b3 * u3 + w3 * m3, e4[1] = x3 * n4 + v3 * l3 + b3 * d3 + w3 * _3, e4[2] = x3 * o3 + v3 * c3 + b3 * p3 + w3 * g3, e4[3] = x3 * s6 + v3 * h3 + b3 * f3 + w3 * y3, e4[4] = (x3 = i3[4]) * r3 + (v3 = i3[5]) * a3 + (b3 = i3[6]) * u3 + (w3 = i3[7]) * m3, e4[5] = x3 * n4 + v3 * l3 + b3 * d3 + w3 * _3, e4[6] = x3 * o3 + v3 * c3 + b3 * p3 + w3 * g3, e4[7] = x3 * s6 + v3 * h3 + b3 * f3 + w3 * y3, e4[8] = (x3 = i3[8]) * r3 + (v3 = i3[9]) * a3 + (b3 = i3[10]) * u3 + (w3 = i3[11]) * m3, e4[9] = x3 * n4 + v3 * l3 + b3 * d3 + w3 * _3, e4[10] = x3 * o3 + v3 * c3 + b3 * p3 + w3 * g3, e4[11] = x3 * s6 + v3 * h3 + b3 * f3 + w3 * y3, e4[12] = (x3 = i3[12]) * r3 + (v3 = i3[13]) * a3 + (b3 = i3[14]) * u3 + (w3 = i3[15]) * m3, e4[13] = x3 * n4 + v3 * l3 + b3 * d3 + w3 * _3, e4[14] = x3 * o3 + v3 * c3 + b3 * p3 + w3 * g3, e4[15] = x3 * s6 + v3 * h3 + b3 * f3 + w3 * y3, e4;
      }
      function Bc(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = r3 + r3, l3 = n4 + n4, c3 = o3 + o3, h3 = r3 * a3, u3 = r3 * l3, d3 = r3 * c3, p3 = n4 * l3, f3 = n4 * c3, m3 = o3 * c3, _3 = s6 * a3, g3 = s6 * l3, y3 = s6 * c3;
        return e4[0] = 1 - (p3 + m3), e4[1] = u3 + y3, e4[2] = d3 - g3, e4[3] = 0, e4[4] = u3 - y3, e4[5] = 1 - (h3 + m3), e4[6] = f3 + _3, e4[7] = 0, e4[8] = d3 + g3, e4[9] = f3 - _3, e4[10] = 1 - (h3 + p3), e4[11] = 0, e4[12] = i3[0], e4[13] = i3[1], e4[14] = i3[2], e4[15] = 1, e4;
      }
      function Fc(e4, t3) {
        var i3 = t3[4], r3 = t3[5], n4 = t3[6], o3 = t3[8], s6 = t3[9], a3 = t3[10];
        return e4[0] = Math.hypot(t3[0], t3[1], t3[2]), e4[1] = Math.hypot(i3, r3, n4), e4[2] = Math.hypot(o3, s6, a3), e4;
      }
      function Nc(e4, t3, i3, r3, n4) {
        var o3, s6 = 1 / Math.tan(t3 / 2);
        return e4[0] = s6 / i3, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = s6, e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[11] = -1, e4[12] = 0, e4[13] = 0, e4[15] = 0, null != n4 && n4 !== 1 / 0 ? (e4[10] = (n4 + r3) * (o3 = 1 / (r3 - n4)), e4[14] = 2 * n4 * r3 * o3) : (e4[10] = -1, e4[14] = -2 * r3), e4;
      }
      function Uc(e4, t3, i3, r3, n4, o3, s6) {
        var a3 = 1 / (t3 - i3), l3 = 1 / (r3 - n4), c3 = 1 / (o3 - s6);
        return e4[0] = -2 * a3, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[4] = 0, e4[5] = -2 * l3, e4[6] = 0, e4[7] = 0, e4[8] = 0, e4[9] = 0, e4[10] = 2 * c3, e4[11] = 0, e4[12] = (t3 + i3) * a3, e4[13] = (n4 + r3) * l3, e4[14] = (s6 + o3) * c3, e4[15] = 1, e4;
      }
      function Vc(e4, t3, i3) {
        return e4[0] = t3[0] - i3[0], e4[1] = t3[1] - i3[1], e4[2] = t3[2] - i3[2], e4[3] = t3[3] - i3[3], e4[4] = t3[4] - i3[4], e4[5] = t3[5] - i3[5], e4[6] = t3[6] - i3[6], e4[7] = t3[7] - i3[7], e4[8] = t3[8] - i3[8], e4[9] = t3[9] - i3[9], e4[10] = t3[10] - i3[10], e4[11] = t3[11] - i3[11], e4[12] = t3[12] - i3[12], e4[13] = t3[13] - i3[13], e4[14] = t3[14] - i3[14], e4[15] = t3[15] - i3[15], e4;
      }
      Pc.perspective = Nc, Pc.ortho = Uc, Pc.mul = Oc, Pc.sub = Vc;
      var jc = {}, Gc = {};
      function qc(e4) {
        return qc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, qc(e4);
      }
      Object.defineProperty(Gc, "__esModule", { value: true }), Gc.create = Wc, Gc.clone = function(e4) {
        var t3 = new Zc.ARRAY_TYPE(3);
        return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3;
      }, Gc.length = Hc, Gc.fromValues = function(e4, t3, i3) {
        var r3 = new Zc.ARRAY_TYPE(3);
        return r3[0] = e4, r3[1] = t3, r3[2] = i3, r3;
      }, Gc.copy = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4;
      }, Gc.set = function(e4, t3, i3, r3) {
        return e4[0] = t3, e4[1] = i3, e4[2] = r3, e4;
      }, Gc.add = function(e4, t3, i3) {
        return e4[0] = t3[0] + i3[0], e4[1] = t3[1] + i3[1], e4[2] = t3[2] + i3[2], e4;
      }, Gc.subtract = Xc, Gc.multiply = Yc, Gc.divide = Kc, Gc.ceil = function(e4, t3) {
        return e4[0] = Math.ceil(t3[0]), e4[1] = Math.ceil(t3[1]), e4[2] = Math.ceil(t3[2]), e4;
      }, Gc.floor = function(e4, t3) {
        return e4[0] = Math.floor(t3[0]), e4[1] = Math.floor(t3[1]), e4[2] = Math.floor(t3[2]), e4;
      }, Gc.min = function(e4, t3, i3) {
        return e4[0] = Math.min(t3[0], i3[0]), e4[1] = Math.min(t3[1], i3[1]), e4[2] = Math.min(t3[2], i3[2]), e4;
      }, Gc.max = function(e4, t3, i3) {
        return e4[0] = Math.max(t3[0], i3[0]), e4[1] = Math.max(t3[1], i3[1]), e4[2] = Math.max(t3[2], i3[2]), e4;
      }, Gc.round = function(e4, t3) {
        return e4[0] = Math.round(t3[0]), e4[1] = Math.round(t3[1]), e4[2] = Math.round(t3[2]), e4;
      }, Gc.scale = function(e4, t3, i3) {
        return e4[0] = t3[0] * i3, e4[1] = t3[1] * i3, e4[2] = t3[2] * i3, e4;
      }, Gc.scaleAndAdd = function(e4, t3, i3, r3) {
        return e4[0] = t3[0] + i3[0] * r3, e4[1] = t3[1] + i3[1] * r3, e4[2] = t3[2] + i3[2] * r3, e4;
      }, Gc.distance = Jc, Gc.squaredDistance = Qc, Gc.squaredLength = eh, Gc.negate = function(e4, t3) {
        return e4[0] = -t3[0], e4[1] = -t3[1], e4[2] = -t3[2], e4;
      }, Gc.inverse = function(e4, t3) {
        return e4[0] = 1 / t3[0], e4[1] = 1 / t3[1], e4[2] = 1 / t3[2], e4;
      }, Gc.normalize = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = i3 * i3 + r3 * r3 + n4 * n4;
        return o3 > 0 && (o3 = 1 / Math.sqrt(o3)), e4[0] = t3[0] * o3, e4[1] = t3[1] * o3, e4[2] = t3[2] * o3, e4;
      }, Gc.dot = th, Gc.cross = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = i3[0], a3 = i3[1], l3 = i3[2];
        return e4[0] = n4 * l3 - o3 * a3, e4[1] = o3 * s6 - r3 * l3, e4[2] = r3 * a3 - n4 * s6, e4;
      }, Gc.lerp = function(e4, t3, i3, r3) {
        var n4 = t3[0], o3 = t3[1], s6 = t3[2];
        return e4[0] = n4 + r3 * (i3[0] - n4), e4[1] = o3 + r3 * (i3[1] - o3), e4[2] = s6 + r3 * (i3[2] - s6), e4;
      }, Gc.hermite = function(e4, t3, i3, r3, n4, o3) {
        var s6 = o3 * o3, a3 = s6 * (2 * o3 - 3) + 1, l3 = s6 * (o3 - 2) + o3, c3 = s6 * (o3 - 1), h3 = s6 * (3 - 2 * o3);
        return e4[0] = t3[0] * a3 + i3[0] * l3 + r3[0] * c3 + n4[0] * h3, e4[1] = t3[1] * a3 + i3[1] * l3 + r3[1] * c3 + n4[1] * h3, e4[2] = t3[2] * a3 + i3[2] * l3 + r3[2] * c3 + n4[2] * h3, e4;
      }, Gc.bezier = function(e4, t3, i3, r3, n4, o3) {
        var s6 = 1 - o3, a3 = s6 * s6, l3 = o3 * o3, c3 = a3 * s6, h3 = 3 * o3 * a3, u3 = 3 * l3 * s6, d3 = l3 * o3;
        return e4[0] = t3[0] * c3 + i3[0] * h3 + r3[0] * u3 + n4[0] * d3, e4[1] = t3[1] * c3 + i3[1] * h3 + r3[1] * u3 + n4[1] * d3, e4[2] = t3[2] * c3 + i3[2] * h3 + r3[2] * u3 + n4[2] * d3, e4;
      }, Gc.random = function(e4, t3) {
        t3 = t3 || 1;
        var i3 = 2 * Zc.RANDOM() * Math.PI, r3 = 2 * Zc.RANDOM() - 1, n4 = Math.sqrt(1 - r3 * r3) * t3;
        return e4[0] = Math.cos(i3) * n4, e4[1] = Math.sin(i3) * n4, e4[2] = r3 * t3, e4;
      }, Gc.transformMat4 = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = i3[3] * r3 + i3[7] * n4 + i3[11] * o3 + i3[15];
        return e4[0] = (i3[0] * r3 + i3[4] * n4 + i3[8] * o3 + i3[12]) / (s6 = s6 || 1), e4[1] = (i3[1] * r3 + i3[5] * n4 + i3[9] * o3 + i3[13]) / s6, e4[2] = (i3[2] * r3 + i3[6] * n4 + i3[10] * o3 + i3[14]) / s6, e4;
      }, Gc.transformMat3 = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2];
        return e4[0] = r3 * i3[0] + n4 * i3[3] + o3 * i3[6], e4[1] = r3 * i3[1] + n4 * i3[4] + o3 * i3[7], e4[2] = r3 * i3[2] + n4 * i3[5] + o3 * i3[8], e4;
      }, Gc.transformQuat = function(e4, t3, i3) {
        var r3 = i3[0], n4 = i3[1], o3 = i3[2], s6 = t3[0], a3 = t3[1], l3 = t3[2], c3 = n4 * l3 - o3 * a3, h3 = o3 * s6 - r3 * l3, u3 = r3 * a3 - n4 * s6, d3 = n4 * u3 - o3 * h3, p3 = o3 * c3 - r3 * u3, f3 = r3 * h3 - n4 * c3, m3 = 2 * i3[3];
        return h3 *= m3, u3 *= m3, p3 *= 2, f3 *= 2, e4[0] = s6 + (c3 *= m3) + (d3 *= 2), e4[1] = a3 + h3 + p3, e4[2] = l3 + u3 + f3, e4;
      }, Gc.rotateX = function(e4, t3, i3, r3) {
        var n4 = [], o3 = [];
        return n4[0] = t3[0] - i3[0], n4[1] = t3[1] - i3[1], n4[2] = t3[2] - i3[2], o3[0] = n4[0], o3[1] = n4[1] * Math.cos(r3) - n4[2] * Math.sin(r3), o3[2] = n4[1] * Math.sin(r3) + n4[2] * Math.cos(r3), e4[0] = o3[0] + i3[0], e4[1] = o3[1] + i3[1], e4[2] = o3[2] + i3[2], e4;
      }, Gc.rotateY = function(e4, t3, i3, r3) {
        var n4 = [], o3 = [];
        return n4[0] = t3[0] - i3[0], n4[1] = t3[1] - i3[1], n4[2] = t3[2] - i3[2], o3[0] = n4[2] * Math.sin(r3) + n4[0] * Math.cos(r3), o3[1] = n4[1], o3[2] = n4[2] * Math.cos(r3) - n4[0] * Math.sin(r3), e4[0] = o3[0] + i3[0], e4[1] = o3[1] + i3[1], e4[2] = o3[2] + i3[2], e4;
      }, Gc.rotateZ = function(e4, t3, i3, r3) {
        var n4 = [], o3 = [];
        return n4[0] = t3[0] - i3[0], n4[1] = t3[1] - i3[1], n4[2] = t3[2] - i3[2], o3[0] = n4[0] * Math.cos(r3) - n4[1] * Math.sin(r3), o3[1] = n4[0] * Math.sin(r3) + n4[1] * Math.cos(r3), o3[2] = n4[2], e4[0] = o3[0] + i3[0], e4[1] = o3[1] + i3[1], e4[2] = o3[2] + i3[2], e4;
      }, Gc.angle = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = e4[2], o3 = t3[0], s6 = t3[1], a3 = t3[2], l3 = Math.sqrt(i3 * i3 + r3 * r3 + n4 * n4) * Math.sqrt(o3 * o3 + s6 * s6 + a3 * a3), c3 = l3 && th(e4, t3) / l3;
        return Math.acos(Math.min(Math.max(c3, -1), 1));
      }, Gc.zero = function(e4) {
        return e4[0] = 0, e4[1] = 0, e4[2] = 0, e4;
      }, Gc.str = function(e4) {
        return "vec3(" + e4[0] + ", " + e4[1] + ", " + e4[2] + ")";
      }, Gc.exactEquals = function(e4, t3) {
        return e4[0] === t3[0] && e4[1] === t3[1] && e4[2] === t3[2];
      }, Gc.equals = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = e4[2], o3 = t3[0], s6 = t3[1], a3 = t3[2];
        return Math.abs(i3 - o3) <= Zc.EPSILON * Math.max(1, Math.abs(i3), Math.abs(o3)) && Math.abs(r3 - s6) <= Zc.EPSILON * Math.max(1, Math.abs(r3), Math.abs(s6)) && Math.abs(n4 - a3) <= Zc.EPSILON * Math.max(1, Math.abs(n4), Math.abs(a3));
      }, Gc.forEach = Gc.sqrLen = Gc.len = Gc.sqrDist = Gc.dist = Gc.div = Gc.mul = Gc.sub = void 0;
      var Zc = function(e4, t3) {
        if (e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== qc(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = $c(void 0);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }(lc);
      function $c(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return ($c = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function Wc() {
        var e4 = new Zc.ARRAY_TYPE(3);
        return Zc.ARRAY_TYPE != Float32Array && (e4[0] = 0, e4[1] = 0, e4[2] = 0), e4;
      }
      function Hc(e4) {
        return Math.hypot(e4[0], e4[1], e4[2]);
      }
      function Xc(e4, t3, i3) {
        return e4[0] = t3[0] - i3[0], e4[1] = t3[1] - i3[1], e4[2] = t3[2] - i3[2], e4;
      }
      function Yc(e4, t3, i3) {
        return e4[0] = t3[0] * i3[0], e4[1] = t3[1] * i3[1], e4[2] = t3[2] * i3[2], e4;
      }
      function Kc(e4, t3, i3) {
        return e4[0] = t3[0] / i3[0], e4[1] = t3[1] / i3[1], e4[2] = t3[2] / i3[2], e4;
      }
      function Jc(e4, t3) {
        return Math.hypot(t3[0] - e4[0], t3[1] - e4[1], t3[2] - e4[2]);
      }
      function Qc(e4, t3) {
        var i3 = t3[0] - e4[0], r3 = t3[1] - e4[1], n4 = t3[2] - e4[2];
        return i3 * i3 + r3 * r3 + n4 * n4;
      }
      function eh(e4) {
        var t3 = e4[0], i3 = e4[1], r3 = e4[2];
        return t3 * t3 + i3 * i3 + r3 * r3;
      }
      function th(e4, t3) {
        return e4[0] * t3[0] + e4[1] * t3[1] + e4[2] * t3[2];
      }
      Gc.sub = Xc, Gc.mul = Yc, Gc.div = Kc, Gc.dist = Jc, Gc.sqrDist = Qc, Gc.len = Hc, Gc.sqrLen = eh;
      var ih, rh = (ih = Wc(), function(e4, t3, i3, r3, n4, o3) {
        var s6, a3;
        for (t3 || (t3 = 3), i3 || (i3 = 0), a3 = r3 ? Math.min(r3 * t3 + i3, e4.length) : e4.length, s6 = i3; s6 < a3; s6 += t3)
          ih[0] = e4[s6], ih[1] = e4[s6 + 1], ih[2] = e4[s6 + 2], n4(ih, ih, o3), e4[s6] = ih[0], e4[s6 + 1] = ih[1], e4[s6 + 2] = ih[2];
        return e4;
      });
      Gc.forEach = rh;
      var nh = {};
      function oh(e4) {
        return oh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, oh(e4);
      }
      Object.defineProperty(nh, "__esModule", { value: true }), nh.create = lh, nh.clone = function(e4) {
        var t3 = new sh.ARRAY_TYPE(4);
        return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3;
      }, nh.fromValues = function(e4, t3, i3, r3) {
        var n4 = new sh.ARRAY_TYPE(4);
        return n4[0] = e4, n4[1] = t3, n4[2] = i3, n4[3] = r3, n4;
      }, nh.copy = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4;
      }, nh.set = function(e4, t3, i3, r3, n4) {
        return e4[0] = t3, e4[1] = i3, e4[2] = r3, e4[3] = n4, e4;
      }, nh.add = function(e4, t3, i3) {
        return e4[0] = t3[0] + i3[0], e4[1] = t3[1] + i3[1], e4[2] = t3[2] + i3[2], e4[3] = t3[3] + i3[3], e4;
      }, nh.subtract = ch, nh.multiply = hh, nh.divide = uh, nh.ceil = function(e4, t3) {
        return e4[0] = Math.ceil(t3[0]), e4[1] = Math.ceil(t3[1]), e4[2] = Math.ceil(t3[2]), e4[3] = Math.ceil(t3[3]), e4;
      }, nh.floor = function(e4, t3) {
        return e4[0] = Math.floor(t3[0]), e4[1] = Math.floor(t3[1]), e4[2] = Math.floor(t3[2]), e4[3] = Math.floor(t3[3]), e4;
      }, nh.min = function(e4, t3, i3) {
        return e4[0] = Math.min(t3[0], i3[0]), e4[1] = Math.min(t3[1], i3[1]), e4[2] = Math.min(t3[2], i3[2]), e4[3] = Math.min(t3[3], i3[3]), e4;
      }, nh.max = function(e4, t3, i3) {
        return e4[0] = Math.max(t3[0], i3[0]), e4[1] = Math.max(t3[1], i3[1]), e4[2] = Math.max(t3[2], i3[2]), e4[3] = Math.max(t3[3], i3[3]), e4;
      }, nh.round = function(e4, t3) {
        return e4[0] = Math.round(t3[0]), e4[1] = Math.round(t3[1]), e4[2] = Math.round(t3[2]), e4[3] = Math.round(t3[3]), e4;
      }, nh.scale = function(e4, t3, i3) {
        return e4[0] = t3[0] * i3, e4[1] = t3[1] * i3, e4[2] = t3[2] * i3, e4[3] = t3[3] * i3, e4;
      }, nh.scaleAndAdd = function(e4, t3, i3, r3) {
        return e4[0] = t3[0] + i3[0] * r3, e4[1] = t3[1] + i3[1] * r3, e4[2] = t3[2] + i3[2] * r3, e4[3] = t3[3] + i3[3] * r3, e4;
      }, nh.distance = dh, nh.squaredDistance = ph, nh.length = fh, nh.squaredLength = mh, nh.negate = function(e4, t3) {
        return e4[0] = -t3[0], e4[1] = -t3[1], e4[2] = -t3[2], e4[3] = -t3[3], e4;
      }, nh.inverse = function(e4, t3) {
        return e4[0] = 1 / t3[0], e4[1] = 1 / t3[1], e4[2] = 1 / t3[2], e4[3] = 1 / t3[3], e4;
      }, nh.normalize = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = i3 * i3 + r3 * r3 + n4 * n4 + o3 * o3;
        return s6 > 0 && (s6 = 1 / Math.sqrt(s6)), e4[0] = i3 * s6, e4[1] = r3 * s6, e4[2] = n4 * s6, e4[3] = o3 * s6, e4;
      }, nh.dot = function(e4, t3) {
        return e4[0] * t3[0] + e4[1] * t3[1] + e4[2] * t3[2] + e4[3] * t3[3];
      }, nh.cross = function(e4, t3, i3, r3) {
        var n4 = i3[0] * r3[1] - i3[1] * r3[0], o3 = i3[0] * r3[2] - i3[2] * r3[0], s6 = i3[0] * r3[3] - i3[3] * r3[0], a3 = i3[1] * r3[2] - i3[2] * r3[1], l3 = i3[1] * r3[3] - i3[3] * r3[1], c3 = i3[2] * r3[3] - i3[3] * r3[2], h3 = t3[0], u3 = t3[1], d3 = t3[2], p3 = t3[3];
        return e4[0] = u3 * c3 - d3 * l3 + p3 * a3, e4[1] = -h3 * c3 + d3 * s6 - p3 * o3, e4[2] = h3 * l3 - u3 * s6 + p3 * n4, e4[3] = -h3 * a3 + u3 * o3 - d3 * n4, e4;
      }, nh.lerp = function(e4, t3, i3, r3) {
        var n4 = t3[0], o3 = t3[1], s6 = t3[2], a3 = t3[3];
        return e4[0] = n4 + r3 * (i3[0] - n4), e4[1] = o3 + r3 * (i3[1] - o3), e4[2] = s6 + r3 * (i3[2] - s6), e4[3] = a3 + r3 * (i3[3] - a3), e4;
      }, nh.random = function(e4, t3) {
        var i3, r3, n4, o3, s6, a3;
        t3 = t3 || 1;
        do {
          s6 = (i3 = 2 * sh.RANDOM() - 1) * i3 + (r3 = 2 * sh.RANDOM() - 1) * r3;
        } while (s6 >= 1);
        do {
          a3 = (n4 = 2 * sh.RANDOM() - 1) * n4 + (o3 = 2 * sh.RANDOM() - 1) * o3;
        } while (a3 >= 1);
        var l3 = Math.sqrt((1 - s6) / a3);
        return e4[0] = t3 * i3, e4[1] = t3 * r3, e4[2] = t3 * n4 * l3, e4[3] = t3 * o3 * l3, e4;
      }, nh.transformMat4 = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3];
        return e4[0] = i3[0] * r3 + i3[4] * n4 + i3[8] * o3 + i3[12] * s6, e4[1] = i3[1] * r3 + i3[5] * n4 + i3[9] * o3 + i3[13] * s6, e4[2] = i3[2] * r3 + i3[6] * n4 + i3[10] * o3 + i3[14] * s6, e4[3] = i3[3] * r3 + i3[7] * n4 + i3[11] * o3 + i3[15] * s6, e4;
      }, nh.transformQuat = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = i3[0], a3 = i3[1], l3 = i3[2], c3 = i3[3], h3 = c3 * r3 + a3 * o3 - l3 * n4, u3 = c3 * n4 + l3 * r3 - s6 * o3, d3 = c3 * o3 + s6 * n4 - a3 * r3, p3 = -s6 * r3 - a3 * n4 - l3 * o3;
        return e4[0] = h3 * c3 + p3 * -s6 + u3 * -l3 - d3 * -a3, e4[1] = u3 * c3 + p3 * -a3 + d3 * -s6 - h3 * -l3, e4[2] = d3 * c3 + p3 * -l3 + h3 * -a3 - u3 * -s6, e4[3] = t3[3], e4;
      }, nh.zero = function(e4) {
        return e4[0] = 0, e4[1] = 0, e4[2] = 0, e4[3] = 0, e4;
      }, nh.str = function(e4) {
        return "vec4(" + e4[0] + ", " + e4[1] + ", " + e4[2] + ", " + e4[3] + ")";
      }, nh.exactEquals = function(e4, t3) {
        return e4[0] === t3[0] && e4[1] === t3[1] && e4[2] === t3[2] && e4[3] === t3[3];
      }, nh.equals = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = e4[2], o3 = e4[3], s6 = t3[0], a3 = t3[1], l3 = t3[2], c3 = t3[3];
        return Math.abs(i3 - s6) <= sh.EPSILON * Math.max(1, Math.abs(i3), Math.abs(s6)) && Math.abs(r3 - a3) <= sh.EPSILON * Math.max(1, Math.abs(r3), Math.abs(a3)) && Math.abs(n4 - l3) <= sh.EPSILON * Math.max(1, Math.abs(n4), Math.abs(l3)) && Math.abs(o3 - c3) <= sh.EPSILON * Math.max(1, Math.abs(o3), Math.abs(c3));
      }, nh.forEach = nh.sqrLen = nh.len = nh.sqrDist = nh.dist = nh.div = nh.mul = nh.sub = void 0;
      var sh = function(e4, t3) {
        if (e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== oh(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = ah(void 0);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }(lc);
      function ah(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (ah = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function lh() {
        var e4 = new sh.ARRAY_TYPE(4);
        return sh.ARRAY_TYPE != Float32Array && (e4[0] = 0, e4[1] = 0, e4[2] = 0, e4[3] = 0), e4;
      }
      function ch(e4, t3, i3) {
        return e4[0] = t3[0] - i3[0], e4[1] = t3[1] - i3[1], e4[2] = t3[2] - i3[2], e4[3] = t3[3] - i3[3], e4;
      }
      function hh(e4, t3, i3) {
        return e4[0] = t3[0] * i3[0], e4[1] = t3[1] * i3[1], e4[2] = t3[2] * i3[2], e4[3] = t3[3] * i3[3], e4;
      }
      function uh(e4, t3, i3) {
        return e4[0] = t3[0] / i3[0], e4[1] = t3[1] / i3[1], e4[2] = t3[2] / i3[2], e4[3] = t3[3] / i3[3], e4;
      }
      function dh(e4, t3) {
        return Math.hypot(t3[0] - e4[0], t3[1] - e4[1], t3[2] - e4[2], t3[3] - e4[3]);
      }
      function ph(e4, t3) {
        var i3 = t3[0] - e4[0], r3 = t3[1] - e4[1], n4 = t3[2] - e4[2], o3 = t3[3] - e4[3];
        return i3 * i3 + r3 * r3 + n4 * n4 + o3 * o3;
      }
      function fh(e4) {
        return Math.hypot(e4[0], e4[1], e4[2], e4[3]);
      }
      function mh(e4) {
        var t3 = e4[0], i3 = e4[1], r3 = e4[2], n4 = e4[3];
        return t3 * t3 + i3 * i3 + r3 * r3 + n4 * n4;
      }
      nh.sub = ch, nh.mul = hh, nh.div = uh, nh.dist = dh, nh.sqrDist = ph, nh.len = fh, nh.sqrLen = mh;
      var _h = function() {
        var e4 = lh();
        return function(t3, i3, r3, n4, o3, s6) {
          var a3, l3;
          for (i3 || (i3 = 4), r3 || (r3 = 0), l3 = n4 ? Math.min(n4 * i3 + r3, t3.length) : t3.length, a3 = r3; a3 < l3; a3 += i3)
            e4[0] = t3[a3], e4[1] = t3[a3 + 1], e4[2] = t3[a3 + 2], e4[3] = t3[a3 + 3], o3(e4, e4, s6), t3[a3] = e4[0], t3[a3 + 1] = e4[1], t3[a3 + 2] = e4[2], t3[a3 + 3] = e4[3];
          return t3;
        };
      }();
      function gh(e4) {
        return gh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, gh(e4);
      }
      nh.forEach = _h, Object.defineProperty(jc, "__esModule", { value: true }), jc.create = Eh, jc.identity = function(e4) {
        return e4[0] = 0, e4[1] = 0, e4[2] = 0, e4[3] = 1, e4;
      }, jc.setAxisAngle = Mh, jc.getAxisAngle = function(e4, t3) {
        var i3 = 2 * Math.acos(t3[3]), r3 = Math.sin(i3 / 2);
        return r3 > yh.EPSILON ? (e4[0] = t3[0] / r3, e4[1] = t3[1] / r3, e4[2] = t3[2] / r3) : (e4[0] = 1, e4[1] = 0, e4[2] = 0), i3;
      }, jc.getAngle = function(e4, t3) {
        var i3 = Dh(e4, t3);
        return Math.acos(2 * i3 * i3 - 1);
      }, jc.multiply = Ah, jc.rotateX = function(e4, t3, i3) {
        i3 *= 0.5;
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = Math.sin(i3), l3 = Math.cos(i3);
        return e4[0] = r3 * l3 + s6 * a3, e4[1] = n4 * l3 + o3 * a3, e4[2] = o3 * l3 - n4 * a3, e4[3] = s6 * l3 - r3 * a3, e4;
      }, jc.rotateY = function(e4, t3, i3) {
        i3 *= 0.5;
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = Math.sin(i3), l3 = Math.cos(i3);
        return e4[0] = r3 * l3 - o3 * a3, e4[1] = n4 * l3 + s6 * a3, e4[2] = o3 * l3 + r3 * a3, e4[3] = s6 * l3 - n4 * a3, e4;
      }, jc.rotateZ = function(e4, t3, i3) {
        i3 *= 0.5;
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = Math.sin(i3), l3 = Math.cos(i3);
        return e4[0] = r3 * l3 + n4 * a3, e4[1] = n4 * l3 - r3 * a3, e4[2] = o3 * l3 + s6 * a3, e4[3] = s6 * l3 - o3 * a3, e4;
      }, jc.calculateW = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2];
        return e4[0] = i3, e4[1] = r3, e4[2] = n4, e4[3] = Math.sqrt(Math.abs(1 - i3 * i3 - r3 * r3 - n4 * n4)), e4;
      }, jc.exp = Sh, jc.ln = Ih, jc.pow = function(e4, t3, i3) {
        return Ih(e4, t3), Ph(e4, e4, i3), Sh(e4, e4), e4;
      }, jc.slerp = Ch, jc.random = function(e4) {
        var t3 = yh.RANDOM(), i3 = yh.RANDOM(), r3 = yh.RANDOM(), n4 = Math.sqrt(1 - t3), o3 = Math.sqrt(t3);
        return e4[0] = n4 * Math.sin(2 * Math.PI * i3), e4[1] = n4 * Math.cos(2 * Math.PI * i3), e4[2] = o3 * Math.sin(2 * Math.PI * r3), e4[3] = o3 * Math.cos(2 * Math.PI * r3), e4;
      }, jc.invert = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = i3 * i3 + r3 * r3 + n4 * n4 + o3 * o3, a3 = s6 ? 1 / s6 : 0;
        return e4[0] = -i3 * a3, e4[1] = -r3 * a3, e4[2] = -n4 * a3, e4[3] = o3 * a3, e4;
      }, jc.conjugate = function(e4, t3) {
        return e4[0] = -t3[0], e4[1] = -t3[1], e4[2] = -t3[2], e4[3] = t3[3], e4;
      }, jc.fromMat3 = zh, jc.fromEuler = function(e4, t3, i3, r3) {
        var n4 = 0.5 * Math.PI / 180;
        t3 *= n4, i3 *= n4, r3 *= n4;
        var o3 = Math.sin(t3), s6 = Math.cos(t3), a3 = Math.sin(i3), l3 = Math.cos(i3), c3 = Math.sin(r3), h3 = Math.cos(r3);
        return e4[0] = o3 * l3 * h3 - s6 * a3 * c3, e4[1] = s6 * a3 * h3 + o3 * l3 * c3, e4[2] = s6 * l3 * c3 - o3 * a3 * h3, e4[3] = s6 * l3 * h3 + o3 * a3 * c3, e4;
      }, jc.str = function(e4) {
        return "quat(" + e4[0] + ", " + e4[1] + ", " + e4[2] + ", " + e4[3] + ")";
      }, jc.setAxes = jc.sqlerp = jc.rotationTo = jc.equals = jc.exactEquals = jc.normalize = jc.sqrLen = jc.squaredLength = jc.len = jc.length = jc.lerp = jc.dot = jc.scale = jc.mul = jc.add = jc.set = jc.copy = jc.fromValues = jc.clone = void 0;
      var yh = Th(lc), xh = Th(Mc), vh = Th(Gc), bh = Th(nh);
      function wh(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (wh = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function Th(e4, t3) {
        if (!t3 && e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== gh(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = wh(t3);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }
      function Eh() {
        var e4 = new yh.ARRAY_TYPE(4);
        return yh.ARRAY_TYPE != Float32Array && (e4[0] = 0, e4[1] = 0, e4[2] = 0), e4[3] = 1, e4;
      }
      function Mh(e4, t3, i3) {
        i3 *= 0.5;
        var r3 = Math.sin(i3);
        return e4[0] = r3 * t3[0], e4[1] = r3 * t3[1], e4[2] = r3 * t3[2], e4[3] = Math.cos(i3), e4;
      }
      function Ah(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = i3[0], l3 = i3[1], c3 = i3[2], h3 = i3[3];
        return e4[0] = r3 * h3 + s6 * a3 + n4 * c3 - o3 * l3, e4[1] = n4 * h3 + s6 * l3 + o3 * a3 - r3 * c3, e4[2] = o3 * h3 + s6 * c3 + r3 * l3 - n4 * a3, e4[3] = s6 * h3 - r3 * a3 - n4 * l3 - o3 * c3, e4;
      }
      function Sh(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = Math.sqrt(i3 * i3 + r3 * r3 + n4 * n4), a3 = Math.exp(o3), l3 = s6 > 0 ? a3 * Math.sin(s6) / s6 : 0;
        return e4[0] = i3 * l3, e4[1] = r3 * l3, e4[2] = n4 * l3, e4[3] = a3 * Math.cos(s6), e4;
      }
      function Ih(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = t3[2], o3 = t3[3], s6 = Math.sqrt(i3 * i3 + r3 * r3 + n4 * n4), a3 = s6 > 0 ? Math.atan2(s6, o3) / s6 : 0;
        return e4[0] = i3 * a3, e4[1] = r3 * a3, e4[2] = n4 * a3, e4[3] = 0.5 * Math.log(i3 * i3 + r3 * r3 + n4 * n4 + o3 * o3), e4;
      }
      function Ch(e4, t3, i3, r3) {
        var n4, o3, s6, a3, l3, c3 = t3[0], h3 = t3[1], u3 = t3[2], d3 = t3[3], p3 = i3[0], f3 = i3[1], m3 = i3[2], _3 = i3[3];
        return (o3 = c3 * p3 + h3 * f3 + u3 * m3 + d3 * _3) < 0 && (o3 = -o3, p3 = -p3, f3 = -f3, m3 = -m3, _3 = -_3), 1 - o3 > yh.EPSILON ? (n4 = Math.acos(o3), s6 = Math.sin(n4), a3 = Math.sin((1 - r3) * n4) / s6, l3 = Math.sin(r3 * n4) / s6) : (a3 = 1 - r3, l3 = r3), e4[0] = a3 * c3 + l3 * p3, e4[1] = a3 * h3 + l3 * f3, e4[2] = a3 * u3 + l3 * m3, e4[3] = a3 * d3 + l3 * _3, e4;
      }
      function zh(e4, t3) {
        var i3, r3 = t3[0] + t3[4] + t3[8];
        if (r3 > 0)
          i3 = Math.sqrt(r3 + 1), e4[3] = 0.5 * i3, e4[0] = (t3[5] - t3[7]) * (i3 = 0.5 / i3), e4[1] = (t3[6] - t3[2]) * i3, e4[2] = (t3[1] - t3[3]) * i3;
        else {
          var n4 = 0;
          t3[4] > t3[0] && (n4 = 1), t3[8] > t3[3 * n4 + n4] && (n4 = 2);
          var o3 = (n4 + 1) % 3, s6 = (n4 + 2) % 3;
          i3 = Math.sqrt(t3[3 * n4 + n4] - t3[3 * o3 + o3] - t3[3 * s6 + s6] + 1), e4[n4] = 0.5 * i3, e4[3] = (t3[3 * o3 + s6] - t3[3 * s6 + o3]) * (i3 = 0.5 / i3), e4[o3] = (t3[3 * o3 + n4] + t3[3 * n4 + o3]) * i3, e4[s6] = (t3[3 * s6 + n4] + t3[3 * n4 + s6]) * i3;
        }
        return e4;
      }
      jc.clone = bh.clone, jc.fromValues = bh.fromValues, jc.copy = bh.copy, jc.set = bh.set, jc.add = bh.add, jc.mul = Ah;
      var Ph = bh.scale;
      jc.scale = Ph;
      var Dh = bh.dot;
      jc.dot = Dh, jc.lerp = bh.lerp;
      var Rh = bh.length;
      jc.length = Rh, jc.len = Rh;
      var Lh = bh.squaredLength;
      jc.squaredLength = Lh, jc.sqrLen = Lh;
      var kh = bh.normalize;
      jc.normalize = kh, jc.exactEquals = bh.exactEquals, jc.equals = bh.equals;
      var Oh, Bh, Fh, Nh = (Oh = vh.create(), Bh = vh.fromValues(1, 0, 0), Fh = vh.fromValues(0, 1, 0), function(e4, t3, i3) {
        var r3 = vh.dot(t3, i3);
        return r3 < -0.999999 ? (vh.cross(Oh, Bh, t3), vh.len(Oh) < 1e-6 && vh.cross(Oh, Fh, t3), vh.normalize(Oh, Oh), Mh(e4, Oh, Math.PI), e4) : r3 > 0.999999 ? (e4[0] = 0, e4[1] = 0, e4[2] = 0, e4[3] = 1, e4) : (vh.cross(Oh, t3, i3), e4[0] = Oh[0], e4[1] = Oh[1], e4[2] = Oh[2], e4[3] = 1 + r3, kh(e4, e4));
      });
      jc.rotationTo = Nh;
      var Uh, Vh, jh = (Uh = Eh(), Vh = Eh(), function(e4, t3, i3, r3, n4, o3) {
        return Ch(Uh, t3, n4, o3), Ch(Vh, i3, r3, o3), Ch(e4, Uh, Vh, 2 * o3 * (1 - o3)), e4;
      });
      jc.sqlerp = jh;
      var Gh, qh = (Gh = xh.create(), function(e4, t3, i3, r3) {
        return Gh[0] = i3[0], Gh[3] = i3[1], Gh[6] = i3[2], Gh[1] = r3[0], Gh[4] = r3[1], Gh[7] = r3[2], Gh[2] = -t3[0], Gh[5] = -t3[1], Gh[8] = -t3[2], kh(e4, zh(e4, Gh));
      });
      jc.setAxes = qh;
      var Zh = {};
      function $h(e4) {
        return $h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, $h(e4);
      }
      Object.defineProperty(Zh, "__esModule", { value: true }), Zh.create = function() {
        var e4 = new Wh.ARRAY_TYPE(8);
        return Wh.ARRAY_TYPE != Float32Array && (e4[0] = 0, e4[1] = 0, e4[2] = 0, e4[4] = 0, e4[5] = 0, e4[6] = 0, e4[7] = 0), e4[3] = 1, e4;
      }, Zh.clone = function(e4) {
        var t3 = new Wh.ARRAY_TYPE(8);
        return t3[0] = e4[0], t3[1] = e4[1], t3[2] = e4[2], t3[3] = e4[3], t3[4] = e4[4], t3[5] = e4[5], t3[6] = e4[6], t3[7] = e4[7], t3;
      }, Zh.fromValues = function(e4, t3, i3, r3, n4, o3, s6, a3) {
        var l3 = new Wh.ARRAY_TYPE(8);
        return l3[0] = e4, l3[1] = t3, l3[2] = i3, l3[3] = r3, l3[4] = n4, l3[5] = o3, l3[6] = s6, l3[7] = a3, l3;
      }, Zh.fromRotationTranslationValues = function(e4, t3, i3, r3, n4, o3, s6) {
        var a3 = new Wh.ARRAY_TYPE(8);
        a3[0] = e4, a3[1] = t3, a3[2] = i3, a3[3] = r3;
        var l3 = 0.5 * n4, c3 = 0.5 * o3, h3 = 0.5 * s6;
        return a3[4] = l3 * r3 + c3 * i3 - h3 * t3, a3[5] = c3 * r3 + h3 * e4 - l3 * i3, a3[6] = h3 * r3 + l3 * t3 - c3 * e4, a3[7] = -l3 * e4 - c3 * t3 - h3 * i3, a3;
      }, Zh.fromRotationTranslation = Jh, Zh.fromTranslation = function(e4, t3) {
        return e4[0] = 0, e4[1] = 0, e4[2] = 0, e4[3] = 1, e4[4] = 0.5 * t3[0], e4[5] = 0.5 * t3[1], e4[6] = 0.5 * t3[2], e4[7] = 0, e4;
      }, Zh.fromRotation = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = 0, e4[5] = 0, e4[6] = 0, e4[7] = 0, e4;
      }, Zh.fromMat4 = function(e4, t3) {
        var i3 = Hh.create();
        Xh.getRotation(i3, t3);
        var r3 = new Wh.ARRAY_TYPE(3);
        return Xh.getTranslation(r3, t3), Jh(e4, i3, r3), e4;
      }, Zh.copy = Qh, Zh.identity = function(e4) {
        return e4[0] = 0, e4[1] = 0, e4[2] = 0, e4[3] = 1, e4[4] = 0, e4[5] = 0, e4[6] = 0, e4[7] = 0, e4;
      }, Zh.set = function(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        return e4[0] = t3, e4[1] = i3, e4[2] = r3, e4[3] = n4, e4[4] = o3, e4[5] = s6, e4[6] = a3, e4[7] = l3, e4;
      }, Zh.getDual = function(e4, t3) {
        return e4[0] = t3[4], e4[1] = t3[5], e4[2] = t3[6], e4[3] = t3[7], e4;
      }, Zh.setDual = function(e4, t3) {
        return e4[4] = t3[0], e4[5] = t3[1], e4[6] = t3[2], e4[7] = t3[3], e4;
      }, Zh.getTranslation = function(e4, t3) {
        var i3 = t3[4], r3 = t3[5], n4 = t3[6], o3 = t3[7], s6 = -t3[0], a3 = -t3[1], l3 = -t3[2], c3 = t3[3];
        return e4[0] = 2 * (i3 * c3 + o3 * s6 + r3 * l3 - n4 * a3), e4[1] = 2 * (r3 * c3 + o3 * a3 + n4 * s6 - i3 * l3), e4[2] = 2 * (n4 * c3 + o3 * l3 + i3 * a3 - r3 * s6), e4;
      }, Zh.translate = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = 0.5 * i3[0], l3 = 0.5 * i3[1], c3 = 0.5 * i3[2], h3 = t3[4], u3 = t3[5], d3 = t3[6], p3 = t3[7];
        return e4[0] = r3, e4[1] = n4, e4[2] = o3, e4[3] = s6, e4[4] = s6 * a3 + n4 * c3 - o3 * l3 + h3, e4[5] = s6 * l3 + o3 * a3 - r3 * c3 + u3, e4[6] = s6 * c3 + r3 * l3 - n4 * a3 + d3, e4[7] = -r3 * a3 - n4 * l3 - o3 * c3 + p3, e4;
      }, Zh.rotateX = function(e4, t3, i3) {
        var r3 = -t3[0], n4 = -t3[1], o3 = -t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = a3 * s6 + h3 * r3 + l3 * o3 - c3 * n4, d3 = l3 * s6 + h3 * n4 + c3 * r3 - a3 * o3, p3 = c3 * s6 + h3 * o3 + a3 * n4 - l3 * r3, f3 = h3 * s6 - a3 * r3 - l3 * n4 - c3 * o3;
        return Hh.rotateX(e4, t3, i3), e4[4] = u3 * (s6 = e4[3]) + f3 * (r3 = e4[0]) + d3 * (o3 = e4[2]) - p3 * (n4 = e4[1]), e4[5] = d3 * s6 + f3 * n4 + p3 * r3 - u3 * o3, e4[6] = p3 * s6 + f3 * o3 + u3 * n4 - d3 * r3, e4[7] = f3 * s6 - u3 * r3 - d3 * n4 - p3 * o3, e4;
      }, Zh.rotateY = function(e4, t3, i3) {
        var r3 = -t3[0], n4 = -t3[1], o3 = -t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = a3 * s6 + h3 * r3 + l3 * o3 - c3 * n4, d3 = l3 * s6 + h3 * n4 + c3 * r3 - a3 * o3, p3 = c3 * s6 + h3 * o3 + a3 * n4 - l3 * r3, f3 = h3 * s6 - a3 * r3 - l3 * n4 - c3 * o3;
        return Hh.rotateY(e4, t3, i3), e4[4] = u3 * (s6 = e4[3]) + f3 * (r3 = e4[0]) + d3 * (o3 = e4[2]) - p3 * (n4 = e4[1]), e4[5] = d3 * s6 + f3 * n4 + p3 * r3 - u3 * o3, e4[6] = p3 * s6 + f3 * o3 + u3 * n4 - d3 * r3, e4[7] = f3 * s6 - u3 * r3 - d3 * n4 - p3 * o3, e4;
      }, Zh.rotateZ = function(e4, t3, i3) {
        var r3 = -t3[0], n4 = -t3[1], o3 = -t3[2], s6 = t3[3], a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = a3 * s6 + h3 * r3 + l3 * o3 - c3 * n4, d3 = l3 * s6 + h3 * n4 + c3 * r3 - a3 * o3, p3 = c3 * s6 + h3 * o3 + a3 * n4 - l3 * r3, f3 = h3 * s6 - a3 * r3 - l3 * n4 - c3 * o3;
        return Hh.rotateZ(e4, t3, i3), e4[4] = u3 * (s6 = e4[3]) + f3 * (r3 = e4[0]) + d3 * (o3 = e4[2]) - p3 * (n4 = e4[1]), e4[5] = d3 * s6 + f3 * n4 + p3 * r3 - u3 * o3, e4[6] = p3 * s6 + f3 * o3 + u3 * n4 - d3 * r3, e4[7] = f3 * s6 - u3 * r3 - d3 * n4 - p3 * o3, e4;
      }, Zh.rotateByQuatAppend = function(e4, t3, i3) {
        var r3 = i3[0], n4 = i3[1], o3 = i3[2], s6 = i3[3], a3 = t3[0], l3 = t3[1], c3 = t3[2], h3 = t3[3];
        return e4[0] = a3 * s6 + h3 * r3 + l3 * o3 - c3 * n4, e4[1] = l3 * s6 + h3 * n4 + c3 * r3 - a3 * o3, e4[2] = c3 * s6 + h3 * o3 + a3 * n4 - l3 * r3, e4[3] = h3 * s6 - a3 * r3 - l3 * n4 - c3 * o3, e4[4] = (a3 = t3[4]) * s6 + (h3 = t3[7]) * r3 + (l3 = t3[5]) * o3 - (c3 = t3[6]) * n4, e4[5] = l3 * s6 + h3 * n4 + c3 * r3 - a3 * o3, e4[6] = c3 * s6 + h3 * o3 + a3 * n4 - l3 * r3, e4[7] = h3 * s6 - a3 * r3 - l3 * n4 - c3 * o3, e4;
      }, Zh.rotateByQuatPrepend = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = i3[0], l3 = i3[1], c3 = i3[2], h3 = i3[3];
        return e4[0] = r3 * h3 + s6 * a3 + n4 * c3 - o3 * l3, e4[1] = n4 * h3 + s6 * l3 + o3 * a3 - r3 * c3, e4[2] = o3 * h3 + s6 * c3 + r3 * l3 - n4 * a3, e4[3] = s6 * h3 - r3 * a3 - n4 * l3 - o3 * c3, e4[4] = r3 * (h3 = i3[7]) + s6 * (a3 = i3[4]) + n4 * (c3 = i3[6]) - o3 * (l3 = i3[5]), e4[5] = n4 * h3 + s6 * l3 + o3 * a3 - r3 * c3, e4[6] = o3 * h3 + s6 * c3 + r3 * l3 - n4 * a3, e4[7] = s6 * h3 - r3 * a3 - n4 * l3 - o3 * c3, e4;
      }, Zh.rotateAroundAxis = function(e4, t3, i3, r3) {
        if (Math.abs(r3) < Wh.EPSILON)
          return Qh(e4, t3);
        var n4 = Math.hypot(i3[0], i3[1], i3[2]);
        r3 *= 0.5;
        var o3 = Math.sin(r3), s6 = o3 * i3[0] / n4, a3 = o3 * i3[1] / n4, l3 = o3 * i3[2] / n4, c3 = Math.cos(r3), h3 = t3[0], u3 = t3[1], d3 = t3[2], p3 = t3[3];
        e4[0] = h3 * c3 + p3 * s6 + u3 * l3 - d3 * a3, e4[1] = u3 * c3 + p3 * a3 + d3 * s6 - h3 * l3, e4[2] = d3 * c3 + p3 * l3 + h3 * a3 - u3 * s6, e4[3] = p3 * c3 - h3 * s6 - u3 * a3 - d3 * l3;
        var f3 = t3[4], m3 = t3[5], _3 = t3[6], g3 = t3[7];
        return e4[4] = f3 * c3 + g3 * s6 + m3 * l3 - _3 * a3, e4[5] = m3 * c3 + g3 * a3 + _3 * s6 - f3 * l3, e4[6] = _3 * c3 + g3 * l3 + f3 * a3 - m3 * s6, e4[7] = g3 * c3 - f3 * s6 - m3 * a3 - _3 * l3, e4;
      }, Zh.add = function(e4, t3, i3) {
        return e4[0] = t3[0] + i3[0], e4[1] = t3[1] + i3[1], e4[2] = t3[2] + i3[2], e4[3] = t3[3] + i3[3], e4[4] = t3[4] + i3[4], e4[5] = t3[5] + i3[5], e4[6] = t3[6] + i3[6], e4[7] = t3[7] + i3[7], e4;
      }, Zh.multiply = eu, Zh.scale = function(e4, t3, i3) {
        return e4[0] = t3[0] * i3, e4[1] = t3[1] * i3, e4[2] = t3[2] * i3, e4[3] = t3[3] * i3, e4[4] = t3[4] * i3, e4[5] = t3[5] * i3, e4[6] = t3[6] * i3, e4[7] = t3[7] * i3, e4;
      }, Zh.lerp = function(e4, t3, i3, r3) {
        var n4 = 1 - r3;
        return tu(t3, i3) < 0 && (r3 = -r3), e4[0] = t3[0] * n4 + i3[0] * r3, e4[1] = t3[1] * n4 + i3[1] * r3, e4[2] = t3[2] * n4 + i3[2] * r3, e4[3] = t3[3] * n4 + i3[3] * r3, e4[4] = t3[4] * n4 + i3[4] * r3, e4[5] = t3[5] * n4 + i3[5] * r3, e4[6] = t3[6] * n4 + i3[6] * r3, e4[7] = t3[7] * n4 + i3[7] * r3, e4;
      }, Zh.invert = function(e4, t3) {
        var i3 = ru(t3);
        return e4[0] = -t3[0] / i3, e4[1] = -t3[1] / i3, e4[2] = -t3[2] / i3, e4[3] = t3[3] / i3, e4[4] = -t3[4] / i3, e4[5] = -t3[5] / i3, e4[6] = -t3[6] / i3, e4[7] = t3[7] / i3, e4;
      }, Zh.conjugate = function(e4, t3) {
        return e4[0] = -t3[0], e4[1] = -t3[1], e4[2] = -t3[2], e4[3] = t3[3], e4[4] = -t3[4], e4[5] = -t3[5], e4[6] = -t3[6], e4[7] = t3[7], e4;
      }, Zh.normalize = function(e4, t3) {
        var i3 = ru(t3);
        if (i3 > 0) {
          i3 = Math.sqrt(i3);
          var r3 = t3[0] / i3, n4 = t3[1] / i3, o3 = t3[2] / i3, s6 = t3[3] / i3, a3 = t3[4], l3 = t3[5], c3 = t3[6], h3 = t3[7], u3 = r3 * a3 + n4 * l3 + o3 * c3 + s6 * h3;
          e4[0] = r3, e4[1] = n4, e4[2] = o3, e4[3] = s6, e4[4] = (a3 - r3 * u3) / i3, e4[5] = (l3 - n4 * u3) / i3, e4[6] = (c3 - o3 * u3) / i3, e4[7] = (h3 - s6 * u3) / i3;
        }
        return e4;
      }, Zh.str = function(e4) {
        return "quat2(" + e4[0] + ", " + e4[1] + ", " + e4[2] + ", " + e4[3] + ", " + e4[4] + ", " + e4[5] + ", " + e4[6] + ", " + e4[7] + ")";
      }, Zh.exactEquals = function(e4, t3) {
        return e4[0] === t3[0] && e4[1] === t3[1] && e4[2] === t3[2] && e4[3] === t3[3] && e4[4] === t3[4] && e4[5] === t3[5] && e4[6] === t3[6] && e4[7] === t3[7];
      }, Zh.equals = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = e4[2], o3 = e4[3], s6 = e4[4], a3 = e4[5], l3 = e4[6], c3 = e4[7], h3 = t3[0], u3 = t3[1], d3 = t3[2], p3 = t3[3], f3 = t3[4], m3 = t3[5], _3 = t3[6], g3 = t3[7];
        return Math.abs(i3 - h3) <= Wh.EPSILON * Math.max(1, Math.abs(i3), Math.abs(h3)) && Math.abs(r3 - u3) <= Wh.EPSILON * Math.max(1, Math.abs(r3), Math.abs(u3)) && Math.abs(n4 - d3) <= Wh.EPSILON * Math.max(1, Math.abs(n4), Math.abs(d3)) && Math.abs(o3 - p3) <= Wh.EPSILON * Math.max(1, Math.abs(o3), Math.abs(p3)) && Math.abs(s6 - f3) <= Wh.EPSILON * Math.max(1, Math.abs(s6), Math.abs(f3)) && Math.abs(a3 - m3) <= Wh.EPSILON * Math.max(1, Math.abs(a3), Math.abs(m3)) && Math.abs(l3 - _3) <= Wh.EPSILON * Math.max(1, Math.abs(l3), Math.abs(_3)) && Math.abs(c3 - g3) <= Wh.EPSILON * Math.max(1, Math.abs(c3), Math.abs(g3));
      }, Zh.sqrLen = Zh.squaredLength = Zh.len = Zh.length = Zh.dot = Zh.mul = Zh.setReal = Zh.getReal = void 0;
      var Wh = Kh(lc), Hh = Kh(jc), Xh = Kh(Pc);
      function Yh(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (Yh = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function Kh(e4, t3) {
        if (!t3 && e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== $h(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = Yh(t3);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }
      function Jh(e4, t3, i3) {
        var r3 = 0.5 * i3[0], n4 = 0.5 * i3[1], o3 = 0.5 * i3[2], s6 = t3[0], a3 = t3[1], l3 = t3[2], c3 = t3[3];
        return e4[0] = s6, e4[1] = a3, e4[2] = l3, e4[3] = c3, e4[4] = r3 * c3 + n4 * l3 - o3 * a3, e4[5] = n4 * c3 + o3 * s6 - r3 * l3, e4[6] = o3 * c3 + r3 * a3 - n4 * s6, e4[7] = -r3 * s6 - n4 * a3 - o3 * l3, e4;
      }
      function Qh(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4[2] = t3[2], e4[3] = t3[3], e4[4] = t3[4], e4[5] = t3[5], e4[6] = t3[6], e4[7] = t3[7], e4;
      }
      function eu(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1], o3 = t3[2], s6 = t3[3], a3 = i3[4], l3 = i3[5], c3 = i3[6], h3 = i3[7], u3 = t3[4], d3 = t3[5], p3 = t3[6], f3 = t3[7], m3 = i3[0], _3 = i3[1], g3 = i3[2], y3 = i3[3];
        return e4[0] = r3 * y3 + s6 * m3 + n4 * g3 - o3 * _3, e4[1] = n4 * y3 + s6 * _3 + o3 * m3 - r3 * g3, e4[2] = o3 * y3 + s6 * g3 + r3 * _3 - n4 * m3, e4[3] = s6 * y3 - r3 * m3 - n4 * _3 - o3 * g3, e4[4] = r3 * h3 + s6 * a3 + n4 * c3 - o3 * l3 + u3 * y3 + f3 * m3 + d3 * g3 - p3 * _3, e4[5] = n4 * h3 + s6 * l3 + o3 * a3 - r3 * c3 + d3 * y3 + f3 * _3 + p3 * m3 - u3 * g3, e4[6] = o3 * h3 + s6 * c3 + r3 * l3 - n4 * a3 + p3 * y3 + f3 * g3 + u3 * _3 - d3 * m3, e4[7] = s6 * h3 - r3 * a3 - n4 * l3 - o3 * c3 + f3 * y3 - u3 * m3 - d3 * _3 - p3 * g3, e4;
      }
      Zh.getReal = Hh.copy, Zh.setReal = Hh.copy, Zh.mul = eu;
      var tu = Hh.dot;
      Zh.dot = tu;
      var iu = Hh.length;
      Zh.length = iu, Zh.len = iu;
      var ru = Hh.squaredLength;
      Zh.squaredLength = ru, Zh.sqrLen = ru;
      var nu = {};
      function ou(e4) {
        return ou = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, ou(e4);
      }
      Object.defineProperty(nu, "__esModule", { value: true }), nu.create = lu, nu.clone = function(e4) {
        var t3 = new su.ARRAY_TYPE(2);
        return t3[0] = e4[0], t3[1] = e4[1], t3;
      }, nu.fromValues = function(e4, t3) {
        var i3 = new su.ARRAY_TYPE(2);
        return i3[0] = e4, i3[1] = t3, i3;
      }, nu.copy = function(e4, t3) {
        return e4[0] = t3[0], e4[1] = t3[1], e4;
      }, nu.set = function(e4, t3, i3) {
        return e4[0] = t3, e4[1] = i3, e4;
      }, nu.add = function(e4, t3, i3) {
        return e4[0] = t3[0] + i3[0], e4[1] = t3[1] + i3[1], e4;
      }, nu.subtract = cu, nu.multiply = hu, nu.divide = uu, nu.ceil = function(e4, t3) {
        return e4[0] = Math.ceil(t3[0]), e4[1] = Math.ceil(t3[1]), e4;
      }, nu.floor = function(e4, t3) {
        return e4[0] = Math.floor(t3[0]), e4[1] = Math.floor(t3[1]), e4;
      }, nu.min = function(e4, t3, i3) {
        return e4[0] = Math.min(t3[0], i3[0]), e4[1] = Math.min(t3[1], i3[1]), e4;
      }, nu.max = function(e4, t3, i3) {
        return e4[0] = Math.max(t3[0], i3[0]), e4[1] = Math.max(t3[1], i3[1]), e4;
      }, nu.round = function(e4, t3) {
        return e4[0] = Math.round(t3[0]), e4[1] = Math.round(t3[1]), e4;
      }, nu.scale = function(e4, t3, i3) {
        return e4[0] = t3[0] * i3, e4[1] = t3[1] * i3, e4;
      }, nu.scaleAndAdd = function(e4, t3, i3, r3) {
        return e4[0] = t3[0] + i3[0] * r3, e4[1] = t3[1] + i3[1] * r3, e4;
      }, nu.distance = du, nu.squaredDistance = pu, nu.length = fu, nu.squaredLength = mu, nu.negate = function(e4, t3) {
        return e4[0] = -t3[0], e4[1] = -t3[1], e4;
      }, nu.inverse = function(e4, t3) {
        return e4[0] = 1 / t3[0], e4[1] = 1 / t3[1], e4;
      }, nu.normalize = function(e4, t3) {
        var i3 = t3[0], r3 = t3[1], n4 = i3 * i3 + r3 * r3;
        return n4 > 0 && (n4 = 1 / Math.sqrt(n4)), e4[0] = t3[0] * n4, e4[1] = t3[1] * n4, e4;
      }, nu.dot = function(e4, t3) {
        return e4[0] * t3[0] + e4[1] * t3[1];
      }, nu.cross = function(e4, t3, i3) {
        var r3 = t3[0] * i3[1] - t3[1] * i3[0];
        return e4[0] = e4[1] = 0, e4[2] = r3, e4;
      }, nu.lerp = function(e4, t3, i3, r3) {
        var n4 = t3[0], o3 = t3[1];
        return e4[0] = n4 + r3 * (i3[0] - n4), e4[1] = o3 + r3 * (i3[1] - o3), e4;
      }, nu.random = function(e4, t3) {
        t3 = t3 || 1;
        var i3 = 2 * su.RANDOM() * Math.PI;
        return e4[0] = Math.cos(i3) * t3, e4[1] = Math.sin(i3) * t3, e4;
      }, nu.transformMat2 = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1];
        return e4[0] = i3[0] * r3 + i3[2] * n4, e4[1] = i3[1] * r3 + i3[3] * n4, e4;
      }, nu.transformMat2d = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1];
        return e4[0] = i3[0] * r3 + i3[2] * n4 + i3[4], e4[1] = i3[1] * r3 + i3[3] * n4 + i3[5], e4;
      }, nu.transformMat3 = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1];
        return e4[0] = i3[0] * r3 + i3[3] * n4 + i3[6], e4[1] = i3[1] * r3 + i3[4] * n4 + i3[7], e4;
      }, nu.transformMat4 = function(e4, t3, i3) {
        var r3 = t3[0], n4 = t3[1];
        return e4[0] = i3[0] * r3 + i3[4] * n4 + i3[12], e4[1] = i3[1] * r3 + i3[5] * n4 + i3[13], e4;
      }, nu.rotate = function(e4, t3, i3, r3) {
        var n4 = t3[0] - i3[0], o3 = t3[1] - i3[1], s6 = Math.sin(r3), a3 = Math.cos(r3);
        return e4[0] = n4 * a3 - o3 * s6 + i3[0], e4[1] = n4 * s6 + o3 * a3 + i3[1], e4;
      }, nu.angle = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = t3[0], o3 = t3[1], s6 = Math.sqrt(i3 * i3 + r3 * r3) * Math.sqrt(n4 * n4 + o3 * o3);
        return Math.acos(Math.min(Math.max(s6 && (i3 * n4 + r3 * o3) / s6, -1), 1));
      }, nu.zero = function(e4) {
        return e4[0] = 0, e4[1] = 0, e4;
      }, nu.str = function(e4) {
        return "vec2(" + e4[0] + ", " + e4[1] + ")";
      }, nu.exactEquals = function(e4, t3) {
        return e4[0] === t3[0] && e4[1] === t3[1];
      }, nu.equals = function(e4, t3) {
        var i3 = e4[0], r3 = e4[1], n4 = t3[0], o3 = t3[1];
        return Math.abs(i3 - n4) <= su.EPSILON * Math.max(1, Math.abs(i3), Math.abs(n4)) && Math.abs(r3 - o3) <= su.EPSILON * Math.max(1, Math.abs(r3), Math.abs(o3));
      }, nu.forEach = nu.sqrLen = nu.sqrDist = nu.dist = nu.div = nu.mul = nu.sub = nu.len = void 0;
      var su = function(e4, t3) {
        if (e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== ou(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = au(void 0);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }(lc);
      function au(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (au = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function lu() {
        var e4 = new su.ARRAY_TYPE(2);
        return su.ARRAY_TYPE != Float32Array && (e4[0] = 0, e4[1] = 0), e4;
      }
      function cu(e4, t3, i3) {
        return e4[0] = t3[0] - i3[0], e4[1] = t3[1] - i3[1], e4;
      }
      function hu(e4, t3, i3) {
        return e4[0] = t3[0] * i3[0], e4[1] = t3[1] * i3[1], e4;
      }
      function uu(e4, t3, i3) {
        return e4[0] = t3[0] / i3[0], e4[1] = t3[1] / i3[1], e4;
      }
      function du(e4, t3) {
        return Math.hypot(t3[0] - e4[0], t3[1] - e4[1]);
      }
      function pu(e4, t3) {
        var i3 = t3[0] - e4[0], r3 = t3[1] - e4[1];
        return i3 * i3 + r3 * r3;
      }
      function fu(e4) {
        return Math.hypot(e4[0], e4[1]);
      }
      function mu(e4) {
        var t3 = e4[0], i3 = e4[1];
        return t3 * t3 + i3 * i3;
      }
      nu.len = fu, nu.sub = cu, nu.mul = hu, nu.div = uu, nu.dist = du, nu.sqrDist = pu, nu.sqrLen = mu;
      var _u = function() {
        var e4 = lu();
        return function(t3, i3, r3, n4, o3, s6) {
          var a3, l3;
          for (i3 || (i3 = 2), r3 || (r3 = 0), l3 = n4 ? Math.min(n4 * i3 + r3, t3.length) : t3.length, a3 = r3; a3 < l3; a3 += i3)
            e4[0] = t3[a3], e4[1] = t3[a3 + 1], o3(e4, e4, s6), t3[a3] = e4[0], t3[a3 + 1] = e4[1];
          return t3;
        };
      }();
      function gu(e4) {
        return gu = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
          return typeof e5;
        } : function(e5) {
          return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
        }, gu(e4);
      }
      nu.forEach = _u, Object.defineProperty(ac, "__esModule", { value: true });
      var yu = ac.vec4 = Du = ac.vec3 = ac.vec2 = ac.quat2 = Iu = ac.quat = Au = ac.mat4 = Eu = ac.mat3 = ac.mat2d = bu = ac.mat2 = ac.glMatrix = void 0, xu = ku(lc);
      ac.glMatrix = xu;
      var vu = ku(pc), bu = ac.mat2 = vu, wu = ku(xc);
      ac.mat2d = wu;
      var Tu = ku(Mc), Eu = ac.mat3 = Tu, Mu = ku(Pc), Au = ac.mat4 = Mu, Su = ku(jc), Iu = ac.quat = Su, Cu = ku(Zh);
      ac.quat2 = Cu;
      var zu = ku(nu);
      ac.vec2 = zu;
      var Pu = ku(Gc), Du = ac.vec3 = Pu, Ru = ku(nh);
      function Lu(e4) {
        if ("function" != typeof WeakMap)
          return null;
        var t3 = /* @__PURE__ */ new WeakMap(), i3 = /* @__PURE__ */ new WeakMap();
        return (Lu = function(e5) {
          return e5 ? i3 : t3;
        })(e4);
      }
      function ku(e4, t3) {
        if (!t3 && e4 && e4.__esModule)
          return e4;
        if (null === e4 || "object" !== gu(e4) && "function" != typeof e4)
          return { default: e4 };
        var i3 = Lu(t3);
        if (i3 && i3.has(e4))
          return i3.get(e4);
        var r3 = {}, n4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o3 in e4)
          if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3)) {
            var s6 = n4 ? Object.getOwnPropertyDescriptor(e4, o3) : null;
            s6 && (s6.get || s6.set) ? Object.defineProperty(r3, o3, s6) : r3[o3] = e4[o3];
          }
        return r3.default = e4, i3 && i3.set(e4, r3), r3;
      }
      yu = ac.vec4 = Ru;
      const Ou = Ia([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: Bu } = Ou, Fu = Ia([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var Nu = Ia([{ name: "a_pos", type: "Int16", components: 2 }]), Uu = {};
      !function(e4, t3) {
        !function(e5) {
          function t4(e6, t5, r3) {
            var n4 = i3(256 * e6, 256 * (t5 = Math.pow(2, r3) - t5 - 1), r3), o3 = i3(256 * (e6 + 1), 256 * (t5 + 1), r3);
            return n4[0] + "," + n4[1] + "," + o3[0] + "," + o3[1];
          }
          function i3(e6, t5, i4) {
            var r3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i4);
            return [e6 * r3 - 2 * Math.PI * 6378137 / 2, t5 * r3 - 2 * Math.PI * 6378137 / 2];
          }
          e5.getURL = function(e6, i4, r3, n4, o3, s6) {
            return s6 = s6 || {}, e6 + "?" + ["bbox=" + t4(r3, n4, o3), "format=" + (s6.format || "image/png"), "service=" + (s6.service || "WMS"), "version=" + (s6.version || "1.1.1"), "request=" + (s6.request || "GetMap"), "srs=" + (s6.srs || "EPSG:3857"), "width=" + (s6.width || 256), "height=" + (s6.height || 256), "layers=" + i4].join("&");
          }, e5.getTileBBox = t4, e5.getMercCoords = i3, Object.defineProperty(e5, "__esModule", { value: true });
        }(t3);
      }(0, Uu);
      var Vu = Uu;
      class ju {
        constructor(e4, t3, i3) {
          this.z = e4, this.x = t3, this.y = i3, this.key = Zu(0, e4, e4, t3, i3);
        }
        equals(e4) {
          return this.z === e4.z && this.x === e4.x && this.y === e4.y;
        }
        url(e4, t3) {
          const i3 = Vu.getTileBBox(this.x, this.y, this.z), r3 = function(e5, t4, i4) {
            let r4, n4 = "";
            for (let o3 = e5; o3 > 0; o3--)
              r4 = 1 << o3 - 1, n4 += (t4 & r4 ? 1 : 0) + (i4 & r4 ? 2 : 0);
            return n4;
          }(this.z, this.x, this.y);
          return e4[(this.x + this.y) % e4.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === t3 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", r3).replace("{bbox-epsg-3857}", i3);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Gu {
        constructor(e4, t3) {
          this.wrap = e4, this.canonical = t3, this.key = Zu(e4, t3.z, t3.z, t3.x, t3.y);
        }
      }
      class qu {
        constructor(e4, t3, i3, r3, n4) {
          this.overscaledZ = e4, this.wrap = t3, this.canonical = new ju(i3, +r3, +n4), this.key = 0 === t3 && e4 === i3 ? this.canonical.key : Zu(t3, e4, i3, r3, n4);
        }
        equals(e4) {
          return this.overscaledZ === e4.overscaledZ && this.wrap === e4.wrap && this.canonical.equals(e4.canonical);
        }
        scaledTo(e4) {
          const t3 = this.canonical.z - e4;
          return e4 > this.canonical.z ? new qu(e4, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new qu(e4, this.wrap, e4, this.canonical.x >> t3, this.canonical.y >> t3);
        }
        calculateScaledKey(e4, t3 = true) {
          if (this.overscaledZ === e4 && t3)
            return this.key;
          if (e4 > this.canonical.z)
            return Zu(this.wrap * +t3, e4, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const i3 = this.canonical.z - e4;
            return Zu(this.wrap * +t3, e4, e4, this.canonical.x >> i3, this.canonical.y >> i3);
          }
        }
        isChildOf(e4) {
          if (e4.wrap !== this.wrap)
            return false;
          const t3 = this.canonical.z - e4.canonical.z;
          return 0 === e4.overscaledZ || e4.overscaledZ < this.overscaledZ && e4.canonical.z < this.canonical.z && e4.canonical.x === this.canonical.x >> t3 && e4.canonical.y === this.canonical.y >> t3;
        }
        children(e4) {
          if (this.overscaledZ >= e4)
            return [new qu(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const t3 = this.canonical.z + 1, i3 = 2 * this.canonical.x, r3 = 2 * this.canonical.y;
          return [new qu(t3, this.wrap, t3, i3, r3), new qu(t3, this.wrap, t3, i3 + 1, r3), new qu(t3, this.wrap, t3, i3, r3 + 1), new qu(t3, this.wrap, t3, i3 + 1, r3 + 1)];
        }
        isLessThan(e4) {
          return this.wrap < e4.wrap || !(this.wrap > e4.wrap) && (this.overscaledZ < e4.overscaledZ || !(this.overscaledZ > e4.overscaledZ) && (this.canonical.x < e4.canonical.x || !(this.canonical.x > e4.canonical.x) && this.canonical.y < e4.canonical.y));
        }
        wrapped() {
          return new qu(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e4) {
          return new qu(this.overscaledZ, e4, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Gu(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function Zu(e4, t3, i3, r3, n4) {
        const o3 = 1 << Math.min(i3, 22);
        let s6 = o3 * (n4 % o3) + r3 % o3;
        return e4 && i3 < 22 && (s6 += o3 * o3 * ((e4 < 0 ? -2 * e4 - 1 : 2 * e4) % (1 << 2 * (22 - i3)))), 16 * (32 * s6 + i3) + (t3 - i3);
      }
      const $u = [(e4) => {
        let t3 = e4.canonical.x - 1, i3 = e4.wrap;
        return t3 < 0 && (t3 = (1 << e4.canonical.z) - 1, i3--), new qu(e4.overscaledZ, i3, e4.canonical.z, t3, e4.canonical.y);
      }, (e4) => {
        let t3 = e4.canonical.x + 1, i3 = e4.wrap;
        return t3 === 1 << e4.canonical.z && (t3 = 0, i3++), new qu(e4.overscaledZ, i3, e4.canonical.z, t3, e4.canonical.y);
      }, (e4) => new qu(e4.overscaledZ, e4.wrap, e4.canonical.z, e4.canonical.x, (0 === e4.canonical.y ? 1 << e4.canonical.z : e4.canonical.y) - 1), (e4) => new qu(e4.overscaledZ, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y === (1 << e4.canonical.z) - 1 ? 0 : e4.canonical.y + 1)];
      Rs(ju, "CanonicalTileID"), Rs(qu, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
      class Wu {
        constructor(e4, t3) {
          this.pos = e4, this.dir = t3;
        }
        intersectsPlane(e4, t3, i3) {
          const r3 = Du.dot(t3, this.dir);
          if (Math.abs(r3) < 1e-6)
            return false;
          const n4 = ((e4[0] - this.pos[0]) * t3[0] + (e4[1] - this.pos[1]) * t3[1] + (e4[2] - this.pos[2]) * t3[2]) / r3;
          return i3[0] = this.pos[0] + this.dir[0] * n4, i3[1] = this.pos[1] + this.dir[1] * n4, i3[2] = this.pos[2] + this.dir[2] * n4, true;
        }
        closestPointOnSphere(e4, t3, i3) {
          if (Du.equals(this.pos, e4) || 0 === t3)
            return i3[0] = i3[1] = i3[2] = 0, false;
          const [r3, n4, o3] = this.dir, s6 = this.pos[0] - e4[0], a3 = this.pos[1] - e4[1], l3 = this.pos[2] - e4[2], c3 = r3 * r3 + n4 * n4 + o3 * o3, h3 = 2 * (s6 * r3 + a3 * n4 + l3 * o3), u3 = h3 * h3 - 4 * c3 * (s6 * s6 + a3 * a3 + l3 * l3 - t3 * t3);
          if (u3 < 0) {
            const e5 = Math.max(-h3 / 2, 0), c4 = s6 + r3 * e5, u4 = a3 + n4 * e5, d3 = l3 + o3 * e5, p3 = Math.hypot(c4, u4, d3);
            return i3[0] = c4 * t3 / p3, i3[1] = u4 * t3 / p3, i3[2] = d3 * t3 / p3, false;
          }
          {
            const e5 = (-h3 - Math.sqrt(u3)) / (2 * c3);
            if (e5 < 0) {
              const e6 = Math.hypot(s6, a3, l3);
              return i3[0] = s6 * t3 / e6, i3[1] = a3 * t3 / e6, i3[2] = l3 * t3 / e6, false;
            }
            return i3[0] = s6 + r3 * e5, i3[1] = a3 + n4 * e5, i3[2] = l3 + o3 * e5, true;
          }
        }
      }
      class Hu {
        constructor(e4, t3, i3, r3, n4) {
          this.TL = e4, this.TR = t3, this.BR = i3, this.BL = r3, this.horizon = n4;
        }
        static fromInvProjectionMatrix(e4, t3, i3) {
          const r3 = [-1, 1, 1], n4 = [1, 1, 1], o3 = [1, -1, 1], s6 = [-1, -1, 1], a3 = Du.transformMat4(r3, r3, e4), l3 = Du.transformMat4(n4, n4, e4), c3 = Du.transformMat4(o3, o3, e4), h3 = Du.transformMat4(s6, s6, e4);
          return new Hu(a3, l3, c3, h3, t3 / i3);
        }
      }
      function Xu(e4, t3, i3) {
        let r3 = 1 / 0, n4 = -1 / 0;
        const o3 = [];
        for (const s6 of e4) {
          Du.sub(o3, s6, t3);
          const e5 = Du.dot(o3, i3);
          r3 = Math.min(r3, e5), n4 = Math.max(n4, e5);
        }
        return [r3, n4];
      }
      function Yu(e4, t3) {
        let i3 = true;
        for (let r3 = 0; r3 < e4.planes.length; r3++) {
          const n4 = e4.planes[r3];
          let o3 = 0;
          for (let e5 = 0; e5 < t3.length; e5++)
            o3 += Du.dot(n4, t3[e5]) + n4[3] >= 0;
          if (0 === o3)
            return 0;
          o3 !== t3.length && (i3 = false);
        }
        return i3 ? 2 : 1;
      }
      function Ku(e4, t3) {
        for (const i3 of e4.projections) {
          const r3 = Xu(t3, e4.points[0], i3.axis);
          if (i3.projection[1] < r3[0] || i3.projection[0] > r3[1])
            return 0;
        }
        return 1;
      }
      function Ju(e4, t3) {
        let i3 = 0;
        const r3 = [0, 0, 0, 0];
        for (let n4 = 0; n4 < e4.length; n4++)
          r3[0] = e4[n4][0], r3[1] = e4[n4][1], r3[2] = e4[n4][2], r3[3] = 1, yu.dot(r3, t3) >= 0 && i3++;
        return i3;
      }
      class Qu {
        constructor(e4, t3) {
          this.points = e4 || new Array(8).fill([0, 0, 0]), this.planes = t3 || new Array(6).fill([0, 0, 0, 0]), this.bounds = ed.fromPoints(this.points), this.projections = [], this.frustumEdges = [Du.sub([], this.points[2], this.points[3]), Du.sub([], this.points[0], this.points[3]), Du.sub([], this.points[4], this.points[0]), Du.sub([], this.points[5], this.points[1]), Du.sub([], this.points[6], this.points[2]), Du.sub([], this.points[7], this.points[3])];
          for (const e5 of this.frustumEdges) {
            const t4 = [0, -e5[2], e5[1]], i3 = [e5[2], 0, -e5[0]];
            this.projections.push({ axis: t4, projection: Xu(this.points, this.points[0], t4) }), this.projections.push({ axis: i3, projection: Xu(this.points, this.points[0], i3) });
          }
        }
        static fromInvProjectionMatrix(e4, t3, i3, r3) {
          const n4 = Math.pow(2, i3), o3 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((i4) => {
            const o4 = yu.transformMat4([], i4, e4), s7 = 1 / o4[3] / t3 * n4;
            return yu.mul(o4, o4, [s7, s7, r3 ? 1 / o4[3] : s7, s7]);
          }), s6 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e5) => {
            const t4 = Du.sub([], o3[e5[0]], o3[e5[1]]), i4 = Du.sub([], o3[e5[2]], o3[e5[1]]), r4 = Du.normalize([], Du.cross([], t4, i4)), n5 = -Du.dot(r4, o3[e5[1]]);
            return r4.concat(n5);
          }), a3 = [];
          for (let e5 = 0; e5 < o3.length; e5++)
            a3.push([o3[e5][0], o3[e5][1], o3[e5][2]]);
          return new Qu(a3, s6);
        }
        intersectsPrecise(e4, t3, i3) {
          for (let i4 = 0; i4 < t3.length; i4++)
            if (!Ju(e4, t3[i4]))
              return 0;
          for (let t4 = 0; t4 < this.planes.length; t4++)
            if (!Ju(e4, this.planes[t4]))
              return 0;
          for (const t4 of i3)
            for (const i4 of this.frustumEdges) {
              const r3 = Du.cross([], t4, i4), n4 = Du.length(r3);
              if (0 === n4)
                continue;
              Du.scale(r3, r3, 1 / n4);
              const o3 = Xu(this.points, this.points[0], r3), s6 = Xu(e4, this.points[0], r3);
              if (o3[0] > s6[1] || s6[0] > o3[1])
                return 0;
            }
          return 1;
        }
      }
      class ed {
        static fromPoints(e4) {
          const t3 = [1 / 0, 1 / 0, 1 / 0], i3 = [-1 / 0, -1 / 0, -1 / 0];
          for (const r3 of e4)
            Du.min(t3, t3, r3), Du.max(i3, i3, r3);
          return new ed(t3, i3);
        }
        static fromTileIdAndHeight(e4, t3, i3) {
          const r3 = 1 << e4.canonical.z, n4 = e4.canonical.x, o3 = e4.canonical.y;
          return new ed([n4 / r3, o3 / r3, t3], [(n4 + 1) / r3, (o3 + 1) / r3, i3]);
        }
        static applyTransform(e4, t3) {
          const i3 = e4.getCorners();
          for (let e5 = 0; e5 < i3.length; ++e5)
            Du.transformMat4(i3[e5], i3[e5], t3);
          return ed.fromPoints(i3);
        }
        static projectAabbCorners(e4, t3) {
          const i3 = e4.getCorners();
          for (let e5 = 0; e5 < i3.length; ++e5)
            Du.transformMat4(i3[e5], i3[e5], t3);
          return i3;
        }
        constructor(e4, t3) {
          this.min = e4, this.max = t3, this.center = Du.scale([], Du.add([], this.min, this.max), 0.5);
        }
        quadrant(e4) {
          const t3 = [e4 % 2 == 0, e4 < 2], i3 = Du.clone(this.min), r3 = Du.clone(this.max);
          for (let e5 = 0; e5 < t3.length; e5++)
            i3[e5] = t3[e5] ? this.min[e5] : this.center[e5], r3[e5] = t3[e5] ? this.center[e5] : this.max[e5];
          return r3[2] = this.max[2], new ed(i3, r3);
        }
        distanceX(e4) {
          return Math.max(Math.min(this.max[0], e4[0]), this.min[0]) - e4[0];
        }
        distanceY(e4) {
          return Math.max(Math.min(this.max[1], e4[1]), this.min[1]) - e4[1];
        }
        distanceZ(e4) {
          return Math.max(Math.min(this.max[2], e4[2]), this.min[2]) - e4[2];
        }
        getCorners() {
          const e4 = this.min, t3 = this.max;
          return [[e4[0], e4[1], e4[2]], [t3[0], e4[1], e4[2]], [t3[0], t3[1], e4[2]], [e4[0], t3[1], e4[2]], [e4[0], e4[1], t3[2]], [t3[0], e4[1], t3[2]], [t3[0], t3[1], t3[2]], [e4[0], t3[1], t3[2]]];
        }
        intersects(e4) {
          return this.intersectsAabb(e4.bounds) ? Yu(e4, this.getCorners()) : 0;
        }
        intersectsFlat(e4) {
          return this.intersectsAabb(e4.bounds) ? Yu(e4, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsPrecise(e4, t3) {
          return t3 || this.intersects(e4) ? Ku(e4, this.getCorners()) : 0;
        }
        intersectsPreciseFlat(e4, t3) {
          return t3 || this.intersectsFlat(e4) ? Ku(e4, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsAabb(e4) {
          for (let t3 = 0; t3 < 3; ++t3)
            if (this.min[t3] > e4.max[t3] || e4.min[t3] > this.max[t3])
              return false;
          return true;
        }
        intersectsAabbXY(e4) {
          return !(this.min[0] > e4.max[0] || e4.min[0] > this.max[0] || this.min[1] > e4.max[1] || e4.min[1] > this.max[1]);
        }
        encapsulate(e4) {
          for (let t3 = 0; t3 < 3; t3++)
            this.min[t3] = Math.min(this.min[t3], e4.min[t3]), this.max[t3] = Math.max(this.max[t3], e4.max[t3]);
        }
        encapsulatePoint(e4) {
          for (let t3 = 0; t3 < 3; t3++)
            this.min[t3] = Math.min(this.min[t3], e4[t3]), this.max[t3] = Math.max(this.max[t3], e4[t3]);
        }
        closestPoint(e4) {
          return [Math.max(Math.min(this.max[0], e4[0]), this.min[0]), Math.max(Math.min(this.max[1], e4[1]), this.min[1]), Math.max(Math.min(this.max[2], e4[2]), this.min[2])];
        }
      }
      Rs(ed, "Aabb");
      const td = 5, id = 6, rd = cr / Math.PI / 2, nd = 16383, od = 64, sd = [od, 32, 16], ad = -rd, ld = rd, cd = [new ed([ad, ad, ad], [ld, ld, ld]), new ed([ad, ad, ad], [0, 0, ld]), new ed([0, ad, ad], [ld, 0, ld]), new ed([ad, 0, ad], [0, ld, ld]), new ed([0, 0, ad], [ld, ld, ld])];
      function hd(e4) {
        return e4 * rd / qd;
      }
      function ud(e4, t3, i3, r3 = true) {
        const n4 = Du.scale([], e4._camera.position, e4.worldSize), o3 = [t3, i3, 1, 1];
        yu.transformMat4(o3, o3, e4.pixelMatrixInverse), yu.scale(o3, o3, 1 / o3[3]);
        const s6 = Du.sub([], o3, n4), a3 = Du.normalize([], s6), l3 = e4.globeMatrix, c3 = [l3[12], l3[13], l3[14]], h3 = Du.sub([], c3, n4), u3 = Du.length(h3), d3 = Du.normalize([], h3), p3 = e4.worldSize / (2 * Math.PI), f3 = Du.dot(d3, a3), m3 = Math.asin(p3 / u3);
        if (m3 < Math.acos(f3)) {
          if (!r3)
            return null;
          const e5 = [], t4 = [];
          Du.scale(e5, a3, u3 / f3), Du.normalize(t4, Du.sub(t4, e5, h3)), Du.normalize(a3, Du.add(a3, h3, Du.scale(a3, t4, Math.tan(m3) * u3)));
        }
        const _3 = [];
        new Wu(n4, a3).closestPointOnSphere(c3, p3, _3);
        const g3 = Du.normalize([], ne(l3, 0)), y3 = Du.normalize([], ne(l3, 1)), x3 = Du.normalize([], ne(l3, 2)), v3 = Du.dot(g3, _3), b3 = Du.dot(y3, _3), w3 = Du.dot(x3, _3), E3 = T2(Math.asin(-b3 / p3));
        let M3 = T2(Math.atan2(v3, w3));
        M3 = e4.center.lng + function(e5, t4) {
          const i4 = (t4 - e5 + 180) % 360 - 180;
          return i4 < -180 ? i4 + 360 : i4;
        }(e4.center.lng, M3);
        const A3 = Kd(M3), S3 = z(Jd(E3), 0, 1);
        return new lp(A3, S3);
      }
      class dd {
        constructor(e4, t3, i3) {
          this.a = Du.sub([], e4, i3), this.b = Du.sub([], t3, i3), this.center = i3;
          const r3 = Du.normalize([], this.a), n4 = Du.normalize([], this.b);
          this.angle = Math.acos(Du.dot(r3, n4));
        }
      }
      function pd(e4, t3) {
        if (0 === e4.angle)
          return null;
        let i3;
        return i3 = 0 === e4.a[t3] ? 1 / e4.angle * 0.5 * Math.PI : 1 / e4.angle * Math.atan(e4.b[t3] / e4.a[t3] / Math.sin(e4.angle) - 1 / Math.tan(e4.angle)), i3 < 0 || i3 > 1 ? null : function(e5, t4, i4, r3) {
          const n4 = Math.sin(i4);
          return e5 * (Math.sin((1 - r3) * i4) / n4) + t4 * (Math.sin(r3 * i4) / n4);
        }(e4.a[t3], e4.b[t3], e4.angle, z(i3, 0, 1)) + e4.center[t3];
      }
      function fd(e4) {
        if (e4.z <= 1)
          return cd[e4.z + 2 * e4.y + e4.x];
        const t3 = vd(xd(e4));
        return ed.fromPoints(t3);
      }
      function md(e4, t3, i3) {
        return Du.scale(e4, e4, 1 - i3), Du.scaleAndAdd(e4, e4, t3, i3);
      }
      function _d(e4, t3) {
        const i3 = Dd(t3.zoom);
        if (0 === i3)
          return fd(e4);
        const r3 = xd(e4), n4 = vd(r3), o3 = Kd(r3.getWest()) * t3.worldSize, s6 = Kd(r3.getEast()) * t3.worldSize, a3 = Jd(r3.getNorth()) * t3.worldSize, l3 = Jd(r3.getSouth()) * t3.worldSize, c3 = [o3, a3, 0], h3 = [s6, a3, 0], u3 = [o3, l3, 0], d3 = [s6, l3, 0], p3 = Au.invert([], t3.globeMatrix);
        return Du.transformMat4(c3, c3, p3), Du.transformMat4(h3, h3, p3), Du.transformMat4(u3, u3, p3), Du.transformMat4(d3, d3, p3), n4[0] = md(n4[0], u3, i3), n4[1] = md(n4[1], d3, i3), n4[2] = md(n4[2], h3, i3), n4[3] = md(n4[3], c3, i3), ed.fromPoints(n4);
      }
      function gd(e4, t3, i3) {
        for (const r3 of e4)
          Du.transformMat4(r3, r3, t3), Du.scale(r3, r3, i3);
      }
      function yd(e4, t3, i3, r3) {
        const n4 = t3 / e4.worldSize, o3 = e4.globeMatrix;
        if (i3.z <= 1) {
          const e5 = fd(i3).getCorners();
          return gd(e5, o3, n4), ed.fromPoints(e5);
        }
        const s6 = xd(i3, r3), a3 = vd(s6);
        gd(a3, o3, n4);
        const l3 = Number.MAX_VALUE, c3 = [-l3, -l3, -l3], h3 = [l3, l3, l3];
        if (s6.contains(e4.center)) {
          for (const e5 of a3)
            Du.min(h3, h3, e5), Du.max(c3, c3, e5);
          c3[2] = 0;
          const t4 = e4.point, i4 = [t4.x * n4, t4.y * n4, 0];
          return Du.min(h3, h3, i4), Du.max(c3, c3, i4), new ed(h3, c3);
        }
        const u3 = [o3[12] * n4, o3[13] * n4, o3[14] * n4], d3 = s6.getCenter(), p3 = z(e4.center.lat, -rp, rp), f3 = z(d3.lat, -rp, rp), m3 = Kd(e4.center.lng), _3 = Jd(p3);
        let g3 = m3 - Kd(d3.lng);
        const y3 = _3 - Jd(f3);
        g3 > 0.5 ? g3 -= 1 : g3 < -0.5 && (g3 += 1);
        let x3 = 0;
        if (Math.abs(g3) > Math.abs(y3))
          x3 = g3 >= 0 ? 1 : 3;
        else {
          x3 = y3 >= 0 ? 0 : 2;
          const e5 = [o3[4] * n4, o3[5] * n4, o3[6] * n4], t4 = -Math.sin(w2(y3 >= 0 ? s6.getSouth() : s6.getNorth())) * rd;
          Du.scaleAndAdd(u3, u3, e5, t4);
        }
        const v3 = a3[x3], b3 = a3[(x3 + 1) % 4], T3 = new dd(v3, b3, u3), E3 = [pd(T3, 0) || v3[0], pd(T3, 1) || v3[1], pd(T3, 2) || v3[2]], M3 = Dd(e4.zoom);
        if (M3 > 0) {
          const r4 = function({ x: e5, y: t4, z: i4 }, r5, n6, o4, s7) {
            const a4 = 1 / (1 << i4);
            let l4 = e5 * a4, c4 = l4 + a4, h4 = t4 * a4, u4 = h4 + a4, d4 = 0;
            const p4 = (l4 + c4) / 2 - o4;
            return p4 > 0.5 ? d4 = -1 : p4 < -0.5 && (d4 = 1), l4 = ((l4 + d4) * r5 - (o4 *= r5)) * n6 + o4, c4 = ((c4 + d4) * r5 - o4) * n6 + o4, h4 = (h4 * r5 - (s7 *= r5)) * n6 + s7, u4 = (u4 * r5 - s7) * n6 + s7, [[l4, u4, 0], [c4, u4, 0], [c4, h4, 0], [l4, h4, 0]];
          }(i3, t3, e4._pixelsPerMercatorPixel, m3, _3);
          for (let e5 = 0; e5 < a3.length; e5++)
            md(a3[e5], r4[e5], M3);
          const n5 = Du.add([], r4[x3], r4[(x3 + 1) % 4]);
          Du.scale(n5, n5, 0.5), md(E3, n5, M3);
        }
        for (const e5 of a3)
          Du.min(h3, h3, e5), Du.max(c3, c3, e5);
        return h3[2] = Math.min(v3[2], b3[2]), Du.min(h3, h3, E3), Du.max(c3, c3, E3), new ed(h3, c3);
      }
      function xd({ x: e4, y: t3, z: i3 }, r3 = false) {
        const n4 = 1 / (1 << i3), o3 = new Wd(ep(e4 * n4), t3 === (1 << i3) - 1 && r3 ? -90 : tp((t3 + 1) * n4)), s6 = new Wd(ep((e4 + 1) * n4), 0 === t3 && r3 ? 90 : tp(t3 * n4));
        return new sc(o3, s6);
      }
      function vd(e4) {
        const t3 = w2(e4.getNorth()), i3 = w2(e4.getSouth()), r3 = Math.cos(t3), n4 = Math.cos(i3), o3 = Math.sin(t3), s6 = Math.sin(i3), a3 = e4.getWest(), l3 = e4.getEast();
        return [bd(n4, s6, a3), bd(n4, s6, l3), bd(r3, o3, l3), bd(r3, o3, a3)];
      }
      function bd(e4, t3, i3, r3 = rd) {
        return i3 = w2(i3), [e4 * Math.sin(i3) * r3, -t3 * r3, e4 * Math.cos(i3) * r3];
      }
      function wd(e4, t3, i3) {
        return bd(Math.cos(w2(e4)), Math.sin(w2(e4)), t3, i3);
      }
      function Td(e4, t3, i3, r3) {
        const n4 = 1 << i3.z, o3 = (e4 / cr + i3.x) / n4;
        return wd(tp((t3 / cr + i3.y) / n4), ep(o3), r3);
      }
      function Ed({ min: e4, max: t3 }) {
        return nd / Math.max(t3[0] - e4[0], t3[1] - e4[1], t3[2] - e4[2]);
      }
      const Md = new Float64Array(16);
      function Ad(e4) {
        const t3 = Ed(e4), i3 = Au.fromScaling(Md, [t3, t3, t3]);
        return Au.translate(i3, i3, Du.negate([], e4.min));
      }
      function Sd(e4) {
        const t3 = Au.fromTranslation(Md, e4.min), i3 = 1 / Ed(e4);
        return Au.scale(t3, t3, [i3, i3, i3]);
      }
      function Id(e4) {
        const t3 = cr / (2 * Math.PI);
        return e4 / (2 * Math.PI) / t3;
      }
      function Cd(e4, t3) {
        return cr / (512 * Math.pow(2, e4)) * Ed(fd(t3));
      }
      function zd(e4, t3, i3, r3, n4) {
        const o3 = Id(i3), s6 = [e4, t3, -i3 / (2 * Math.PI)], a3 = Au.identity(new Float64Array(16));
        return Au.translate(a3, a3, s6), Au.scale(a3, a3, [o3, o3, o3]), Au.rotateX(a3, a3, w2(-n4)), Au.rotateY(a3, a3, w2(-r3)), a3;
      }
      function Pd(e4) {
        const t3 = e4.pixelsPerMeter, i3 = t3 / Qd(1, e4.center.lat), r3 = Au.identity(new Float64Array(16));
        return Au.translate(r3, r3, [e4.point.x, e4.point.y, 0]), Au.scale(r3, r3, [i3, i3, t3]), Float32Array.from(r3);
      }
      function Dd(e4) {
        return P2(td, id, e4);
      }
      function Rd(e4, t3, i3) {
        const r3 = Au.identity(new Float64Array(16)), n4 = (t3 / (1 << e4) - 0.5) * Math.PI * 2;
        return Au.rotateY(r3, i3.globeMatrix, n4), Float32Array.from(r3);
      }
      function Ld(e4, t3, i3) {
        const r3 = Dd(i3.zoom), n4 = e4.style.map._antialias, o3 = t3.options.extStandardDerivativesForceOff || e4.terrain && e4.terrain.exaggeration() > 0;
        return 0 === r3 && !n4 && !o3;
      }
      function kd(e4, t3, i3, r3) {
        const n4 = t3.getNorth(), o3 = t3.getSouth(), s6 = t3.getWest(), a3 = t3.getEast(), l3 = 1 << e4.z, c3 = a3 - s6, h3 = n4 - o3, u3 = c3 / od, d3 = -h3 / sd[i3], p3 = [0, u3, 0, d3, 0, 0, n4, s6, 0];
        if (e4.z > 0) {
          const e5 = 180 / r3;
          Eu.multiply(p3, p3, [e5 / c3 + 1, 0, 0, 0, e5 / h3 + 1, 0, -0.5 * e5 / u3, 0.5 * e5 / d3, 1]);
        }
        return p3[2] = l3, p3[5] = e4.x, p3[8] = e4.y, p3;
      }
      function Od(e4) {
        const t3 = rp - 5;
        e4 = z(e4, -t3, t3) / t3 * 90;
        const i3 = Math.pow(Math.abs(Math.sin(w2(e4))), 3);
        return Math.round(i3 * (sd.length - 1));
      }
      function Bd(e4) {
        const t3 = [0, 0, 0], i3 = Au.identity(new Float64Array(16));
        return Au.multiply(i3, e4.pixelMatrix, e4.globeMatrix), Du.transformMat4(t3, t3, i3), new y2(t3[0], t3[1]);
      }
      function Fd(e4, t3) {
        const i3 = wd(t3.lat, t3.lng), r3 = function(e5) {
          const t4 = wd(e5._center.lat, e5._center.lng), i4 = Du.fromValues(0, 1, 0);
          let r4 = Du.cross([], i4, t4);
          const n5 = Au.fromRotation([], -e5.angle, t4);
          r4 = Du.transformMat4(r4, r4, n5), Au.fromRotation(n5, -e5._pitch, r4);
          const o3 = Du.normalize([], t4);
          return Du.scale(o3, o3, hd(e5.cameraToCenterDistance / e5.pixelsPerMeter)), Du.transformMat4(o3, o3, n5), Du.add([], t4, o3);
        }(e4), n4 = Du.subtract([], r3, i3);
        return Du.angle(n4, i3);
      }
      function Nd(e4, t3) {
        return Fd(e4, t3) > Math.PI / 2 * 1.01;
      }
      const Ud = w2(85), Vd = Math.cos(Ud), jd = Math.sin(Ud);
      class Gd {
        constructor(e4) {
          this._createGrid(e4), this._createPoles(e4);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const e4 of this._poleSegments)
            e4.destroy();
          for (const e4 of this._gridSegments)
            e4.withSkirts.destroy(), e4.withoutSkirts.destroy();
        }
        _fillGridMeshWithLods(e4, t3) {
          const i3 = new za(), r3 = new Wa(), n4 = [], o3 = e4 + 1 + 2, s6 = t3[0] + 1, a3 = t3[0] + 1 + (1 + t3.length), l3 = (e5, t4, i4) => {
            let r4 = e5 === o3 - 1 ? e5 - 2 : 0 === e5 ? e5 : e5 - 1;
            return r4 += i4 ? 24575 : 0, [r4, t4];
          };
          for (let e5 = 0; e5 < o3; ++e5)
            i3.emplaceBack(...l3(e5, 0, true));
          for (let e5 = 0; e5 < s6; ++e5)
            for (let t4 = 0; t4 < o3; ++t4)
              i3.emplaceBack(...l3(t4, e5, (0 === t4 || t4 === o3 - 1) && true));
          for (let e5 = 0; e5 < t3.length; ++e5) {
            const r4 = t3[e5];
            for (let e6 = 0; e6 < o3; ++e6)
              i3.emplaceBack(...l3(e6, r4, true));
          }
          for (let e5 = 0; e5 < t3.length; ++e5) {
            const s7 = r3.length, l4 = t3[e5] + 1 + 2, c3 = new Wa();
            for (let i4 = 0; i4 < l4 - 1; i4++) {
              const n5 = i4 === l4 - 2, s8 = n5 ? o3 * (a3 - t3.length + e5 - i4) : o3;
              for (let e6 = 0; e6 < o3 - 1; e6++) {
                const t4 = i4 * o3 + e6;
                0 === i4 || n5 || 0 === e6 || e6 === o3 - 2 ? (c3.emplaceBack(t4 + 1, t4, t4 + s8), c3.emplaceBack(t4 + s8, t4 + s8 + 1, t4 + 1)) : (r3.emplaceBack(t4 + 1, t4, t4 + s8), r3.emplaceBack(t4 + s8, t4 + s8 + 1, t4 + 1));
              }
            }
            const h3 = xl.simpleSegment(0, s7, i3.length, r3.length - s7);
            for (let e6 = 0; e6 < c3.uint16.length; e6 += 3)
              r3.emplaceBack(c3.uint16[e6], c3.uint16[e6 + 1], c3.uint16[e6 + 2]);
            const u3 = xl.simpleSegment(0, s7, i3.length, r3.length - s7);
            n4.push({ withoutSkirts: h3, withSkirts: u3 });
          }
          return { vertices: i3, indices: r3, segments: n4 };
        }
        _createGrid(e4) {
          const t3 = this._fillGridMeshWithLods(od, sd);
          this._gridSegments = t3.segments, this._gridBuffer = e4.createVertexBuffer(t3.vertices, Nu.members), this._gridIndexBuffer = e4.createIndexBuffer(t3.indices, true);
        }
        _createPoles(e4) {
          const t3 = new Wa();
          for (let e5 = 0; e5 <= od; e5++)
            t3.emplaceBack(0, e5 + 1, e5 + 2);
          this._poleIndexBuffer = e4.createIndexBuffer(t3, true);
          const i3 = new Ka(), r3 = new Ka(), n4 = new Ka(), o3 = new Ka();
          this._poleSegments = [];
          for (let e5 = 0, t4 = 0; e5 < td; e5++) {
            const s6 = 360 / (1 << e5);
            i3.emplaceBack(0, -rd, 0, 0.5, 0), r3.emplaceBack(0, -rd, 0, 0.5, 1), n4.emplaceBack(0, -rd, 0, 0.5, 0.5), o3.emplaceBack(0, -rd, 0, 0.5, 0.5);
            for (let e6 = 0; e6 <= od; e6++) {
              let t5 = e6 / od, a3 = 0;
              const l3 = Kr(0, s6, t5), [c3, h3, u3] = bd(Vd, jd, l3, rd);
              i3.emplaceBack(c3, h3, u3, t5, a3), r3.emplaceBack(c3, h3, u3, t5, 1 - a3);
              const d3 = w2(l3);
              t5 = 0.5 + 0.5 * Math.sin(d3), a3 = 0.5 + 0.5 * Math.cos(d3), n4.emplaceBack(c3, h3, u3, t5, a3), o3.emplaceBack(c3, h3, u3, t5, 1 - a3);
            }
            this._poleSegments.push(xl.simpleSegment(t4, 0, 66, 64)), t4 += 66;
          }
          this._poleNorthVertexBuffer = e4.createVertexBuffer(i3, Bu, false), this._poleSouthVertexBuffer = e4.createVertexBuffer(r3, Bu, false), this._texturedPoleNorthVertexBuffer = e4.createVertexBuffer(n4, Bu, false), this._texturedPoleSouthVertexBuffer = e4.createVertexBuffer(o3, Bu, false);
        }
        getGridBuffers(e4, t3) {
          return [this._gridBuffer, this._gridIndexBuffer, t3 ? this._gridSegments[e4].withSkirts : this._gridSegments[e4].withoutSkirts];
        }
        getPoleBuffers(e4, t3) {
          return [t3 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, t3 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[e4]];
        }
      }
      const qd = 63710088e-1, Zd = 2 * Math.PI * qd;
      class $d {
        constructor(e4, t3) {
          if (isNaN(e4) || isNaN(t3))
            throw new Error(`Invalid LngLat object: (${e4}, ${t3})`);
          if (this.lng = +e4, this.lat = +t3, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new $d(D(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e4) {
          const t3 = Math.PI / 180, i3 = this.lat * t3, r3 = e4.lat * t3, n4 = Math.sin(i3) * Math.sin(r3) + Math.cos(i3) * Math.cos(r3) * Math.cos((e4.lng - this.lng) * t3);
          return qd * Math.acos(Math.min(n4, 1));
        }
        toBounds(e4 = 0) {
          const t3 = 360 * e4 / 40075017, i3 = t3 / Math.cos(Math.PI / 180 * this.lat);
          return new sc(new $d(this.lng - i3, this.lat - t3), new $d(this.lng + i3, this.lat + t3));
        }
        toEcef(e4) {
          const t3 = hd(e4);
          return wd(this.lat, this.lng, rd + t3);
        }
        static convert(e4) {
          if (e4 instanceof $d)
            return e4;
          if (Array.isArray(e4) && (2 === e4.length || 3 === e4.length))
            return new $d(Number(e4[0]), Number(e4[1]));
          if (!Array.isArray(e4) && "object" == typeof e4 && null !== e4)
            return new $d(Number("lng" in e4 ? e4.lng : e4.lon), Number(e4.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      var Wd = $d;
      const Hd = 0, Xd = 25.5;
      function Yd(e4) {
        return Zd * Math.cos(e4 * Math.PI / 180);
      }
      function Kd(e4) {
        return (180 + e4) / 360;
      }
      function Jd(e4) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e4 * Math.PI / 360))) / 360;
      }
      function Qd(e4, t3) {
        return e4 / Yd(t3);
      }
      function ep(e4) {
        return 360 * e4 - 180;
      }
      function tp(e4) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e4) * Math.PI / 180)) - 90;
      }
      function ip(e4, t3) {
        return e4 * Yd(tp(t3));
      }
      const rp = 85.051129;
      function np(e4) {
        return Math.cos(w2(z(e4, -rp, rp)));
      }
      function op(e4, t3) {
        const i3 = z(t3, Hd, Xd), r3 = Math.pow(2, i3);
        return np(e4) * Zd / (512 * r3);
      }
      function sp(e4) {
        return 1 / Math.cos(e4 * Math.PI / 180);
      }
      function ap(e4, t3 = 0) {
        const i3 = Math.exp(Math.PI * (1 - (e4.y + t3 / cr) / (1 << e4.z) * 2));
        return 80150034 * i3 / (i3 * i3 + 1) / cr / (1 << e4.z);
      }
      class lp {
        constructor(e4, t3, i3 = 0) {
          this.x = +e4, this.y = +t3, this.z = +i3;
        }
        static fromLngLat(e4, t3 = 0) {
          const i3 = Wd.convert(e4);
          return new lp(Kd(i3.lng), Jd(i3.lat), Qd(t3, i3.lat));
        }
        toLngLat() {
          return new Wd(ep(this.x), tp(this.y));
        }
        toAltitude() {
          return ip(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Zd * sp(tp(this.y));
        }
      }
      function cp(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        const c3 = (t3 + r3) / 2, h3 = (i3 + n4) / 2, u3 = new y2(c3, h3);
        a3(u3), function(e5, t4, i4, r4, n5, o4) {
          const s7 = i4 - n5, a4 = r4 - o4;
          return Math.abs((r4 - t4) * s7 - (i4 - e5) * a4) / Math.hypot(s7, a4);
        }(u3.x, u3.y, o3.x, o3.y, s6.x, s6.y) >= l3 ? (cp(e4, t3, i3, c3, h3, o3, u3, a3, l3), cp(e4, c3, h3, r3, n4, u3, s6, a3, l3)) : e4.push(s6);
      }
      function hp(e4, t3, i3) {
        let r3 = e4[0], n4 = r3.x, o3 = r3.y;
        t3(r3);
        const s6 = [r3];
        for (let a3 = 1; a3 < e4.length; a3++) {
          const l3 = e4[a3], { x: c3, y: h3 } = l3;
          t3(l3), cp(s6, n4, o3, c3, h3, r3, l3, t3, i3), n4 = c3, o3 = h3, r3 = l3;
        }
        return s6;
      }
      function up(e4, t3, i3, r3) {
        if (r3(t3, i3)) {
          const n4 = t3.add(i3)._mult(0.5);
          up(e4, t3, n4, r3), up(e4, n4, i3, r3);
        } else
          e4.push(i3);
      }
      function dp(e4, t3) {
        let i3 = e4[0];
        const r3 = [i3];
        for (let n4 = 1; n4 < e4.length; n4++) {
          const o3 = e4[n4];
          up(r3, i3, o3, t3), i3 = o3;
        }
        return r3;
      }
      const pp = Math.pow(2, 14) - 1, fp = -pp - 1;
      function mp(e4, t3) {
        const i3 = Math.round(e4.x * t3), r3 = Math.round(e4.y * t3);
        return e4.x = z(i3, fp, pp), e4.y = z(r3, fp, pp), (i3 < e4.x || i3 > e4.x + 1 || r3 < e4.y || r3 > e4.y + 1) && H2("Geometry exceeds allowed extent, reduce your vector tile buffer size"), e4;
      }
      function _p(e4, t3, i3) {
        const r3 = e4.loadGeometry(), n4 = e4.extent, o3 = cr / n4;
        if (t3 && i3 && i3.projection.isReprojectedInTileSpace) {
          const o4 = 1 << t3.z, { scale: s6, x: a3, y: l3, projection: c3 } = i3, h3 = (e5) => {
            const i4 = ep((t3.x + e5.x / n4) / o4), r4 = tp((t3.y + e5.y / n4) / o4), h4 = c3.project(i4, r4);
            e5.x = (h4.x * s6 - a3) * n4, e5.y = (h4.y * s6 - l3) * n4;
          };
          for (let t4 = 0; t4 < r3.length; t4++)
            if (1 !== e4.type)
              r3[t4] = hp(r3[t4], h3, 1);
            else {
              const e5 = [];
              for (const i4 of r3[t4])
                i4.x < 0 || i4.x >= n4 || i4.y < 0 || i4.y >= n4 || (h3(i4), e5.push(i4));
              r3[t4] = e5;
            }
        }
        for (const e5 of r3)
          for (const t4 of e5)
            mp(t4, o3);
        return r3;
      }
      function gp(e4, t3) {
        return { type: e4.type, id: e4.id, properties: e4.properties, geometry: t3 ? _p(e4) : [] };
      }
      function yp(e4, t3, i3, r3, n4) {
        e4.emplaceBack(2 * t3 + (r3 + 1) / 2, 2 * i3 + (n4 + 1) / 2);
      }
      function xp(e4, t3, i3) {
        const r3 = 16384;
        e4.emplaceBack(t3.x, t3.y, t3.z, i3[0] * r3, i3[1] * r3, i3[2] * r3);
      }
      class vp {
        constructor(e4) {
          this.zoom = e4.zoom, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((e5) => e5.fqid), this.index = e4.index, this.hasPattern = false, this.projection = e4.projection, this.layoutVertexArray = new za(), this.indexArray = new Wa(), this.segments = new xl(), this.programConfigurations = new ec(e4.layers, e4.zoom), this.stateDependentLayerIds = this.layers.filter((e5) => e5.isStateDependent()).map((e5) => e5.id);
        }
        populate(e4, t3, i3, r3) {
          const n4 = this.layers[0], o3 = [];
          let s6 = null;
          "circle" === n4.type && (s6 = n4.layout.get("circle-sort-key"));
          for (const { feature: t4, id: n5, index: a4, sourceLayerIndex: l3 } of e4) {
            const e5 = this.layers[0]._featureFilter.needGeometry, c3 = gp(t4, e5);
            if (!this.layers[0]._featureFilter.filter(new oa(this.zoom), c3, i3))
              continue;
            const h3 = s6 ? s6.evaluate(c3, {}, i3) : void 0, u3 = { id: n5, properties: t4.properties, type: t4.type, sourceLayerIndex: l3, index: a4, geometry: e5 ? c3.geometry : _p(t4, i3, r3), patterns: {}, sortKey: h3 };
            o3.push(u3);
          }
          s6 && o3.sort((e5, t4) => e5.sortKey - t4.sortKey);
          let a3 = null;
          "globe" === r3.projection.name && (this.globeExtVertexArray = new Fa(), a3 = r3.projection);
          for (const r4 of o3) {
            const { geometry: n5, index: o4, sourceLayerIndex: s7 } = r4, l3 = e4[o4].feature;
            this.addFeature(r4, n5, o4, t3.availableImages, i3, a3, t3.brightness), t3.featureIndex.insert(l3, n5, o4, s7, this.index);
          }
        }
        update(e4, t3, i3, r3, n4) {
          const o3 = 0 !== Object.keys(e4).length;
          o3 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(e4, t3, o3 ? this.stateDependentLayers : this.layers, i3, r3, n4);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e4) {
          this.uploaded || (this.layoutVertexBuffer = e4.createVertexBuffer(this.layoutVertexArray, gl.members), this.indexBuffer = e4.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e4.createVertexBuffer(this.globeExtVertexArray, yl.members))), this.programConfigurations.upload(e4), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(e4, t3, i3, r3, n4, o3, s6) {
          for (const i4 of t3)
            for (const t4 of i4) {
              const i5 = t4.x, r4 = t4.y;
              if (i5 < 0 || i5 >= cr || r4 < 0 || r4 >= cr)
                continue;
              if (o3) {
                const e5 = o3.projectTilePoint(i5, r4, n4), t5 = o3.upVector(n4, i5, r4), s8 = this.globeExtVertexArray;
                xp(s8, e5, t5), xp(s8, e5, t5), xp(s8, e5, t5), xp(s8, e5, t5);
              }
              const s7 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e4.sortKey), a3 = s7.vertexLength;
              yp(this.layoutVertexArray, i5, r4, -1, -1), yp(this.layoutVertexArray, i5, r4, 1, -1), yp(this.layoutVertexArray, i5, r4, 1, 1), yp(this.layoutVertexArray, i5, r4, -1, 1), this.indexArray.emplaceBack(a3, a3 + 1, a3 + 2), this.indexArray.emplaceBack(a3, a3 + 2, a3 + 3), s7.vertexLength += 4, s7.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e4, i3, {}, r3, n4, s6);
        }
      }
      function bp(e4, t3) {
        for (let i3 = 0; i3 < e4.length; i3++)
          if (zp(t3, e4[i3]))
            return true;
        for (let i3 = 0; i3 < t3.length; i3++)
          if (zp(e4, t3[i3]))
            return true;
        return !!Mp(e4, t3);
      }
      function wp(e4, t3, i3) {
        return !!zp(e4, t3) || !!Sp(t3, e4, i3);
      }
      function Tp(e4, t3) {
        if (1 === e4.length)
          return Cp(t3, e4[0]);
        for (let i3 = 0; i3 < t3.length; i3++) {
          const r3 = t3[i3];
          for (let t4 = 0; t4 < r3.length; t4++)
            if (zp(e4, r3[t4]))
              return true;
        }
        for (let i3 = 0; i3 < e4.length; i3++)
          if (Cp(t3, e4[i3]))
            return true;
        for (let i3 = 0; i3 < t3.length; i3++)
          if (Mp(e4, t3[i3]))
            return true;
        return false;
      }
      function Ep(e4, t3, i3) {
        if (e4.length > 1) {
          if (Mp(e4, t3))
            return true;
          for (let r3 = 0; r3 < t3.length; r3++)
            if (Sp(t3[r3], e4, i3))
              return true;
        }
        for (let r3 = 0; r3 < e4.length; r3++)
          if (Sp(e4[r3], t3, i3))
            return true;
        return false;
      }
      function Mp(e4, t3) {
        if (0 === e4.length || 0 === t3.length)
          return false;
        for (let i3 = 0; i3 < e4.length - 1; i3++) {
          const r3 = e4[i3], n4 = e4[i3 + 1];
          for (let e5 = 0; e5 < t3.length - 1; e5++)
            if (Ap(r3, n4, t3[e5], t3[e5 + 1]))
              return true;
        }
        return false;
      }
      function Ap(e4, t3, i3, r3) {
        return X(e4, i3, r3) !== X(t3, i3, r3) && X(e4, t3, i3) !== X(e4, t3, r3);
      }
      function Sp(e4, t3, i3) {
        const r3 = i3 * i3;
        if (1 === t3.length)
          return e4.distSqr(t3[0]) < r3;
        for (let i4 = 1; i4 < t3.length; i4++)
          if (Ip(e4, t3[i4 - 1], t3[i4]) < r3)
            return true;
        return false;
      }
      function Ip(e4, t3, i3) {
        const r3 = t3.distSqr(i3);
        if (0 === r3)
          return e4.distSqr(t3);
        const n4 = ((e4.x - t3.x) * (i3.x - t3.x) + (e4.y - t3.y) * (i3.y - t3.y)) / r3;
        return e4.distSqr(n4 < 0 ? t3 : n4 > 1 ? i3 : i3.sub(t3)._mult(n4)._add(t3));
      }
      function Cp(e4, t3) {
        let i3, r3, n4, o3 = false;
        for (let s6 = 0; s6 < e4.length; s6++) {
          i3 = e4[s6];
          for (let e5 = 0, s7 = i3.length - 1; e5 < i3.length; s7 = e5++)
            r3 = i3[e5], n4 = i3[s7], r3.y > t3.y != n4.y > t3.y && t3.x < (n4.x - r3.x) * (t3.y - r3.y) / (n4.y - r3.y) + r3.x && (o3 = !o3);
        }
        return o3;
      }
      function zp(e4, t3) {
        let i3 = false;
        for (let r3 = 0, n4 = e4.length - 1; r3 < e4.length; n4 = r3++) {
          const o3 = e4[r3], s6 = e4[n4];
          o3.y > t3.y != s6.y > t3.y && t3.x < (s6.x - o3.x) * (t3.y - o3.y) / (s6.y - o3.y) + o3.x && (i3 = !i3);
        }
        return i3;
      }
      function Pp(e4, t3, i3, r3, n4) {
        for (const o4 of e4)
          if (t3 <= o4.x && i3 <= o4.y && r3 >= o4.x && n4 >= o4.y)
            return true;
        const o3 = [new y2(t3, i3), new y2(t3, n4), new y2(r3, n4), new y2(r3, i3)];
        if (e4.length > 2) {
          for (const t4 of o3)
            if (zp(e4, t4))
              return true;
        }
        for (let t4 = 0; t4 < e4.length - 1; t4++)
          if (Dp(e4[t4], e4[t4 + 1], o3))
            return true;
        return false;
      }
      function Dp(e4, t3, i3) {
        const r3 = i3[0], n4 = i3[2];
        if (e4.x < r3.x && t3.x < r3.x || e4.x > n4.x && t3.x > n4.x || e4.y < r3.y && t3.y < r3.y || e4.y > n4.y && t3.y > n4.y)
          return false;
        const o3 = X(e4, t3, i3[0]);
        return o3 !== X(e4, t3, i3[1]) || o3 !== X(e4, t3, i3[2]) || o3 !== X(e4, t3, i3[3]);
      }
      function Rp(e4, t3, i3, r3, n4, o3) {
        let s6 = t3.y - e4.y, a3 = e4.x - t3.x;
        if (o3 = o3 || 0) {
          const e5 = s6 * s6 + a3 * a3;
          if (0 === e5)
            return true;
          const t4 = Math.sqrt(e5);
          s6 /= t4, a3 /= t4;
        }
        return !((i3.x - e4.x) * s6 + (i3.y - e4.y) * a3 - o3 < 0 || (r3.x - e4.x) * s6 + (r3.y - e4.y) * a3 - o3 < 0 || (n4.x - e4.x) * s6 + (n4.y - e4.y) * a3 - o3 < 0);
      }
      function Lp(e4, t3, i3, r3, n4, o3, s6) {
        return !(Rp(e4, t3, r3, n4, o3, s6) || Rp(t3, i3, r3, n4, o3, s6) || Rp(i3, e4, r3, n4, o3, s6) || Rp(r3, n4, e4, t3, i3, s6) || Rp(n4, o3, e4, t3, i3, s6) || Rp(o3, r3, e4, t3, i3, s6));
      }
      function kp(e4, t3, i3) {
        const r3 = t3.paint.get(e4).value;
        return "constant" === r3.kind ? r3.value : i3.programConfigurations.get(t3.id).getMaxValue(e4);
      }
      function Op(e4) {
        return Math.sqrt(e4[0] * e4[0] + e4[1] * e4[1]);
      }
      function Bp(e4, t3, i3, r3, n4) {
        if (!t3[0] && !t3[1])
          return e4;
        const o3 = y2.convert(t3)._mult(n4);
        "viewport" === i3 && o3._rotate(-r3);
        const s6 = [];
        for (let t4 = 0; t4 < e4.length; t4++)
          s6.push(e4[t4].sub(o3));
        return s6;
      }
      function Fp(e4, t3, i3, r3) {
        const n4 = y2.convert(e4)._mult(r3);
        return "viewport" === t3 && n4._rotate(-i3), n4;
      }
      Rs(vp, "CircleBucket", { omit: ["layers"] });
      const Np = new ga({ "circle-sort-key": new ma(Pt.layout_circle["circle-sort-key"]), visibility: new fa(Pt.layout_circle.visibility) });
      var Up = { paint: new ga({ "circle-radius": new ma(Pt.paint_circle["circle-radius"]), "circle-color": new ma(Pt.paint_circle["circle-color"]), "circle-blur": new ma(Pt.paint_circle["circle-blur"]), "circle-opacity": new ma(Pt.paint_circle["circle-opacity"]), "circle-translate": new fa(Pt.paint_circle["circle-translate"]), "circle-translate-anchor": new fa(Pt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new fa(Pt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new fa(Pt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ma(Pt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ma(Pt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ma(Pt.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new fa(Pt.paint_circle["circle-emissive-strength"]) }), layout: Np };
      const Vp = Au.create(), jp = (e4, t3, i3, r3, n4, o3) => {
        const s6 = e4.transform, a3 = "globe" === s6.projection.name;
        let l3;
        if ("map" === o3.paint.get("circle-pitch-alignment"))
          if (a3) {
            const e5 = Cd(s6.zoom, t3.canonical) * s6._pixelsPerMercatorPixel;
            l3 = Float32Array.from([e5, 0, 0, e5]);
          } else
            l3 = s6.calculatePixelsToTileUnitsMatrix(i3);
        else
          l3 = new Float32Array([s6.pixelsToGLUnits[0], 0, 0, s6.pixelsToGLUnits[1]]);
        const c3 = { u_camera_to_center_distance: e4.transform.getCameraToCenterDistance(s6.projection), u_matrix: e4.translatePosMatrix(t3.projMatrix, i3, o3.paint.get("circle-translate"), o3.paint.get("circle-translate-anchor")), u_device_pixel_ratio: dt.devicePixelRatio, u_extrude_scale: l3, u_inv_rot_matrix: Vp, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: o3.paint.get("circle-emissive-strength") };
        if (a3) {
          c3.u_inv_rot_matrix = r3, c3.u_merc_center = n4, c3.u_tile_id = [t3.canonical.x, t3.canonical.y, 1 << t3.canonical.z], c3.u_zoom_transition = Dd(s6.zoom);
          const e5 = n4[0] * cr, i4 = n4[1] * cr;
          c3.u_up_dir = s6.projection.upVector(new ju(0, 0, 0), e5, i4);
        }
        return c3;
      }, Gp = (e4) => {
        const t3 = [];
        return "map" === e4.paint.get("circle-pitch-alignment") && t3.push("PITCH_WITH_MAP"), "map" === e4.paint.get("circle-pitch-scale") && t3.push("SCALE_WITH_MAP"), t3;
      };
      function qp(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        if (o3 && e4.queryGeometry.isAboveHorizon)
          return false;
        o3 && (l3 *= e4.pixelToTileUnitsFactor);
        const c3 = e4.tileID.canonical, h3 = i3.projection.upVectorScale(c3, i3.center.lat, i3.worldSize).metersToTile;
        for (const u3 of t3)
          for (const t4 of u3) {
            const u4 = t4.add(a3), d3 = n4 && i3.elevation ? i3.elevation.exaggeration() * n4.getElevationAt(u4.x, u4.y, true) : 0, p3 = i3.projection.projectTilePoint(u4.x, u4.y, c3);
            if (d3 > 0) {
              const e5 = i3.projection.upVector(c3, u4.x, u4.y);
              p3.x += e5[0] * h3 * d3, p3.y += e5[1] * h3 * d3, p3.z += e5[2] * h3 * d3;
            }
            const f3 = o3 ? u4 : Zp(p3.x, p3.y, p3.z, r3), m3 = o3 ? e4.tilespaceRays.map((e5) => Hp(e5, d3)) : e4.queryGeometry.screenGeometry, _3 = yu.transformMat4([], [p3.x, p3.y, p3.z, 1], r3);
            if (!s6 && o3 ? l3 *= _3[3] / i3.cameraToCenterDistance : s6 && !o3 && (l3 *= i3.cameraToCenterDistance / _3[3]), o3) {
              const e5 = tp((t4.y / cr + c3.y) / (1 << c3.z));
              l3 /= i3.projection.pixelsPerMeter(e5, 1) / Qd(1, e5);
            }
            if (wp(m3, f3, l3))
              return true;
          }
        return false;
      }
      function Zp(e4, t3, i3, r3) {
        const n4 = yu.transformMat4([], [e4, t3, i3, 1], r3);
        return new y2(n4[0] / n4[3], n4[1] / n4[3]);
      }
      const $p = Du.fromValues(0, 0, 0), Wp = Du.fromValues(0, 0, 1);
      function Hp(e4, t3) {
        const i3 = Du.create();
        return $p[2] = t3, e4.intersectsPlane($p, Wp, i3), new y2(i3[0], i3[1]);
      }
      class Xp extends vp {
      }
      function Yp(e4, { width: t3, height: i3 }, r3, n4) {
        if (n4) {
          if (n4 instanceof Uint8ClampedArray)
            n4 = new Uint8Array(n4.buffer);
          else if (n4.length !== t3 * i3 * r3)
            throw new RangeError("mismatched image size");
        } else
          n4 = new Uint8Array(t3 * i3 * r3);
        return e4.width = t3, e4.height = i3, e4.data = n4, e4;
      }
      function Kp(e4, t3, i3) {
        const { width: r3, height: n4 } = t3;
        r3 === e4.width && n4 === e4.height || (Jp(e4, t3, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(e4.width, r3), height: Math.min(e4.height, n4) }, i3), e4.width = r3, e4.height = n4, e4.data = t3.data);
      }
      function Jp(e4, t3, i3, r3, n4, o3) {
        if (0 === n4.width || 0 === n4.height)
          return t3;
        if (n4.width > e4.width || n4.height > e4.height || i3.x > e4.width - n4.width || i3.y > e4.height - n4.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (n4.width > t3.width || n4.height > t3.height || r3.x > t3.width - n4.width || r3.y > t3.height - n4.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const s6 = e4.data, a3 = t3.data;
        for (let l3 = 0; l3 < n4.height; l3++) {
          const c3 = ((i3.y + l3) * e4.width + i3.x) * o3, h3 = ((r3.y + l3) * t3.width + r3.x) * o3;
          for (let e5 = 0; e5 < n4.width * o3; e5++)
            a3[h3 + e5] = s6[c3 + e5];
        }
        return t3;
      }
      Rs(Xp, "HeatmapBucket", { omit: ["layers"] });
      class Qp {
        constructor(e4, t3) {
          Yp(this, e4, 1, t3);
        }
        resize(e4) {
          Kp(this, new Qp(e4), 1);
        }
        clone() {
          return new Qp({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e4, t3, i3, r3, n4) {
          Jp(e4, t3, i3, r3, n4, 1);
        }
      }
      class ef {
        constructor(e4, t3) {
          Yp(this, e4, 4, t3);
        }
        resize(e4) {
          Kp(this, new ef(e4), 4);
        }
        replace(e4, t3) {
          t3 ? this.data.set(e4) : this.data = e4 instanceof Uint8ClampedArray ? new Uint8Array(e4.buffer) : e4;
        }
        clone() {
          return new ef({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e4, t3, i3, r3, n4) {
          Jp(e4, t3, i3, r3, n4, 4);
        }
      }
      class tf {
        constructor(e4, t3) {
          this.width = e4.width, this.height = e4.height, this.data = t3 instanceof Uint8Array ? new Float32Array(t3.buffer) : t3;
        }
      }
      Rs(Qp, "AlphaImage"), Rs(ef, "RGBAImage");
      const rf = new ga({ visibility: new fa(Pt.layout_heatmap.visibility) });
      var nf = { paint: new ga({ "heatmap-radius": new ma(Pt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ma(Pt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new fa(Pt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new _a2(Pt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new fa(Pt.paint_heatmap["heatmap-opacity"]) }), layout: rf };
      function of(e4) {
        const t3 = {}, i3 = e4.resolution || 256, r3 = e4.clips ? e4.clips.length : 1, n4 = e4.image || new ef({ width: i3, height: r3 }), o3 = (i4, r4, o4) => {
          t3[e4.evaluationKey] = o4;
          const s6 = e4.expression.evaluate(t3);
          s6 && (n4.data[i4 + r4 + 0] = Math.floor(255 * s6.r / s6.a), n4.data[i4 + r4 + 1] = Math.floor(255 * s6.g / s6.a), n4.data[i4 + r4 + 2] = Math.floor(255 * s6.b / s6.a), n4.data[i4 + r4 + 3] = Math.floor(255 * s6.a));
        };
        if (e4.clips)
          for (let t4 = 0, n5 = 0; t4 < r3; ++t4, n5 += 4 * i3)
            for (let r4 = 0, s6 = 0; r4 < i3; r4++, s6 += 4) {
              const a3 = r4 / (i3 - 1), { start: l3, end: c3 } = e4.clips[t4];
              o3(n5, s6, l3 * (1 - a3) + c3 * a3);
            }
        else
          for (let e5 = 0, t4 = 0; e5 < i3; e5++, t4 += 4)
            o3(0, t4, e5 / (i3 - 1));
        return n4;
      }
      const sf = new ga({ visibility: new fa(Pt.layout_hillshade.visibility) });
      var af = { paint: new ga({ "hillshade-illumination-direction": new fa(Pt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new fa(Pt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new fa(Pt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new fa(Pt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new fa(Pt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new fa(Pt.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new fa(Pt.paint_hillshade["hillshade-emissive-strength"]) }), layout: sf };
      const lf = Ia([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: cf } = lf;
      var hf = { exports: {} };
      function uf(e4, t3, i3) {
        i3 = i3 || 2;
        var r3, n4, o3, s6, a3, l3, c3, h3 = t3 && t3.length, u3 = h3 ? t3[0] * i3 : e4.length, d3 = df(e4, 0, u3, i3, true), p3 = [];
        if (!d3 || d3.next === d3.prev)
          return p3;
        if (h3 && (d3 = function(e5, t4, i4, r4) {
          var n5, o4, s7, a4 = [];
          for (n5 = 0, o4 = t4.length; n5 < o4; n5++)
            (s7 = df(e5, t4[n5] * r4, n5 < o4 - 1 ? t4[n5 + 1] * r4 : e5.length, r4, false)) === s7.next && (s7.steiner = true), a4.push(Tf(s7));
          for (a4.sort(xf), n5 = 0; n5 < a4.length; n5++)
            i4 = vf(a4[n5], i4);
          return i4;
        }(e4, t3, d3, i3)), e4.length > 80 * i3) {
          r3 = o3 = e4[0], n4 = s6 = e4[1];
          for (var f3 = i3; f3 < u3; f3 += i3)
            (a3 = e4[f3]) < r3 && (r3 = a3), (l3 = e4[f3 + 1]) < n4 && (n4 = l3), a3 > o3 && (o3 = a3), l3 > s6 && (s6 = l3);
          c3 = 0 !== (c3 = Math.max(o3 - r3, s6 - n4)) ? 32767 / c3 : 0;
        }
        return ff(d3, p3, i3, r3, n4, c3, 0), p3;
      }
      function df(e4, t3, i3, r3, n4) {
        var o3, s6;
        if (n4 === Of(e4, t3, i3, r3) > 0)
          for (o3 = t3; o3 < i3; o3 += r3)
            s6 = Rf(o3, e4[o3], e4[o3 + 1], s6);
        else
          for (o3 = i3 - r3; o3 >= t3; o3 -= r3)
            s6 = Rf(o3, e4[o3], e4[o3 + 1], s6);
        return s6 && Sf(s6, s6.next) && (Lf(s6), s6 = s6.next), s6;
      }
      function pf(e4, t3) {
        if (!e4)
          return e4;
        t3 || (t3 = e4);
        var i3, r3 = e4;
        do {
          if (i3 = false, r3.steiner || !Sf(r3, r3.next) && 0 !== Af(r3.prev, r3, r3.next))
            r3 = r3.next;
          else {
            if (Lf(r3), (r3 = t3 = r3.prev) === r3.next)
              break;
            i3 = true;
          }
        } while (i3 || r3 !== t3);
        return t3;
      }
      function ff(e4, t3, i3, r3, n4, o3, s6) {
        if (e4) {
          !s6 && o3 && function(e5, t4, i4, r4) {
            var n5 = e5;
            do {
              0 === n5.z && (n5.z = wf(n5.x, n5.y, t4, i4, r4)), n5.prevZ = n5.prev, n5.nextZ = n5.next, n5 = n5.next;
            } while (n5 !== e5);
            n5.prevZ.nextZ = null, n5.prevZ = null, function(e6) {
              var t5, i5, r5, n6, o4, s7, a4, l4, c4 = 1;
              do {
                for (i5 = e6, e6 = null, o4 = null, s7 = 0; i5; ) {
                  for (s7++, r5 = i5, a4 = 0, t5 = 0; t5 < c4 && (a4++, r5 = r5.nextZ); t5++)
                    ;
                  for (l4 = c4; a4 > 0 || l4 > 0 && r5; )
                    0 !== a4 && (0 === l4 || !r5 || i5.z <= r5.z) ? (n6 = i5, i5 = i5.nextZ, a4--) : (n6 = r5, r5 = r5.nextZ, l4--), o4 ? o4.nextZ = n6 : e6 = n6, n6.prevZ = o4, o4 = n6;
                  i5 = r5;
                }
                o4.nextZ = null, c4 *= 2;
              } while (s7 > 1);
            }(n5);
          }(e4, r3, n4, o3);
          for (var a3, l3, c3 = e4; e4.prev !== e4.next; )
            if (a3 = e4.prev, l3 = e4.next, o3 ? _f(e4, r3, n4, o3) : mf(e4))
              t3.push(a3.i / i3 | 0), t3.push(e4.i / i3 | 0), t3.push(l3.i / i3 | 0), Lf(e4), e4 = l3.next, c3 = l3.next;
            else if ((e4 = l3) === c3) {
              s6 ? 1 === s6 ? ff(e4 = gf(pf(e4), t3, i3), t3, i3, r3, n4, o3, 2) : 2 === s6 && yf(e4, t3, i3, r3, n4, o3) : ff(pf(e4), t3, i3, r3, n4, o3, 1);
              break;
            }
        }
      }
      function mf(e4) {
        var t3 = e4.prev, i3 = e4, r3 = e4.next;
        if (Af(t3, i3, r3) >= 0)
          return false;
        for (var n4 = t3.x, o3 = i3.x, s6 = r3.x, a3 = t3.y, l3 = i3.y, c3 = r3.y, h3 = n4 < o3 ? n4 < s6 ? n4 : s6 : o3 < s6 ? o3 : s6, u3 = a3 < l3 ? a3 < c3 ? a3 : c3 : l3 < c3 ? l3 : c3, d3 = n4 > o3 ? n4 > s6 ? n4 : s6 : o3 > s6 ? o3 : s6, p3 = a3 > l3 ? a3 > c3 ? a3 : c3 : l3 > c3 ? l3 : c3, f3 = r3.next; f3 !== t3; ) {
          if (f3.x >= h3 && f3.x <= d3 && f3.y >= u3 && f3.y <= p3 && Ef(n4, a3, o3, l3, s6, c3, f3.x, f3.y) && Af(f3.prev, f3, f3.next) >= 0)
            return false;
          f3 = f3.next;
        }
        return true;
      }
      function _f(e4, t3, i3, r3) {
        var n4 = e4.prev, o3 = e4, s6 = e4.next;
        if (Af(n4, o3, s6) >= 0)
          return false;
        for (var a3 = n4.x, l3 = o3.x, c3 = s6.x, h3 = n4.y, u3 = o3.y, d3 = s6.y, p3 = a3 < l3 ? a3 < c3 ? a3 : c3 : l3 < c3 ? l3 : c3, f3 = h3 < u3 ? h3 < d3 ? h3 : d3 : u3 < d3 ? u3 : d3, m3 = a3 > l3 ? a3 > c3 ? a3 : c3 : l3 > c3 ? l3 : c3, _3 = h3 > u3 ? h3 > d3 ? h3 : d3 : u3 > d3 ? u3 : d3, g3 = wf(p3, f3, t3, i3, r3), y3 = wf(m3, _3, t3, i3, r3), x3 = e4.prevZ, v3 = e4.nextZ; x3 && x3.z >= g3 && v3 && v3.z <= y3; ) {
          if (x3.x >= p3 && x3.x <= m3 && x3.y >= f3 && x3.y <= _3 && x3 !== n4 && x3 !== s6 && Ef(a3, h3, l3, u3, c3, d3, x3.x, x3.y) && Af(x3.prev, x3, x3.next) >= 0)
            return false;
          if (x3 = x3.prevZ, v3.x >= p3 && v3.x <= m3 && v3.y >= f3 && v3.y <= _3 && v3 !== n4 && v3 !== s6 && Ef(a3, h3, l3, u3, c3, d3, v3.x, v3.y) && Af(v3.prev, v3, v3.next) >= 0)
            return false;
          v3 = v3.nextZ;
        }
        for (; x3 && x3.z >= g3; ) {
          if (x3.x >= p3 && x3.x <= m3 && x3.y >= f3 && x3.y <= _3 && x3 !== n4 && x3 !== s6 && Ef(a3, h3, l3, u3, c3, d3, x3.x, x3.y) && Af(x3.prev, x3, x3.next) >= 0)
            return false;
          x3 = x3.prevZ;
        }
        for (; v3 && v3.z <= y3; ) {
          if (v3.x >= p3 && v3.x <= m3 && v3.y >= f3 && v3.y <= _3 && v3 !== n4 && v3 !== s6 && Ef(a3, h3, l3, u3, c3, d3, v3.x, v3.y) && Af(v3.prev, v3, v3.next) >= 0)
            return false;
          v3 = v3.nextZ;
        }
        return true;
      }
      function gf(e4, t3, i3) {
        var r3 = e4;
        do {
          var n4 = r3.prev, o3 = r3.next.next;
          !Sf(n4, o3) && If(n4, r3, r3.next, o3) && Pf(n4, o3) && Pf(o3, n4) && (t3.push(n4.i / i3 | 0), t3.push(r3.i / i3 | 0), t3.push(o3.i / i3 | 0), Lf(r3), Lf(r3.next), r3 = e4 = o3), r3 = r3.next;
        } while (r3 !== e4);
        return pf(r3);
      }
      function yf(e4, t3, i3, r3, n4, o3) {
        var s6 = e4;
        do {
          for (var a3 = s6.next.next; a3 !== s6.prev; ) {
            if (s6.i !== a3.i && Mf(s6, a3)) {
              var l3 = Df(s6, a3);
              return s6 = pf(s6, s6.next), l3 = pf(l3, l3.next), ff(s6, t3, i3, r3, n4, o3, 0), void ff(l3, t3, i3, r3, n4, o3, 0);
            }
            a3 = a3.next;
          }
          s6 = s6.next;
        } while (s6 !== e4);
      }
      function xf(e4, t3) {
        return e4.x - t3.x;
      }
      function vf(e4, t3) {
        var i3 = function(e5, t4) {
          var i4, r4 = t4, n4 = e5.x, o3 = e5.y, s6 = -1 / 0;
          do {
            if (o3 <= r4.y && o3 >= r4.next.y && r4.next.y !== r4.y) {
              var a3 = r4.x + (o3 - r4.y) * (r4.next.x - r4.x) / (r4.next.y - r4.y);
              if (a3 <= n4 && a3 > s6 && (s6 = a3, i4 = r4.x < r4.next.x ? r4 : r4.next, a3 === n4))
                return i4;
            }
            r4 = r4.next;
          } while (r4 !== t4);
          if (!i4)
            return null;
          var l3, c3 = i4, h3 = i4.x, u3 = i4.y, d3 = 1 / 0;
          r4 = i4;
          do {
            n4 >= r4.x && r4.x >= h3 && n4 !== r4.x && Ef(o3 < u3 ? n4 : s6, o3, h3, u3, o3 < u3 ? s6 : n4, o3, r4.x, r4.y) && (l3 = Math.abs(o3 - r4.y) / (n4 - r4.x), Pf(r4, e5) && (l3 < d3 || l3 === d3 && (r4.x > i4.x || r4.x === i4.x && bf(i4, r4))) && (i4 = r4, d3 = l3)), r4 = r4.next;
          } while (r4 !== c3);
          return i4;
        }(e4, t3);
        if (!i3)
          return t3;
        var r3 = Df(i3, e4);
        return pf(r3, r3.next), pf(i3, i3.next);
      }
      function bf(e4, t3) {
        return Af(e4.prev, e4, t3.prev) < 0 && Af(t3.next, e4, e4.next) < 0;
      }
      function wf(e4, t3, i3, r3, n4) {
        return (e4 = 1431655765 & ((e4 = 858993459 & ((e4 = 252645135 & ((e4 = 16711935 & ((e4 = (e4 - i3) * n4 | 0) | e4 << 8)) | e4 << 4)) | e4 << 2)) | e4 << 1)) | (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = (t3 - r3) * n4 | 0) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) << 1;
      }
      function Tf(e4) {
        var t3 = e4, i3 = e4;
        do {
          (t3.x < i3.x || t3.x === i3.x && t3.y < i3.y) && (i3 = t3), t3 = t3.next;
        } while (t3 !== e4);
        return i3;
      }
      function Ef(e4, t3, i3, r3, n4, o3, s6, a3) {
        return (n4 - s6) * (t3 - a3) >= (e4 - s6) * (o3 - a3) && (e4 - s6) * (r3 - a3) >= (i3 - s6) * (t3 - a3) && (i3 - s6) * (o3 - a3) >= (n4 - s6) * (r3 - a3);
      }
      function Mf(e4, t3) {
        return e4.next.i !== t3.i && e4.prev.i !== t3.i && !function(e5, t4) {
          var i3 = e5;
          do {
            if (i3.i !== e5.i && i3.next.i !== e5.i && i3.i !== t4.i && i3.next.i !== t4.i && If(i3, i3.next, e5, t4))
              return true;
            i3 = i3.next;
          } while (i3 !== e5);
          return false;
        }(e4, t3) && (Pf(e4, t3) && Pf(t3, e4) && function(e5, t4) {
          var i3 = e5, r3 = false, n4 = (e5.x + t4.x) / 2, o3 = (e5.y + t4.y) / 2;
          do {
            i3.y > o3 != i3.next.y > o3 && i3.next.y !== i3.y && n4 < (i3.next.x - i3.x) * (o3 - i3.y) / (i3.next.y - i3.y) + i3.x && (r3 = !r3), i3 = i3.next;
          } while (i3 !== e5);
          return r3;
        }(e4, t3) && (Af(e4.prev, e4, t3.prev) || Af(e4, t3.prev, t3)) || Sf(e4, t3) && Af(e4.prev, e4, e4.next) > 0 && Af(t3.prev, t3, t3.next) > 0);
      }
      function Af(e4, t3, i3) {
        return (t3.y - e4.y) * (i3.x - t3.x) - (t3.x - e4.x) * (i3.y - t3.y);
      }
      function Sf(e4, t3) {
        return e4.x === t3.x && e4.y === t3.y;
      }
      function If(e4, t3, i3, r3) {
        var n4 = zf(Af(e4, t3, i3)), o3 = zf(Af(e4, t3, r3)), s6 = zf(Af(i3, r3, e4)), a3 = zf(Af(i3, r3, t3));
        return n4 !== o3 && s6 !== a3 || !(0 !== n4 || !Cf(e4, i3, t3)) || !(0 !== o3 || !Cf(e4, r3, t3)) || !(0 !== s6 || !Cf(i3, e4, r3)) || !(0 !== a3 || !Cf(i3, t3, r3));
      }
      function Cf(e4, t3, i3) {
        return t3.x <= Math.max(e4.x, i3.x) && t3.x >= Math.min(e4.x, i3.x) && t3.y <= Math.max(e4.y, i3.y) && t3.y >= Math.min(e4.y, i3.y);
      }
      function zf(e4) {
        return e4 > 0 ? 1 : e4 < 0 ? -1 : 0;
      }
      function Pf(e4, t3) {
        return Af(e4.prev, e4, e4.next) < 0 ? Af(e4, t3, e4.next) >= 0 && Af(e4, e4.prev, t3) >= 0 : Af(e4, t3, e4.prev) < 0 || Af(e4, e4.next, t3) < 0;
      }
      function Df(e4, t3) {
        var i3 = new kf(e4.i, e4.x, e4.y), r3 = new kf(t3.i, t3.x, t3.y), n4 = e4.next, o3 = t3.prev;
        return e4.next = t3, t3.prev = e4, i3.next = n4, n4.prev = i3, r3.next = i3, i3.prev = r3, o3.next = r3, r3.prev = o3, r3;
      }
      function Rf(e4, t3, i3, r3) {
        var n4 = new kf(e4, t3, i3);
        return r3 ? (n4.next = r3.next, n4.prev = r3, r3.next.prev = n4, r3.next = n4) : (n4.prev = n4, n4.next = n4), n4;
      }
      function Lf(e4) {
        e4.next.prev = e4.prev, e4.prev.next = e4.next, e4.prevZ && (e4.prevZ.nextZ = e4.nextZ), e4.nextZ && (e4.nextZ.prevZ = e4.prevZ);
      }
      function kf(e4, t3, i3) {
        this.i = e4, this.x = t3, this.y = i3, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function Of(e4, t3, i3, r3) {
        for (var n4 = 0, o3 = t3, s6 = i3 - r3; o3 < i3; o3 += r3)
          n4 += (e4[s6] - e4[o3]) * (e4[o3 + 1] + e4[s6 + 1]), s6 = o3;
        return n4;
      }
      hf.exports = uf, hf.exports.default = uf, uf.deviation = function(e4, t3, i3, r3) {
        var n4 = t3 && t3.length, o3 = Math.abs(Of(e4, 0, n4 ? t3[0] * i3 : e4.length, i3));
        if (n4)
          for (var s6 = 0, a3 = t3.length; s6 < a3; s6++)
            o3 -= Math.abs(Of(e4, t3[s6] * i3, s6 < a3 - 1 ? t3[s6 + 1] * i3 : e4.length, i3));
        var l3 = 0;
        for (s6 = 0; s6 < r3.length; s6 += 3) {
          var c3 = r3[s6] * i3, h3 = r3[s6 + 1] * i3, u3 = r3[s6 + 2] * i3;
          l3 += Math.abs((e4[c3] - e4[u3]) * (e4[h3 + 1] - e4[c3 + 1]) - (e4[c3] - e4[h3]) * (e4[u3 + 1] - e4[c3 + 1]));
        }
        return 0 === o3 && 0 === l3 ? 0 : Math.abs((l3 - o3) / o3);
      }, uf.flatten = function(e4) {
        for (var t3 = e4[0][0].length, i3 = { vertices: [], holes: [], dimensions: t3 }, r3 = 0, n4 = 0; n4 < e4.length; n4++) {
          for (var o3 = 0; o3 < e4[n4].length; o3++)
            for (var s6 = 0; s6 < t3; s6++)
              i3.vertices.push(e4[n4][o3][s6]);
          n4 > 0 && i3.holes.push(r3 += e4[n4 - 1].length);
        }
        return i3;
      };
      var Bf = d2(hf.exports);
      function Ff(e4, t3) {
        const i3 = e4.length;
        if (i3 <= 1)
          return [e4];
        const r3 = [];
        let n4, o3;
        for (let t4 = 0; t4 < i3; t4++) {
          const i4 = Y(e4[t4]);
          0 !== i4 && (e4[t4].area = Math.abs(i4), void 0 === o3 && (o3 = i4 < 0), o3 === i4 < 0 ? (n4 && r3.push(n4), n4 = [e4[t4]]) : n4.push(e4[t4]));
        }
        if (n4 && r3.push(n4), t3 > 1)
          for (let e5 = 0; e5 < r3.length; e5++)
            r3[e5].length <= t3 || (Fi(r3[e5], t3, 1, r3[e5].length - 1, Nf), r3[e5] = r3[e5].slice(0, t3));
        return r3;
      }
      function Nf(e4, t3) {
        return t3.area - e4.area;
      }
      function Uf(e4, t3, i3) {
        const r3 = i3.patternDependencies;
        let n4 = false;
        for (const i4 of t3) {
          const t4 = i4.paint.get(`${e4}-pattern`);
          t4.isConstant() || (n4 = true);
          const o3 = t4.constantOr(null);
          o3 && (n4 = true, r3[o3] = true);
        }
        return n4;
      }
      function Vf(e4, t3, i3, r3, n4) {
        const o3 = n4.patternDependencies;
        for (const s6 of t3) {
          const t4 = s6.paint.get(`${e4}-pattern`).value;
          if ("constant" !== t4.kind) {
            let e5 = t4.evaluate({ zoom: r3 }, i3, {}, n4.availableImages);
            e5 = e5 && e5.name ? e5.name : e5, o3[e5] = true, i3.patterns[s6.id] = e5;
          }
        }
        return i3;
      }
      class jf {
        constructor(e4) {
          this.zoom = e4.zoom, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((e5) => e5.fqid), this.index = e4.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new za(), this.indexArray = new Wa(), this.indexArray2 = new ja(), this.programConfigurations = new ec(e4.layers, e4.zoom), this.segments = new xl(), this.segments2 = new xl(), this.stateDependentLayerIds = this.layers.filter((e5) => e5.isStateDependent()).map((e5) => e5.id), this.projection = e4.projection;
        }
        populate(e4, t3, i3, r3) {
          this.hasPattern = Uf("fill", this.layers, t3);
          const n4 = this.layers[0].layout.get("fill-sort-key"), o3 = [];
          for (const { feature: s6, id: a3, index: l3, sourceLayerIndex: c3 } of e4) {
            const e5 = this.layers[0]._featureFilter.needGeometry, h3 = gp(s6, e5);
            if (!this.layers[0]._featureFilter.filter(new oa(this.zoom), h3, i3))
              continue;
            const u3 = n4 ? n4.evaluate(h3, {}, i3, t3.availableImages) : void 0, d3 = { id: a3, properties: s6.properties, type: s6.type, sourceLayerIndex: c3, index: l3, geometry: e5 ? h3.geometry : _p(s6, i3, r3), patterns: {}, sortKey: u3 };
            o3.push(d3);
          }
          n4 && o3.sort((e5, t4) => e5.sortKey - t4.sortKey);
          for (const r4 of o3) {
            const { geometry: n5, index: o4, sourceLayerIndex: s6 } = r4;
            if (this.hasPattern) {
              const e5 = Vf("fill", this.layers, r4, this.zoom, t3);
              this.patternFeatures.push(e5);
            } else
              this.addFeature(r4, n5, o4, i3, {}, t3.availableImages, t3.brightness);
            t3.featureIndex.insert(e4[o4].feature, n5, o4, s6, this.index);
          }
        }
        update(e4, t3, i3, r3, n4) {
          const o3 = 0 !== Object.keys(e4).length;
          o3 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(e4, t3, o3 ? this.stateDependentLayers : this.layers, i3, r3, n4);
        }
        addFeatures(e4, t3, i3, r3, n4, o3) {
          for (const e5 of this.patternFeatures)
            this.addFeature(e5, e5.geometry, e5.index, t3, i3, r3, o3);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e4) {
          this.uploaded || (this.layoutVertexBuffer = e4.createVertexBuffer(this.layoutVertexArray, cf), this.indexBuffer = e4.createIndexBuffer(this.indexArray), this.indexBuffer2 = e4.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e4), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e4, t3, i3, r3, n4, o3 = [], s6) {
          for (const e5 of Ff(t3, 500)) {
            let t4 = 0;
            for (const i5 of e5)
              t4 += i5.length;
            const i4 = this.segments.prepareSegment(t4, this.layoutVertexArray, this.indexArray), r4 = i4.vertexLength, n5 = [], o4 = [];
            for (const t5 of e5) {
              if (0 === t5.length)
                continue;
              t5 !== e5[0] && o4.push(n5.length / 2);
              const i5 = this.segments2.prepareSegment(t5.length, this.layoutVertexArray, this.indexArray2), r5 = i5.vertexLength;
              this.layoutVertexArray.emplaceBack(t5[0].x, t5[0].y), this.indexArray2.emplaceBack(r5 + t5.length - 1, r5), n5.push(t5[0].x), n5.push(t5[0].y);
              for (let e6 = 1; e6 < t5.length; e6++)
                this.layoutVertexArray.emplaceBack(t5[e6].x, t5[e6].y), this.indexArray2.emplaceBack(r5 + e6 - 1, r5 + e6), n5.push(t5[e6].x), n5.push(t5[e6].y);
              i5.vertexLength += t5.length, i5.primitiveLength += t5.length;
            }
            const s7 = Bf(n5, o4);
            for (let e6 = 0; e6 < s7.length; e6 += 3)
              this.indexArray.emplaceBack(r4 + s7[e6], r4 + s7[e6 + 1], r4 + s7[e6 + 2]);
            i4.vertexLength += t4, i4.primitiveLength += s7.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e4, i3, n4, o3, r3, s6);
        }
      }
      Rs(jf, "FillBucket", { omit: ["layers", "patternFeatures"] });
      const Gf = new ga({ "fill-sort-key": new ma(Pt.layout_fill["fill-sort-key"]), visibility: new fa(Pt.layout_fill.visibility) });
      var qf = { paint: new ga({ "fill-antialias": new fa(Pt.paint_fill["fill-antialias"]), "fill-opacity": new ma(Pt.paint_fill["fill-opacity"]), "fill-color": new ma(Pt.paint_fill["fill-color"]), "fill-outline-color": new ma(Pt.paint_fill["fill-outline-color"]), "fill-translate": new fa(Pt.paint_fill["fill-translate"]), "fill-translate-anchor": new fa(Pt.paint_fill["fill-translate-anchor"]), "fill-pattern": new ma(Pt.paint_fill["fill-pattern"]), "fill-emissive-strength": new fa(Pt.paint_fill["fill-emissive-strength"]) }), layout: Gf };
      const Zf = Ia([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), $f = Ia([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Wf = Ia([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Hf = Ia([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Xf = Ia([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Yf } = Zf;
      var Kf = {}, Jf = _2, Qf = em;
      function em(e4, t3, i3, r3, n4) {
        this.properties = {}, this.extent = i3, this.type = 0, this._pbf = e4, this._geometry = -1, this._keys = r3, this._values = n4, e4.readFields(tm, this, t3);
      }
      function tm(e4, t3, i3) {
        1 == e4 ? t3.id = i3.readVarint() : 2 == e4 ? function(e5, t4) {
          for (var i4 = e5.readVarint() + e5.pos; e5.pos < i4; ) {
            var r3 = t4._keys[e5.readVarint()], n4 = t4._values[e5.readVarint()];
            t4.properties[r3] = n4;
          }
        }(i3, t3) : 3 == e4 ? t3.type = i3.readVarint() : 4 == e4 && (t3._geometry = i3.pos);
      }
      function im(e4) {
        for (var t3, i3, r3 = 0, n4 = 0, o3 = e4.length, s6 = o3 - 1; n4 < o3; s6 = n4++)
          r3 += ((i3 = e4[s6]).x - (t3 = e4[n4]).x) * (t3.y + i3.y);
        return r3;
      }
      em.types = ["Unknown", "Point", "LineString", "Polygon"], em.prototype.loadGeometry = function() {
        var e4 = this._pbf;
        e4.pos = this._geometry;
        for (var t3, i3 = e4.readVarint() + e4.pos, r3 = 1, n4 = 0, o3 = 0, s6 = 0, a3 = []; e4.pos < i3; ) {
          if (n4 <= 0) {
            var l3 = e4.readVarint();
            r3 = 7 & l3, n4 = l3 >> 3;
          }
          if (n4--, 1 === r3 || 2 === r3)
            o3 += e4.readSVarint(), s6 += e4.readSVarint(), 1 === r3 && (t3 && a3.push(t3), t3 = []), t3.push(new Jf(o3, s6));
          else {
            if (7 !== r3)
              throw new Error("unknown command " + r3);
            t3 && t3.push(t3[0].clone());
          }
        }
        return t3 && a3.push(t3), a3;
      }, em.prototype.bbox = function() {
        var e4 = this._pbf;
        e4.pos = this._geometry;
        for (var t3 = e4.readVarint() + e4.pos, i3 = 1, r3 = 0, n4 = 0, o3 = 0, s6 = 1 / 0, a3 = -1 / 0, l3 = 1 / 0, c3 = -1 / 0; e4.pos < t3; ) {
          if (r3 <= 0) {
            var h3 = e4.readVarint();
            i3 = 7 & h3, r3 = h3 >> 3;
          }
          if (r3--, 1 === i3 || 2 === i3)
            (n4 += e4.readSVarint()) < s6 && (s6 = n4), n4 > a3 && (a3 = n4), (o3 += e4.readSVarint()) < l3 && (l3 = o3), o3 > c3 && (c3 = o3);
          else if (7 !== i3)
            throw new Error("unknown command " + i3);
        }
        return [s6, l3, a3, c3];
      }, em.prototype.toGeoJSON = function(e4, t3, i3) {
        var r3, n4, o3 = this.extent * Math.pow(2, i3), s6 = this.extent * e4, a3 = this.extent * t3, l3 = this.loadGeometry(), c3 = em.types[this.type];
        function h3(e5) {
          for (var t4 = 0; t4 < e5.length; t4++) {
            var i4 = e5[t4];
            e5[t4] = [360 * (i4.x + s6) / o3 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (i4.y + a3) / o3) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var u3 = [];
            for (r3 = 0; r3 < l3.length; r3++)
              u3[r3] = l3[r3][0];
            h3(l3 = u3);
            break;
          case 2:
            for (r3 = 0; r3 < l3.length; r3++)
              h3(l3[r3]);
            break;
          case 3:
            for (l3 = function(e5) {
              var t4 = e5.length;
              if (t4 <= 1)
                return [e5];
              for (var i4, r4, n5 = [], o4 = 0; o4 < t4; o4++) {
                var s7 = im(e5[o4]);
                0 !== s7 && (void 0 === r4 && (r4 = s7 < 0), r4 === s7 < 0 ? (i4 && n5.push(i4), i4 = [e5[o4]]) : i4.push(e5[o4]));
              }
              return i4 && n5.push(i4), n5;
            }(l3), r3 = 0; r3 < l3.length; r3++)
              for (n4 = 0; n4 < l3[r3].length; n4++)
                h3(l3[r3][n4]);
        }
        1 === l3.length ? l3 = l3[0] : c3 = "Multi" + c3;
        var d3 = { type: "Feature", geometry: { type: c3, coordinates: l3 }, properties: this.properties };
        return "id" in this && (d3.id = this.id), d3;
      };
      var rm = Qf, nm = om;
      function om(e4, t3) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = e4, this._keys = [], this._values = [], this._features = [], e4.readFields(sm, this, t3), this.length = this._features.length;
      }
      function sm(e4, t3, i3) {
        15 === e4 ? t3.version = i3.readVarint() : 1 === e4 ? t3.name = i3.readString() : 5 === e4 ? t3.extent = i3.readVarint() : 2 === e4 ? t3._features.push(i3.pos) : 3 === e4 ? t3._keys.push(i3.readString()) : 4 === e4 && t3._values.push(function(e5) {
          for (var t4 = null, i4 = e5.readVarint() + e5.pos; e5.pos < i4; ) {
            var r3 = e5.readVarint() >> 3;
            t4 = 1 === r3 ? e5.readString() : 2 === r3 ? e5.readFloat() : 3 === r3 ? e5.readDouble() : 4 === r3 ? e5.readVarint64() : 5 === r3 ? e5.readVarint() : 6 === r3 ? e5.readSVarint() : 7 === r3 ? e5.readBoolean() : null;
          }
          return t4;
        }(i3));
      }
      om.prototype.feature = function(e4) {
        if (e4 < 0 || e4 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[e4];
        var t3 = this._pbf.readVarint() + this._pbf.pos;
        return new rm(this._pbf, t3, this.extent, this._keys, this._values);
      };
      var am = nm;
      function lm(e4, t3, i3) {
        if (3 === e4) {
          var r3 = new am(i3, i3.readVarint() + i3.pos);
          r3.length && (t3[r3.name] = r3);
        }
      }
      var cm = Kf.VectorTile = function(e4, t3) {
        this.layers = e4.readFields(lm, {}, t3);
      }, hm = Kf.VectorTileFeature = Qf;
      function um(e4, t3, i3, r3) {
        const n4 = [], o3 = 0 === r3 ? (e5, t4, i4, r4, n5, o4) => {
          e5.push(new y2(o4, i4 + (o4 - t4) / (r4 - t4) * (n5 - i4)));
        } : (e5, t4, i4, r4, n5, o4) => {
          e5.push(new y2(t4 + (o4 - i4) / (n5 - i4) * (r4 - t4), o4));
        };
        for (const s6 of e4) {
          const e5 = [];
          for (const n5 of s6) {
            if (n5.length <= 2)
              continue;
            const s7 = [];
            for (let e6 = 0; e6 < n5.length - 1; e6++) {
              const a4 = n5[e6].x, l4 = n5[e6].y, c3 = n5[e6 + 1].x, h3 = n5[e6 + 1].y, u3 = 0 === r3 ? a4 : l4, d3 = 0 === r3 ? c3 : h3;
              u3 < t3 ? d3 > t3 && o3(s7, a4, l4, c3, h3, t3) : u3 > i3 ? d3 < i3 && o3(s7, a4, l4, c3, h3, i3) : s7.push(n5[e6]), d3 < t3 && u3 >= t3 && o3(s7, a4, l4, c3, h3, t3), d3 > i3 && u3 <= i3 && o3(s7, a4, l4, c3, h3, i3);
            }
            let a3 = n5[n5.length - 1];
            const l3 = 0 === r3 ? a3.x : a3.y;
            l3 >= t3 && l3 <= i3 && s7.push(a3), s7.length && (a3 = s7[s7.length - 1], s7[0].x === a3.x && s7[0].y === a3.y || s7.push(s7[0]), e5.push(s7));
          }
          e5.length && n4.push(e5);
        }
        return n4;
      }
      Kf.VectorTileLayer = nm;
      class dm {
        constructor(e4) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let t3 = 0; t3 < e4.length; t3++) {
            const i3 = e4[t3];
            this._stringToNumber[i3] = t3, this._numberToString[t3] = i3;
          }
        }
        encode(e4) {
          return this._stringToNumber[e4];
        }
        decode(e4) {
          return this._numberToString[e4];
        }
      }
      var pm = {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        read: function(e4, t3, i3, r3, n4) {
          var o3, s6, a3 = 8 * n4 - r3 - 1, l3 = (1 << a3) - 1, c3 = l3 >> 1, h3 = -7, u3 = i3 ? n4 - 1 : 0, d3 = i3 ? -1 : 1, p3 = e4[t3 + u3];
          for (u3 += d3, o3 = p3 & (1 << -h3) - 1, p3 >>= -h3, h3 += a3; h3 > 0; o3 = 256 * o3 + e4[t3 + u3], u3 += d3, h3 -= 8)
            ;
          for (s6 = o3 & (1 << -h3) - 1, o3 >>= -h3, h3 += r3; h3 > 0; s6 = 256 * s6 + e4[t3 + u3], u3 += d3, h3 -= 8)
            ;
          if (0 === o3)
            o3 = 1 - c3;
          else {
            if (o3 === l3)
              return s6 ? NaN : 1 / 0 * (p3 ? -1 : 1);
            s6 += Math.pow(2, r3), o3 -= c3;
          }
          return (p3 ? -1 : 1) * s6 * Math.pow(2, o3 - r3);
        },
        write: function(e4, t3, i3, r3, n4, o3) {
          var s6, a3, l3, c3 = 8 * o3 - n4 - 1, h3 = (1 << c3) - 1, u3 = h3 >> 1, d3 = 23 === n4 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p3 = r3 ? 0 : o3 - 1, f3 = r3 ? 1 : -1, m3 = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
          for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a3 = isNaN(t3) ? 1 : 0, s6 = h3) : (s6 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l3 = Math.pow(2, -s6)) < 1 && (s6--, l3 *= 2), (t3 += s6 + u3 >= 1 ? d3 / l3 : d3 * Math.pow(2, 1 - u3)) * l3 >= 2 && (s6++, l3 /= 2), s6 + u3 >= h3 ? (a3 = 0, s6 = h3) : s6 + u3 >= 1 ? (a3 = (t3 * l3 - 1) * Math.pow(2, n4), s6 += u3) : (a3 = t3 * Math.pow(2, u3 - 1) * Math.pow(2, n4), s6 = 0)); n4 >= 8; e4[i3 + p3] = 255 & a3, p3 += f3, a3 /= 256, n4 -= 8)
            ;
          for (s6 = s6 << n4 | a3, c3 += n4; c3 > 0; e4[i3 + p3] = 255 & s6, p3 += f3, s6 /= 256, c3 -= 8)
            ;
          e4[i3 + p3 - f3] |= 128 * m3;
        }
      }, fm = _m, mm = pm;
      function _m(e4) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e4) ? e4 : new Uint8Array(e4 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      _m.Varint = 0, _m.Fixed64 = 1, _m.Bytes = 2, _m.Fixed32 = 5;
      var gm = 4294967296, ym = 1 / gm, xm = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
      function vm(e4) {
        return e4.type === _m.Bytes ? e4.readVarint() + e4.pos : e4.pos + 1;
      }
      function bm(e4, t3, i3) {
        return i3 ? 4294967296 * t3 + (e4 >>> 0) : 4294967296 * (t3 >>> 0) + (e4 >>> 0);
      }
      function wm(e4, t3, i3) {
        var r3 = t3 <= 16383 ? 1 : t3 <= 2097151 ? 2 : t3 <= 268435455 ? 3 : Math.floor(Math.log(t3) / (7 * Math.LN2));
        i3.realloc(r3);
        for (var n4 = i3.pos - 1; n4 >= e4; n4--)
          i3.buf[n4 + r3] = i3.buf[n4];
      }
      function Tm(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeVarint(e4[i3]);
      }
      function Em(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeSVarint(e4[i3]);
      }
      function Mm(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeFloat(e4[i3]);
      }
      function Am(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeDouble(e4[i3]);
      }
      function Sm(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeBoolean(e4[i3]);
      }
      function Im(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeFixed32(e4[i3]);
      }
      function Cm(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeSFixed32(e4[i3]);
      }
      function zm(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeFixed64(e4[i3]);
      }
      function Pm(e4, t3) {
        for (var i3 = 0; i3 < e4.length; i3++)
          t3.writeSFixed64(e4[i3]);
      }
      function Dm(e4, t3) {
        return (e4[t3] | e4[t3 + 1] << 8 | e4[t3 + 2] << 16) + 16777216 * e4[t3 + 3];
      }
      function Rm(e4, t3, i3) {
        e4[i3] = t3, e4[i3 + 1] = t3 >>> 8, e4[i3 + 2] = t3 >>> 16, e4[i3 + 3] = t3 >>> 24;
      }
      function Lm(e4, t3) {
        return (e4[t3] | e4[t3 + 1] << 8 | e4[t3 + 2] << 16) + (e4[t3 + 3] << 24);
      }
      _m.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(e4, t3, i3) {
        for (i3 = i3 || this.length; this.pos < i3; ) {
          var r3 = this.readVarint(), n4 = r3 >> 3, o3 = this.pos;
          this.type = 7 & r3, e4(n4, t3, this), this.pos === o3 && this.skip(r3);
        }
        return t3;
      }, readMessage: function(e4, t3) {
        return this.readFields(e4, t3, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var e4 = Dm(this.buf, this.pos);
        return this.pos += 4, e4;
      }, readSFixed32: function() {
        var e4 = Lm(this.buf, this.pos);
        return this.pos += 4, e4;
      }, readFixed64: function() {
        var e4 = Dm(this.buf, this.pos) + Dm(this.buf, this.pos + 4) * gm;
        return this.pos += 8, e4;
      }, readSFixed64: function() {
        var e4 = Dm(this.buf, this.pos) + Lm(this.buf, this.pos + 4) * gm;
        return this.pos += 8, e4;
      }, readFloat: function() {
        var e4 = mm.read(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, e4;
      }, readDouble: function() {
        var e4 = mm.read(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, e4;
      }, readVarint: function(e4) {
        var t3, i3, r3 = this.buf;
        return t3 = 127 & (i3 = r3[this.pos++]), i3 < 128 ? t3 : (t3 |= (127 & (i3 = r3[this.pos++])) << 7, i3 < 128 ? t3 : (t3 |= (127 & (i3 = r3[this.pos++])) << 14, i3 < 128 ? t3 : (t3 |= (127 & (i3 = r3[this.pos++])) << 21, i3 < 128 ? t3 : function(e5, t4, i4) {
          var r4, n4, o3 = i4.buf;
          if (r4 = (112 & (n4 = o3[i4.pos++])) >> 4, n4 < 128)
            return bm(e5, r4, t4);
          if (r4 |= (127 & (n4 = o3[i4.pos++])) << 3, n4 < 128)
            return bm(e5, r4, t4);
          if (r4 |= (127 & (n4 = o3[i4.pos++])) << 10, n4 < 128)
            return bm(e5, r4, t4);
          if (r4 |= (127 & (n4 = o3[i4.pos++])) << 17, n4 < 128)
            return bm(e5, r4, t4);
          if (r4 |= (127 & (n4 = o3[i4.pos++])) << 24, n4 < 128)
            return bm(e5, r4, t4);
          if (r4 |= (1 & (n4 = o3[i4.pos++])) << 31, n4 < 128)
            return bm(e5, r4, t4);
          throw new Error("Expected varint not more than 10 bytes");
        }(t3 |= (15 & (i3 = r3[this.pos])) << 28, e4, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var e4 = this.readVarint();
        return e4 % 2 == 1 ? (e4 + 1) / -2 : e4 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var e4 = this.readVarint() + this.pos, t3 = this.pos;
        return this.pos = e4, e4 - t3 >= 12 && xm ? function(e5, t4, i3) {
          return xm.decode(e5.subarray(t4, i3));
        }(this.buf, t3, e4) : function(e5, t4, i3) {
          for (var r3 = "", n4 = t4; n4 < i3; ) {
            var o3, s6, a3, l3 = e5[n4], c3 = null, h3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
            if (n4 + h3 > i3)
              break;
            1 === h3 ? l3 < 128 && (c3 = l3) : 2 === h3 ? 128 == (192 & (o3 = e5[n4 + 1])) && (c3 = (31 & l3) << 6 | 63 & o3) <= 127 && (c3 = null) : 3 === h3 ? (s6 = e5[n4 + 2], 128 == (192 & (o3 = e5[n4 + 1])) && 128 == (192 & s6) && ((c3 = (15 & l3) << 12 | (63 & o3) << 6 | 63 & s6) <= 2047 || c3 >= 55296 && c3 <= 57343) && (c3 = null)) : 4 === h3 && (s6 = e5[n4 + 2], a3 = e5[n4 + 3], 128 == (192 & (o3 = e5[n4 + 1])) && 128 == (192 & s6) && 128 == (192 & a3) && ((c3 = (15 & l3) << 18 | (63 & o3) << 12 | (63 & s6) << 6 | 63 & a3) <= 65535 || c3 >= 1114112) && (c3 = null)), null === c3 ? (c3 = 65533, h3 = 1) : c3 > 65535 && (c3 -= 65536, r3 += String.fromCharCode(c3 >>> 10 & 1023 | 55296), c3 = 56320 | 1023 & c3), r3 += String.fromCharCode(c3), n4 += h3;
          }
          return r3;
        }(this.buf, t3, e4);
      }, readBytes: function() {
        var e4 = this.readVarint() + this.pos, t3 = this.buf.subarray(this.pos, e4);
        return this.pos = e4, t3;
      }, readPackedVarint: function(e4, t3) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readVarint(t3));
        var i3 = vm(this);
        for (e4 = e4 || []; this.pos < i3; )
          e4.push(this.readVarint(t3));
        return e4;
      }, readPackedSVarint: function(e4) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readSVarint());
        var t3 = vm(this);
        for (e4 = e4 || []; this.pos < t3; )
          e4.push(this.readSVarint());
        return e4;
      }, readPackedBoolean: function(e4) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readBoolean());
        var t3 = vm(this);
        for (e4 = e4 || []; this.pos < t3; )
          e4.push(this.readBoolean());
        return e4;
      }, readPackedFloat: function(e4) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readFloat());
        var t3 = vm(this);
        for (e4 = e4 || []; this.pos < t3; )
          e4.push(this.readFloat());
        return e4;
      }, readPackedDouble: function(e4) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readDouble());
        var t3 = vm(this);
        for (e4 = e4 || []; this.pos < t3; )
          e4.push(this.readDouble());
        return e4;
      }, readPackedFixed32: function(e4) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readFixed32());
        var t3 = vm(this);
        for (e4 = e4 || []; this.pos < t3; )
          e4.push(this.readFixed32());
        return e4;
      }, readPackedSFixed32: function(e4) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readSFixed32());
        var t3 = vm(this);
        for (e4 = e4 || []; this.pos < t3; )
          e4.push(this.readSFixed32());
        return e4;
      }, readPackedFixed64: function(e4) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readFixed64());
        var t3 = vm(this);
        for (e4 = e4 || []; this.pos < t3; )
          e4.push(this.readFixed64());
        return e4;
      }, readPackedSFixed64: function(e4) {
        if (this.type !== _m.Bytes)
          return e4.push(this.readSFixed64());
        var t3 = vm(this);
        for (e4 = e4 || []; this.pos < t3; )
          e4.push(this.readSFixed64());
        return e4;
      }, skip: function(e4) {
        var t3 = 7 & e4;
        if (t3 === _m.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (t3 === _m.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (t3 === _m.Fixed32)
          this.pos += 4;
        else {
          if (t3 !== _m.Fixed64)
            throw new Error("Unimplemented type: " + t3);
          this.pos += 8;
        }
      }, writeTag: function(e4, t3) {
        this.writeVarint(e4 << 3 | t3);
      }, realloc: function(e4) {
        for (var t3 = this.length || 16; t3 < this.pos + e4; )
          t3 *= 2;
        if (t3 !== this.length) {
          var i3 = new Uint8Array(t3);
          i3.set(this.buf), this.buf = i3, this.length = t3;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(e4) {
        this.realloc(4), Rm(this.buf, e4, this.pos), this.pos += 4;
      }, writeSFixed32: function(e4) {
        this.realloc(4), Rm(this.buf, e4, this.pos), this.pos += 4;
      }, writeFixed64: function(e4) {
        this.realloc(8), Rm(this.buf, -1 & e4, this.pos), Rm(this.buf, Math.floor(e4 * ym), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(e4) {
        this.realloc(8), Rm(this.buf, -1 & e4, this.pos), Rm(this.buf, Math.floor(e4 * ym), this.pos + 4), this.pos += 8;
      }, writeVarint: function(e4) {
        (e4 = +e4 || 0) > 268435455 || e4 < 0 ? function(e5, t3) {
          var i3, r3;
          if (e5 >= 0 ? (i3 = e5 % 4294967296 | 0, r3 = e5 / 4294967296 | 0) : (r3 = ~(-e5 / 4294967296), 4294967295 ^ (i3 = ~(-e5 % 4294967296)) ? i3 = i3 + 1 | 0 : (i3 = 0, r3 = r3 + 1 | 0)), e5 >= 18446744073709552e3 || e5 < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          t3.realloc(10), function(e6, t4, i4) {
            i4.buf[i4.pos++] = 127 & e6 | 128, e6 >>>= 7, i4.buf[i4.pos++] = 127 & e6 | 128, e6 >>>= 7, i4.buf[i4.pos++] = 127 & e6 | 128, e6 >>>= 7, i4.buf[i4.pos++] = 127 & e6 | 128, i4.buf[i4.pos] = 127 & (e6 >>>= 7);
          }(i3, 0, t3), function(e6, t4) {
            var i4 = (7 & e6) << 4;
            t4.buf[t4.pos++] |= i4 | ((e6 >>>= 3) ? 128 : 0), e6 && (t4.buf[t4.pos++] = 127 & e6 | ((e6 >>>= 7) ? 128 : 0), e6 && (t4.buf[t4.pos++] = 127 & e6 | ((e6 >>>= 7) ? 128 : 0), e6 && (t4.buf[t4.pos++] = 127 & e6 | ((e6 >>>= 7) ? 128 : 0), e6 && (t4.buf[t4.pos++] = 127 & e6 | ((e6 >>>= 7) ? 128 : 0), e6 && (t4.buf[t4.pos++] = 127 & e6)))));
          }(r3, t3);
        }(e4, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e4 | (e4 > 127 ? 128 : 0), e4 <= 127 || (this.buf[this.pos++] = 127 & (e4 >>>= 7) | (e4 > 127 ? 128 : 0), e4 <= 127 || (this.buf[this.pos++] = 127 & (e4 >>>= 7) | (e4 > 127 ? 128 : 0), e4 <= 127 || (this.buf[this.pos++] = e4 >>> 7 & 127))));
      }, writeSVarint: function(e4) {
        this.writeVarint(e4 < 0 ? 2 * -e4 - 1 : 2 * e4);
      }, writeBoolean: function(e4) {
        this.writeVarint(Boolean(e4));
      }, writeString: function(e4) {
        e4 = String(e4), this.realloc(4 * e4.length), this.pos++;
        var t3 = this.pos;
        this.pos = function(e5, t4, i4) {
          for (var r3, n4, o3 = 0; o3 < t4.length; o3++) {
            if ((r3 = t4.charCodeAt(o3)) > 55295 && r3 < 57344) {
              if (!n4) {
                r3 > 56319 || o3 + 1 === t4.length ? (e5[i4++] = 239, e5[i4++] = 191, e5[i4++] = 189) : n4 = r3;
                continue;
              }
              if (r3 < 56320) {
                e5[i4++] = 239, e5[i4++] = 191, e5[i4++] = 189, n4 = r3;
                continue;
              }
              r3 = n4 - 55296 << 10 | r3 - 56320 | 65536, n4 = null;
            } else
              n4 && (e5[i4++] = 239, e5[i4++] = 191, e5[i4++] = 189, n4 = null);
            r3 < 128 ? e5[i4++] = r3 : (r3 < 2048 ? e5[i4++] = r3 >> 6 | 192 : (r3 < 65536 ? e5[i4++] = r3 >> 12 | 224 : (e5[i4++] = r3 >> 18 | 240, e5[i4++] = r3 >> 12 & 63 | 128), e5[i4++] = r3 >> 6 & 63 | 128), e5[i4++] = 63 & r3 | 128);
          }
          return i4;
        }(this.buf, e4, this.pos);
        var i3 = this.pos - t3;
        i3 >= 128 && wm(t3, i3, this), this.pos = t3 - 1, this.writeVarint(i3), this.pos += i3;
      }, writeFloat: function(e4) {
        this.realloc(4), mm.write(this.buf, e4, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(e4) {
        this.realloc(8), mm.write(this.buf, e4, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(e4) {
        var t3 = e4.length;
        this.writeVarint(t3), this.realloc(t3);
        for (var i3 = 0; i3 < t3; i3++)
          this.buf[this.pos++] = e4[i3];
      }, writeRawMessage: function(e4, t3) {
        this.pos++;
        var i3 = this.pos;
        e4(t3, this);
        var r3 = this.pos - i3;
        r3 >= 128 && wm(i3, r3, this), this.pos = i3 - 1, this.writeVarint(r3), this.pos += r3;
      }, writeMessage: function(e4, t3, i3) {
        this.writeTag(e4, _m.Bytes), this.writeRawMessage(t3, i3);
      }, writePackedVarint: function(e4, t3) {
        t3.length && this.writeMessage(e4, Tm, t3);
      }, writePackedSVarint: function(e4, t3) {
        t3.length && this.writeMessage(e4, Em, t3);
      }, writePackedBoolean: function(e4, t3) {
        t3.length && this.writeMessage(e4, Sm, t3);
      }, writePackedFloat: function(e4, t3) {
        t3.length && this.writeMessage(e4, Mm, t3);
      }, writePackedDouble: function(e4, t3) {
        t3.length && this.writeMessage(e4, Am, t3);
      }, writePackedFixed32: function(e4, t3) {
        t3.length && this.writeMessage(e4, Im, t3);
      }, writePackedSFixed32: function(e4, t3) {
        t3.length && this.writeMessage(e4, Cm, t3);
      }, writePackedFixed64: function(e4, t3) {
        t3.length && this.writeMessage(e4, zm, t3);
      }, writePackedSFixed64: function(e4, t3) {
        t3.length && this.writeMessage(e4, Pm, t3);
      }, writeBytesField: function(e4, t3) {
        this.writeTag(e4, _m.Bytes), this.writeBytes(t3);
      }, writeFixed32Field: function(e4, t3) {
        this.writeTag(e4, _m.Fixed32), this.writeFixed32(t3);
      }, writeSFixed32Field: function(e4, t3) {
        this.writeTag(e4, _m.Fixed32), this.writeSFixed32(t3);
      }, writeFixed64Field: function(e4, t3) {
        this.writeTag(e4, _m.Fixed64), this.writeFixed64(t3);
      }, writeSFixed64Field: function(e4, t3) {
        this.writeTag(e4, _m.Fixed64), this.writeSFixed64(t3);
      }, writeVarintField: function(e4, t3) {
        this.writeTag(e4, _m.Varint), this.writeVarint(t3);
      }, writeSVarintField: function(e4, t3) {
        this.writeTag(e4, _m.Varint), this.writeSVarint(t3);
      }, writeStringField: function(e4, t3) {
        this.writeTag(e4, _m.Bytes), this.writeString(t3);
      }, writeFloatField: function(e4, t3) {
        this.writeTag(e4, _m.Fixed32), this.writeFloat(t3);
      }, writeDoubleField: function(e4, t3) {
        this.writeTag(e4, _m.Fixed64), this.writeDouble(t3);
      }, writeBooleanField: function(e4, t3) {
        this.writeVarintField(e4, Boolean(t3));
      } };
      var km = d2(fm);
      const Om = ["tile", "layer", "source", "sourceLayer", "state"];
      class Bm {
        constructor(e4, t3, i3, r3, n4) {
          this.type = "Feature", this._vectorTileFeature = e4, this._z = t3, this._x = i3, this._y = r3, this.properties = e4.properties, this.id = n4;
        }
        get geometry() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(e4) {
          this._geometry = e4;
        }
        toJSON() {
          const e4 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
          void 0 !== this.id && (e4.id = this.id);
          for (const t3 of Om)
            void 0 !== this[t3] && (e4[t3] = this[t3]);
          return e4;
        }
      }
      class Fm {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e4, t3, i3) {
          const r3 = String(t3);
          if (this.stateChanges[e4] = this.stateChanges[e4] || {}, this.stateChanges[e4][r3] = this.stateChanges[e4][r3] || {}, k2(this.stateChanges[e4][r3], i3), null === this.deletedStates[e4]) {
            this.deletedStates[e4] = {};
            for (const t4 in this.state[e4])
              t4 !== r3 && (this.deletedStates[e4][t4] = null);
          } else if (this.deletedStates[e4] && null === this.deletedStates[e4][r3]) {
            this.deletedStates[e4][r3] = {};
            for (const t4 in this.state[e4][r3])
              i3[t4] || (this.deletedStates[e4][r3][t4] = null);
          } else
            for (const t4 in i3)
              this.deletedStates[e4] && this.deletedStates[e4][r3] && null === this.deletedStates[e4][r3][t4] && delete this.deletedStates[e4][r3][t4];
        }
        removeFeatureState(e4, t3, i3) {
          if (null === this.deletedStates[e4])
            return;
          const r3 = String(t3);
          if (this.deletedStates[e4] = this.deletedStates[e4] || {}, i3 && void 0 !== t3)
            null !== this.deletedStates[e4][r3] && (this.deletedStates[e4][r3] = this.deletedStates[e4][r3] || {}, this.deletedStates[e4][r3][i3] = null);
          else if (void 0 !== t3)
            if (this.stateChanges[e4] && this.stateChanges[e4][r3])
              for (i3 in this.deletedStates[e4][r3] = {}, this.stateChanges[e4][r3])
                this.deletedStates[e4][r3][i3] = null;
            else
              this.deletedStates[e4][r3] = null;
          else
            this.deletedStates[e4] = null;
        }
        getState(e4, t3) {
          const i3 = String(t3), r3 = k2({}, (this.state[e4] || {})[i3], (this.stateChanges[e4] || {})[i3]);
          if (null === this.deletedStates[e4])
            return {};
          if (this.deletedStates[e4]) {
            const i4 = this.deletedStates[e4][t3];
            if (null === i4)
              return {};
            for (const e5 in i4)
              delete r3[e5];
          }
          return r3;
        }
        initializeTileState(e4, t3) {
          e4.setFeatureState(this.state, t3);
        }
        coalesceChanges(e4, t3) {
          const i3 = {};
          for (const e5 in this.stateChanges) {
            this.state[e5] = this.state[e5] || {};
            const t4 = {};
            for (const i4 in this.stateChanges[e5])
              this.state[e5][i4] || (this.state[e5][i4] = {}), k2(this.state[e5][i4], this.stateChanges[e5][i4]), t4[i4] = this.state[e5][i4];
            i3[e5] = t4;
          }
          for (const e5 in this.deletedStates) {
            this.state[e5] = this.state[e5] || {};
            const t4 = {};
            if (null === this.deletedStates[e5])
              for (const i4 in this.state[e5])
                t4[i4] = {}, this.state[e5][i4] = {};
            else
              for (const i4 in this.deletedStates[e5]) {
                if (null === this.deletedStates[e5][i4])
                  this.state[e5][i4] = {};
                else if (this.state[e5][i4])
                  for (const t5 of Object.keys(this.deletedStates[e5][i4]))
                    delete this.state[e5][i4][t5];
                t4[i4] = this.state[e5][i4];
              }
            i3[e5] = i3[e5] || {}, k2(i3[e5], t4);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(i3).length)
            for (const r3 in e4)
              e4[r3].setFeatureState(i3, t3);
        }
      }
      class Nm {
        constructor(e4) {
          this.size = e4, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(e4, t3) {
          const i3 = this.toIdx(e4, t3);
          return { min: this.minimums[i3], max: this.maximums[i3] };
        }
        isLeaf(e4, t3) {
          return this.leaves[this.toIdx(e4, t3)];
        }
        toIdx(e4, t3) {
          return t3 * this.size + e4;
        }
      }
      function Um(e4, t3, i3, r3) {
        let n4 = 0, o3 = Number.MAX_VALUE;
        for (let s6 = 0; s6 < 3; s6++)
          if (Math.abs(r3[s6]) < 1e-15) {
            if (i3[s6] < e4[s6] || i3[s6] > t3[s6])
              return null;
          } else {
            const a3 = 1 / r3[s6];
            let l3 = (e4[s6] - i3[s6]) * a3, c3 = (t3[s6] - i3[s6]) * a3;
            if (l3 > c3) {
              const e5 = l3;
              l3 = c3, c3 = e5;
            }
            if (l3 > n4 && (n4 = l3), c3 < o3 && (o3 = c3), n4 > o3)
              return null;
          }
        return n4;
      }
      function Vm(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3) {
        const u3 = r3 - e4, d3 = n4 - t3, p3 = o3 - i3, f3 = s6 - e4, m3 = a3 - t3, _3 = l3 - i3, g3 = h3[1] * _3 - h3[2] * m3, y3 = h3[2] * f3 - h3[0] * _3, x3 = h3[0] * m3 - h3[1] * f3, v3 = u3 * g3 + d3 * y3 + p3 * x3;
        if (Math.abs(v3) < 1e-15)
          return null;
        const b3 = 1 / v3, w3 = c3[0] - e4, T3 = c3[1] - t3, E3 = c3[2] - i3, M3 = (w3 * g3 + T3 * y3 + E3 * x3) * b3;
        if (M3 < 0 || M3 > 1)
          return null;
        const A3 = T3 * p3 - E3 * d3, S3 = E3 * u3 - w3 * p3, I3 = w3 * d3 - T3 * u3, C3 = (h3[0] * A3 + h3[1] * S3 + h3[2] * I3) * b3;
        return C3 < 0 || M3 + C3 > 1 ? null : (f3 * A3 + m3 * S3 + _3 * I3) * b3;
      }
      function jm(e4, t3, i3) {
        return (e4 - t3) / (i3 - t3);
      }
      function Gm(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        const c3 = 1 << i3, h3 = o3 - r3, u3 = s6 - n4, d3 = (e4 + 1) / c3 * h3 + r3, p3 = (t3 + 0) / c3 * u3 + n4, f3 = (t3 + 1) / c3 * u3 + n4;
        a3[0] = (e4 + 0) / c3 * h3 + r3, a3[1] = p3, l3[0] = d3, l3[1] = f3;
      }
      class qm {
        constructor(e4) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e4, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const t3 = function(e5) {
            const t4 = Math.ceil(Math.log2(e5.dim / 8)), i4 = [];
            let r4 = Math.ceil(Math.pow(2, t4));
            const n4 = 1 / r4, o3 = (e6, t5, i5, r5, n5) => {
              const o4 = r5 ? 1 : 0, s7 = (e6 + 1) * i5 - o4, a4 = t5 * i5, l3 = (t5 + 1) * i5 - o4;
              n5[0] = e6 * i5, n5[1] = a4, n5[2] = s7, n5[3] = l3;
            };
            let s6 = new Nm(r4);
            const a3 = [];
            for (let t5 = 0; t5 < r4 * r4; t5++) {
              o3(t5 % r4, Math.floor(t5 / r4), n4, false, a3);
              const i5 = $m(a3[0], a3[1], e5), l3 = $m(a3[2], a3[1], e5), c3 = $m(a3[2], a3[3], e5), h3 = $m(a3[0], a3[3], e5);
              s6.minimums.push(Math.min(i5, l3, c3, h3)), s6.maximums.push(Math.max(i5, l3, c3, h3)), s6.leaves.push(1);
            }
            for (i4.push(s6), r4 /= 2; r4 >= 1; r4 /= 2) {
              const e6 = i4[i4.length - 1];
              s6 = new Nm(r4);
              for (let t5 = 0; t5 < r4 * r4; t5++) {
                o3(t5 % r4, Math.floor(t5 / r4), 2, true, a3);
                const i5 = e6.getElevation(a3[0], a3[1]), n5 = e6.getElevation(a3[2], a3[1]), l3 = e6.getElevation(a3[2], a3[3]), c3 = e6.getElevation(a3[0], a3[3]), h3 = e6.isLeaf(a3[0], a3[1]), u3 = e6.isLeaf(a3[2], a3[1]), d3 = e6.isLeaf(a3[2], a3[3]), p3 = e6.isLeaf(a3[0], a3[3]), f3 = Math.min(i5.min, n5.min, l3.min, c3.min), m3 = Math.max(i5.max, n5.max, l3.max, c3.max), _3 = h3 && u3 && d3 && p3;
                s6.maximums.push(m3), s6.minimums.push(f3), s6.leaves.push(m3 - f3 <= 5 && _3 ? 1 : 0);
              }
              i4.push(s6);
            }
            return i4;
          }(this.dem), i3 = t3.length - 1, r3 = t3[i3];
          this._addNode(r3.minimums[0], r3.maximums[0], r3.leaves[0]), this._construct(t3, 0, 0, i3, 0);
        }
        raycastRoot(e4, t3, i3, r3, n4, o3, s6 = 1) {
          return Um([e4, t3, -100], [i3, r3, this.maximums[0] * s6], n4, o3);
        }
        raycast(e4, t3, i3, r3, n4, o3, s6 = 1) {
          if (!this.nodeCount)
            return null;
          const a3 = this.raycastRoot(e4, t3, i3, r3, n4, o3, s6);
          if (null == a3)
            return null;
          const l3 = [], c3 = [], h3 = [], u3 = [], d3 = [{ idx: 0, t: a3, nodex: 0, nodey: 0, depth: 0 }];
          for (; d3.length > 0; ) {
            const { idx: a4, t: p3, nodex: f3, nodey: m3, depth: _3 } = d3.pop();
            if (this.leaves[a4]) {
              Gm(f3, m3, _3, e4, t3, i3, r3, h3, u3);
              const a5 = 1 << _3, l4 = (f3 + 0) / a5, c4 = (f3 + 1) / a5, d4 = (m3 + 0) / a5, g4 = (m3 + 1) / a5, y3 = $m(l4, d4, this.dem) * s6, x3 = $m(c4, d4, this.dem) * s6, v3 = $m(c4, g4, this.dem) * s6, b3 = $m(l4, g4, this.dem) * s6, w3 = Vm(h3[0], h3[1], y3, u3[0], h3[1], x3, u3[0], u3[1], v3, n4, o3), T3 = Vm(u3[0], u3[1], v3, h3[0], u3[1], b3, h3[0], h3[1], y3, n4, o3), E3 = Math.min(null !== w3 ? w3 : Number.MAX_VALUE, null !== T3 ? T3 : Number.MAX_VALUE);
              if (E3 !== Number.MAX_VALUE)
                return E3;
              {
                const e5 = Du.scaleAndAdd([], n4, o3, p3);
                if (Zm(y3, x3, b3, v3, jm(e5[0], h3[0], u3[0]), jm(e5[1], h3[1], u3[1])) >= e5[2])
                  return p3;
              }
              continue;
            }
            let g3 = 0;
            for (let d4 = 0; d4 < this._siblingOffset.length; d4++) {
              Gm((f3 << 1) + this._siblingOffset[d4][0], (m3 << 1) + this._siblingOffset[d4][1], _3 + 1, e4, t3, i3, r3, h3, u3), h3[2] = -100, u3[2] = this.maximums[this.childOffsets[a4] + d4] * s6;
              const p4 = Um(h3, u3, n4, o3);
              if (null != p4) {
                const e5 = p4;
                l3[d4] = e5;
                let t4 = false;
                for (let i4 = 0; i4 < g3 && !t4; i4++)
                  e5 >= l3[c3[i4]] && (c3.splice(i4, 0, d4), t4 = true);
                t4 || (c3[g3] = d4), g3++;
              }
            }
            for (let e5 = 0; e5 < g3; e5++) {
              const t4 = c3[e5];
              d3.push({ idx: this.childOffsets[a4] + t4, t: l3[t4], nodex: (f3 << 1) + this._siblingOffset[t4][0], nodey: (m3 << 1) + this._siblingOffset[t4][1], depth: _3 + 1 });
            }
          }
          return null;
        }
        _addNode(e4, t3, i3) {
          return this.minimums.push(e4), this.maximums.push(t3), this.leaves.push(i3), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(e4, t3, i3, r3, n4) {
          if (1 === e4[r3].isLeaf(t3, i3))
            return;
          this.childOffsets[n4] || (this.childOffsets[n4] = this.nodeCount);
          const o3 = r3 - 1, s6 = e4[o3];
          let a3 = 0, l3 = 0;
          for (let e5 = 0; e5 < this._siblingOffset.length; e5++) {
            const r4 = 2 * t3 + this._siblingOffset[e5][0], n5 = 2 * i3 + this._siblingOffset[e5][1], o4 = s6.getElevation(r4, n5), c3 = s6.isLeaf(r4, n5), h3 = this._addNode(o4.min, o4.max, c3);
            c3 && (a3 |= 1 << e5), l3 || (l3 = h3);
          }
          for (let r4 = 0; r4 < this._siblingOffset.length; r4++)
            a3 & 1 << r4 || this._construct(e4, 2 * t3 + this._siblingOffset[r4][0], 2 * i3 + this._siblingOffset[r4][1], o3, l3 + r4);
        }
      }
      function Zm(e4, t3, i3, r3, n4, o3) {
        return Kr(Kr(e4, i3, o3), Kr(t3, r3, o3), n4);
      }
      function $m(e4, t3, i3) {
        const r3 = i3.dim, n4 = z(e4 * r3 - 0.5, 0, r3 - 1), o3 = z(t3 * r3 - 0.5, 0, r3 - 1), s6 = Math.floor(n4), a3 = Math.floor(o3), l3 = Math.min(s6 + 1, r3 - 1), c3 = Math.min(a3 + 1, r3 - 1);
        return Zm(i3.get(s6, a3), i3.get(l3, a3), i3.get(s6, c3), i3.get(l3, c3), n4 - s6, o3 - a3);
      }
      const Wm = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      function Hm(e4, t3, i3) {
        return (256 * e4 * 256 + 256 * t3 + i3) / 10 - 1e4;
      }
      function Xm(e4, t3, i3) {
        return 256 * e4 + t3 + i3 / 256 - 32768;
      }
      class Ym {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(e4, t3, i3, r3 = false) {
          if (this.uid = e4, t3.height !== t3.width)
            throw new RangeError("DEM tiles must be square");
          if (i3 && "mapbox" !== i3 && "terrarium" !== i3)
            return H2(`"${i3}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = t3.height;
          const n4 = this.dim = t3.height - 2, o3 = new Uint32Array(t3.data.buffer);
          if (this.pixels = new Uint8Array(t3.data.buffer), this.floatView = new Float32Array(t3.data.buffer), this.borderReady = r3, this._modifiedForSources = {}, !r3) {
            for (let e5 = 0; e5 < n4; e5++)
              o3[this._idx(-1, e5)] = o3[this._idx(0, e5)], o3[this._idx(n4, e5)] = o3[this._idx(n4 - 1, e5)], o3[this._idx(e5, -1)] = o3[this._idx(e5, 0)], o3[this._idx(e5, n4)] = o3[this._idx(e5, n4 - 1)];
            o3[this._idx(-1, -1)] = o3[this._idx(0, 0)], o3[this._idx(n4, -1)] = o3[this._idx(n4 - 1, 0)], o3[this._idx(-1, n4)] = o3[this._idx(0, n4 - 1)], o3[this._idx(n4, n4)] = o3[this._idx(n4 - 1, n4 - 1)];
          }
          const s6 = "terrarium" === i3 ? Xm : Hm;
          for (let e5 = 0; e5 < o3.length; ++e5) {
            const t4 = 4 * e5;
            this.floatView[e5] = s6(this.pixels[t4], this.pixels[t4 + 1], this.pixels[t4 + 2]);
          }
          this._timestamp = dt.now();
        }
        _buildQuadTree() {
          this._tree = new qm(this);
        }
        get(e4, t3, i3 = false) {
          i3 && (e4 = z(e4, -1, this.dim), t3 = z(t3, -1, this.dim));
          const r3 = this._idx(e4, t3);
          return this.floatView[r3];
        }
        set(e4, t3, i3) {
          const r3 = this._idx(e4, t3), n4 = this.floatView[r3];
          return this.floatView[r3] = i3, i3 - n4;
        }
        static getUnpackVector(e4) {
          return Wm[e4];
        }
        _idx(e4, t3) {
          if (e4 < -1 || e4 >= this.dim + 1 || t3 < -1 || t3 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (t3 + 1) * this.stride + (e4 + 1);
        }
        static pack(e4, t3) {
          const i3 = [0, 0, 0, 0], r3 = Ym.getUnpackVector(t3);
          let n4 = Math.floor((e4 + r3[3]) / r3[2]);
          return i3[2] = n4 % 256, n4 = Math.floor(n4 / 256), i3[1] = n4 % 256, n4 = Math.floor(n4 / 256), i3[0] = n4, i3;
        }
        getPixels() {
          return new tf({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(e4, t3, i3) {
          if (this.dim !== e4.dim)
            throw new Error("dem dimension mismatch");
          let r3 = t3 * this.dim, n4 = t3 * this.dim + this.dim, o3 = i3 * this.dim, s6 = i3 * this.dim + this.dim;
          switch (t3) {
            case -1:
              r3 = n4 - 1;
              break;
            case 1:
              n4 = r3 + 1;
          }
          switch (i3) {
            case -1:
              o3 = s6 - 1;
              break;
            case 1:
              s6 = o3 + 1;
          }
          const a3 = -t3 * this.dim, l3 = -i3 * this.dim;
          for (let t4 = o3; t4 < s6; t4++)
            for (let i4 = r3; i4 < n4; i4++) {
              const r4 = 4 * this._idx(i4, t4), n5 = 4 * this._idx(i4 + a3, t4 + l3);
              this.pixels[r4 + 0] = e4.pixels[n5 + 0], this.pixels[r4 + 1] = e4.pixels[n5 + 1], this.pixels[r4 + 2] = e4.pixels[n5 + 2], this.pixels[r4 + 3] = e4.pixels[n5 + 3];
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      Rs(Ym, "DEMData"), Rs(qm, "DemMinMaxQuadTree", { omit: ["dem"] });
      class Km {
        isDataAvailableAtPoint(e4) {
          const t3 = this._source();
          if (this.isUsingMockSource() || !t3 || e4.y < 0 || e4.y > 1)
            return false;
          const i3 = t3.getSource().maxzoom, r3 = 1 << i3, n4 = Math.floor(e4.x), o3 = Math.floor((e4.x - n4) * r3), s6 = Math.floor(e4.y * r3), a3 = this.findDEMTileFor(new qu(i3, n4, i3, o3, s6));
          return !(!a3 || !a3.dem);
        }
        getAtPointOrZero(e4, t3 = 0) {
          return this.getAtPoint(e4, t3) || 0;
        }
        getAtPoint(e4, t3, i3 = true) {
          if (this.isUsingMockSource())
            return null;
          null == t3 && (t3 = null);
          const r3 = this._source();
          if (!r3)
            return t3;
          if (e4.y < 0 || e4.y > 1)
            return t3;
          const n4 = r3.getSource().maxzoom, o3 = 1 << n4, s6 = Math.floor(e4.x), a3 = e4.x - s6, l3 = new qu(n4, s6, n4, Math.floor(a3 * o3), Math.floor(e4.y * o3)), c3 = this.findDEMTileFor(l3);
          if (!c3 || !c3.dem)
            return t3;
          const h3 = c3.dem, u3 = 1 << c3.tileID.canonical.z, d3 = (a3 * u3 - c3.tileID.canonical.x) * h3.dim, p3 = (e4.y * u3 - c3.tileID.canonical.y) * h3.dim, f3 = Math.floor(d3), m3 = Math.floor(p3);
          return (i3 ? this.exaggeration() : 1) * Kr(Kr(h3.get(f3, m3), h3.get(f3, m3 + 1), p3 - m3), Kr(h3.get(f3 + 1, m3), h3.get(f3 + 1, m3 + 1), p3 - m3), d3 - f3);
        }
        getAtTileOffset(e4, t3, i3) {
          const r3 = 1 << e4.canonical.z;
          return this.getAtPointOrZero(new lp(e4.wrap + (e4.canonical.x + t3 / cr) / r3, (e4.canonical.y + i3 / cr) / r3));
        }
        getAtTileOffsetFunc(e4, t3, i3, r3) {
          return (n4) => {
            const o3 = this.getAtTileOffset(e4, n4.x, n4.y), s6 = r3.upVector(e4.canonical, n4.x, n4.y), a3 = r3.upVectorScale(e4.canonical, t3, i3).metersToTile;
            return Du.scale(s6, s6, o3 * a3), s6;
          };
        }
        getForTilePoints(e4, t3, i3, r3) {
          if (this.isUsingMockSource())
            return false;
          const n4 = Jm.create(this, e4, r3);
          return !!n4 && (t3.forEach((e5) => {
            e5[2] = this.exaggeration() * n4.getElevationAt(e5[0], e5[1], i3);
          }), true);
        }
        getMinMaxForTile(e4) {
          if (this.isUsingMockSource())
            return null;
          const t3 = this.findDEMTileFor(e4);
          if (!t3 || !t3.dem)
            return null;
          const i3 = t3.dem.tree, r3 = t3.tileID, n4 = 1 << e4.canonical.z - r3.canonical.z;
          let o3 = e4.canonical.x / n4 - r3.canonical.x, s6 = e4.canonical.y / n4 - r3.canonical.y, a3 = 0;
          for (let t4 = 0; t4 < e4.canonical.z - r3.canonical.z && !i3.leaves[a3]; t4++) {
            o3 *= 2, s6 *= 2;
            const e5 = 2 * Math.floor(s6) + Math.floor(o3);
            a3 = i3.childOffsets[a3] + e5, o3 %= 1, s6 %= 1;
          }
          return { min: this.exaggeration() * i3.minimums[a3], max: this.exaggeration() * i3.maximums[a3] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(e4, t3, i3) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(e4) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(e4) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
        getMinMaxForVisibleTiles() {
          const e4 = this.visibleDemTiles;
          if (0 === e4.length)
            return null;
          let t3 = false, i3 = Number.MAX_VALUE, r3 = Number.MIN_VALUE;
          for (const n4 of e4) {
            const e5 = this.getMinMaxForTile(n4.tileID);
            e5 && (i3 = Math.min(i3, e5.min), r3 = Math.max(r3, e5.max), t3 = true);
          }
          return t3 ? { min: i3, max: r3 } : null;
        }
      }
      class Jm {
        constructor(e4, t3, i3) {
          this._demTile = e4, this._dem = this._demTile.dem, this._scale = t3, this._offset = i3;
        }
        static create(e4, t3, i3) {
          const r3 = i3 || e4.findDEMTileFor(t3);
          if (!r3 || !r3.dem)
            return;
          const n4 = r3.dem, o3 = r3.tileID, s6 = 1 << t3.canonical.z - o3.canonical.z;
          return new Jm(r3, n4.dim / cr / s6, [(t3.canonical.x / s6 - o3.canonical.x) * n4.dim, (t3.canonical.y / s6 - o3.canonical.y) * n4.dim]);
        }
        tileCoordToPixel(e4, t3) {
          const i3 = t3 * this._scale + this._offset[1], r3 = Math.floor(e4 * this._scale + this._offset[0]), n4 = Math.floor(i3);
          return new y2(r3, n4);
        }
        getElevationAt(e4, t3, i3, r3) {
          const n4 = e4 * this._scale + this._offset[0], o3 = t3 * this._scale + this._offset[1], s6 = Math.floor(n4), a3 = Math.floor(o3), l3 = this._dem;
          return r3 = !!r3, i3 ? Kr(Kr(l3.get(s6, a3, r3), l3.get(s6, a3 + 1, r3), o3 - a3), Kr(l3.get(s6 + 1, a3, r3), l3.get(s6 + 1, a3 + 1, r3), o3 - a3), n4 - s6) : l3.get(s6, a3, r3);
        }
        getElevationAtPixel(e4, t3, i3) {
          return this._dem.get(e4, t3, !!i3);
        }
        getMeterToDEM(e4) {
          return (1 << this._demTile.tileID.canonical.z) * Qd(1, e4) * this._dem.stride;
        }
      }
      class Qm {
        constructor(e4, t3) {
          this.tileID = e4, this.x = e4.canonical.x, this.y = e4.canonical.y, this.z = e4.canonical.z, this.grid = new Ps(cr, 16, 0), this.featureIndexArray = new ml(), this.promoteId = t3;
        }
        insert(e4, t3, i3, r3, n4, o3 = 0) {
          const s6 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(i3, r3, n4, o3);
          const a3 = this.grid;
          for (let e5 = 0; e5 < t3.length; e5++) {
            const i4 = t3[e5], r4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let e6 = 0; e6 < i4.length; e6++) {
              const t4 = i4[e6];
              r4[0] = Math.min(r4[0], t4.x), r4[1] = Math.min(r4[1], t4.y), r4[2] = Math.max(r4[2], t4.x), r4[3] = Math.max(r4[3], t4.y);
            }
            r4[0] < cr && r4[1] < cr && r4[2] >= 0 && r4[3] >= 0 && a3.insert(s6, r4[0], r4[1], r4[2], r4[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new cm(new km(this.rawTileData)).layers, this.sourceLayerCoder = new dm(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const e4 in this.vtLayers)
              this.vtFeatures[e4] = [];
          }
          return this.vtLayers;
        }
        query(e4, t3, i3, r3) {
          this.loadVTLayers();
          const n4 = e4.params || {}, o3 = Fo(n4.filter), s6 = e4.tileResult, a3 = e4.transform, l3 = s6.bufferedTilespaceBounds, c3 = this.grid.query(l3.min.x, l3.min.y, l3.max.x, l3.max.y, (e5, t4, i4, r4) => Pp(s6.bufferedTilespaceGeometry, e5, t4, i4, r4));
          c3.sort(t_);
          let h3 = null;
          a3.elevation && c3.length > 0 && (h3 = Jm.create(a3.elevation, this.tileID));
          const u3 = {};
          let d3;
          for (let a4 = 0; a4 < c3.length; a4++) {
            const l4 = c3[a4];
            if (l4 === d3)
              continue;
            d3 = l4;
            const p3 = this.featureIndexArray.get(l4);
            let f3 = null;
            this.loadMatchingFeature(u3, p3, o3, n4.layers, n4.availableImages, t3, i3, r3, (t4, i4, r4, n5 = 0) => (f3 || (f3 = _p(t4, this.tileID.canonical, e4.tileTransform)), i4.queryIntersectsFeature(s6, t4, r4, f3, this.z, e4.transform, e4.pixelPosMatrix, h3, n5)));
          }
          return u3;
        }
        loadMatchingFeature(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
          const { featureIndex: c3, bucketIndex: h3, sourceLayerIndex: u3, layoutVertexArrayOffset: d3 } = t3, p3 = this.bucketLayerIDs[h3];
          if (r3 && !function(e5, t4) {
            for (let i4 = 0; i4 < e5.length; i4++)
              if (t4.indexOf(e5[i4]) >= 0)
                return true;
            return false;
          }(r3, p3))
            return;
          const f3 = this.sourceLayerCoder.decode(u3), m3 = this.vtLayers[f3].feature(c3);
          if (i3.needGeometry) {
            const e5 = gp(m3, true);
            if (!i3.filter(new oa(this.tileID.overscaledZ), e5, this.tileID.canonical))
              return;
          } else if (!i3.filter(new oa(this.tileID.overscaledZ), m3))
            return;
          const _3 = this.getId(m3, f3);
          for (let t4 = 0; t4 < p3.length; t4++) {
            const i4 = p3[t4];
            if (r3 && r3.indexOf(i4) < 0)
              continue;
            const h4 = o3[i4];
            if (!h4)
              continue;
            let u4 = {};
            void 0 !== _3 && a3 && (u4 = a3.getState(h4.sourceLayer || "_geojsonTileLayer", _3));
            const f4 = k2({}, s6[i4]);
            f4.paint = e_(f4.paint, h4.paint, m3, u4, n4), f4.layout = e_(f4.layout, h4.layout, m3, u4, n4);
            const g3 = !l3 || l3(m3, h4, u4, d3);
            if (!g3)
              continue;
            const y3 = new Bm(m3, this.z, this.x, this.y, _3);
            y3.layer = f4;
            let x3 = e4[i4];
            void 0 === x3 && (x3 = e4[i4] = []), x3.push({ featureIndex: c3, feature: y3, intersectionZ: g3 });
          }
        }
        lookupSymbolFeatures(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = {};
          this.loadVTLayers();
          const c3 = Fo(n4);
          for (const n5 of e4)
            this.loadMatchingFeature(l3, { bucketIndex: i3, sourceLayerIndex: r3, featureIndex: n5, layoutVertexArrayOffset: 0 }, c3, o3, s6, a3, t3);
          return l3;
        }
        loadFeature(e4) {
          const { featureIndex: t3, sourceLayerIndex: i3 } = e4;
          this.loadVTLayers();
          const r3 = this.sourceLayerCoder.decode(i3), n4 = this.vtFeatures[r3];
          if (n4[t3])
            return n4[t3];
          const o3 = this.vtLayers[r3].feature(t3);
          return n4[t3] = o3, o3;
        }
        hasLayer(e4) {
          for (const t3 of this.bucketLayerIDs)
            for (const i3 of t3)
              if (e4 === i3)
                return true;
          return false;
        }
        getId(e4, t3) {
          let i3 = e4.id;
          if (this.promoteId) {
            const r3 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[t3];
            null != r3 && (i3 = e4.properties[r3]), "boolean" == typeof i3 && (i3 = Number(i3));
          }
          return i3;
        }
      }
      function e_(e4, t3, i3, r3, n4) {
        return q(e4, (e5, o3) => {
          const s6 = t3 instanceof pa ? t3.get(o3) : null;
          return s6 && s6.evaluate ? s6.evaluate(i3, r3, n4) : s6;
        });
      }
      function t_(e4, t3) {
        return t3 - e4;
      }
      Rs(Qm, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      const i_ = Ia([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), r_ = Ia([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), n_ = Ia([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      Ia([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const o_ = Ia([{ name: "a_z_offset", components: 1, type: "Float32" }], 4), s_ = Ia([{ name: "a_texb", components: 2, type: "Uint16" }]), a_ = Ia([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), l_ = Ia([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_z_offset", components: 1, type: "Float32" }]);
      Ia([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const c_ = Ia([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), h_ = Ia([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      Ia([{ name: "triangle", components: 3, type: "Uint16" }]), Ia([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Ia([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), Ia([{ type: "Float32", name: "offsetX" }]), Ia([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      var u_ = 24;
      const d_ = 128;
      function p_(e4, t3) {
        const { expression: i3 } = t3;
        if ("constant" === i3.kind)
          return { kind: "constant", layoutSize: i3.evaluate(new oa(e4 + 1)) };
        if ("source" === i3.kind)
          return { kind: "source" };
        {
          const { zoomStops: t4, interpolationType: r3 } = i3;
          let n4 = 0;
          for (; n4 < t4.length && t4[n4] <= e4; )
            n4++;
          n4 = Math.max(0, n4 - 1);
          let o3 = n4;
          for (; o3 < t4.length && t4[o3] < e4 + 1; )
            o3++;
          o3 = Math.min(t4.length - 1, o3);
          const s6 = t4[n4], a3 = t4[o3];
          return "composite" === i3.kind ? { kind: "composite", minZoom: s6, maxZoom: a3, interpolationType: r3 } : { kind: "camera", minZoom: s6, maxZoom: a3, minSize: i3.evaluate(new oa(s6)), maxSize: i3.evaluate(new oa(a3)), interpolationType: r3 };
        }
      }
      function f_(e4, { uSize: t3, uSizeT: i3 }, { lowerSize: r3, upperSize: n4 }) {
        return "source" === e4.kind ? r3 / d_ : "composite" === e4.kind ? Kr(r3 / d_, n4 / d_, i3) : t3;
      }
      function m_(e4, t3) {
        let i3 = 0, r3 = 0;
        if ("constant" === e4.kind)
          r3 = e4.layoutSize;
        else if ("source" !== e4.kind) {
          const { interpolationType: n4, minZoom: o3, maxZoom: s6 } = e4, a3 = n4 ? z(bn.interpolationFactor(n4, t3, o3, s6), 0, 1) : 0;
          "camera" === e4.kind ? r3 = Kr(e4.minSize, e4.maxSize, a3) : i3 = a3;
        }
        return { uSizeT: i3, uSize: r3 };
      }
      var __ = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: d_, evaluateSizeForFeature: f_, evaluateSizeForZoom: m_, getSizeData: p_ });
      function g_(e4, t3, i3) {
        return e4.sections.forEach((e5) => {
          e5.text = function(e6, t4, i4) {
            const r3 = t4.layout.get("text-transform").evaluate(i4, {});
            return "uppercase" === r3 ? e6 = e6.toLocaleUpperCase() : "lowercase" === r3 && (e6 = e6.toLocaleLowerCase()), na.applyArabicShaping && (e6 = na.applyArabicShaping(e6)), e6;
          }(e5.text, t3, i3);
        }), e4;
      }
      const y_ = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      function x_(e4) {
        return "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4;
      }
      function v_(e4) {
        return "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4 || "" === e4;
      }
      const b_ = 3;
      function w_(e4, t3, i3) {
        t3.glyphs = [], 1 === e4 && i3.readMessage(T_, t3);
      }
      function T_(e4, t3, i3) {
        if (3 === e4) {
          const { id: e5, bitmap: r3, width: n4, height: o3, left: s6, top: a3, advance: l3 } = i3.readMessage(E_, {});
          t3.glyphs.push({ id: e5, bitmap: new Qp({ width: n4 + 2 * b_, height: o3 + 2 * b_ }, r3), metrics: { width: n4, height: o3, left: s6, top: a3, advance: l3 } });
        } else
          4 === e4 ? t3.ascender = i3.readSVarint() : 5 === e4 && (t3.descender = i3.readSVarint());
      }
      function E_(e4, t3, i3) {
        1 === e4 ? t3.id = i3.readVarint() : 2 === e4 ? t3.bitmap = i3.readBytes() : 3 === e4 ? t3.width = i3.readVarint() : 4 === e4 ? t3.height = i3.readVarint() : 5 === e4 ? t3.left = i3.readSVarint() : 6 === e4 ? t3.top = i3.readSVarint() : 7 === e4 && (t3.advance = i3.readVarint());
      }
      const M_ = b_, A_ = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, S_ = -17;
      class I_ {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(e4, t3) {
          const i3 = new I_();
          return i3.scale = e4 || 1, i3.fontStack = t3, i3;
        }
        static forImage(e4) {
          const t3 = new I_();
          return t3.imageName = e4, t3;
        }
      }
      class C_ {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(e4, t3) {
          const i3 = new C_();
          for (let r3 = 0; r3 < e4.sections.length; r3++) {
            const n4 = e4.sections[r3];
            n4.image ? i3.addImageSection(n4) : i3.addTextSection(n4, t3);
          }
          return i3;
        }
        length() {
          return this.text.length;
        }
        getSection(e4) {
          return this.sections[this.sectionIndex[e4]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(e4) {
          return this.sectionIndex[e4];
        }
        getCodePoint(e4) {
          return this.text.codePointAt(e4);
        }
        verticalizePunctuation(e4) {
          this.text = function(e5, t3) {
            let i3 = "";
            for (let r3 = 0; r3 < e5.length; r3++) {
              const n4 = e5.charCodeAt(r3 + 1) || null, o3 = e5.charCodeAt(r3 - 1) || null;
              i3 += !t3 && (n4 && Gs(n4) && !y_[e5[r3 + 1]] || o3 && Gs(o3) && !y_[e5[r3 - 1]]) || !y_[e5[r3]] ? e5[r3] : y_[e5[r3]];
            }
            return i3;
          }(this.text, e4);
        }
        trim() {
          let e4 = 0;
          for (let t4 = 0; t4 < this.text.length && P_[this.text.charCodeAt(t4)]; t4++)
            e4++;
          let t3 = this.text.length;
          for (let i3 = this.text.length - 1; i3 >= 0 && i3 >= e4 && P_[this.text.charCodeAt(i3)]; i3--)
            t3--;
          this.text = this.text.substring(e4, t3), this.sectionIndex = this.sectionIndex.slice(e4, t3);
        }
        substring(e4, t3) {
          const i3 = new C_();
          return i3.text = this.text.substring(e4, t3), i3.sectionIndex = this.sectionIndex.slice(e4, t3), i3.sections = this.sections, i3;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((e4, t3) => Math.max(e4, this.sections[t3].scale), 0);
        }
        addTextSection(e4, t3) {
          this.text += e4.text, this.sections.push(I_.forText(e4.scale, e4.fontStack || t3));
          const i3 = this.sections.length - 1;
          for (let t4 = 0; t4 < e4.text.length; ++t4)
            this.sectionIndex.push(i3);
        }
        addImageSection(e4) {
          const t3 = e4.image ? e4.image.namePrimary : "";
          if (0 === t3.length)
            return void H2("Can't add FormattedSection with an empty image.");
          const i3 = this.getNextImageSectionCharCode();
          i3 ? (this.text += String.fromCodePoint(i3), this.sections.push(I_.forImage(t3)), this.sectionIndex.push(this.sections.length - 1)) : H2("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function z_(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3) {
        const m3 = C_.fromFeature(e4, n4);
        u3 === A_.vertical && m3.verticalizePunctuation(d3);
        let _3 = [];
        const g3 = function(e5, t4, i4, r4, n5, o4) {
          if (!e5)
            return [];
          const s7 = [], a4 = function(e6, t5, i5, r5, n6, o5) {
            let s8 = 0;
            for (let i6 = 0; i6 < e6.length(); i6++) {
              const a5 = e6.getSection(i6);
              s8 += R_(e6.getCodePoint(i6), a5, r5, n6, t5, o5);
            }
            return s8 / Math.max(1, Math.ceil(s8 / i5));
          }(e5, t4, i4, r4, n5, o4), l4 = e5.text.indexOf("") >= 0;
          let c4 = 0;
          for (let i5 = 0; i5 < e5.length(); i5++) {
            const u4 = e5.getSection(i5), d4 = e5.getCodePoint(i5);
            if (P_[d4] || (c4 += R_(d4, u4, r4, n5, t4, o4)), i5 < e5.length() - 1) {
              const t5 = !((h4 = d4) < 11904 || !(Fs["Bopomofo Extended"](h4) || Fs.Bopomofo(h4) || Fs["CJK Compatibility Forms"](h4) || Fs["CJK Compatibility Ideographs"](h4) || Fs["CJK Compatibility"](h4) || Fs["CJK Radicals Supplement"](h4) || Fs["CJK Strokes"](h4) || Fs["CJK Symbols and Punctuation"](h4) || Fs["CJK Unified Ideographs Extension A"](h4) || Fs["CJK Unified Ideographs"](h4) || Fs["Enclosed CJK Letters and Months"](h4) || Fs["Halfwidth and Fullwidth Forms"](h4) || Fs.Hiragana(h4) || Fs["Ideographic Description Characters"](h4) || Fs["Kangxi Radicals"](h4) || Fs["Katakana Phonetic Extensions"](h4) || Fs.Katakana(h4) || Fs["Vertical Forms"](h4) || Fs["Yi Radicals"](h4) || Fs["Yi Syllables"](h4)));
              (D_[d4] || t5 || u4.imageName) && s7.push(O_(i5 + 1, c4, a4, s7, k_(d4, e5.getCodePoint(i5 + 1), t5 && l4), false));
            }
          }
          var h4;
          return B_(O_(e5.length(), c4, a4, s7, 0, true));
        }(m3, c3, o3, t3, r3, p3), { processBidirectionalText: y3, processStyledBidirectionalText: x3 } = na;
        if (y3 && 1 === m3.sections.length) {
          const e5 = y3(m3.toString(), g3);
          for (const t4 of e5) {
            const e6 = new C_();
            e6.text = t4, e6.sections = m3.sections;
            for (let i4 = 0; i4 < t4.length; i4++)
              e6.sectionIndex.push(0);
            _3.push(e6);
          }
        } else if (x3) {
          const e5 = x3(m3.text, m3.sectionIndex, g3);
          for (const t4 of e5) {
            const e6 = new C_();
            e6.text = t4[0], e6.sectionIndex = t4[1], e6.sections = m3.sections, _3.push(e6);
          }
        } else
          _3 = function(e5, t4) {
            const i4 = [], r4 = e5.text;
            let n5 = 0;
            for (const r5 of t4)
              i4.push(e5.substring(n5, r5)), n5 = r5;
            return n5 < r4.length && i4.push(e5.substring(n5, r4.length)), i4;
          }(m3, g3);
        const v3 = [], b3 = { positionedLines: v3, text: m3.toString(), top: h3[1], bottom: h3[1], left: h3[0], right: h3[0], writingMode: u3, iconsInText: false, verticalizable: false, hasBaseline: false };
        return function(e5, t4, i4, r4, n5, o4, s7, a4, l4, c4, h4, u4) {
          let d4 = 0, p4 = 0, f4 = 0;
          const m4 = "right" === a4 ? 1 : "left" === a4 ? 0 : 0.5;
          let _4 = false;
          for (const e6 of n5) {
            const i5 = e6.getSections();
            for (const e7 of i5) {
              if (e7.imageName)
                continue;
              const i6 = t4[e7.fontStack];
              if (i6 && (_4 = void 0 !== i6.ascender && void 0 !== i6.descender, !_4))
                break;
            }
            if (!_4)
              break;
          }
          let g4 = 0;
          for (const s8 of n5) {
            s8.trim();
            const n6 = s8.getMaxScale(), a5 = (n6 - 1) * u_, x5 = { positionedGlyphs: [], lineOffset: 0 };
            e5.positionedLines[g4] = x5;
            const v5 = x5.positionedGlyphs;
            let b5 = 0;
            if (!s8.length()) {
              p4 += o4, ++g4;
              continue;
            }
            let w3 = 0, T3 = 0;
            for (let o5 = 0; o5 < s8.length(); o5++) {
              const a6 = s8.getSection(o5), f5 = s8.getSectionIndex(o5), m5 = s8.getCodePoint(o5);
              let g5 = a6.scale, x6 = null, E4 = null, M3 = null, A3 = u_, S3 = 0;
              const I3 = !(l4 === A_.horizontal || !h4 && !js(m5) || h4 && (P_[m5] || (y4 = m5, Fs.Arabic(y4) || Fs["Arabic Supplement"](y4) || Fs["Arabic Extended-A"](y4) || Fs["Arabic Presentation Forms-A"](y4) || Fs["Arabic Presentation Forms-B"](y4))));
              if (a6.imageName) {
                const t5 = r4[a6.imageName];
                if (!t5)
                  continue;
                M3 = a6.imageName, e5.iconsInText = e5.iconsInText || true, E4 = t5.paddedRect;
                const i5 = t5.displaySize;
                g5 = g5 * u_ / u4, x6 = { width: i5[0], height: i5[1], left: 0, top: -M_, advance: I3 ? i5[1] : i5[0], localGlyph: false }, S3 = _4 ? -x6.height * g5 : S_ + n6 * u_ - i5[1] * g5, A3 = x6.advance;
                const o6 = (I3 ? i5[0] : i5[1]) * g5 - u_ * n6;
                o6 > 0 && o6 > b5 && (b5 = o6);
              } else {
                const e6 = i4[a6.fontStack];
                if (!e6)
                  continue;
                e6[m5] && (E4 = e6[m5]);
                const r5 = t4[a6.fontStack];
                if (!r5)
                  continue;
                const o6 = r5.glyphs[m5];
                if (!o6)
                  continue;
                if (x6 = o6.metrics, A3 = 8203 !== m5 ? u_ : 0, _4) {
                  const e7 = void 0 !== r5.ascender ? Math.abs(r5.ascender) : 0, t5 = void 0 !== r5.descender ? Math.abs(r5.descender) : 0, i5 = (e7 + t5) * g5;
                  w3 < i5 && (w3 = i5, T3 = (e7 - t5) / 2 * g5), S3 = -e7 * g5;
                } else
                  S3 = S_ + (n6 - g5) * u_;
              }
              I3 ? (e5.verticalizable = true, v5.push({ glyph: m5, imageName: M3, x: d4, y: p4 + S3, vertical: I3, scale: g5, localGlyph: x6.localGlyph, fontStack: a6.fontStack, sectionIndex: f5, metrics: x6, rect: E4 }), d4 += A3 * g5 + c4) : (v5.push({ glyph: m5, imageName: M3, x: d4, y: p4 + S3, vertical: I3, scale: g5, localGlyph: x6.localGlyph, fontStack: a6.fontStack, sectionIndex: f5, metrics: x6, rect: E4 }), d4 += x6.advance * g5 + c4);
            }
            0 !== v5.length && (f4 = Math.max(d4 - c4, f4), _4 ? N_(v5, m4, b5, T3, o4 * n6 / 2) : N_(v5, m4, b5, 0, o4 / 2)), d4 = 0;
            const E3 = o4 * n6 + b5;
            x5.lineOffset = Math.max(b5, a5), p4 += E3, ++g4;
          }
          var y4;
          const x4 = p4, { horizontalAlign: v4, verticalAlign: b4 } = F_(s7);
          (function(e6, t5, i5, r5, n6, o5) {
            const s8 = (t5 - i5) * n6, a5 = -o5 * r5;
            for (const t6 of e6)
              for (const e7 of t6.positionedGlyphs)
                e7.x += s8, e7.y += a5;
          })(e5.positionedLines, m4, v4, b4, f4, x4), e5.top += -b4 * x4, e5.bottom = e5.top + x4, e5.left += -v4 * f4, e5.right = e5.left + f4, e5.hasBaseline = _4;
        }(b3, t3, i3, r3, _3, s6, a3, l3, u3, c3, d3, f3), !function(e5) {
          for (const t4 of e5)
            if (0 !== t4.positionedGlyphs.length)
              return false;
          return true;
        }(v3) && b3;
      }
      const P_ = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, D_ = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
      function R_(e4, t3, i3, r3, n4, o3) {
        if (t3.imageName) {
          const e5 = r3[t3.imageName];
          return e5 ? e5.displaySize[0] * t3.scale * u_ / o3 + n4 : 0;
        }
        {
          const r4 = i3[t3.fontStack], o4 = r4 && r4.glyphs[e4];
          return o4 ? o4.metrics.advance * t3.scale + n4 : 0;
        }
      }
      function L_(e4, t3, i3, r3) {
        const n4 = Math.pow(e4 - t3, 2);
        return r3 ? e4 < t3 ? n4 / 2 : 2 * n4 : n4 + Math.abs(i3) * i3;
      }
      function k_(e4, t3, i3) {
        let r3 = 0;
        return 10 === e4 && (r3 -= 1e4), i3 && (r3 += 150), 40 !== e4 && 65288 !== e4 || (r3 += 50), 41 !== t3 && 65289 !== t3 || (r3 += 50), r3;
      }
      function O_(e4, t3, i3, r3, n4, o3) {
        let s6 = null, a3 = L_(t3, i3, n4, o3);
        for (const e5 of r3) {
          const r4 = L_(t3 - e5.x, i3, n4, o3) + e5.badness;
          r4 <= a3 && (s6 = e5, a3 = r4);
        }
        return { index: e4, x: t3, priorBreak: s6, badness: a3 };
      }
      function B_(e4) {
        return e4 ? B_(e4.priorBreak).concat(e4.index) : [];
      }
      function F_(e4) {
        let t3 = 0.5, i3 = 0.5;
        switch (e4) {
          case "right":
          case "top-right":
          case "bottom-right":
            t3 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            t3 = 0;
        }
        switch (e4) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            i3 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            i3 = 0;
        }
        return { horizontalAlign: t3, verticalAlign: i3 };
      }
      function N_(e4, t3, i3, r3, n4) {
        if (!(t3 || i3 || r3 || n4))
          return;
        const o3 = e4.length - 1, s6 = e4[o3], a3 = (s6.x + s6.metrics.advance * s6.scale) * t3;
        for (let t4 = 0; t4 <= o3; t4++)
          e4[t4].x -= a3, e4[t4].y += i3 + r3 + n4;
      }
      function U_(e4, t3, i3, r3) {
        const { horizontalAlign: n4, verticalAlign: o3 } = F_(r3), s6 = i3[0] - e4.displaySize[0] * n4, a3 = i3[1] - e4.displaySize[1] * o3;
        return { imagePrimary: e4, imageSecondary: t3, top: a3, bottom: a3 + e4.displaySize[1], left: s6, right: s6 + e4.displaySize[0] };
      }
      function V_(e4, t3, i3, r3, n4, o3) {
        const s6 = e4.imagePrimary;
        let a3;
        if (s6.content) {
          const e5 = s6.content, t4 = s6.pixelRatio || 1;
          a3 = [e5[0] / t4, e5[1] / t4, s6.displaySize[0] - e5[2] / t4, s6.displaySize[1] - e5[3] / t4];
        }
        const l3 = t3.left * o3, c3 = t3.right * o3;
        let h3, u3, d3, p3;
        "width" === i3 || "both" === i3 ? (p3 = n4[0] + l3 - r3[3], u3 = n4[0] + c3 + r3[1]) : (p3 = n4[0] + (l3 + c3 - s6.displaySize[0]) / 2, u3 = p3 + s6.displaySize[0]);
        const f3 = t3.top * o3, m3 = t3.bottom * o3;
        return "height" === i3 || "both" === i3 ? (h3 = n4[1] + f3 - r3[0], d3 = n4[1] + m3 + r3[2]) : (h3 = n4[1] + (f3 + m3 - s6.displaySize[1]) / 2, d3 = h3 + s6.displaySize[1]), { imagePrimary: s6, imageSecondary: void 0, top: h3, right: u3, bottom: d3, left: p3, collisionPadding: a3 };
      }
      class j_ extends y2 {
        constructor(e4, t3, i3, r3, n4) {
          super(e4, t3), this.angle = r3, this.z = i3, void 0 !== n4 && (this.segment = n4);
        }
        clone() {
          return new j_(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function G_(e4, t3, i3, r3, n4) {
        if (void 0 === t3.segment)
          return true;
        let o3 = t3, s6 = t3.segment + 1, a3 = 0;
        for (; a3 > -i3 / 2; ) {
          if (s6--, s6 < 0)
            return false;
          a3 -= e4[s6].dist(o3), o3 = e4[s6];
        }
        a3 += e4[s6].dist(e4[s6 + 1]), s6++;
        const l3 = [];
        let c3 = 0;
        for (; a3 < i3 / 2; ) {
          const t4 = e4[s6], i4 = e4[s6 + 1];
          if (!i4)
            return false;
          let o4 = e4[s6 - 1].angleTo(t4) - t4.angleTo(i4);
          for (o4 = Math.abs((o4 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l3.push({ distance: a3, angleDelta: o4 }), c3 += o4; a3 - l3[0].distance > r3; )
            c3 -= l3.shift().angleDelta;
          if (c3 > n4)
            return false;
          s6++, a3 += t4.dist(i4);
        }
        return true;
      }
      function q_(e4) {
        let t3 = 0;
        for (let i3 = 0; i3 < e4.length - 1; i3++)
          t3 += e4[i3].dist(e4[i3 + 1]);
        return t3;
      }
      function Z_(e4, t3, i3) {
        return e4 ? 0.6 * t3 * i3 : 0;
      }
      function $_(e4, t3) {
        return Math.max(e4 ? e4.right - e4.left : 0, t3 ? t3.right - t3.left : 0);
      }
      function W_(e4, t3, i3, r3, n4, o3) {
        const s6 = Z_(i3, n4, o3), a3 = $_(i3, r3) * o3;
        let l3 = 0;
        const c3 = q_(e4) / 2;
        for (let i4 = 0; i4 < e4.length - 1; i4++) {
          const r4 = e4[i4], n5 = e4[i4 + 1], o4 = r4.dist(n5);
          if (l3 + o4 > c3) {
            const h3 = (c3 - l3) / o4, u3 = Kr(r4.x, n5.x, h3), d3 = Kr(r4.y, n5.y, h3), p3 = new j_(u3, d3, 0, n5.angleTo(r4), i4);
            return !s6 || G_(e4, p3, a3, s6, t3) ? p3 : void 0;
          }
          l3 += o4;
        }
      }
      function H_(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        const c3 = Z_(r3, o3, s6), h3 = $_(r3, n4), u3 = h3 * s6, d3 = 0 === e4[0].x || e4[0].x === l3 || 0 === e4[0].y || e4[0].y === l3;
        return t3 - u3 < t3 / 4 && (t3 = u3 + t3 / 4), X_(e4, d3 ? t3 / 2 * a3 % t3 : (h3 / 2 + 2 * o3) * s6 * a3 % t3, t3, c3, i3, u3, d3, false, l3);
      }
      function X_(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        const c3 = o3 / 2, h3 = q_(e4);
        let u3 = 0, d3 = t3 - i3, p3 = [];
        for (let t4 = 0; t4 < e4.length - 1; t4++) {
          const s7 = e4[t4], a4 = e4[t4 + 1], f3 = s7.dist(a4), m3 = a4.angleTo(s7);
          for (; d3 + i3 < u3 + f3; ) {
            d3 += i3;
            const _3 = (d3 - u3) / f3, g3 = Kr(s7.x, a4.x, _3), y3 = Kr(s7.y, a4.y, _3);
            if (g3 >= 0 && g3 < l3 && y3 >= 0 && y3 < l3 && d3 - c3 >= 0 && d3 + c3 <= h3) {
              const i4 = new j_(g3, y3, 0, m3, t4);
              r3 && !G_(e4, i4, o3, r3, n4) || p3.push(i4);
            }
          }
          u3 += f3;
        }
        return a3 || p3.length || s6 || (p3 = X_(e4, u3 / 2, i3, r3, n4, o3, s6, true, l3)), p3;
      }
      function Y_(e4, t3, i3, r3, n4) {
        const o3 = [];
        for (let s6 = 0; s6 < e4.length; s6++) {
          const a3 = e4[s6];
          let l3;
          for (let e5 = 0; e5 < a3.length - 1; e5++) {
            let s7 = a3[e5], c3 = a3[e5 + 1];
            s7.x < t3 && c3.x < t3 || (s7.x < t3 ? s7 = new y2(t3, s7.y + (t3 - s7.x) / (c3.x - s7.x) * (c3.y - s7.y))._round() : c3.x < t3 && (c3 = new y2(t3, s7.y + (t3 - s7.x) / (c3.x - s7.x) * (c3.y - s7.y))._round()), s7.y < i3 && c3.y < i3 || (s7.y < i3 ? s7 = new y2(s7.x + (i3 - s7.y) / (c3.y - s7.y) * (c3.x - s7.x), i3)._round() : c3.y < i3 && (c3 = new y2(s7.x + (i3 - s7.y) / (c3.y - s7.y) * (c3.x - s7.x), i3)._round()), s7.x >= r3 && c3.x >= r3 || (s7.x >= r3 ? s7 = new y2(r3, s7.y + (r3 - s7.x) / (c3.x - s7.x) * (c3.y - s7.y))._round() : c3.x >= r3 && (c3 = new y2(r3, s7.y + (r3 - s7.x) / (c3.x - s7.x) * (c3.y - s7.y))._round()), s7.y >= n4 && c3.y >= n4 || (s7.y >= n4 ? s7 = new y2(s7.x + (n4 - s7.y) / (c3.y - s7.y) * (c3.x - s7.x), n4)._round() : c3.y >= n4 && (c3 = new y2(s7.x + (n4 - s7.y) / (c3.y - s7.y) * (c3.x - s7.x), n4)._round()), l3 && s7.equals(l3[l3.length - 1]) || (l3 = [s7], o3.push(l3)), l3.push(c3)))));
          }
        }
        return o3;
      }
      function K_(e4) {
        let t3 = 0, i3 = 0;
        for (const r4 of e4)
          t3 += r4.w * r4.h, i3 = Math.max(i3, r4.w);
        e4.sort((e5, t4) => t4.h - e5.h);
        const r3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t3 / 0.95)), i3), h: 1 / 0 }];
        let n4 = 0, o3 = 0;
        for (const t4 of e4)
          for (let e5 = r3.length - 1; e5 >= 0; e5--) {
            const i4 = r3[e5];
            if (!(t4.w > i4.w || t4.h > i4.h)) {
              if (t4.x = i4.x, t4.y = i4.y, o3 = Math.max(o3, t4.y + t4.h), n4 = Math.max(n4, t4.x + t4.w), t4.w === i4.w && t4.h === i4.h) {
                const t5 = r3.pop();
                e5 < r3.length && (r3[e5] = t5);
              } else
                t4.h === i4.h ? (i4.x += t4.w, i4.w -= t4.w) : t4.w === i4.w ? (i4.y += t4.h, i4.h -= t4.h) : (r3.push({ x: i4.x + t4.w, y: i4.y, w: i4.w - t4.w, h: t4.h }), i4.y += t4.h, i4.h -= t4.h);
              break;
            }
          }
        return { w: n4, h: o3, fill: t3 / (n4 * o3) || 0 };
      }
      Rs(j_, "Anchor");
      const J_ = 1;
      class Q_ {
        constructor(e4, { pixelRatio: t3, version: i3, stretchX: r3, stretchY: n4, content: o3 }) {
          this.paddedRect = e4, this.pixelRatio = t3, this.stretchX = r3, this.stretchY = n4, this.content = o3, this.version = i3;
        }
        get tl() {
          return [this.paddedRect.x + J_, this.paddedRect.y + J_];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - J_, this.paddedRect.y + this.paddedRect.h - J_];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * J_) / this.pixelRatio, (this.paddedRect.h - 2 * J_) / this.pixelRatio];
        }
      }
      class eg {
        constructor(e4, t3) {
          const i3 = {}, r3 = {};
          this.haveRenderCallbacks = [];
          const n4 = [];
          this.addImages(e4, i3, n4), this.addImages(t3, r3, n4);
          const { w: o3, h: s6 } = K_(n4), a3 = new ef({ width: o3 || 1, height: s6 || 1 });
          for (const t4 in e4) {
            const r4 = e4[t4], n5 = i3[t4].paddedRect;
            ef.copy(r4.data, a3, { x: 0, y: 0 }, { x: n5.x + J_, y: n5.y + J_ }, r4.data);
          }
          for (const e5 in t3) {
            const i4 = t3[e5], n5 = r3[e5].paddedRect, o4 = n5.x + J_, s7 = n5.y + J_, l3 = i4.data.width, c3 = i4.data.height;
            ef.copy(i4.data, a3, { x: 0, y: 0 }, { x: o4, y: s7 }, i4.data), ef.copy(i4.data, a3, { x: 0, y: c3 - 1 }, { x: o4, y: s7 - 1 }, { width: l3, height: 1 }), ef.copy(i4.data, a3, { x: 0, y: 0 }, { x: o4, y: s7 + c3 }, { width: l3, height: 1 }), ef.copy(i4.data, a3, { x: l3 - 1, y: 0 }, { x: o4 - 1, y: s7 }, { width: 1, height: c3 }), ef.copy(i4.data, a3, { x: 0, y: 0 }, { x: o4 + l3, y: s7 }, { width: 1, height: c3 });
          }
          this.image = a3, this.iconPositions = i3, this.patternPositions = r3;
        }
        addImages(e4, t3, i3) {
          for (const r3 in e4) {
            const n4 = e4[r3], o3 = { x: 0, y: 0, w: n4.data.width + 2 * J_, h: n4.data.height + 2 * J_ };
            i3.push(o3), t3[r3] = new Q_(o3, n4), n4.hasRenderCallback && this.haveRenderCallbacks.push(r3);
          }
        }
        patchUpdatedImages(e4, t3, i3) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((t4) => e4.hasImage(t4, i3)), e4.dispatchRenderCallbacks(this.haveRenderCallbacks, i3);
          for (const r3 in e4.getUpdatedImages(i3))
            this.patchUpdatedImage(this.iconPositions[r3], e4.getImage(r3, i3), t3), this.patchUpdatedImage(this.patternPositions[r3], e4.getImage(r3, i3), t3);
        }
        patchUpdatedImage(e4, t3, i3) {
          if (!e4 || !t3)
            return;
          if (e4.version === t3.version)
            return;
          e4.version = t3.version;
          const [r3, n4] = e4.tl;
          i3.update(t3.data, void 0, { x: r3, y: n4 });
        }
      }
      Rs(Q_, "ImagePosition"), Rs(eg, "ImageAtlas");
      const tg = 1e20;
      function ig(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        for (let c3 = t3; c3 < t3 + r3; c3++)
          rg(e4, i3 * o3 + c3, o3, n4, s6, a3, l3);
        for (let c3 = i3; c3 < i3 + n4; c3++)
          rg(e4, c3 * o3 + t3, 1, r3, s6, a3, l3);
      }
      function rg(e4, t3, i3, r3, n4, o3, s6) {
        o3[0] = 0, s6[0] = -tg, s6[1] = tg, n4[0] = e4[t3];
        for (let a3 = 1, l3 = 0, c3 = 0; a3 < r3; a3++) {
          n4[a3] = e4[t3 + a3 * i3];
          const r4 = a3 * a3;
          do {
            const e5 = o3[l3];
            c3 = (n4[a3] - n4[e5] + r4 - e5 * e5) / (a3 - e5) / 2;
          } while (c3 <= s6[l3] && --l3 > -1);
          l3++, o3[l3] = a3, s6[l3] = c3, s6[l3 + 1] = tg;
        }
        for (let a3 = 0, l3 = 0; a3 < r3; a3++) {
          for (; s6[l3 + 1] < a3; )
            l3++;
          const r4 = o3[l3], c3 = a3 - r4;
          e4[t3 + a3 * i3] = n4[r4] + c3 * c3;
        }
      }
      const ng = 2;
      class og {
        constructor(e4, t3, i3) {
          this.requestManager = e4, this.localGlyphMode = t3, this.localFontFamily = i3, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(e4, t3) {
          this.urls[t3] = e4;
        }
        getGlyphs(e4, t3, i3) {
          const r3 = [], o3 = this.urls[t3] || n3.GLYPHS_URL;
          for (const t4 in e4)
            for (const i4 of e4[t4])
              r3.push({ stack: t4, id: i4 });
          R2(r3, ({ stack: e5, id: t4 }, i4) => {
            let r4 = this.entries[e5];
            r4 || (r4 = this.entries[e5] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let n4 = r4.glyphs[t4];
            if (void 0 !== n4)
              return void i4(null, { stack: e5, id: t4, glyph: n4 });
            if (n4 = this._tinySDF(r4, e5, t4), n4)
              return r4.glyphs[t4] = n4, void i4(null, { stack: e5, id: t4, glyph: n4 });
            const s6 = Math.floor(t4 / 256);
            if (256 * s6 > 65535)
              return void i4(new Error("glyphs > 65535 not supported"));
            if (r4.ranges[s6])
              return void i4(null, { stack: e5, id: t4, glyph: n4 });
            let a3 = r4.requests[s6];
            a3 || (a3 = r4.requests[s6] = [], og.loadGlyphRange(e5, s6, o3, this.requestManager, (e6, t5) => {
              if (t5) {
                r4.ascender = t5.ascender, r4.descender = t5.descender;
                for (const e7 in t5.glyphs)
                  this._doesCharSupportLocalGlyph(+e7) || (r4.glyphs[+e7] = t5.glyphs[+e7]);
                r4.ranges[s6] = true;
              }
              for (const i5 of a3)
                i5(e6, t5);
              delete r4.requests[s6];
            })), a3.push((r5, n5) => {
              r5 ? i4(r5) : n5 && i4(null, { stack: e5, id: t4, glyph: n5.glyphs[t4] || null });
            });
          }, (e5, t4) => {
            if (e5)
              i3(e5);
            else if (t4) {
              const e6 = {};
              for (const { stack: i4, id: r4, glyph: n4 } of t4)
                void 0 === e6[i4] && (e6[i4] = {}), void 0 === e6[i4].glyphs && (e6[i4].glyphs = {}), e6[i4].glyphs[r4] = n4 && { id: n4.id, bitmap: n4.bitmap.clone(), metrics: n4.metrics }, e6[i4].ascender = this.entries[i4].ascender, e6[i4].descender = this.entries[i4].descender;
              i3(null, e6);
            }
          });
        }
        _doesCharSupportLocalGlyph(e4) {
          return 0 !== this.localGlyphMode && (2 === this.localGlyphMode ? !!this.localFontFamily : !!this.localFontFamily && (Fs["CJK Unified Ideographs"](e4) || Fs["Hangul Syllables"](e4) || Fs.Hiragana(e4) || Fs.Katakana(e4) || Fs["CJK Symbols and Punctuation"](e4) || Fs["CJK Unified Ideographs Extension A"](e4) || Fs["CJK Unified Ideographs Extension B"](e4)));
        }
        _tinySDF(e4, t3, i3) {
          const r3 = this.localFontFamily;
          if (!r3 || !this._doesCharSupportLocalGlyph(i3))
            return;
          let n4 = e4.tinySDF;
          if (!n4) {
            let i4 = "400";
            /bold/i.test(t3) ? i4 = "900" : /medium/i.test(t3) ? i4 = "500" : /light/i.test(t3) && (i4 = "200"), n4 = e4.tinySDF = new og.TinySDF({ fontFamily: r3, fontWeight: i4, fontSize: 24 * ng, buffer: 3 * ng, radius: 8 * ng }), n4.fontWeight = i4;
          }
          if (this.localGlyphs[n4.fontWeight][i3])
            return this.localGlyphs[n4.fontWeight][i3];
          const o3 = String.fromCodePoint(i3), { data: s6, width: a3, height: l3, glyphWidth: c3, glyphHeight: h3, glyphLeft: u3, glyphTop: d3, glyphAdvance: p3 } = n4.draw(o3);
          return this.localGlyphs[n4.fontWeight][i3] = { id: i3, bitmap: new Qp({ width: a3, height: l3 }, s6), metrics: { width: c3 / ng, height: h3 / ng, left: u3 / ng, top: d3 / ng - 27, advance: p3 / ng, localGlyph: true } };
        }
      }
      og.loadGlyphRange = function(e4, t3, i3, r3, n4) {
        const o3 = 256 * t3, s6 = o3 + 255, a3 = r3.transformRequest(r3.normalizeGlyphsURL(i3).replace("{fontstack}", e4).replace("{range}", `${o3}-${s6}`), ye.Glyphs);
        Te(a3, (e5, t4) => {
          if (e5)
            n4(e5);
          else if (t4) {
            const e6 = {}, i4 = function(e7) {
              return new km(e7).readFields(w_, {});
            }(t4);
            for (const t5 of i4.glyphs)
              e6[t5.id] = t5;
            n4(null, { glyphs: e6, ascender: i4.ascender, descender: i4.descender });
          }
        });
      }, og.TinySDF = class {
        constructor({ fontSize: e4 = 24, buffer: t3 = 3, radius: i3 = 8, cutoff: r3 = 0.25, fontFamily: n4 = "sans-serif", fontWeight: o3 = "normal", fontStyle: s6 = "normal" } = {}) {
          this.buffer = t3, this.cutoff = r3, this.radius = i3;
          const a3 = this.size = e4 + 4 * t3, l3 = this._createCanvas(a3), c3 = this.ctx = l3.getContext("2d", { willReadFrequently: true });
          c3.font = `${s6} ${o3} ${e4}px ${n4}`, c3.textBaseline = "alphabetic", c3.textAlign = "left", c3.fillStyle = "black", this.gridOuter = new Float64Array(a3 * a3), this.gridInner = new Float64Array(a3 * a3), this.f = new Float64Array(a3), this.z = new Float64Array(a3 + 1), this.v = new Uint16Array(a3);
        }
        _createCanvas(e4) {
          const t3 = document.createElement("canvas");
          return t3.width = t3.height = e4, t3;
        }
        draw(e4) {
          const { width: t3, actualBoundingBoxAscent: i3, actualBoundingBoxDescent: r3, actualBoundingBoxLeft: n4, actualBoundingBoxRight: o3 } = this.ctx.measureText(e4), s6 = Math.ceil(i3), a3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o3 - n4))), l3 = Math.min(this.size - this.buffer, s6 + Math.ceil(r3)), c3 = a3 + 2 * this.buffer, h3 = l3 + 2 * this.buffer, u3 = Math.max(c3 * h3, 0), d3 = new Uint8ClampedArray(u3), p3 = { data: d3, width: c3, height: h3, glyphWidth: a3, glyphHeight: l3, glyphTop: s6, glyphLeft: 0, glyphAdvance: t3 };
          if (0 === a3 || 0 === l3)
            return p3;
          const { ctx: f3, buffer: m3, gridInner: _3, gridOuter: g3 } = this;
          f3.clearRect(m3, m3, a3, l3), f3.fillText(e4, m3, m3 + s6);
          const y3 = f3.getImageData(m3, m3, a3, l3);
          g3.fill(tg, 0, u3), _3.fill(0, 0, u3);
          for (let e5 = 0; e5 < l3; e5++)
            for (let t4 = 0; t4 < a3; t4++) {
              const i4 = y3.data[4 * (e5 * a3 + t4) + 3] / 255;
              if (0 === i4)
                continue;
              const r4 = (e5 + m3) * c3 + t4 + m3;
              if (1 === i4)
                g3[r4] = 0, _3[r4] = tg;
              else {
                const e6 = 0.5 - i4;
                g3[r4] = e6 > 0 ? e6 * e6 : 0, _3[r4] = e6 < 0 ? e6 * e6 : 0;
              }
            }
          ig(g3, 0, 0, c3, h3, c3, this.f, this.v, this.z), ig(_3, m3, m3, a3, l3, c3, this.f, this.v, this.z);
          for (let e5 = 0; e5 < u3; e5++) {
            const t4 = Math.sqrt(g3[e5]) - Math.sqrt(_3[e5]);
            d3[e5] = Math.round(255 - 255 * (t4 / this.radius + this.cutoff));
          }
          return p3;
        }
      };
      const sg = J_;
      function ag(e4, t3, i3, r3) {
        const n4 = [], o3 = e4.imagePrimary, s6 = o3.pixelRatio, a3 = o3.paddedRect.w - 2 * sg, l3 = o3.paddedRect.h - 2 * sg, c3 = e4.right - e4.left, h3 = e4.bottom - e4.top, u3 = o3.stretchX || [[0, a3]], d3 = o3.stretchY || [[0, l3]], p3 = (e5, t4) => e5 + t4[1] - t4[0], f3 = u3.reduce(p3, 0), m3 = d3.reduce(p3, 0), _3 = a3 - f3, g3 = l3 - m3;
        let x3 = 0, v3 = f3, b3 = 0, w3 = m3, T3 = 0, E3 = _3, M3 = 0, A3 = g3;
        if (o3.content && r3) {
          const e5 = o3.content;
          x3 = lg(u3, 0, e5[0]), b3 = lg(d3, 0, e5[1]), v3 = lg(u3, e5[0], e5[2]), w3 = lg(d3, e5[1], e5[3]), T3 = e5[0] - x3, M3 = e5[1] - b3, E3 = e5[2] - e5[0] - v3, A3 = e5[3] - e5[1] - w3;
        }
        const S3 = (r4, n5, a4, l4) => {
          const u4 = hg(r4.stretch - x3, v3, c3, e4.left), d4 = ug(r4.fixed - T3, E3, r4.stretch, f3), p4 = hg(n5.stretch - b3, w3, h3, e4.top), _4 = ug(n5.fixed - M3, A3, n5.stretch, m3), g4 = hg(a4.stretch - x3, v3, c3, e4.left), S4 = ug(a4.fixed - T3, E3, a4.stretch, f3), I3 = hg(l4.stretch - b3, w3, h3, e4.top), C3 = ug(l4.fixed - M3, A3, l4.stretch, m3), z2 = new y2(u4, p4), P3 = new y2(g4, p4), D2 = new y2(g4, I3), R3 = new y2(u4, I3), L3 = new y2(d4 / s6, _4 / s6), k3 = new y2(S4 / s6, C3 / s6), O2 = t3 * Math.PI / 180;
          if (O2) {
            const e5 = Math.sin(O2), t4 = Math.cos(O2), i4 = [t4, -e5, e5, t4];
            z2._matMult(i4), P3._matMult(i4), R3._matMult(i4), D2._matMult(i4);
          }
          const B2 = r4.stretch + r4.fixed, F2 = a4.stretch + a4.fixed, N3 = n5.stretch + n5.fixed, U2 = l4.stretch + l4.fixed, V3 = e4.imageSecondary;
          return { tl: z2, tr: P3, bl: R3, br: D2, texPrimary: { x: o3.paddedRect.x + sg + B2, y: o3.paddedRect.y + sg + N3, w: F2 - B2, h: U2 - N3 }, texSecondary: V3 ? { x: V3.paddedRect.x + sg + B2, y: V3.paddedRect.y + sg + N3, w: F2 - B2, h: U2 - N3 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: L3, pixelOffsetBR: k3, minFontScaleX: E3 / s6 / c3, minFontScaleY: A3 / s6 / h3, isSDF: i3 };
        };
        if (r3 && (o3.stretchX || o3.stretchY)) {
          const e5 = cg(u3, _3, f3), t4 = cg(d3, g3, m3);
          for (let i4 = 0; i4 < e5.length - 1; i4++) {
            const r4 = e5[i4], o4 = e5[i4 + 1];
            for (let e6 = 0; e6 < t4.length - 1; e6++)
              n4.push(S3(r4, t4[e6], o4, t4[e6 + 1]));
          }
        } else
          n4.push(S3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: a3 + 1 }, { fixed: 0, stretch: l3 + 1 }));
        return n4;
      }
      function lg(e4, t3, i3) {
        let r3 = 0;
        for (const n4 of e4)
          r3 += Math.max(t3, Math.min(i3, n4[1])) - Math.max(t3, Math.min(i3, n4[0]));
        return r3;
      }
      function cg(e4, t3, i3) {
        const r3 = [{ fixed: -sg, stretch: 0 }];
        for (const [t4, i4] of e4) {
          const e5 = r3[r3.length - 1];
          r3.push({ fixed: t4 - e5.stretch, stretch: e5.stretch }), r3.push({ fixed: t4 - e5.stretch, stretch: e5.stretch + (i4 - t4) });
        }
        return r3.push({ fixed: t3 + sg, stretch: i3 }), r3;
      }
      function hg(e4, t3, i3, r3) {
        return e4 / t3 * i3 + r3;
      }
      function ug(e4, t3, i3, r3) {
        return e4 - t3 * i3 / r3;
      }
      function dg(e4, t3, i3, r3) {
        const n4 = t3 + e4.positionedLines[r3].lineOffset;
        return 0 === r3 ? i3 + n4 / 2 : i3 + (n4 + (t3 + e4.positionedLines[r3 - 1].lineOffset)) / 2;
      }
      function pg(e4, t3 = 1, i3 = false) {
        let r3 = 1 / 0, n4 = 1 / 0, o3 = -1 / 0, s6 = -1 / 0;
        const a3 = e4[0];
        for (let e5 = 0; e5 < a3.length; e5++) {
          const t4 = a3[e5];
          (!e5 || t4.x < r3) && (r3 = t4.x), (!e5 || t4.y < n4) && (n4 = t4.y), (!e5 || t4.x > o3) && (o3 = t4.x), (!e5 || t4.y > s6) && (s6 = t4.y);
        }
        const l3 = Math.min(o3 - r3, s6 - n4);
        let c3 = l3 / 2;
        const h3 = new lr([], fg);
        if (0 === l3)
          return new y2(r3, n4);
        for (let t4 = r3; t4 < o3; t4 += l3)
          for (let i4 = n4; i4 < s6; i4 += l3)
            h3.push(new mg(t4 + c3, i4 + c3, c3, e4));
        let u3 = function(e5) {
          let t4 = 0, i4 = 0, r4 = 0;
          const n5 = e5[0];
          for (let e6 = 0, o4 = n5.length, s7 = o4 - 1; e6 < o4; s7 = e6++) {
            const o5 = n5[e6], a4 = n5[s7], l4 = o5.x * a4.y - a4.x * o5.y;
            i4 += (o5.x + a4.x) * l4, r4 += (o5.y + a4.y) * l4, t4 += 3 * l4;
          }
          return new mg(i4 / t4, r4 / t4, 0, e5);
        }(e4), d3 = h3.length;
        for (; h3.length; ) {
          const r4 = h3.pop();
          (r4.d > u3.d || !u3.d) && (u3 = r4, i3 && console.log("found best %d after %d probes", Math.round(1e4 * r4.d) / 1e4, d3)), r4.max - u3.d <= t3 || (c3 = r4.h / 2, h3.push(new mg(r4.p.x - c3, r4.p.y - c3, c3, e4)), h3.push(new mg(r4.p.x + c3, r4.p.y - c3, c3, e4)), h3.push(new mg(r4.p.x - c3, r4.p.y + c3, c3, e4)), h3.push(new mg(r4.p.x + c3, r4.p.y + c3, c3, e4)), d3 += 4);
        }
        return i3 && (console.log(`num probes: ${d3}`), console.log(`best distance: ${u3.d}`)), u3.p;
      }
      function fg(e4, t3) {
        return t3.max - e4.max;
      }
      class mg {
        constructor(e4, t3, i3, r3) {
          this.p = new y2(e4, t3), this.h = i3, this.d = function(e5, t4) {
            let i4 = false, r4 = 1 / 0;
            for (let n4 = 0; n4 < t4.length; n4++) {
              const o3 = t4[n4];
              for (let t5 = 0, n5 = o3.length, s6 = n5 - 1; t5 < n5; s6 = t5++) {
                const n6 = o3[t5], a3 = o3[s6];
                n6.y > e5.y != a3.y > e5.y && e5.x < (a3.x - n6.x) * (e5.y - n6.y) / (a3.y - n6.y) + n6.x && (i4 = !i4), r4 = Math.min(r4, Ip(e5, n6, a3));
              }
            }
            return (i4 ? 1 : -1) * Math.sqrt(r4);
          }(this.p, r3), this.max = this.d + this.h * Math.SQRT2;
        }
      }
      const _g = 7, gg = Number.POSITIVE_INFINITY, yg = Math.sqrt(2);
      function xg(e4, [t3, i3]) {
        let r3 = 0, n4 = 0;
        if (i3 === gg) {
          t3 < 0 && (t3 = 0);
          const i4 = t3 / yg;
          switch (e4) {
            case "top-right":
            case "top-left":
              n4 = i4 - _g;
              break;
            case "bottom-right":
            case "bottom-left":
              n4 = -i4 + _g;
              break;
            case "bottom":
              n4 = -t3 + _g;
              break;
            case "top":
              n4 = t3 - _g;
          }
          switch (e4) {
            case "top-right":
            case "bottom-right":
              r3 = -i4;
              break;
            case "top-left":
            case "bottom-left":
              r3 = i4;
              break;
            case "left":
              r3 = t3;
              break;
            case "right":
              r3 = -t3;
          }
        } else {
          switch (t3 = Math.abs(t3), i3 = Math.abs(i3), e4) {
            case "top-right":
            case "top-left":
            case "top":
              n4 = i3 - _g;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              n4 = -i3 + _g;
          }
          switch (e4) {
            case "top-right":
            case "bottom-right":
            case "right":
              r3 = -t3;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              r3 = t3;
          }
        }
        return [r3, n4];
      }
      function vg(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3) {
        e4.createArrays(), e4.tilePixelRatio = cr / (512 * e4.overscaling), e4.compareText = {}, e4.iconsNeedLinear = false;
        const u3 = e4.layers[0].layout, d3 = e4.layers[0]._unevaluatedLayout._values, p3 = {};
        if ("composite" === e4.textSizeData.kind) {
          const { minZoom: t4, maxZoom: i4 } = e4.textSizeData;
          p3.compositeTextSizes = [d3["text-size"].possiblyEvaluate(new oa(t4), a3), d3["text-size"].possiblyEvaluate(new oa(i4), a3)];
        }
        if ("composite" === e4.iconSizeData.kind) {
          const { minZoom: t4, maxZoom: i4 } = e4.iconSizeData;
          p3.compositeIconSizes = [d3["icon-size"].possiblyEvaluate(new oa(t4), a3), d3["icon-size"].possiblyEvaluate(new oa(i4), a3)];
        }
        p3.layoutTextSize = d3["text-size"].possiblyEvaluate(new oa(l3 + 1), a3), p3.layoutIconSize = d3["icon-size"].possiblyEvaluate(new oa(l3 + 1), a3), p3.textMaxSize = d3["text-size"].possiblyEvaluate(new oa(18), a3);
        const f3 = "map" === u3.get("text-rotation-alignment") && "point" !== u3.get("symbol-placement"), m3 = u3.get("text-size");
        let _3 = false;
        for (const t4 of e4.features)
          if (t4.icon && t4.icon.nameSecondary) {
            _3 = true;
            break;
          }
        for (const o4 of e4.features) {
          const l4 = u3.get("text-font").evaluate(o4, {}, a3).join(","), d4 = m3.evaluate(o4, {}, a3), g3 = p3.layoutTextSize.evaluate(o4, {}, a3), y3 = (p3.layoutIconSize.evaluate(o4, {}, a3), { horizontal: {}, vertical: void 0 }), x3 = o4.text;
          let v3, b3 = [0, 0];
          if (x3) {
            const r4 = x3.toString(), s7 = u3.get("text-letter-spacing").evaluate(o4, {}, a3) * u_, c4 = u3.get("text-line-height").evaluate(o4, {}, a3) * u_, h4 = Us(r4) ? s7 : 0, p4 = u3.get("text-anchor").evaluate(o4, {}, a3), m4 = u3.get("text-variable-anchor");
            if (!m4) {
              const e5 = u3.get("text-radial-offset").evaluate(o4, {}, a3);
              b3 = e5 ? xg(p4, [e5 * u_, gg]) : u3.get("text-offset").evaluate(o4, {}, a3).map((e6) => e6 * u_);
            }
            let _4 = f3 ? "center" : u3.get("text-justify").evaluate(o4, {}, a3);
            const v4 = "point" === u3.get("symbol-placement"), w4 = v4 ? u3.get("text-max-width").evaluate(o4, {}, a3) * u_ : 1 / 0, T4 = (o5) => {
              e4.allowVerticalPlacement && Ns(r4) && (y3.vertical = z_(x3, t3, i3, n4, l4, w4, c4, p4, o5, h4, b3, A_.vertical, true, g3, d4));
            };
            if (!f3 && m4) {
              const e5 = "auto" === _4 ? m4.map((e6) => bg(e6)) : [_4];
              let r5 = false;
              for (let o5 = 0; o5 < e5.length; o5++) {
                const s8 = e5[o5];
                if (!y3.horizontal[s8])
                  if (r5)
                    y3.horizontal[s8] = y3.horizontal[0];
                  else {
                    const e6 = z_(x3, t3, i3, n4, l4, w4, c4, "center", s8, h4, b3, A_.horizontal, false, g3, d4);
                    e6 && (y3.horizontal[s8] = e6, r5 = 1 === e6.positionedLines.length);
                  }
              }
              T4("left");
            } else {
              if ("auto" === _4 && (_4 = bg(p4)), v4 || u3.get("text-writing-mode").indexOf("horizontal") >= 0 || !Ns(r4)) {
                const e5 = z_(x3, t3, i3, n4, l4, w4, c4, p4, _4, h4, b3, A_.horizontal, false, g3, d4);
                e5 && (y3.horizontal[_4] = e5);
              }
              T4(v4 ? "left" : _4);
            }
          }
          let w3 = false;
          if (o4.icon && o4.icon.namePrimary) {
            const t4 = r3[o4.icon.namePrimary];
            t4 && (v3 = U_(n4[o4.icon.namePrimary], o4.icon.nameSecondary ? n4[o4.icon.nameSecondary] : void 0, u3.get("icon-offset").evaluate(o4, {}, a3), u3.get("icon-anchor").evaluate(o4, {}, a3)), w3 = t4.sdf, void 0 === e4.sdfIcons ? e4.sdfIcons = t4.sdf : e4.sdfIcons !== t4.sdf && H2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t4.pixelRatio !== e4.pixelRatio || 0 !== u3.get("icon-rotate").constantOr(1)) && (e4.iconsNeedLinear = true));
          }
          const T3 = Ag(y3.horizontal) || y3.vertical;
          e4.iconsInText || (e4.iconsInText = !!T3 && T3.iconsInText), (T3 || v3) && wg(e4, o4, y3, v3, r3, p3, g3, 0, b3, w3, s6, a3, c3, h3, _3);
        }
        o3 && e4.generateCollisionDebugBuffers(l3, e4.collisionBoxArray);
      }
      function bg(e4) {
        switch (e4) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function wg(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3) {
        let m3 = o3.textMaxSize.evaluate(t3, {}, u3);
        void 0 === m3 && (m3 = s6);
        const _3 = e4.layers[0].layout, g3 = _3.get("icon-offset").evaluate(t3, {}, u3), y3 = Ag(i3.horizontal) || i3.vertical, x3 = "globe" === d3.name, v3 = u_, b3 = s6 / v3, T3 = e4.tilePixelRatio * m3 / v3, E3 = (D2 = e4.overscaling, e4.zoom > 18 && D2 > 2 && (D2 >>= 1), Math.max(cr / (512 * D2), 1) * _3.get("symbol-spacing")), M3 = _3.get("text-padding") * e4.tilePixelRatio, A3 = _3.get("icon-padding") * e4.tilePixelRatio, S3 = w2(_3.get("text-max-angle")), I3 = "map" === _3.get("text-rotation-alignment") && "point" !== _3.get("symbol-placement"), C3 = "map" === _3.get("icon-rotation-alignment") && "point" !== _3.get("symbol-placement"), z2 = _3.get("symbol-placement"), P3 = E3 / 2;
        var D2;
        const R3 = _3.get("icon-text-fit").evaluate(t3, {}, u3), L3 = _3.get("icon-text-fit-padding").evaluate(t3, {}, u3), k3 = "none" !== R3;
        let O2;
        false === e4.hasAnyIconTextFit && k3 && (e4.hasAnyIconTextFit = true), r3 && k3 && (e4.allowVerticalPlacement && i3.vertical && (O2 = V_(r3, i3.vertical, R3, L3, g3, b3)), y3 && (r3 = V_(r3, y3, R3, L3, g3, b3)));
        const B2 = (s7, a4, m4) => {
          if (a4.x < 0 || a4.x >= cr || a4.y < 0 || a4.y >= cr)
            return;
          let _4 = null;
          if (x3) {
            const { x: e5, y: t4, z: i4 } = d3.projectTilePoint(a4.x, a4.y, m4);
            _4 = { anchor: new j_(e5, t4, i4, 0, void 0), up: d3.upVector(m4, a4.x, a4.y) };
          }
          !function(e5, t4, i4, r4, n5, o4, s8, a5, l4, c4, h4, u4, d4, p4, f4, m5, _5, g4, y4, x4, v4, b4, w3, T4, E4, M4, A4) {
            const S4 = e5.addToLineVertexArray(t4, r4);
            let I4, C4, z3, P4, D3, R4, L4, k4 = 0, O3 = 0, B3 = 0, F2 = 0, N3 = -1, U2 = -1;
            const V3 = {};
            let j3 = Cl("");
            const G2 = i4 ? i4.anchor : t4, q2 = "none" !== l4.layout.get("icon-text-fit").evaluate(v4, {}, E4);
            let Z3 = 0, $3 = 0;
            if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset") ? [Z3, $3] = l4.layout.get("text-offset").evaluate(v4, {}, E4).map((e6) => e6 * u_) : (Z3 = l4.layout.get("text-radial-offset").evaluate(v4, {}, E4) * u_, $3 = gg), e5.allowVerticalPlacement && n5.vertical) {
              const e6 = n5.vertical;
              if (f4)
                R4 = Ig(e6), a5 && (L4 = Ig(a5));
              else {
                const i5 = l4.layout.get("text-rotate").evaluate(v4, {}, E4) + 90;
                z3 = Sg(c4, G2, t4, h4, u4, d4, e6, p4, i5, m5), a5 && (P4 = Sg(c4, G2, t4, h4, u4, d4, a5, g4, i5));
              }
            }
            if (o4) {
              const r5 = l4.layout.get("icon-rotate").evaluate(v4, {}, E4), n6 = ag(o4, r5, w3, q2), s9 = a5 ? ag(a5, r5, w3, q2) : void 0;
              C4 = Sg(c4, G2, t4, h4, u4, d4, o4, g4, r5), k4 = 4 * n6.length;
              const p5 = e5.iconSizeData;
              let f5 = null;
              "source" === p5.kind ? (f5 = [d_ * l4.layout.get("icon-size").evaluate(v4, {}, E4)], f5[0] > Eg && H2(`${e5.layerIds[0]}: Value for "icon-size" is >= ${Tg}. Reduce your "icon-size".`)) : "composite" === p5.kind && (f5 = [d_ * b4.compositeIconSizes[0].evaluate(v4, {}, E4), d_ * b4.compositeIconSizes[1].evaluate(v4, {}, E4)], (f5[0] > Eg || f5[1] > Eg) && H2(`${e5.layerIds[0]}: Value for "icon-size" is >= ${Tg}. Reduce your "icon-size".`)), e5.addSymbols(e5.icon, n6, f5, x4, y4, v4, false, i4, t4, S4.lineStartIndex, S4.lineLength, -1, T4, E4, M4, A4), N3 = e5.icon.placedSymbolArray.length - 1, s9 && (O3 = 4 * s9.length, e5.addSymbols(e5.icon, s9, f5, x4, y4, v4, A_.vertical, i4, t4, S4.lineStartIndex, S4.lineLength, -1, T4, E4, M4, A4), U2 = e5.icon.placedSymbolArray.length - 1);
            }
            for (const r5 in n5.horizontal) {
              const o5 = n5.horizontal[r5];
              I4 || (j3 = Cl(o5.text), f4 ? D3 = Ig(o5) : I4 = Sg(c4, G2, t4, h4, u4, d4, o5, p4, l4.layout.get("text-rotate").evaluate(v4, {}, E4), m5));
              const a6 = 1 === o5.positionedLines.length;
              if (B3 += Mg(e5, i4, t4, o5, s8, l4, f4, v4, m5, S4, n5.vertical ? A_.horizontal : A_.horizontalOnly, a6 ? Object.keys(n5.horizontal) : [r5], V3, N3, b4, T4, E4, M4), a6)
                break;
            }
            n5.vertical && (F2 += Mg(e5, i4, t4, n5.vertical, s8, l4, f4, v4, m5, S4, A_.vertical, ["vertical"], V3, U2, b4, T4, E4, M4));
            let W2 = -1;
            const X2 = (e6, t5) => e6 ? Math.max(e6, t5) : t5;
            W2 = X2(D3, W2), W2 = X2(R4, W2), W2 = X2(L4, W2);
            const Y2 = W2 > -1 ? 1 : 0;
            e5.glyphOffsetArray.length >= gy.MAX_GLYPHS && H2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== v4.sortKey && e5.addToSortKeyRanges(e5.symbolInstances.length, v4.sortKey), e5.symbolInstances.emplaceBack(t4.x, t4.y, G2.x, G2.y, G2.z, V3.right >= 0 ? V3.right : -1, V3.center >= 0 ? V3.center : -1, V3.left >= 0 ? V3.left : -1, V3.vertical >= 0 ? V3.vertical : -1, N3, U2, j3, void 0 !== I4 ? I4 : e5.collisionBoxArray.length, void 0 !== I4 ? I4 + 1 : e5.collisionBoxArray.length, void 0 !== z3 ? z3 : e5.collisionBoxArray.length, void 0 !== z3 ? z3 + 1 : e5.collisionBoxArray.length, void 0 !== C4 ? C4 : e5.collisionBoxArray.length, void 0 !== C4 ? C4 + 1 : e5.collisionBoxArray.length, P4 || e5.collisionBoxArray.length, P4 ? P4 + 1 : e5.collisionBoxArray.length, h4, B3, F2, k4, O3, Y2, 0, Z3, $3, W2, 0, q2 ? 1 : 0);
          }(e4, a4, _4, s7, i3, r3, n4, O2, e4.layers[0], e4.collisionBoxArray, t3.index, t3.sourceLayerIndex, e4.index, M3, I3, l3, 0, A3, C3, g3, t3, o3, c3, h3, u3, p3, f3);
        };
        if ("line" === z2)
          for (const n5 of Y_(t3.geometry, 0, 0, cr, cr)) {
            const t4 = H_(n5, E3, S3, i3.vertical || y3, r3, v3, T3, e4.overscaling, cr);
            for (const i4 of t4)
              y3 && Cg(e4, y3.text, P3, i4) || B2(n5, i4, u3);
          }
        else if ("line-center" === z2) {
          for (const e5 of t3.geometry)
            if (e5.length > 1) {
              const t4 = W_(e5, S3, i3.vertical || y3, r3, v3, T3);
              t4 && B2(e5, t4, u3);
            }
        } else if ("Polygon" === t3.type)
          for (const e5 of Ff(t3.geometry, 0)) {
            const t4 = pg(e5, 16);
            B2(e5[0], new j_(t4.x, t4.y, 0, 0, void 0), u3);
          }
        else if ("LineString" === t3.type)
          for (const e5 of t3.geometry)
            B2(e5, new j_(e5[0].x, e5[0].y, 0, 0, void 0), u3);
        else if ("Point" === t3.type)
          for (const e5 of t3.geometry)
            for (const t4 of e5)
              B2([t4], new j_(t4.x, t4.y, 0, 0, void 0), u3);
      }
      const Tg = 255, Eg = Tg * d_;
      function Mg(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3) {
        const x3 = function(e5, t4, i4, r4, n5, o4, s7, a4) {
          const l4 = [];
          if (0 === t4.positionedLines.length)
            return l4;
          const c4 = r4.layout.get("text-rotate").evaluate(o4, {}) * Math.PI / 180, h4 = function(e6) {
            const t5 = e6[0], i5 = e6[1], r5 = t5 * i5;
            return r5 > 0 ? [t5, -i5] : r5 < 0 ? [-t5, i5] : 0 === t5 ? [i5, t5] : [i5, -t5];
          }(i4);
          let u4 = Math.abs(t4.top - t4.bottom);
          for (const e6 of t4.positionedLines)
            u4 -= e6.lineOffset;
          const d4 = t4.positionedLines.length, p4 = u4 / d4;
          let f4 = t4.top - i4[1];
          for (let e6 = 0; e6 < d4; ++e6) {
            const r5 = t4.positionedLines[e6];
            f4 = dg(t4, p4, f4, e6);
            for (const e7 of r5.positionedGlyphs) {
              if (!e7.rect)
                continue;
              const r6 = e7.rect || {};
              let o5 = M_ + 1, u5 = true, d5 = 1, p5 = 0;
              if (e7.imageName) {
                const t5 = s7[e7.imageName];
                if (!t5)
                  continue;
                if (t5.sdf) {
                  H2("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                u5 = false, d5 = t5.pixelRatio, o5 = J_ / d5;
              }
              const m4 = (n5 || a4) && e7.vertical, _4 = e7.metrics.advance * e7.scale / 2, g4 = e7.metrics, x4 = e7.rect;
              if (null === x4)
                continue;
              a4 && t4.verticalizable && (p5 = e7.imageName ? _4 - e7.metrics.width * e7.scale / 2 : 0);
              const v4 = n5 ? [e7.x + _4, e7.y] : [0, 0];
              let b4 = [0, 0], w3 = [0, 0], T3 = false;
              n5 || (m4 ? (w3 = [e7.x + _4 + h4[0], e7.y + h4[1] - p5], T3 = true) : b4 = [e7.x + _4 + i4[0], e7.y + i4[1] - p5]);
              const E3 = x4.w * e7.scale / (d5 * (e7.localGlyph ? ng : 1)), M3 = x4.h * e7.scale / (d5 * (e7.localGlyph ? ng : 1));
              let A3, S3, I3, C3;
              if (m4) {
                const t5 = e7.y - f4, i5 = new y2(-_4, _4 - t5), r7 = -Math.PI / 2, n6 = new y2(...w3);
                A3 = new y2(-_4 + b4[0], b4[1]), A3._rotateAround(r7, i5)._add(n6), A3.x += -t5 + _4, A3.y -= (g4.left - o5) * e7.scale;
                const s8 = e7.imageName ? g4.advance * e7.scale : u_ * e7.scale, a5 = String.fromCodePoint(e7.glyph);
                x_(a5) ? A3.x += (1 - o5) * e7.scale : v_(a5) ? A3.x += s8 - g4.height * e7.scale + (-o5 - 1) * e7.scale : A3.x += e7.imageName || g4.width + 2 * o5 === x4.w && g4.height + 2 * o5 === x4.h ? (s8 - M3) / 2 : (s8 - (g4.height + 2 * o5) * e7.scale) / 2, S3 = new y2(A3.x, A3.y - E3), I3 = new y2(A3.x + M3, A3.y), C3 = new y2(A3.x + M3, A3.y - E3);
              } else {
                const t5 = (g4.left - o5) * e7.scale - _4 + b4[0], i5 = (-g4.top - o5) * e7.scale + b4[1], r7 = t5 + E3, n6 = i5 + M3;
                A3 = new y2(t5, i5), S3 = new y2(r7, i5), I3 = new y2(t5, n6), C3 = new y2(r7, n6);
              }
              if (c4) {
                let e8;
                e8 = n5 ? new y2(0, 0) : T3 ? new y2(h4[0], h4[1]) : new y2(i4[0], i4[1]), A3._rotateAround(c4, e8), S3._rotateAround(c4, e8), I3._rotateAround(c4, e8), C3._rotateAround(c4, e8);
              }
              const z2 = new y2(0, 0), P3 = new y2(0, 0);
              l4.push({ tl: A3, tr: S3, bl: I3, br: C3, texPrimary: r6, texSecondary: void 0, writingMode: t4.writingMode, glyphOffset: v4, sectionIndex: e7.sectionIndex, isSDF: u5, pixelOffsetTL: z2, pixelOffsetBR: P3, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return l4;
        }(0, r3, l3, o3, s6, a3, n4, e4.allowVerticalPlacement), v3 = e4.textSizeData;
        let b3 = null;
        "source" === v3.kind ? (b3 = [d_ * o3.layout.get("text-size").evaluate(a3, {}, _3)], b3[0] > Eg && H2(`${e4.layerIds[0]}: Value for "text-size" is >= ${Tg}. Reduce your "text-size".`)) : "composite" === v3.kind && (b3 = [d_ * f3.compositeTextSizes[0].evaluate(a3, {}, _3), d_ * f3.compositeTextSizes[1].evaluate(a3, {}, _3)], (b3[0] > Eg || b3[1] > Eg) && H2(`${e4.layerIds[0]}: Value for "text-size" is >= ${Tg}. Reduce your "text-size".`)), e4.addSymbols(e4.text, x3, b3, l3, s6, a3, h3, t3, i3, c3.lineStartIndex, c3.lineLength, p3, m3, _3, g3, false);
        for (const t4 of u3)
          d3[t4] = e4.text.placedSymbolArray.length - 1;
        return 4 * x3.length;
      }
      function Ag(e4) {
        for (const t3 in e4)
          return e4[t3];
        return null;
      }
      function Sg(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3) {
        let h3 = s6.top, u3 = s6.bottom, d3 = s6.left, p3 = s6.right;
        const f3 = s6.collisionPadding;
        if (f3 && (d3 -= f3[0], h3 -= f3[1], p3 += f3[2], u3 += f3[3]), l3) {
          const e5 = new y2(d3, h3), t4 = new y2(p3, h3), i4 = new y2(d3, u3), r4 = new y2(p3, u3), n5 = w2(l3);
          let o4 = new y2(0, 0);
          c3 && (o4 = new y2(c3[0], c3[1])), e5._rotateAround(n5, o4), t4._rotateAround(n5, o4), i4._rotateAround(n5, o4), r4._rotateAround(n5, o4), d3 = Math.min(e5.x, t4.x, i4.x, r4.x), p3 = Math.max(e5.x, t4.x, i4.x, r4.x), h3 = Math.min(e5.y, t4.y, i4.y, r4.y), u3 = Math.max(e5.y, t4.y, i4.y, r4.y);
        }
        return e4.emplaceBack(t3.x, t3.y, t3.z, i3.x, i3.y, d3, h3, p3, u3, a3, r3, n4, o3), e4.length - 1;
      }
      function Ig(e4) {
        e4.collisionPadding && (e4.top -= e4.collisionPadding[1], e4.bottom += e4.collisionPadding[3]);
        const t3 = e4.bottom - e4.top;
        return t3 > 0 ? Math.max(10, t3) : null;
      }
      function Cg(e4, t3, i3, r3) {
        const n4 = e4.compareText;
        if (t3 in n4) {
          const e5 = n4[t3];
          for (let t4 = e5.length - 1; t4 >= 0; t4--)
            if (r3.dist(e5[t4]) < i3)
              return true;
        } else
          n4[t3] = [];
        return n4[t3].push(r3), false;
      }
      function zg(e4, t3) {
        const i3 = e4.fovAboveCenter, r3 = e4.elevation ? e4.elevation.getMinElevationBelowMSL() * t3 : 0, n4 = (e4._camera.position[2] * e4.worldSize - r3) / Math.cos(e4._pitch), o3 = Math.sin(i3) * n4 / Math.sin(Math.max(Math.PI / 2 - e4._pitch - i3, 0.01)), s6 = Math.sin(e4._pitch) * o3 + n4;
        return Math.min(1.01 * s6, n4 * (1 / e4._horizonShift));
      }
      function Pg(e4, t3) {
        if (!t3.isReprojectedInTileSpace)
          return { scale: 1 << e4.z, x: e4.x, y: e4.y, x2: e4.x + 1, y2: e4.y + 1, projection: t3 };
        const i3 = Math.pow(2, -e4.z), r3 = e4.x * i3, n4 = (e4.x + 1) * i3, o3 = e4.y * i3, s6 = (e4.y + 1) * i3, a3 = ep(r3), l3 = ep(n4), c3 = tp(o3), h3 = tp(s6), u3 = t3.project(a3, c3), d3 = t3.project(l3, c3), p3 = t3.project(l3, h3), f3 = t3.project(a3, h3);
        let m3 = Math.min(u3.x, d3.x, p3.x, f3.x), _3 = Math.min(u3.y, d3.y, p3.y, f3.y), g3 = Math.max(u3.x, d3.x, p3.x, f3.x), y3 = Math.max(u3.y, d3.y, p3.y, f3.y);
        const x3 = i3 / 16;
        function v3(e5, i4, r4, n5, o4, s7) {
          const a4 = (r4 + o4) / 2, l4 = (n5 + s7) / 2, c4 = t3.project(ep(a4), tp(l4)), h4 = Math.max(0, m3 - c4.x, _3 - c4.y, c4.x - g3, c4.y - y3);
          m3 = Math.min(m3, c4.x), g3 = Math.max(g3, c4.x), _3 = Math.min(_3, c4.y), y3 = Math.max(y3, c4.y), h4 > x3 && (v3(e5, c4, r4, n5, a4, l4), v3(c4, i4, a4, l4, o4, s7));
        }
        v3(u3, d3, r3, o3, n4, o3), v3(d3, p3, n4, o3, n4, s6), v3(p3, f3, n4, s6, r3, s6), v3(f3, u3, r3, s6, r3, o3), m3 -= x3, _3 -= x3, g3 += x3, y3 += x3;
        const b3 = 1 / Math.max(g3 - m3, y3 - _3);
        return { scale: b3, x: m3 * b3, y: _3 * b3, x2: g3 * b3, y2: y3 * b3, projection: t3 };
      }
      function Dg(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
        if ("globe" === l3.name)
          return yd(e4, t3, new ju(i3, r3, n4), false);
        const c3 = Pg({ z: i3, x: r3, y: n4 }, l3);
        return new ed([(o3 + c3.x / c3.scale) * t3, t3 * (c3.y / c3.scale), s6], [(o3 + c3.x2 / c3.scale) * t3, t3 * (c3.y2 / c3.scale), a3]);
      }
      function Rg(e4, { x: t3, y: i3 }, r3 = 0) {
        return new y2(((t3 - r3) * e4.scale - e4.x) * cr, (i3 * e4.scale - e4.y) * cr);
      }
      function Lg(e4, t3, i3 = 0) {
        return Du.fromValues(((t3.x - i3) * e4.scale - e4.x) * cr, (t3.y * e4.scale - e4.y) * cr, ip(t3.z, t3.y));
      }
      const kg = Au.identity(new Float32Array(16));
      class Og {
        constructor(e4) {
          this.spec = e4, this.name = e4.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(e4, t3) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(e4, t3) {
          return new Wd(0, 0);
        }
        projectTilePoint(e4, t3, i3) {
          return { x: e4, y: t3, z: 0 };
        }
        locationPoint(e4, t3, i3 = true) {
          return e4._coordinatePoint(e4.locationCoordinate(t3), i3);
        }
        pixelsPerMeter(e4, t3) {
          return Qd(1, e4) * t3;
        }
        pixelSpaceConversion(e4, t3, i3) {
          return 1;
        }
        farthestPixelDistance(e4) {
          return zg(e4, e4.pixelsPerMeter);
        }
        pointCoordinate(e4, t3, i3, r3) {
          const n4 = e4.horizonLineFromTop(false), o3 = new y2(t3, Math.max(n4, i3));
          return e4.rayIntersectionCoordinate(e4.pointRayIntersection(o3, r3));
        }
        pointCoordinate3D(e4, t3, i3) {
          const r3 = new y2(t3, i3);
          if (e4.elevation)
            return e4.elevation.pointCoordinate(r3);
          {
            const t4 = this.pointCoordinate(e4, r3.x, r3.y, 0);
            return [t4.x, t4.y, t4.z];
          }
        }
        isPointAboveHorizon(e4, t3) {
          if (e4.elevation)
            return !this.pointCoordinate3D(e4, t3.x, t3.y);
          const i3 = e4.horizonLineFromTop();
          return t3.y < i3;
        }
        createInversionMatrix(e4, t3) {
          return kg;
        }
        createTileMatrix(e4, t3, i3) {
          let r3, n4, o3;
          const s6 = i3.canonical, a3 = Au.identity(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const l3 = Pg(s6, this);
            r3 = 1, n4 = l3.x + i3.wrap * l3.scale, o3 = l3.y, Au.scale(a3, a3, [r3 / l3.scale, r3 / l3.scale, e4.pixelsPerMeter / t3]);
          } else
            r3 = t3 / e4.zoomScale(s6.z), n4 = (s6.x + Math.pow(2, s6.z) * i3.wrap) * r3, o3 = s6.y * r3;
          return Au.translate(a3, a3, [n4, o3, 0]), Au.scale(a3, a3, [r3 / cr, r3 / cr, 1]), a3;
        }
        upVector(e4, t3, i3) {
          return [0, 0, 1];
        }
        upVectorScale(e4, t3, i3) {
          return { metersToTile: 1 };
        }
      }
      class Bg extends Og {
        constructor(e4) {
          super(e4), this.range = [4, 7], this.center = e4.center || [-96, 37.5];
          const [t3, i3] = this.parallels = e4.parallels || [29.5, 45.5], r3 = Math.sin(w2(t3));
          this.n = (r3 + Math.sin(w2(i3))) / 2, this.c = 1 + r3 * (2 * this.n - r3), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(e4, t3) {
          const { n: i3, c: r3, r0: n4 } = this, o3 = w2(e4 - this.center[0]), s6 = w2(t3), a3 = Math.sqrt(r3 - 2 * i3 * Math.sin(s6)) / i3;
          return { x: a3 * Math.sin(o3 * i3), y: a3 * Math.cos(o3 * i3) - n4, z: 0 };
        }
        unproject(e4, t3) {
          const { n: i3, c: r3, r0: n4 } = this, o3 = n4 + t3;
          let s6 = Math.atan2(e4, Math.abs(o3)) * Math.sign(o3);
          o3 * i3 < 0 && (s6 -= Math.PI * Math.sign(e4) * Math.sign(o3));
          const a3 = w2(this.center[0]) * i3;
          s6 = D(s6, -Math.PI - a3, Math.PI - a3);
          const l3 = z(T2(s6 / i3) + this.center[0], -180, 180), c3 = Math.asin(z((r3 - (e4 * e4 + o3 * o3) * i3 * i3) / (2 * i3), -1, 1)), h3 = z(T2(c3), -rp, rp);
          return new Wd(l3, h3);
        }
      }
      const Fg = 1.340264, Ng = -0.081106, Ug = 893e-6, Vg = 3796e-6, jg = Math.sqrt(3) / 2;
      class Gg extends Og {
        project(e4, t3) {
          t3 = t3 / 180 * Math.PI, e4 = e4 / 180 * Math.PI;
          const i3 = Math.asin(jg * Math.sin(t3)), r3 = i3 * i3, n4 = r3 * r3 * r3;
          return { x: 0.5 * (e4 * Math.cos(i3) / (jg * (Fg + 3 * Ng * r3 + n4 * (7 * Ug + 9 * Vg * r3))) / Math.PI + 0.5), y: 1 - 0.5 * (i3 * (Fg + Ng * r3 + n4 * (Ug + Vg * r3)) / Math.PI + 1), z: 0 };
        }
        unproject(e4, t3) {
          e4 = (2 * e4 - 0.5) * Math.PI;
          let i3 = t3 = (2 * (1 - t3) - 1) * Math.PI, r3 = i3 * i3, n4 = r3 * r3 * r3;
          for (let e5, o4, s7, a4 = 0; a4 < 12 && (o4 = i3 * (Fg + Ng * r3 + n4 * (Ug + Vg * r3)) - t3, s7 = Fg + 3 * Ng * r3 + n4 * (7 * Ug + 9 * Vg * r3), e5 = o4 / s7, i3 = z(i3 - e5, -Math.PI / 3, Math.PI / 3), r3 = i3 * i3, n4 = r3 * r3 * r3, !(Math.abs(e5) < 1e-12)); ++a4)
            ;
          const o3 = jg * e4 * (Fg + 3 * Ng * r3 + n4 * (7 * Ug + 9 * Vg * r3)) / Math.cos(i3), s6 = Math.asin(Math.sin(i3) / jg), a3 = z(180 * o3 / Math.PI, -180, 180), l3 = z(180 * s6 / Math.PI, -rp, rp);
          return new Wd(a3, l3);
        }
      }
      class qg extends Og {
        constructor(e4) {
          super(e4), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(e4, t3) {
          return { x: 0.5 + e4 / 360, y: 0.5 - t3 / 360, z: 0 };
        }
        unproject(e4, t3) {
          const i3 = 360 * (e4 - 0.5), r3 = z(360 * (0.5 - t3), -rp, rp);
          return new Wd(i3, r3);
        }
      }
      const Zg = Math.PI / 2;
      function $g(e4) {
        return Math.tan((Zg + e4) / 2);
      }
      class Wg extends Og {
        constructor(e4) {
          super(e4), this.center = e4.center || [0, 30];
          const [t3, i3] = this.parallels = e4.parallels || [30, 30];
          let r3 = w2(t3), n4 = w2(i3);
          this.southernCenter = r3 + n4 < 0, this.southernCenter && (r3 = -r3, n4 = -n4);
          const o3 = Math.cos(r3), s6 = $g(r3);
          this.n = r3 === n4 ? Math.sin(r3) : Math.log(o3 / Math.cos(n4)) / Math.log($g(n4) / s6), this.f = o3 * Math.pow($g(r3), this.n) / this.n;
        }
        project(e4, t3) {
          t3 = w2(t3), this.southernCenter && (t3 = -t3), e4 = w2(e4 - this.center[0]);
          const i3 = 1e-6, { n: r3, f: n4 } = this;
          n4 > 0 ? t3 < -Zg + i3 && (t3 = -Zg + i3) : t3 > Zg - i3 && (t3 = Zg - i3);
          const o3 = n4 / Math.pow($g(t3), r3);
          let s6 = o3 * Math.sin(r3 * e4), a3 = n4 - o3 * Math.cos(r3 * e4);
          return s6 = 0.5 * (s6 / Math.PI + 0.5), a3 = 0.5 * (a3 / Math.PI + 0.5), { x: s6, y: this.southernCenter ? a3 : 1 - a3, z: 0 };
        }
        unproject(e4, t3) {
          e4 = (2 * e4 - 0.5) * Math.PI, this.southernCenter && (t3 = 1 - t3), t3 = (2 * (1 - t3) - 0.5) * Math.PI;
          const { n: i3, f: r3 } = this, n4 = r3 - t3, o3 = Math.sign(n4), s6 = Math.sign(i3) * Math.sqrt(e4 * e4 + n4 * n4);
          let a3 = Math.atan2(e4, Math.abs(n4)) * o3;
          n4 * i3 < 0 && (a3 -= Math.PI * Math.sign(e4) * o3);
          const l3 = z(T2(a3 / i3) + this.center[0], -180, 180), c3 = z(T2(2 * Math.atan(Math.pow(r3 / s6, 1 / i3)) - Zg), -rp, rp);
          return new Wd(l3, this.southernCenter ? -c3 : c3);
        }
      }
      class Hg extends Og {
        constructor(e4) {
          super(e4), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
        }
        project(e4, t3) {
          return { x: Kd(e4), y: Jd(t3), z: 0 };
        }
        unproject(e4, t3) {
          const i3 = ep(e4), r3 = tp(t3);
          return new Wd(i3, r3);
        }
      }
      const Xg = w2(rp);
      class Yg extends Og {
        project(e4, t3) {
          const i3 = (t3 = w2(t3)) * t3, r3 = i3 * i3;
          return { x: 0.5 * ((e4 = w2(e4)) * (0.8707 - 0.131979 * i3 + r3 * (r3 * (3971e-6 * i3 - 1529e-6 * r3) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (t3 * (1.007226 + i3 * (0.015085 + r3 * (0.028874 * i3 - 0.044475 - 5916e-6 * r3))) / Math.PI + 1), z: 0 };
        }
        unproject(e4, t3) {
          e4 = (2 * e4 - 0.5) * Math.PI;
          let i3 = t3 = (2 * (1 - t3) - 1) * Math.PI, r3 = 25, n4 = 0, o3 = i3 * i3;
          do {
            o3 = i3 * i3;
            const e5 = o3 * o3;
            n4 = (i3 * (1.007226 + o3 * (0.015085 + e5 * (0.028874 * o3 - 0.044475 - 5916e-6 * e5))) - t3) / (1.007226 + o3 * (0.045255 + e5 * (0.259866 * o3 - 0.311325 - 5916e-6 * 11 * e5))), i3 = z(i3 - n4, -Xg, Xg);
          } while (Math.abs(n4) > 1e-6 && --r3 > 0);
          o3 = i3 * i3;
          const s6 = z(T2(e4 / (0.8707 + o3 * (o3 * (o3 * o3 * o3 * (3971e-6 - 1529e-6 * o3) - 0.013791) - 0.131979))), -180, 180), a3 = T2(i3);
          return new Wd(s6, a3);
        }
      }
      const Kg = w2(rp);
      class Jg extends Og {
        project(e4, t3) {
          t3 = w2(t3), e4 = w2(e4);
          const i3 = Math.cos(t3), r3 = 2 / Math.PI, n4 = Math.acos(i3 * Math.cos(e4 / 2)), o3 = Math.sin(n4) / n4, s6 = 0.5 * (e4 * r3 + 2 * i3 * Math.sin(e4 / 2) / o3) || 0, a3 = 0.5 * (t3 + Math.sin(t3) / o3) || 0;
          return { x: 0.5 * (s6 / Math.PI + 0.5), y: 1 - 0.5 * (a3 / Math.PI + 1), z: 0 };
        }
        unproject(e4, t3) {
          let i3 = e4 = (2 * e4 - 0.5) * Math.PI, r3 = t3 = (2 * (1 - t3) - 1) * Math.PI, n4 = 25;
          const o3 = 1e-6;
          let s6 = 0, a3 = 0;
          do {
            const n5 = Math.cos(r3), o4 = Math.sin(r3), l3 = 2 * o4 * n5, c3 = o4 * o4, h3 = n5 * n5, u3 = Math.cos(i3 / 2), d3 = Math.sin(i3 / 2), p3 = 2 * u3 * d3, f3 = d3 * d3, m3 = 1 - h3 * u3 * u3, _3 = m3 ? 1 / m3 : 0, g3 = m3 ? Math.acos(n5 * u3) * Math.sqrt(1 / m3) : 0, y3 = 0.5 * (2 * g3 * n5 * d3 + 2 * i3 / Math.PI) - e4, x3 = 0.5 * (g3 * o4 + r3) - t3, v3 = 0.5 * _3 * (h3 * f3 + g3 * n5 * u3 * c3) + 1 / Math.PI, b3 = _3 * (p3 * l3 / 4 - g3 * o4 * d3), w3 = 0.125 * _3 * (l3 * d3 - g3 * o4 * h3 * p3), T3 = 0.5 * _3 * (c3 * u3 + g3 * f3 * n5) + 0.5, E3 = b3 * w3 - T3 * v3;
            s6 = (x3 * b3 - y3 * T3) / E3, a3 = (y3 * w3 - x3 * v3) / E3, i3 = z(i3 - s6, -Math.PI, Math.PI), r3 = z(r3 - a3, -Kg, Kg);
          } while ((Math.abs(s6) > o3 || Math.abs(a3) > o3) && --n4 > 0);
          return new Wd(T2(i3), T2(r3));
        }
      }
      class Qg extends Og {
        constructor(e4) {
          super(e4), this.center = e4.center || [0, 0], this.parallels = e4.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(w2(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(e4, t3) {
          const { scale: i3, cosPhi: r3 } = this;
          return { x: w2(e4) * r3 * i3 + 0.5, y: -Math.sin(w2(t3)) / r3 * i3 + 0.5, z: 0 };
        }
        unproject(e4, t3) {
          const { scale: i3, cosPhi: r3 } = this, n4 = -(t3 - 0.5) / i3, o3 = z(T2((e4 - 0.5) / i3) / r3, -180, 180), s6 = Math.asin(z(n4 * r3, -1, 1)), a3 = z(T2(s6), -rp, rp);
          return new Wd(o3, a3);
        }
      }
      class ey extends Hg {
        constructor(e4) {
          super(e4), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
        }
        projectTilePoint(e4, t3, i3) {
          const r3 = Td(e4, t3, i3), n4 = Ad(fd(i3));
          return Du.transformMat4(r3, r3, n4), { x: r3[0], y: r3[1], z: r3[2] };
        }
        locationPoint(e4, t3) {
          const i3 = wd(t3.lat, t3.lng), r3 = Du.normalize([], i3), n4 = e4.elevation ? e4.elevation.getAtPointOrZero(e4.locationCoordinate(t3), e4._centerAltitude) : e4._centerAltitude, o3 = Qd(1, 0) * cr * n4;
          Du.scaleAndAdd(i3, i3, r3, o3);
          const s6 = Au.identity(new Float64Array(16));
          return Au.multiply(s6, e4.pixelMatrix, e4.globeMatrix), Du.transformMat4(i3, i3, s6), new y2(i3[0], i3[1]);
        }
        pixelsPerMeter(e4, t3) {
          return Qd(1, 0) * t3;
        }
        pixelSpaceConversion(e4, t3, i3) {
          const r3 = Qd(1, e4) * t3, n4 = Kr(Qd(1, 45) * t3, r3, i3);
          return this.pixelsPerMeter(e4, t3) / n4;
        }
        createTileMatrix(e4, t3, i3) {
          const r3 = Sd(fd(i3.canonical));
          return Au.multiply(new Float64Array(16), e4.globeMatrix, r3);
        }
        createInversionMatrix(e4, t3) {
          const { center: i3 } = e4, r3 = Ad(fd(t3));
          return Au.rotateY(r3, r3, w2(i3.lng)), Au.rotateX(r3, r3, w2(i3.lat)), Au.scale(r3, r3, [e4._pixelsPerMercatorPixel, e4._pixelsPerMercatorPixel, 1]), Float32Array.from(r3);
        }
        pointCoordinate(e4, t3, i3, r3) {
          return ud(e4, t3, i3, true) || new lp(0, 0);
        }
        pointCoordinate3D(e4, t3, i3) {
          const r3 = this.pointCoordinate(e4, t3, i3, 0);
          return [r3.x, r3.y, r3.z];
        }
        isPointAboveHorizon(e4, t3) {
          return !ud(e4, t3.x, t3.y, false);
        }
        farthestPixelDistance(e4) {
          const t3 = function(e5, t4) {
            const i4 = e5.cameraToCenterDistance, r3 = e5._centerAltitude * t4, n4 = e5._camera, o3 = e5._camera.forward(), s6 = Du.add([], Du.scale([], o3, -i4), [0, 0, r3]), a3 = e5.worldSize / (2 * Math.PI), l3 = [0, 0, -a3], c3 = e5.width / e5.height, h3 = Math.tan(e5.fovAboveCenter), u3 = Du.scale([], n4.up(), h3), d3 = Du.scale([], n4.right(), h3 * c3), p3 = Du.normalize([], Du.add([], Du.add([], o3, u3), d3)), f3 = [];
            let m3;
            if (new Wu(s6, p3).closestPointOnSphere(l3, a3, f3)) {
              const t5 = Du.add([], f3, l3), i5 = Du.sub([], t5, s6);
              m3 = Math.cos(e5.fovAboveCenter) * Du.length(i5);
            } else {
              const e6 = Du.sub([], s6, l3), t5 = Du.sub([], l3, s6);
              Du.normalize(t5, t5);
              const i5 = Du.length(e6) - a3;
              m3 = Math.sqrt(i5 * (i5 + 2 * a3));
              const r4 = Math.acos(m3 / (a3 + i5)) - Math.acos(Du.dot(o3, t5));
              m3 *= Math.cos(r4);
            }
            return 1.01 * m3;
          }(e4, this.pixelsPerMeter(e4.center.lat, e4.worldSize)), i3 = Dd(e4.zoom);
          if (i3 > 0) {
            const r3 = zg(e4, Qd(1, e4.center.lat) * e4.worldSize), n4 = e4.worldSize / (2 * Math.PI), o3 = Math.max(e4.width, e4.height) / e4.worldSize * Math.PI;
            return Kr(t3, r3 + n4 * (1 - Math.cos(o3)), Math.pow(i3, 10));
          }
          return t3;
        }
        upVector(e4, t3, i3) {
          return Td(t3, i3, e4, 1);
        }
        upVectorScale(e4) {
          return { metersToTile: hd(Ed(fd(e4))) };
        }
      }
      function ty(e4) {
        const t3 = e4.parallels, i3 = !!t3 && Math.abs(t3[0] + t3[1]) < 0.01;
        switch (e4.name) {
          case "mercator":
            return new Hg(e4);
          case "equirectangular":
            return new qg(e4);
          case "naturalEarth":
            return new Yg(e4);
          case "equalEarth":
            return new Gg(e4);
          case "winkelTripel":
            return new Jg(e4);
          case "albers":
            return i3 ? new Qg(e4) : new Bg(e4);
          case "lambertConformalConic":
            return i3 ? new Qg(e4) : new Wg(e4);
          case "globe":
            return new ey(e4);
        }
        throw new Error(`Invalid projection name: ${e4.name}`);
      }
      const iy = new ga({ "symbol-placement": new fa(Pt.layout_symbol["symbol-placement"]), "symbol-spacing": new fa(Pt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new fa(Pt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ma(Pt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new fa(Pt.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new fa(Pt.layout_symbol["symbol-z-elevate"]), "icon-allow-overlap": new fa(Pt.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new fa(Pt.layout_symbol["icon-ignore-placement"]), "icon-optional": new fa(Pt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new fa(Pt.layout_symbol["icon-rotation-alignment"]), "icon-size": new ma(Pt.layout_symbol["icon-size"]), "icon-text-fit": new ma(Pt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ma(Pt.layout_symbol["icon-text-fit-padding"]), "icon-image": new ma(Pt.layout_symbol["icon-image"]), "icon-rotate": new ma(Pt.layout_symbol["icon-rotate"]), "icon-padding": new fa(Pt.layout_symbol["icon-padding"]), "icon-keep-upright": new fa(Pt.layout_symbol["icon-keep-upright"]), "icon-offset": new ma(Pt.layout_symbol["icon-offset"]), "icon-anchor": new ma(Pt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new fa(Pt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new fa(Pt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new fa(Pt.layout_symbol["text-rotation-alignment"]), "text-field": new ma(Pt.layout_symbol["text-field"]), "text-font": new ma(Pt.layout_symbol["text-font"]), "text-size": new ma(Pt.layout_symbol["text-size"]), "text-max-width": new ma(Pt.layout_symbol["text-max-width"]), "text-line-height": new ma(Pt.layout_symbol["text-line-height"]), "text-letter-spacing": new ma(Pt.layout_symbol["text-letter-spacing"]), "text-justify": new ma(Pt.layout_symbol["text-justify"]), "text-radial-offset": new ma(Pt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new fa(Pt.layout_symbol["text-variable-anchor"]), "text-anchor": new ma(Pt.layout_symbol["text-anchor"]), "text-max-angle": new fa(Pt.layout_symbol["text-max-angle"]), "text-writing-mode": new fa(Pt.layout_symbol["text-writing-mode"]), "text-rotate": new ma(Pt.layout_symbol["text-rotate"]), "text-padding": new fa(Pt.layout_symbol["text-padding"]), "text-keep-upright": new fa(Pt.layout_symbol["text-keep-upright"]), "text-transform": new ma(Pt.layout_symbol["text-transform"]), "text-offset": new ma(Pt.layout_symbol["text-offset"]), "text-allow-overlap": new fa(Pt.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new fa(Pt.layout_symbol["text-ignore-placement"]), "text-optional": new fa(Pt.layout_symbol["text-optional"]), visibility: new fa(Pt.layout_symbol.visibility) });
      var ry = { paint: new ga({ "icon-opacity": new ma(Pt.paint_symbol["icon-opacity"]), "icon-emissive-strength": new ma(Pt.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new ma(Pt.paint_symbol["text-emissive-strength"]), "icon-color": new ma(Pt.paint_symbol["icon-color"]), "icon-halo-color": new ma(Pt.paint_symbol["icon-halo-color"]), "icon-halo-width": new ma(Pt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ma(Pt.paint_symbol["icon-halo-blur"]), "icon-translate": new fa(Pt.paint_symbol["icon-translate"]), "icon-translate-anchor": new fa(Pt.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new ma(Pt.paint_symbol["icon-image-cross-fade"]), "text-opacity": new ma(Pt.paint_symbol["text-opacity"]), "text-color": new ma(Pt.paint_symbol["text-color"], { runtimeType: Zt, getOverride: (e4) => e4.textColor, hasOverride: (e4) => !!e4.textColor }), "text-halo-color": new ma(Pt.paint_symbol["text-halo-color"]), "text-halo-width": new ma(Pt.paint_symbol["text-halo-width"]), "text-halo-blur": new ma(Pt.paint_symbol["text-halo-blur"]), "text-translate": new fa(Pt.paint_symbol["text-translate"]), "text-translate-anchor": new fa(Pt.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new fa(Pt.paint_symbol["icon-color-saturation"]) }), layout: iy };
      class ny {
        constructor(e4) {
          this.type = e4.property.overrides ? e4.property.overrides.runtimeType : Vt, this.defaultValue = e4;
        }
        evaluate(e4) {
          if (e4.formattedSection) {
            const t3 = this.defaultValue.property.overrides;
            if (t3 && t3.hasOverride(e4.formattedSection))
              return t3.getOverride(e4.formattedSection);
          }
          return e4.feature && e4.featureState ? this.defaultValue.evaluate(e4.feature, e4.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e4) {
          this.defaultValue.isConstant() || e4(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      Rs(ny, "FormatSectionOverride", { omit: ["defaultValue"] });
      class oy extends Ta {
        constructor(e4, t3) {
          super(e4, ry, t3);
        }
        recalculate(e4, t3) {
          super.recalculate(e4, t3), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const i3 = this.layout.get("text-writing-mode");
          if (i3) {
            const e5 = [];
            for (const t4 of i3)
              e5.indexOf(t4) < 0 && e5.push(t4);
            this.layout._values["text-writing-mode"] = e5;
          } else
            this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(e4, t3, i3, r3) {
          const n4 = this.layout.get(e4).evaluate(t3, {}, i3, r3), o3 = this._unevaluatedLayout._values[e4];
          return o3.isDataDriven() || To(o3.value) || !n4 ? n4 : function(e5, t4) {
            return t4.replace(/{([^{}]+)}/g, (t5, i4) => i4 in e5 ? String(e5[i4]) : "");
          }(t3.properties, n4);
        }
        createBucket(e4) {
          return new gy(e4);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _setPaintOverrides() {
          for (const e4 of ry.paint.overridableProperties) {
            if (!oy.hasPaintOverride(this.layout, e4))
              continue;
            const t3 = this.paint.get(e4), i3 = new ny(t3), r3 = new wo(i3, t3.property.specification);
            let n4 = null;
            n4 = "constant" === t3.value.kind || "source" === t3.value.kind ? new Mo("source", r3) : new Ao("composite", r3, t3.value.zoomStops, t3.value._interpolationType), this.paint._values[e4] = new da(t3.property, n4, t3.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e4, t3, i3) {
          return !(!this.layout || t3.isDataDriven() || i3.isDataDriven()) && oy.hasPaintOverride(this.layout, e4);
        }
        static hasPaintOverride(e4, t3) {
          const i3 = e4.get("text-field"), r3 = ry.paint.properties[t3];
          let n4 = false;
          const o3 = (e5) => {
            for (const t4 of e5)
              if (r3.overrides && r3.overrides.hasOverride(t4))
                return void (n4 = true);
          };
          if ("constant" === i3.value.kind && i3.value.value instanceof pi)
            o3(i3.value.value.sections);
          else if ("source" === i3.value.kind) {
            const e5 = (t5) => {
              n4 || (t5 instanceof vi && gi(t5.value) === Xt ? o3(t5.value.sections) : t5 instanceof Mi ? o3(t5.sections) : t5.eachChild(e5));
            }, t4 = i3.value;
            t4._styleExpression && e5(t4._styleExpression.expression);
          }
          return n4;
        }
        getProgramIds() {
          const e4 = 0 !== this.paint.get("icon-opacity").constantOr(1), t3 = 0 !== this.paint.get("text-opacity").constantOr(1), i3 = [];
          return e4 && i3.push("symbolIcon"), t3 && i3.push("symbolSDF"), i3;
        }
        getDefaultProgramParams(e4, t3) {
          return { config: new Ql(this, t3), overrideFog: false };
        }
      }
      const sy = hm.types, ay = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function ly(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3) {
        const p3 = a3 ? Math.min(Eg, Math.round(a3[0])) : 0, f3 = a3 ? Math.min(Eg, Math.round(a3[1])) : 0;
        e4.emplaceBack(t3, i3, Math.round(32 * r3), Math.round(32 * n4), o3, s6, (p3 << 1) + (l3 ? 1 : 0), f3, 16 * c3, 16 * h3, 256 * u3, 256 * d3);
      }
      function cy(e4, t3, i3) {
        e4.emplaceBack(t3, i3);
      }
      function hy(e4, t3, i3, r3, n4, o3, s6) {
        e4.emplaceBack(t3, i3, r3, n4, o3, s6);
      }
      function uy(e4, t3, i3, r3, n4) {
        const o3 = 5 * t3 + 2;
        e4.float32[o3 + 0] = i3, e4.float32[o3 + 1] = r3, e4.float32[o3 + 2] = n4;
      }
      function dy(e4, t3, i3, r3, n4) {
        e4.emplaceBack(t3, i3, r3, n4), e4.emplaceBack(t3, i3, r3, n4), e4.emplaceBack(t3, i3, r3, n4), e4.emplaceBack(t3, i3, r3, n4);
      }
      function py(e4) {
        for (const t3 of e4.sections)
          if ($s(t3.text))
            return true;
        return false;
      }
      class fy {
        constructor(e4) {
          this.layoutVertexArray = new Na(), this.indexArray = new Wa(), this.programConfigurations = e4, this.segments = new xl(), this.dynamicLayoutVertexArray = new ka(), this.opacityVertexArray = new Va(), this.placedSymbolArray = new cl(), this.iconTransitioningVertexArray = new ja(), this.globeExtVertexArray = new Ua(), this.zOffsetVertexArray = new Ya();
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
        }
        upload(e4, t3, i3, r3, n4) {
          this.isEmpty() || (i3 && (this.layoutVertexBuffer = e4.createVertexBuffer(this.layoutVertexArray, i_.members), this.indexBuffer = e4.createIndexBuffer(this.indexArray, t3), this.dynamicLayoutVertexBuffer = e4.createVertexBuffer(this.dynamicLayoutVertexArray, n_.members, true), this.opacityVertexBuffer = e4.createVertexBuffer(this.opacityVertexArray, ay, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = e4.createVertexBuffer(this.iconTransitioningVertexArray, s_.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e4.createVertexBuffer(this.globeExtVertexArray, r_.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || n4) && (this.zOffsetVertexBuffer = e4.createVertexBuffer(this.zOffsetVertexArray, o_.members, true)), this.opacityVertexBuffer.itemSize = 1), (i3 || r3) && this.programConfigurations.upload(e4));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
        }
      }
      Rs(fy, "SymbolBuffers");
      class my {
        constructor(e4, t3, i3) {
          this.layoutVertexArray = new e4(), this.layoutAttributes = t3, this.indexArray = new i3(), this.segments = new xl(), this.collisionVertexArray = new $a(), this.collisionVertexArrayExt = new ka();
        }
        upload(e4) {
          this.layoutVertexBuffer = e4.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e4.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e4.createVertexBuffer(this.collisionVertexArray, a_.members, true), this.collisionVertexBufferExt = e4.createVertexBuffer(this.collisionVertexArrayExt, l_.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      Rs(my, "CollisionBuffers");
      class _y {
        constructor(e4) {
          this.collisionBoxArray = e4.collisionBoxArray, this.zoom = e4.zoom, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((e5) => e5.fqid), this.index = e4.index, this.pixelRatio = e4.pixelRatio, this.sourceLayerIndex = e4.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Au.identity([]), this.placementViewportMatrix = Au.identity([]);
          const t3 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = p_(this.zoom, t3["text-size"]), this.iconSizeData = p_(this.zoom, t3["icon-size"]);
          const i3 = this.layers[0].layout, r3 = i3.get("symbol-sort-key"), n4 = i3.get("symbol-z-order");
          this.canOverlap = i3.get("text-allow-overlap") || i3.get("icon-allow-overlap") || i3.get("text-ignore-placement") || i3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== n4 && void 0 !== r3.constantOr(1), this.sortFeaturesByY = ("viewport-y" === n4 || "auto" === n4 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = i3.get("text-writing-mode").map((e5) => A_[e5]), this.stateDependentLayerIds = this.layers.filter((e5) => e5.isStateDependent()).map((e5) => e5.id), this.sourceID = e4.sourceID, this.projection = e4.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = i3.get("symbol-z-elevate");
        }
        createArrays() {
          this.text = new fy(new ec(this.layers, this.zoom, (e4) => /^text/.test(e4))), this.icon = new fy(new ec(this.layers, this.zoom, (e4) => /^icon/.test(e4))), this.glyphOffsetArray = new dl(), this.lineVertexArray = new pl(), this.symbolInstances = new ul();
        }
        calculateGlyphDependencies(e4, t3, i3, r3, n4) {
          for (let i4 = 0; i4 < e4.length; i4++) {
            const o3 = e4.codePointAt(i4);
            if (void 0 === o3)
              break;
            if (t3[o3] = true, r3 && n4 && o3 <= 65535) {
              const r4 = y_[e4.charAt(i4)];
              r4 && (t3[r4.charCodeAt(0)] = true);
            }
          }
        }
        populate(e4, t3, i3, r3) {
          const n4 = this.layers[0], o3 = n4.layout, s6 = "globe" === this.projection.name, a3 = o3.get("text-font"), l3 = o3.get("text-field"), c3 = o3.get("icon-image"), h3 = ("constant" !== l3.value.kind || l3.value.value instanceof pi && !l3.value.value.isEmpty() || l3.value.value.toString().length > 0) && ("constant" !== a3.value.kind || a3.value.value.length > 0), u3 = "constant" !== c3.value.kind || !!c3.value.value || Object.keys(c3.parameters).length > 0, d3 = o3.get("symbol-sort-key");
          if (this.features = [], !h3 && !u3)
            return;
          const p3 = t3.iconDependencies, f3 = t3.glyphDependencies, m3 = t3.availableImages, _3 = new oa(this.zoom);
          for (const { feature: t4, id: l4, index: c4, sourceLayerIndex: g3 } of e4) {
            const e5 = n4._featureFilter.needGeometry, y3 = gp(t4, e5);
            if (!n4._featureFilter.filter(_3, y3, i3))
              continue;
            if (e5 || (y3.geometry = _p(t4, i3, r3)), s6 && 1 !== t4.type && i3.z <= 5) {
              const e6 = y3.geometry, t5 = 0.98078528056, r4 = (e7, r5) => {
                const n5 = Td(e7.x, e7.y, i3, 1), o4 = Td(r5.x, r5.y, i3, 1);
                return Du.dot(n5, o4) < t5;
              };
              for (let t6 = 0; t6 < e6.length; t6++)
                e6[t6] = dp(e6[t6], r4);
            }
            let x3, v3;
            if (h3) {
              const e6 = n4.getValueAndResolveTokens("text-field", y3, i3, m3), t5 = pi.factory(e6);
              py(t5) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ia() || this.hasRTLText && na.isParsed()) && (x3 = g_(t5, n4, y3));
            }
            if (u3) {
              const e6 = n4.getValueAndResolveTokens("icon-image", y3, i3, m3);
              v3 = e6 instanceof fi ? e6 : fi.fromString(e6);
            }
            if (!x3 && !v3)
              continue;
            const b3 = this.sortFeaturesByKey ? d3.evaluate(y3, {}, i3) : void 0;
            if (this.features.push({ id: l4, text: x3, icon: v3, index: c4, sourceLayerIndex: g3, geometry: y3.geometry, properties: t4.properties, type: sy[t4.type], sortKey: b3 }), v3 && (p3[v3.namePrimary] = true, v3.nameSecondary && (p3[v3.nameSecondary] = true)), x3) {
              const e6 = a3.evaluate(y3, {}, i3).join(","), t5 = "map" === o3.get("text-rotation-alignment") && "point" !== o3.get("symbol-placement");
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(A_.vertical) >= 0;
              for (const i4 of x3.sections)
                if (i4.image)
                  p3[i4.image.namePrimary] = true;
                else {
                  const r4 = Ns(x3.toString()), n5 = i4.fontStack || e6, o4 = f3[n5] = f3[n5] || {};
                  this.calculateGlyphDependencies(i4.text, o4, t5, this.allowVerticalPlacement, r4);
                }
            }
          }
          "line" === o3.get("symbol-placement") && (this.features = function(e5) {
            const t4 = {}, i4 = {}, r4 = [];
            let n5 = 0;
            function o4(t5) {
              r4.push(e5[t5]), n5++;
            }
            function s7(e6, t5, n6) {
              const o5 = i4[e6];
              return delete i4[e6], i4[t5] = o5, r4[o5].geometry[0].pop(), r4[o5].geometry[0] = r4[o5].geometry[0].concat(n6[0]), o5;
            }
            function a4(e6, i5, n6) {
              const o5 = t4[i5];
              return delete t4[i5], t4[e6] = o5, r4[o5].geometry[0].shift(), r4[o5].geometry[0] = n6[0].concat(r4[o5].geometry[0]), o5;
            }
            function l4(e6, t5, i5) {
              const r5 = i5 ? t5[0][t5[0].length - 1] : t5[0][0];
              return `${e6}:${r5.x}:${r5.y}`;
            }
            for (let c4 = 0; c4 < e5.length; c4++) {
              const h4 = e5[c4], u4 = h4.geometry, d4 = h4.text ? h4.text.toString() : null;
              if (!d4) {
                o4(c4);
                continue;
              }
              const p4 = l4(d4, u4), f4 = l4(d4, u4, true);
              if (p4 in i4 && f4 in t4 && i4[p4] !== t4[f4]) {
                const e6 = a4(p4, f4, u4), n6 = s7(p4, f4, r4[e6].geometry);
                delete t4[p4], delete i4[f4], i4[l4(d4, r4[n6].geometry, true)] = n6, r4[e6].geometry = null;
              } else
                p4 in i4 ? s7(p4, f4, u4) : f4 in t4 ? a4(p4, f4, u4) : (o4(c4), t4[p4] = n5 - 1, i4[f4] = n5 - 1);
            }
            return r4.filter((e6) => e6.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((e5, t4) => e5.sortKey - t4.sortKey);
        }
        update(e4, t3, i3, r3, n4) {
          const o3 = 0 !== Object.keys(e4).length;
          if (o3 && !this.stateDependentLayers.length)
            return;
          const s6 = o3 ? this.stateDependentLayers : this.layers;
          this.text.programConfigurations.updatePaintArrays(e4, t3, s6, i3, r3, n4), this.icon.programConfigurations.updatePaintArrays(e4, t3, s6, i3, r3, n4);
        }
        updateZOffset() {
          const e4 = (e5, t4, r4) => {
            i3 += t4, i3 > e5.length && e5.resize(i3);
            for (let n4 = -t4; n4 < 0; n4++)
              e5.emplace(n4 + i3, r4);
          }, t3 = (e5, t4, i4) => {
            r3 += t4, r3 > e5.length && e5.resize(r3);
            for (let n4 = -t4; n4 < 0; n4++)
              e5.emplace(n4 + r3, i4);
          };
          if (!this.zOffsetBuffersNeedUpload)
            return;
          this.zOffsetBuffersNeedUpload = false;
          let i3 = 0, r3 = 0;
          for (let i4 = 0; i4 < this.symbolInstances.length; i4++) {
            const r4 = this.symbolInstances.get(i4), { numHorizontalGlyphVertices: n4, numVerticalGlyphVertices: o3, numIconVertices: s6 } = r4, a3 = r4.zOffset, l3 = s6 > 0;
            if ((n4 > 0 || o3 > 0) && (e4(this.text.zOffsetVertexArray, n4, a3), e4(this.text.zOffsetVertexArray, o3, a3)), l3) {
              const { placedIconSymbolIndex: e5, verticalPlacedIconSymbolIndex: i5 } = r4;
              e5 >= 0 && t3(this.icon.zOffsetVertexArray, s6, a3), i5 >= 0 && t3(this.icon.zOffsetVertexArray, r4.numVerticalIconVertices, a3);
            }
          }
          this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
        }
        isEmpty() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e4) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e4), this.iconCollisionBox.upload(e4)), this.text.upload(e4, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(e4, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = ty(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e4, t3) {
          const i3 = this.lineVertexArray.length;
          if (void 0 !== e4.segment)
            for (const { x: e5, y: i4 } of t3)
              this.lineVertexArray.emplaceBack(e5, i4);
          return { lineStartIndex: i3, lineLength: this.lineVertexArray.length - i3 };
        }
        addSymbols(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3) {
          const _3 = e4.indexArray, g3 = e4.layoutVertexArray, y3 = e4.globeExtVertexArray, x3 = e4.segments.prepareSegment(4 * t3.length, g3, _3, this.canOverlap ? o3.sortKey : void 0), v3 = this.glyphOffsetArray.length, b3 = x3.vertexLength, w3 = this.allowVerticalPlacement && s6 === A_.vertical ? Math.PI / 2 : 0, T3 = o3.text && o3.text.sections;
          for (let r4 = 0; r4 < t3.length; r4++) {
            const { tl: n5, tr: s7, bl: c4, br: h4, texPrimary: u4, texSecondary: v4, pixelOffsetTL: b4, pixelOffsetBR: E4, minFontScaleX: M3, minFontScaleY: A3, glyphOffset: S3, isSDF: I3, sectionIndex: C3 } = t3[r4], z2 = x3.vertexLength, P3 = S3[1];
            if (ly(g3, l3.x, l3.y, n5.x, P3 + n5.y, u4.x, u4.y, i3, I3, b4.x, b4.y, M3, A3), ly(g3, l3.x, l3.y, s7.x, P3 + s7.y, u4.x + u4.w, u4.y, i3, I3, E4.x, b4.y, M3, A3), ly(g3, l3.x, l3.y, c4.x, P3 + c4.y, u4.x, u4.y + u4.h, i3, I3, b4.x, E4.y, M3, A3), ly(g3, l3.x, l3.y, h4.x, P3 + h4.y, u4.x + u4.w, u4.y + u4.h, i3, I3, E4.x, E4.y, M3, A3), a3) {
              const { x: t4, y: i4, z: r5 } = a3.anchor, [n6, o4, s8] = a3.up;
              hy(y3, t4, i4, r5, n6, o4, s8), hy(y3, t4, i4, r5, n6, o4, s8), hy(y3, t4, i4, r5, n6, o4, s8), hy(y3, t4, i4, r5, n6, o4, s8), dy(e4.dynamicLayoutVertexArray, t4, i4, r5, w3);
            } else
              dy(e4.dynamicLayoutVertexArray, l3.x, l3.y, l3.z, w3);
            if (m3) {
              const t4 = v4 || u4;
              cy(e4.iconTransitioningVertexArray, t4.x, t4.y), cy(e4.iconTransitioningVertexArray, t4.x + t4.w, t4.y), cy(e4.iconTransitioningVertexArray, t4.x, t4.y + t4.h), cy(e4.iconTransitioningVertexArray, t4.x + t4.w, t4.y + t4.h);
            }
            _3.emplaceBack(z2, z2 + 1, z2 + 2), _3.emplaceBack(z2 + 1, z2 + 2, z2 + 3), x3.vertexLength += 4, x3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S3[0]), r4 !== t3.length - 1 && C3 === t3[r4 + 1].sectionIndex || e4.programConfigurations.populatePaintArrays(g3.length, o3, o3.index, {}, d3, p3, f3, T3 && T3[C3]);
          }
          const E3 = a3 ? a3.anchor : l3;
          e4.placedSymbolArray.emplaceBack(E3.x, E3.y, E3.z, l3.x, l3.y, v3, this.glyphOffsetArray.length - v3, b3, c3, h3, l3.segment, i3 ? i3[0] : 0, i3 ? i3[1] : 0, r3[0], r3[1], s6, 0, false, 0, u3, 0);
        }
        _commitLayoutVertex(e4, t3, i3, r3, n4, o3, s6) {
          e4.emplaceBack(t3, i3, r3, n4, o3, Math.round(s6.x), Math.round(s6.y));
        }
        _addCollisionDebugVertices(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = i3.segments.prepareSegment(4, i3.layoutVertexArray, i3.indexArray), l3 = a3.vertexLength, c3 = s6.tileAnchorX, h3 = s6.tileAnchorY;
          for (let e5 = 0; e5 < 4; e5++)
            i3.collisionVertexArray.emplaceBack(0, 0, 0, 0);
          this._commitDebugCollisionVertexUpdate(i3.collisionVertexArrayExt, t3, e4.padding, s6.zOffset), this._commitLayoutVertex(i3.layoutVertexArray, r3, n4, o3, c3, h3, new y2(e4.x1, e4.y1)), this._commitLayoutVertex(i3.layoutVertexArray, r3, n4, o3, c3, h3, new y2(e4.x2, e4.y1)), this._commitLayoutVertex(i3.layoutVertexArray, r3, n4, o3, c3, h3, new y2(e4.x2, e4.y2)), this._commitLayoutVertex(i3.layoutVertexArray, r3, n4, o3, c3, h3, new y2(e4.x1, e4.y2)), a3.vertexLength += 4;
          const u3 = i3.indexArray;
          u3.emplaceBack(l3, l3 + 1), u3.emplaceBack(l3 + 1, l3 + 2), u3.emplaceBack(l3 + 2, l3 + 3), u3.emplaceBack(l3 + 3, l3), a3.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(e4, t3, i3, r3, n4, o3) {
          for (let s6 = r3; s6 < n4; s6++) {
            const r4 = i3.get(s6), n5 = this.getSymbolInstanceTextSize(e4, o3, t3, s6);
            this._addCollisionDebugVertices(r4, n5, this.textCollisionBox, r4.projectedAnchorX, r4.projectedAnchorY, r4.projectedAnchorZ, o3);
          }
        }
        _addIconDebugCollisionBoxes(e4, t3, i3, r3, n4, o3) {
          for (let s6 = r3; s6 < n4; s6++) {
            const r4 = i3.get(s6), n5 = this.getSymbolInstanceIconSize(e4, t3, o3.placedIconSymbolIndex);
            this._addCollisionDebugVertices(r4, n5, this.iconCollisionBox, r4.projectedAnchorX, r4.projectedAnchorY, r4.projectedAnchorZ, o3);
          }
        }
        generateCollisionDebugBuffers(e4, t3) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new my(qa, c_.members, ja), this.iconCollisionBox = new my(qa, c_.members, ja);
          const i3 = m_(this.iconSizeData, e4), r3 = m_(this.textSizeData, e4);
          for (let n4 = 0; n4 < this.symbolInstances.length; n4++) {
            const o3 = this.symbolInstances.get(n4);
            this._addTextDebugCollisionBoxes(r3, e4, t3, o3.textBoxStartIndex, o3.textBoxEndIndex, o3), this._addTextDebugCollisionBoxes(r3, e4, t3, o3.verticalTextBoxStartIndex, o3.verticalTextBoxEndIndex, o3), this._addIconDebugCollisionBoxes(i3, e4, t3, o3.iconBoxStartIndex, o3.iconBoxEndIndex, o3), this._addIconDebugCollisionBoxes(i3, e4, t3, o3.verticalIconBoxStartIndex, o3.verticalIconBoxEndIndex, o3);
          }
        }
        getSymbolInstanceTextSize(e4, t3, i3, r3) {
          const n4 = this.text.placedSymbolArray.get(t3.rightJustifiedTextSymbolIndex >= 0 ? t3.rightJustifiedTextSymbolIndex : t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.leftJustifiedTextSymbolIndex >= 0 ? t3.leftJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex >= 0 ? t3.verticalPlacedTextSymbolIndex : r3), o3 = f_(this.textSizeData, e4, n4) / u_;
          return this.tilePixelRatio * o3;
        }
        getSymbolInstanceIconSize(e4, t3, i3) {
          const r3 = this.icon.placedSymbolArray.get(i3), n4 = f_(this.iconSizeData, e4, r3);
          return this.tilePixelRatio * n4;
        }
        _commitDebugCollisionVertexUpdate(e4, t3, i3, r3) {
          e4.emplaceBack(t3, -i3, -i3, r3), e4.emplaceBack(t3, i3, -i3, r3), e4.emplaceBack(t3, i3, i3, r3), e4.emplaceBack(t3, -i3, i3, r3);
        }
        _updateTextDebugCollisionBoxes(e4, t3, i3, r3, n4, o3) {
          for (let s6 = r3; s6 < n4; s6++) {
            const r4 = i3.get(s6), n5 = this.getSymbolInstanceTextSize(e4, o3, t3, s6);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, n5, r4.padding, o3.zOffset);
          }
        }
        _updateIconDebugCollisionBoxes(e4, t3, i3, r3, n4, o3) {
          for (let s6 = r3; s6 < n4; s6++) {
            const r4 = i3.get(s6), n5 = this.getSymbolInstanceIconSize(e4, t3, o3.placedIconSymbolIndex);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, n5, r4.padding, o3.zOffset);
          }
        }
        updateCollisionDebugBuffers(e4, t3) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const i3 = m_(this.iconSizeData, e4), r3 = m_(this.textSizeData, e4);
          for (let n4 = 0; n4 < this.symbolInstances.length; n4++) {
            const o3 = this.symbolInstances.get(n4);
            this._updateTextDebugCollisionBoxes(r3, e4, t3, o3.textBoxStartIndex, o3.textBoxEndIndex, o3), this._updateTextDebugCollisionBoxes(r3, e4, t3, o3.verticalTextBoxStartIndex, o3.verticalTextBoxEndIndex, o3), this._updateIconDebugCollisionBoxes(i3, e4, t3, o3.iconBoxStartIndex, o3.iconBoxEndIndex, o3), this._updateIconDebugCollisionBoxes(i3, e4, t3, o3.verticalIconBoxStartIndex, o3.verticalIconBoxEndIndex, o3);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
          const c3 = {};
          if (t3 < i3) {
            const { x1: i4, y1: r4, x2: n5, y2: o4, padding: s7, projectedAnchorX: a4, projectedAnchorY: l4, projectedAnchorZ: h3, tileAnchorX: u3, tileAnchorY: d3, featureIndex: p3 } = e4.get(t3);
            c3.textBox = { x1: i4, y1: r4, x2: n5, y2: o4, padding: s7, projectedAnchorX: a4, projectedAnchorY: l4, projectedAnchorZ: h3, tileAnchorX: u3, tileAnchorY: d3 }, c3.textFeatureIndex = p3;
          }
          if (r3 < n4) {
            const { x1: t4, y1: i4, x2: n5, y2: o4, padding: s7, projectedAnchorX: a4, projectedAnchorY: l4, projectedAnchorZ: h3, tileAnchorX: u3, tileAnchorY: d3, featureIndex: p3 } = e4.get(r3);
            c3.verticalTextBox = { x1: t4, y1: i4, x2: n5, y2: o4, padding: s7, projectedAnchorX: a4, projectedAnchorY: l4, projectedAnchorZ: h3, tileAnchorX: u3, tileAnchorY: d3 }, c3.verticalTextFeatureIndex = p3;
          }
          if (o3 < s6) {
            const { x1: t4, y1: i4, x2: r4, y2: n5, padding: s7, projectedAnchorX: a4, projectedAnchorY: l4, projectedAnchorZ: h3, tileAnchorX: u3, tileAnchorY: d3, featureIndex: p3 } = e4.get(o3);
            c3.iconBox = { x1: t4, y1: i4, x2: r4, y2: n5, padding: s7, projectedAnchorX: a4, projectedAnchorY: l4, projectedAnchorZ: h3, tileAnchorX: u3, tileAnchorY: d3 }, c3.iconFeatureIndex = p3;
          }
          if (a3 < l3) {
            const { x1: t4, y1: i4, x2: r4, y2: n5, padding: o4, projectedAnchorX: s7, projectedAnchorY: l4, projectedAnchorZ: h3, tileAnchorX: u3, tileAnchorY: d3, featureIndex: p3 } = e4.get(a3);
            c3.verticalIconBox = { x1: t4, y1: i4, x2: r4, y2: n5, padding: o4, projectedAnchorX: s7, projectedAnchorY: l4, projectedAnchorZ: h3, tileAnchorX: u3, tileAnchorY: d3 }, c3.verticalIconFeatureIndex = p3;
          }
          return c3;
        }
        deserializeCollisionBoxes(e4) {
          this.collisionArrays = [];
          for (let t3 = 0; t3 < this.symbolInstances.length; t3++) {
            const i3 = this.symbolInstances.get(t3);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e4, i3.textBoxStartIndex, i3.textBoxEndIndex, i3.verticalTextBoxStartIndex, i3.verticalTextBoxEndIndex, i3.iconBoxStartIndex, i3.iconBoxEndIndex, i3.verticalIconBoxStartIndex, i3.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        hasIconTextFit() {
          return this.hasAnyIconTextFit;
        }
        addIndicesForPlacedSymbol(e4, t3) {
          const i3 = e4.placedSymbolArray.get(t3), r3 = i3.vertexStartIndex + 4 * i3.numGlyphs;
          for (let t4 = i3.vertexStartIndex; t4 < r3; t4 += 4)
            e4.indexArray.emplaceBack(t4, t4 + 1, t4 + 2), e4.indexArray.emplaceBack(t4 + 1, t4 + 2, t4 + 3);
        }
        getSortedSymbolIndexes(e4) {
          if (this.sortedAngle === e4 && void 0 !== this.symbolInstanceIndexes)
            return this.symbolInstanceIndexes;
          const t3 = Math.sin(e4), i3 = Math.cos(e4), r3 = [], n4 = [], o3 = [];
          for (let e5 = 0; e5 < this.symbolInstances.length; ++e5) {
            o3.push(e5);
            const s6 = this.symbolInstances.get(e5);
            r3.push(0 | Math.round(t3 * s6.tileAnchorX + i3 * s6.tileAnchorY)), n4.push(s6.featureIndex);
          }
          return o3.sort((e5, t4) => r3[e5] - r3[t4] || n4[t4] - n4[e5]), o3;
        }
        getSortedIndexesByZOffset() {
          if (!this.zOffsetSortDirty)
            return this.symbolInstanceIndexesSortedZOffset;
          if (!this.symbolInstanceIndexesSortedZOffset) {
            this.symbolInstanceIndexesSortedZOffset = [];
            for (let e4 = 0; e4 < this.symbolInstances.length; ++e4)
              this.symbolInstanceIndexesSortedZOffset.push(e4);
          }
          return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((e4, t3) => this.symbolInstances.get(t3).zOffset - this.symbolInstances.get(e4).zOffset);
        }
        addToSortKeyRanges(e4, t3) {
          const i3 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          i3 && i3.sortKey === t3 ? i3.symbolInstanceEnd = e4 + 1 : this.sortKeyRanges.push({ sortKey: t3, symbolInstanceStart: e4, symbolInstanceEnd: e4 + 1 });
        }
        sortFeatures(e4) {
          if (this.sortFeaturesByY && this.sortedAngle !== e4 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e4), this.sortedAngle = e4, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const e5 of this.symbolInstanceIndexes) {
              const t3 = this.symbolInstances.get(e5);
              this.featureSortOrder.push(t3.featureIndex);
              const { rightJustifiedTextSymbolIndex: i3, centerJustifiedTextSymbolIndex: r3, leftJustifiedTextSymbolIndex: n4, verticalPlacedTextSymbolIndex: o3, placedIconSymbolIndex: s6, verticalPlacedIconSymbolIndex: a3 } = t3;
              i3 >= 0 && this.addIndicesForPlacedSymbol(this.text, i3), r3 >= 0 && r3 !== i3 && this.addIndicesForPlacedSymbol(this.text, r3), n4 >= 0 && n4 !== r3 && n4 !== i3 && this.addIndicesForPlacedSymbol(this.text, n4), o3 >= 0 && this.addIndicesForPlacedSymbol(this.text, o3), s6 >= 0 && this.addIndicesForPlacedSymbol(this.icon, s6), a3 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a3);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      Rs(_y, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), _y.MAX_GLYPHS = 65535, _y.addDynamicAttributes = dy;
      var gy = _y;
      const yy = Ia([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: xy } = yy, vy = Ia([{ name: "a_packed", components: 4, type: "Float32" }]), { members: by } = vy, wy = hm.types, Ty = Math.cos(Math.PI / 180 * 37.5);
      class Ey {
        constructor(e4) {
          this.zoom = e4.zoom, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((e5) => e5.fqid), this.index = e4.index, this.projection = e4.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((e5) => {
            this.gradients[e5.id] = {};
          }), this.layoutVertexArray = new La(), this.layoutVertexArray2 = new ka(), this.indexArray = new Wa(), this.programConfigurations = new ec(e4.layers, e4.zoom), this.segments = new xl(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((e5) => e5.isStateDependent()).map((e5) => e5.id);
        }
        populate(e4, t3, i3, r3) {
          this.hasPattern = Uf("line", this.layers, t3);
          const n4 = this.layers[0].layout.get("line-sort-key"), o3 = [];
          for (const { feature: t4, id: s7, index: a4, sourceLayerIndex: l4 } of e4) {
            const e5 = this.layers[0]._featureFilter.needGeometry, c3 = gp(t4, e5);
            if (!this.layers[0]._featureFilter.filter(new oa(this.zoom), c3, i3))
              continue;
            const h3 = n4 ? n4.evaluate(c3, {}, i3) : void 0, u3 = { id: s7, properties: t4.properties, type: t4.type, sourceLayerIndex: l4, index: a4, geometry: e5 ? c3.geometry : _p(t4, i3, r3), patterns: {}, sortKey: h3 };
            o3.push(u3);
          }
          n4 && o3.sort((e5, t4) => e5.sortKey - t4.sortKey);
          const { lineAtlas: s6, featureIndex: a3 } = t3, l3 = this.addConstantDashes(s6);
          for (const r4 of o3) {
            const { geometry: n5, index: o4, sourceLayerIndex: c3 } = r4;
            if (l3 && this.addFeatureDashes(r4, s6), this.hasPattern) {
              const e5 = Vf("line", this.layers, r4, this.zoom, t3);
              this.patternFeatures.push(e5);
            } else
              this.addFeature(r4, n5, o4, i3, s6.positions, t3.availableImages, t3.brightness);
            a3.insert(e4[o4].feature, n5, o4, c3, this.index);
          }
        }
        addConstantDashes(e4) {
          let t3 = false;
          for (const i3 of this.layers) {
            const r3 = i3.paint.get("line-dasharray").value, n4 = i3.layout.get("line-cap").value;
            if ("constant" !== r3.kind || "constant" !== n4.kind)
              t3 = true;
            else {
              const t4 = n4.value, i4 = r3.value;
              if (!i4)
                continue;
              e4.addDash(i4, t4);
            }
          }
          return t3;
        }
        addFeatureDashes(e4, t3) {
          const i3 = this.zoom;
          for (const r3 of this.layers) {
            const n4 = r3.paint.get("line-dasharray").value, o3 = r3.layout.get("line-cap").value;
            if ("constant" === n4.kind && "constant" === o3.kind)
              continue;
            let s6, a3;
            if ("constant" === n4.kind) {
              if (s6 = n4.value, !s6)
                continue;
            } else
              s6 = n4.evaluate({ zoom: i3 }, e4);
            a3 = "constant" === o3.kind ? o3.value : o3.evaluate({ zoom: i3 }, e4), t3.addDash(s6, a3), e4.patterns[r3.id] = t3.getKey(s6, a3);
          }
        }
        update(e4, t3, i3, r3, n4) {
          const o3 = 0 !== Object.keys(e4).length;
          o3 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(e4, t3, o3 ? this.stateDependentLayers : this.layers, i3, r3, n4);
        }
        addFeatures(e4, t3, i3, r3, n4, o3) {
          for (const e5 of this.patternFeatures)
            this.addFeature(e5, e5.geometry, e5.index, t3, i3, r3, o3);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e4) {
          this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = e4.createVertexBuffer(this.layoutVertexArray2, by)), this.layoutVertexBuffer = e4.createVertexBuffer(this.layoutVertexArray, xy), this.indexBuffer = e4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e4), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e4) {
          if (e4.properties && e4.properties.hasOwnProperty("mapbox_clip_start") && e4.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +e4.properties.mapbox_clip_start, end: +e4.properties.mapbox_clip_end };
        }
        addFeature(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = this.layers[0].layout, l3 = a3.get("line-join").evaluate(e4, {}), c3 = a3.get("line-cap").evaluate(e4, {}), h3 = a3.get("line-miter-limit"), u3 = a3.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(e4);
          for (const i4 of t3)
            this.addLine(i4, e4, l3, c3, h3, u3);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e4, i3, n4, o3, r3, s6);
        }
        addLine(e4, t3, i3, r3, n4, o3) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let t4 = 0; t4 < e4.length - 1; t4++)
              this.totalDistance += e4[t4].dist(e4[t4 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const s6 = "Polygon" === wy[t3.type];
          let a3 = e4.length;
          for (; a3 >= 2 && e4[a3 - 1].equals(e4[a3 - 2]); )
            a3--;
          let l3 = 0;
          for (; l3 < a3 - 1 && e4[l3].equals(e4[l3 + 1]); )
            l3++;
          if (a3 < (s6 ? 3 : 2))
            return;
          "bevel" === i3 && (n4 = 1.05);
          const c3 = this.overscaling <= 16 ? 15 * cr / (512 * this.overscaling) : 0, h3 = this.segments.prepareSegment(10 * a3, this.layoutVertexArray, this.indexArray);
          let u3, d3, p3, f3, m3;
          this.e1 = this.e2 = -1, s6 && (u3 = e4[a3 - 2], m3 = e4[l3].sub(u3)._unit()._perp());
          for (let t4 = l3; t4 < a3; t4++) {
            if (p3 = t4 === a3 - 1 ? s6 ? e4[l3 + 1] : void 0 : e4[t4 + 1], p3 && e4[t4].equals(p3))
              continue;
            m3 && (f3 = m3), u3 && (d3 = u3), u3 = e4[t4], m3 = p3 ? p3.sub(u3)._unit()._perp() : f3, f3 = f3 || m3;
            let _3 = f3.add(m3);
            0 === _3.x && 0 === _3.y || _3._unit();
            const g3 = f3.x * m3.x + f3.y * m3.y, y3 = _3.x * m3.x + _3.y * m3.y, x3 = 0 !== y3 ? 1 / y3 : 1 / 0, v3 = 2 * Math.sqrt(2 - 2 * y3), b3 = y3 < Ty && d3 && p3, w3 = f3.x * m3.y - f3.y * m3.x > 0;
            if (b3 && t4 > l3) {
              const e5 = u3.dist(d3);
              if (e5 > 2 * c3) {
                const t5 = u3.sub(u3.sub(d3)._mult(c3 / e5)._round());
                this.updateDistance(d3, t5), this.addCurrentVertex(t5, f3, 0, 0, h3), d3 = t5;
              }
            }
            const T3 = d3 && p3;
            let E3 = T3 ? i3 : s6 ? "butt" : r3;
            if (T3 && "round" === E3 && (x3 < o3 ? E3 = "miter" : x3 <= 2 && (E3 = "fakeround")), "miter" === E3 && x3 > n4 && (E3 = "bevel"), "bevel" === E3 && (x3 > 2 && (E3 = "flipbevel"), x3 < n4 && (E3 = "miter")), d3 && this.updateDistance(d3, u3), "miter" === E3)
              _3._mult(x3), this.addCurrentVertex(u3, _3, 0, 0, h3);
            else if ("flipbevel" === E3) {
              if (x3 > 100)
                _3 = m3.mult(-1);
              else {
                const e5 = x3 * f3.add(m3).mag() / f3.sub(m3).mag();
                _3._perp()._mult(e5 * (w3 ? -1 : 1));
              }
              this.addCurrentVertex(u3, _3, 0, 0, h3), this.addCurrentVertex(u3, _3.mult(-1), 0, 0, h3);
            } else if ("bevel" === E3 || "fakeround" === E3) {
              const e5 = -Math.sqrt(x3 * x3 - 1), t5 = w3 ? e5 : 0, i4 = w3 ? 0 : e5;
              if (d3 && this.addCurrentVertex(u3, f3, t5, i4, h3), "fakeround" === E3) {
                const e6 = Math.round(180 * v3 / Math.PI / 20);
                for (let t6 = 1; t6 < e6; t6++) {
                  let i5 = t6 / e6;
                  if (0.5 !== i5) {
                    const e7 = i5 - 0.5;
                    i5 += i5 * e7 * (i5 - 1) * ((1.0904 + g3 * (g3 * (3.55645 - 1.43519 * g3) - 3.2452)) * e7 * e7 + (0.848013 + g3 * (0.215638 * g3 - 1.06021)));
                  }
                  const r4 = m3.sub(f3)._mult(i5)._add(f3)._unit()._mult(w3 ? -1 : 1);
                  this.addHalfVertex(u3, r4.x, r4.y, false, w3, 0, h3);
                }
              }
              p3 && this.addCurrentVertex(u3, m3, -t5, -i4, h3);
            } else if ("butt" === E3)
              this.addCurrentVertex(u3, _3, 0, 0, h3);
            else if ("square" === E3) {
              const e5 = d3 ? 1 : -1;
              d3 || this.addCurrentVertex(u3, _3, e5, e5, h3), this.addCurrentVertex(u3, _3, 0, 0, h3), d3 && this.addCurrentVertex(u3, _3, e5, e5, h3);
            } else
              "round" === E3 && (d3 && (this.addCurrentVertex(u3, f3, 0, 0, h3), this.addCurrentVertex(u3, f3, 1, 1, h3, true)), p3 && (this.addCurrentVertex(u3, m3, -1, -1, h3, true), this.addCurrentVertex(u3, m3, 0, 0, h3)));
            if (b3 && t4 < a3 - 1) {
              const e5 = u3.dist(p3);
              if (e5 > 2 * c3) {
                const t5 = u3.add(p3.sub(u3)._mult(c3 / e5)._round());
                this.updateDistance(u3, t5), this.addCurrentVertex(t5, m3, 0, 0, h3), u3 = t5;
              }
            }
          }
        }
        addCurrentVertex(e4, t3, i3, r3, n4, o3 = false) {
          const s6 = t3.y * r3 - t3.x, a3 = -t3.y - t3.x * r3;
          this.addHalfVertex(e4, t3.x + t3.y * i3, t3.y - t3.x * i3, o3, false, i3, n4), this.addHalfVertex(e4, s6, a3, o3, true, -r3, n4);
        }
        addHalfVertex({ x: e4, y: t3 }, i3, r3, n4, o3, s6, a3) {
          this.layoutVertexArray.emplaceBack((e4 << 1) + (n4 ? 1 : 0), (t3 << 1) + (o3 ? 1 : 0), Math.round(63 * i3) + 128, Math.round(63 * r3) + 128, 1 + (0 === s6 ? 0 : s6 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const l3 = a3.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l3), a3.primitiveLength++), o3 ? this.e2 = l3 : this.e1 = l3;
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const e4 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = e4 * this.lineClips.start + this.distance;
          } else
            this.lineSoFar = this.distance;
        }
        updateDistance(e4, t3) {
          this.distance += e4.dist(t3), this.updateScaledDistance();
        }
      }
      Rs(Ey, "LineBucket", { omit: ["layers", "patternFeatures"] });
      class My {
        constructor(e4, t3, i3, r3) {
          this.context = e4, this.format = i3, this.texture = e4.gl.createTexture(), this.update(t3, r3);
        }
        update(e4, i3, r3) {
          const { width: n4, height: o3 } = e4, { context: s6 } = this, { gl: a3 } = s6, { HTMLImageElement: l3, HTMLCanvasElement: c3, HTMLVideoElement: h3, ImageData: u3, ImageBitmap: d3 } = t2;
          if (a3.bindTexture(a3.TEXTURE_2D, this.texture), s6.pixelStoreUnpackFlipY.set(false), s6.pixelStoreUnpack.set(1), s6.pixelStoreUnpackPremultiplyAlpha.set(this.format === a3.RGBA && (!i3 || false !== i3.premultiply)), r3 || this.size && this.size[0] === n4 && this.size[1] === o3) {
            const { x: t3, y: i4 } = r3 || { x: 0, y: 0 };
            if (e4 instanceof l3 || e4 instanceof c3 || e4 instanceof h3 || e4 instanceof u3 || d3 && e4 instanceof d3)
              a3.texSubImage2D(a3.TEXTURE_2D, 0, t3, i4, a3.RGBA, a3.UNSIGNED_BYTE, e4);
            else {
              let r4 = this.format, s7 = a3.UNSIGNED_BYTE;
              this.format === a3.R32F && (r4 = a3.RED, s7 = a3.FLOAT), a3.texSubImage2D(a3.TEXTURE_2D, 0, t3, i4, n4, o3, r4, s7, e4.data);
            }
          } else if (this.size = [n4, o3], e4 instanceof l3 || e4 instanceof c3 || e4 instanceof h3 || e4 instanceof u3 || d3 && e4 instanceof d3) {
            let t3 = this.format;
            this.format === a3.R8 && (t3 = a3.RED), a3.texImage2D(a3.TEXTURE_2D, 0, this.format, t3, a3.UNSIGNED_BYTE, e4);
          } else {
            let t3 = this.format, i4 = this.format, r4 = a3.UNSIGNED_BYTE;
            this.format === a3.DEPTH_COMPONENT && (t3 = a3.DEPTH_COMPONENT16, r4 = a3.UNSIGNED_SHORT), this.format === a3.R32F && (r4 = a3.FLOAT, i4 = a3.RED), a3.texImage2D(a3.TEXTURE_2D, 0, t3, n4, o3, 0, i4, r4, e4.data);
          }
          this.useMipmap = Boolean(i3 && i3.useMipmap), this.useMipmap && a3.generateMipmap(a3.TEXTURE_2D);
        }
        bind(e4, t3) {
          const { context: i3 } = this, { gl: r3 } = i3;
          r3.bindTexture(r3.TEXTURE_2D, this.texture), e4 !== this.minFilter && (r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, e4), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, this.useMipmap ? e4 === r3.NEAREST ? r3.NEAREST_MIPMAP_NEAREST : r3.LINEAR_MIPMAP_NEAREST : e4), this.minFilter = e4), t3 !== this.wrapS && (r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, t3), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, t3), this.wrapS = t3);
        }
        bindExtraParam(e4, t3, i3, r3) {
          const { context: n4 } = this, { gl: o3 } = n4;
          o3.bindTexture(o3.TEXTURE_2D, this.texture), t3 !== this.magFilter && (o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, t3), this.magFilter = t3), e4 !== this.minFilter && (o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, this.useMipmap ? e4 === o3.NEAREST ? o3.NEAREST_MIPMAP_NEAREST : o3.LINEAR_MIPMAP_NEAREST : e4), this.minFilter = e4), i3 !== this.wrapS && (o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, i3), this.wrapS = i3), r3 !== this.wrapT && (o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, r3), this.wrapT = r3);
        }
        destroy() {
          const { gl: e4 } = this.context;
          e4.deleteTexture(this.texture), this.texture = null;
        }
      }
      class Ay {
        constructor(e4, t3) {
          this.context = e4, this.texture = t3;
        }
        bind(e4, t3) {
          const { context: i3 } = this, { gl: r3 } = i3;
          r3.bindTexture(r3.TEXTURE_2D, this.texture), e4 !== this.minFilter && (r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, e4), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, e4), this.minFilter = e4), t3 !== this.wrapS && (r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, t3), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, t3), this.wrapS = t3);
        }
      }
      const Sy = 32, Iy = 33, Cy = new Uint16Array(8184);
      for (let e4 = 0; e4 < 2046; e4++) {
        let t3 = e4 + 2, i3 = 0, r3 = 0, n4 = 0, o3 = 0, s6 = 0, a3 = 0;
        for (1 & t3 ? n4 = o3 = s6 = Sy : i3 = r3 = a3 = Sy; (t3 >>= 1) > 1; ) {
          const e5 = i3 + n4 >> 1, l4 = r3 + o3 >> 1;
          1 & t3 ? (n4 = i3, o3 = r3, i3 = s6, r3 = a3) : (i3 = n4, r3 = o3, n4 = s6, o3 = a3), s6 = e5, a3 = l4;
        }
        const l3 = 4 * e4;
        Cy[l3 + 0] = i3, Cy[l3 + 1] = r3, Cy[l3 + 2] = n4, Cy[l3 + 3] = o3;
      }
      const zy = new Uint16Array(2178), Py = new Uint8Array(1089), Dy = new Uint16Array(1089);
      function Ry(e4) {
        return 0 === e4 ? -0.03125 : 32 === e4 ? 0.03125 : 0;
      }
      var Ly = Ia([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      const ky = { type: 2, extent: cr, loadGeometry: () => [[new y2(0, 0), new y2(cr + 1, 0), new y2(cr + 1, cr + 1), new y2(0, cr + 1), new y2(0, 0)]] };
      class Oy {
        constructor(e4, t3, i3, r3, n4) {
          this.tileID = e4, this.uid = F(), this.uses = 0, this.tileSize = t3, this.tileZoom = i3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = n4, r3 && r3.style && (this._lastUpdatedBrightness = r3.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", r3 && r3.transform && (this.projection = r3.transform.projection);
        }
        registerFadeDuration(e4) {
          const t3 = e4 + this.timeAdded;
          t3 < dt.now() || this.fadeEndTime && t3 < this.fadeEndTime || (this.fadeEndTime = t3);
        }
        wasRequested() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = Pg(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(e4, t3, i3) {
          if (this.unloadVectorData(), this.state = "loaded", e4) {
            e4.featureIndex && (this.latestFeatureIndex = e4.featureIndex, e4.rawTileData ? (this.latestRawTileData = e4.rawTileData, this.latestFeatureIndex.rawTileData = e4.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e4.collisionBoxArray, this.buckets = function(e5, t4) {
              const i4 = {};
              if (!t4)
                return i4;
              for (const r3 of e5) {
                const e6 = r3.layerIds.map((e7) => t4.getLayer(e7)).filter(Boolean);
                if (0 !== e6.length) {
                  r3.layers = e6, r3.stateDependentLayerIds && (r3.stateDependentLayers = r3.stateDependentLayerIds.map((t5) => e6.filter((e7) => e7.id === t5)[0]));
                  for (const t5 of e6)
                    i4[t5.fqid] = r3;
                }
              }
              return i4;
            }(e4.buckets, t3.style), this.hasSymbolBuckets = false;
            for (const e5 in this.buckets) {
              const t4 = this.buckets[e5];
              if (t4 instanceof gy) {
                if (this.hasSymbolBuckets = true, !i3)
                  break;
                t4.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const e5 in this.buckets) {
                const t4 = this.buckets[e5];
                if (t4 instanceof gy && t4.hasRTLText) {
                  this.hasRTLText = true, na.isLoading() || na.isLoaded() || "deferred" !== ia() || ra();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const e5 in this.buckets) {
              const i4 = this.buckets[e5], r3 = t3.style.getOwnLayer(e5);
              if (!r3)
                continue;
              const n4 = r3.queryRadius(i4);
              this.queryPadding = Math.max(this.queryPadding, n4);
            }
            e4.imageAtlas && (this.imageAtlas = e4.imageAtlas), e4.glyphAtlasImage && (this.glyphAtlasImage = e4.glyphAtlasImage), e4.lineAtlas && (this.lineAtlas = e4.lineAtlas), this._lastUpdatedBrightness = e4.brightness;
          } else
            this.collisionBoxArray = new al();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const e4 in this.buckets)
              this.buckets[e4].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        getBucket(e4) {
          return this.buckets[e4.fqid];
        }
        upload(e4) {
          for (const t4 in this.buckets) {
            const i3 = this.buckets[t4];
            i3.uploadPending() && i3.upload(e4);
          }
          const t3 = e4.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new My(e4, this.imageAtlas.image, t3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new My(e4, this.glyphAtlasImage, t3.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new My(e4, this.lineAtlas.image, t3.ALPHA), this.lineAtlas.uploaded = true);
        }
        prepare(e4, t3, i3) {
          if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e4, this.imageAtlasTexture, i3), !t3 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
            return;
          const r3 = t3.style.getBrightness();
          (this._lastUpdatedBrightness || r3) && (this._lastUpdatedBrightness && r3 && Math.abs(this._lastUpdatedBrightness - r3) < 1e-3 || (this._lastUpdatedBrightness = r3, this.updateBuckets(void 0, t3)));
        }
        queryRenderedFeatures(e4, t3, i3, r3, n4, o3, s6, a3) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: r3, pixelPosMatrix: s6, transform: o3, params: n4, tileTransform: this.tileTransform }, e4, t3, i3) : {};
        }
        querySourceFeatures(e4, t3) {
          const i3 = this.latestFeatureIndex;
          if (!i3 || !i3.rawTileData)
            return;
          const r3 = i3.loadVTLayers(), n4 = t3 ? t3.sourceLayer : "", o3 = r3._geojsonTileLayer || r3[n4];
          if (!o3)
            return;
          const s6 = Fo(t3 && t3.filter), { z: a3, x: l3, y: c3 } = this.tileID.canonical, h3 = { z: a3, x: l3, y: c3 };
          for (let t4 = 0; t4 < o3.length; t4++) {
            const r4 = o3.feature(t4);
            if (s6.needGeometry) {
              const e5 = gp(r4, true);
              if (!s6.filter(new oa(this.tileID.overscaledZ), e5, this.tileID.canonical))
                continue;
            } else if (!s6.filter(new oa(this.tileID.overscaledZ), r4))
              continue;
            const u3 = i3.getId(r4, n4), d3 = new Bm(r4, a3, l3, c3, u3);
            d3.tile = h3, e4.push(d3);
          }
        }
        hasData() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }
        bucketsLoaded() {
          for (const e4 in this.buckets)
            if (this.buckets[e4].uploadPending())
              return false;
          return true;
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e4) {
          const t3 = this.expirationTime;
          if (e4.cacheControl) {
            const t4 = ee(e4.cacheControl);
            t4["max-age"] && (this.expirationTime = Date.now() + 1e3 * t4["max-age"]);
          } else
            e4.expires && (this.expirationTime = new Date(e4.expires).getTime());
          if (this.expirationTime) {
            const e5 = Date.now();
            let i3 = false;
            if (this.expirationTime > e5)
              i3 = false;
            else if (t3)
              if (this.expirationTime < t3)
                i3 = true;
              else {
                const r3 = this.expirationTime - t3;
                r3 ? this.expirationTime = e5 + Math.max(r3, 3e4) : i3 = true;
              }
            else
              i3 = true;
            i3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(e4, t3) {
          this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(e4).length && t3 && this.updateBuckets(e4, t3);
        }
        updateBuckets(e4, t3) {
          if (!this.latestFeatureIndex)
            return;
          const i3 = this.latestFeatureIndex.loadVTLayers(), r3 = t3.style.listImages(), n4 = t3.style.getBrightness();
          for (const o3 in this.buckets) {
            if (!t3.style.hasLayer(o3))
              continue;
            const s6 = this.buckets[o3], a3 = s6.layers[0].sourceLayer || "_geojsonTileLayer", l3 = i3[a3];
            let c3 = {};
            if (e4 && (c3 = e4[a3], !l3 || !c3 || 0 === Object.keys(c3).length))
              continue;
            if (s6.update(c3, l3, r3, this.imageAtlas && this.imageAtlas.patternPositions || {}, n4), s6 instanceof Ey || s6 instanceof jf) {
              const e5 = t3.style.getOwnSourceCache(s6.layers[0].source);
              t3._terrain && t3._terrain.enabled && e5 && s6.programConfigurations.needsUpload && t3._terrain._clearRenderCacheForTile(e5.id, this.tileID);
            }
            const h3 = t3 && t3.style && t3.style.getOwnLayer(o3);
            h3 && (this.queryPadding = Math.max(this.queryPadding, h3.queryRadius(s6)));
          }
        }
        holdingForFade() {
          return void 0 !== this.symbolFadeHoldUntil;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < dt.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(e4) {
          this.symbolFadeHoldUntil = dt.now() + e4;
        }
        setTexture(e4, t3) {
          const i3 = t3.context, r3 = i3.gl;
          this.texture = this.texture || t3.getTileTexture(e4.width), this.texture && this.texture instanceof My ? this.texture.update(e4, { useMipmap: true }) : (this.texture = new My(i3, e4, r3.RGBA, { useMipmap: true }), this.texture.bind(r3.LINEAR, r3.CLAMP_TO_EDGE));
        }
        setDependencies(e4, t3) {
          const i3 = {};
          for (const e5 of t3)
            i3[e5] = true;
          this.dependencies[e4] = i3;
        }
        hasDependency(e4, t3) {
          for (const i3 of e4) {
            const e5 = this.dependencies[i3];
            if (e5) {
              for (const i4 of t3)
                if (e5[i4])
                  return true;
            }
          }
          return false;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(e4, t3) {
          if (!t3 || "mercator" === t3.name || this._tileDebugBuffer)
            return;
          const i3 = _p(ky, this.tileID.canonical, this.tileTransform)[0], r3 = new za(), n4 = new el();
          for (let e5 = 0; e5 < i3.length; e5++) {
            const { x: t4, y: o3 } = i3[e5];
            r3.emplaceBack(t4, o3), n4.emplaceBack(e5);
          }
          n4.emplaceBack(0), this._tileDebugIndexBuffer = e4.createIndexBuffer(n4), this._tileDebugBuffer = e4.createVertexBuffer(r3, Nu.members), this._tileDebugSegments = xl.simpleSegment(0, 0, r3.length, n4.length);
        }
        _makeTileBoundsBuffers(e4, t3) {
          if (this._tileBoundsBuffer || !t3 || "mercator" === t3.name)
            return;
          const i3 = _p(ky, this.tileID.canonical, this.tileTransform)[0];
          let r3, n4;
          if (this.isRaster) {
            const e5 = function(e6, t4) {
              const i4 = Pg(e6, t4), r4 = Math.pow(2, e6.z);
              for (let n6 = 0; n6 < Iy; n6++)
                for (let o4 = 0; o4 < Iy; o4++) {
                  const s7 = ep((e6.x + (o4 + Ry(o4)) / Sy) / r4), a4 = tp((e6.y + (n6 + Ry(n6)) / Sy) / r4), l4 = t4.project(s7, a4), c3 = n6 * Iy + o4;
                  zy[2 * c3 + 0] = Math.round((l4.x * i4.scale - i4.x) * cr), zy[2 * c3 + 1] = Math.round((l4.y * i4.scale - i4.y) * cr);
                }
              Py.fill(0), Dy.fill(0);
              for (let e7 = 2045; e7 >= 0; e7--) {
                const t5 = 4 * e7, i5 = Cy[t5 + 0], r5 = Cy[t5 + 1], n6 = Cy[t5 + 2], o4 = Cy[t5 + 3], s7 = i5 + n6 >> 1, a4 = r5 + o4 >> 1, l4 = s7 + a4 - r5, c3 = a4 + i5 - s7, h3 = r5 * Iy + i5, u3 = o4 * Iy + n6, d3 = a4 * Iy + s7, p3 = Math.hypot((zy[2 * h3 + 0] + zy[2 * u3 + 0]) / 2 - zy[2 * d3 + 0], (zy[2 * h3 + 1] + zy[2 * u3 + 1]) / 2 - zy[2 * d3 + 1]) >= 16;
                Py[d3] = Py[d3] || (p3 ? 1 : 0), e7 < 1022 && (Py[d3] = Py[d3] || Py[(r5 + c3 >> 1) * Iy + (i5 + l4 >> 1)] || Py[(o4 + c3 >> 1) * Iy + (n6 + l4 >> 1)]);
              }
              const n5 = new Da(), o3 = new Wa();
              let s6 = 0;
              function a3(e7, t5) {
                const i5 = t5 * Iy + e7;
                return 0 === Dy[i5] && (n5.emplaceBack(zy[2 * i5 + 0], zy[2 * i5 + 1], e7 * cr / Sy, t5 * cr / Sy), Dy[i5] = ++s6), Dy[i5] - 1;
              }
              function l3(e7, t5, i5, r5, n6, s7) {
                const c3 = e7 + i5 >> 1, h3 = t5 + r5 >> 1;
                if (Math.abs(e7 - n6) + Math.abs(t5 - s7) > 1 && Py[h3 * Iy + c3])
                  l3(n6, s7, e7, t5, c3, h3), l3(i5, r5, n6, s7, c3, h3);
                else {
                  const l4 = a3(e7, t5), c4 = a3(i5, r5), h4 = a3(n6, s7);
                  o3.emplaceBack(l4, c4, h4);
                }
              }
              return l3(0, 0, Sy, Sy, Sy, 0), l3(Sy, Sy, 0, 0, 0, Sy), { vertices: n5, indices: o3 };
            }(this.tileID.canonical, t3);
            r3 = e5.vertices, n4 = e5.indices;
          } else {
            r3 = new Da(), n4 = new Wa();
            for (const { x: e6, y: t4 } of i3)
              r3.emplaceBack(e6, t4, 0, 0);
            const e5 = Bf(r3.int16, void 0, 4);
            for (let t4 = 0; t4 < e5.length; t4 += 3)
              n4.emplaceBack(e5[t4], e5[t4 + 1], e5[t4 + 2]);
          }
          this._tileBoundsBuffer = e4.createVertexBuffer(r3, Ly.members), this._tileBoundsIndexBuffer = e4.createIndexBuffer(n4), this._tileBoundsSegments = xl.simpleSegment(0, 0, r3.length, n4.length);
        }
        _makeGlobeTileDebugBuffers(e4, t3) {
          const i3 = t3.projection;
          if (!i3 || "globe" !== i3.name || t3.freezeTileCoverage)
            return;
          const r3 = this.tileID.canonical, n4 = Ad(_d(r3, t3)), o3 = Dd(t3.zoom);
          let s6;
          o3 > 0 && (s6 = Au.invert(new Float64Array(16), t3.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(e4, r3, t3, n4, s6, o3), this._makeGlobeTileDebugTextBuffer(e4, r3, t3, n4, s6, o3);
        }
        _globePoint(e4, t3, i3, r3, n4, o3, s6) {
          let a3 = Td(e4, t3, i3);
          if (o3) {
            const n5 = 1 << i3.z, l3 = Kd(r3.center.lng), c3 = Jd(r3.center.lat), h3 = (i3.x + 0.5) / n5 - l3;
            let u3 = 0;
            h3 > 0.5 ? u3 = -1 : h3 < -0.5 && (u3 = 1);
            let d3 = (e4 / cr + i3.x) / n5 + u3, p3 = (t3 / cr + i3.y) / n5;
            d3 = (d3 - l3) * r3._pixelsPerMercatorPixel + l3, p3 = (p3 - c3) * r3._pixelsPerMercatorPixel + c3;
            const f3 = [d3 * r3.worldSize, p3 * r3.worldSize, 0];
            Du.transformMat4(f3, f3, o3), a3 = md(a3, f3, s6);
          }
          return Du.transformMat4(a3, a3, n4);
        }
        _makeGlobeTileDebugBorderBuffer(e4, t3, i3, r3, n4, o3) {
          const s6 = new za(), a3 = new el(), l3 = new Pa(), c3 = (e5, c4, h4, u3, d3) => {
            const p3 = (h4 - e5) / (d3 - 1), f3 = (u3 - c4) / (d3 - 1), m3 = s6.length;
            for (let h5 = 0; h5 < d3; h5++) {
              const u4 = e5 + h5 * p3, d4 = c4 + h5 * f3;
              s6.emplaceBack(u4, d4);
              const _3 = this._globePoint(u4, d4, t3, i3, r3, n4, o3);
              l3.emplaceBack(_3[0], _3[1], _3[2]), a3.emplaceBack(m3 + h5);
            }
          }, h3 = cr;
          c3(0, 0, h3, 0, 16), c3(h3, 0, h3, h3, 16), c3(h3, h3, 0, h3, 16), c3(0, h3, 0, 0, 16), this._tileDebugIndexBuffer = e4.createIndexBuffer(a3), this._tileDebugBuffer = e4.createVertexBuffer(s6, Nu.members), this._globeTileDebugBorderBuffer = e4.createVertexBuffer(l3, Fu.members), this._tileDebugSegments = xl.simpleSegment(0, 0, s6.length, a3.length);
        }
        _makeGlobeTileDebugTextBuffer(e4, t3, i3, r3, n4, o3) {
          const s6 = cr / 4, a3 = new za(), l3 = new Wa(), c3 = new Pa(), h3 = 25;
          l3.reserve(32), a3.reserve(h3), c3.reserve(h3);
          const u3 = (e5, t4) => h3 * e5 + t4;
          for (let e5 = 0; e5 < h3; e5++) {
            const l4 = e5 * s6;
            for (let e6 = 0; e6 < h3; e6++) {
              const h4 = e6 * s6;
              a3.emplaceBack(h4, l4);
              const u4 = this._globePoint(h4, l4, t3, i3, r3, n4, o3);
              c3.emplaceBack(u4[0], u4[1], u4[2]);
            }
          }
          for (let e5 = 0; e5 < 4; e5++)
            for (let t4 = 0; t4 < 4; t4++) {
              const i4 = u3(e5, t4), r4 = u3(e5, t4 + 1), n5 = u3(e5 + 1, t4), o4 = u3(e5 + 1, t4 + 1);
              l3.emplaceBack(i4, r4, n5), l3.emplaceBack(n5, r4, o4);
            }
          this._tileDebugTextIndexBuffer = e4.createIndexBuffer(l3), this._tileDebugTextBuffer = e4.createVertexBuffer(a3, Nu.members), this._globeTileDebugTextBuffer = e4.createVertexBuffer(c3, Fu.members), this._tileDebugTextSegments = xl.simpleSegment(0, 0, h3, 32);
        }
        destroy(e4 = false) {
          for (const e5 in this.buckets)
            this.buckets[e5].destroy();
          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !e4 && this.texture && this.texture instanceof My && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.latestFeatureIndex = null, this.state = "unloaded";
        }
      }
      class By {
        constructor(e4, t3) {
          this.max = e4, this.onRemove = t3, this.reset();
        }
        reset() {
          for (const e4 in this.data)
            for (const t3 of this.data[e4])
              t3.timeout && clearTimeout(t3.timeout), this.onRemove(t3.value);
          return this.data = {}, this.order = [], this;
        }
        add(e4, t3, i3) {
          const r3 = e4.wrapped().key;
          void 0 === this.data[r3] && (this.data[r3] = []);
          const n4 = { value: t3, timeout: void 0 };
          if (void 0 !== i3 && (n4.timeout = setTimeout(() => {
            this.remove(e4, n4);
          }, i3)), this.data[r3].push(n4), this.order.push(r3), this.order.length > this.max) {
            const e5 = this._getAndRemoveByKey(this.order[0]);
            e5 && this.onRemove(e5);
          }
          return this;
        }
        has(e4) {
          return e4.wrapped().key in this.data;
        }
        getAndRemove(e4) {
          return this.has(e4) ? this._getAndRemoveByKey(e4.wrapped().key) : null;
        }
        _getAndRemoveByKey(e4) {
          const t3 = this.data[e4].shift();
          return t3.timeout && clearTimeout(t3.timeout), 0 === this.data[e4].length && delete this.data[e4], this.order.splice(this.order.indexOf(e4), 1), t3.value;
        }
        getByKey(e4) {
          const t3 = this.data[e4];
          return t3 ? t3[0].value : null;
        }
        get(e4) {
          return this.has(e4) ? this.data[e4.wrapped().key][0].value : null;
        }
        remove(e4, t3) {
          if (!this.has(e4))
            return this;
          const i3 = e4.wrapped().key, r3 = void 0 === t3 ? 0 : this.data[i3].indexOf(t3), n4 = this.data[i3][r3];
          return this.data[i3].splice(r3, 1), n4.timeout && clearTimeout(n4.timeout), 0 === this.data[i3].length && delete this.data[i3], this.onRemove(n4.value), this.order.splice(this.order.indexOf(i3), 1), this;
        }
        setMaxSize(e4) {
          for (this.max = e4; this.order.length > this.max; ) {
            const e5 = this._getAndRemoveByKey(this.order[0]);
            e5 && this.onRemove(e5);
          }
          return this;
        }
        filter(e4) {
          const t3 = [];
          for (const i3 in this.data)
            for (const r3 of this.data[i3])
              e4(r3.value) || t3.push(r3);
          for (const e5 of t3)
            this.remove(e5.value.tileID, e5);
        }
      }
      class Fy {
        constructor(e4, t3, i3, r3) {
          this.id = Fy.uniqueIdxCounter, Fy.uniqueIdxCounter++, this.context = e4;
          const n4 = e4.gl;
          this.buffer = n4.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), e4.bindElementBuffer.set(this.buffer), n4.bufferData(n4.ELEMENT_ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? n4.DYNAMIC_DRAW : n4.STATIC_DRAW), this.dynamicDraw || r3 || t3.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e4) {
          this.id = Fy.uniqueIdxCounter, Fy.uniqueIdxCounter++;
          const t3 = this.context.gl;
          this.context.unbindVAO(), this.bind(), t3.bufferSubData(t3.ELEMENT_ARRAY_BUFFER, 0, e4.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      Fy.uniqueIdxCounter = 0;
      const Ny = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Uy {
        constructor(e4, t3, i3, r3, n4, o3) {
          this.length = t3.length, this.attributes = i3, this.itemSize = t3.bytesPerElement, this.dynamicDraw = r3, this.instanceCount = o3, this.context = e4;
          const s6 = e4.gl;
          this.buffer = s6.createBuffer(), e4.bindVertexBuffer.set(this.buffer), s6.bufferData(s6.ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? s6.DYNAMIC_DRAW : s6.STATIC_DRAW), this.dynamicDraw || n4 || t3.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e4) {
          const t3 = this.context.gl;
          this.bind(), t3.bufferSubData(t3.ARRAY_BUFFER, 0, e4.arrayBuffer);
        }
        enableAttributes(e4, t3) {
          for (let i3 = 0; i3 < this.attributes.length; i3++) {
            const r3 = t3.attributes[this.attributes[i3].name];
            void 0 !== r3 && e4.enableVertexAttribArray(r3);
          }
        }
        setVertexAttribPointers(e4, t3, i3) {
          for (let r3 = 0; r3 < this.attributes.length; r3++) {
            const n4 = this.attributes[r3], o3 = t3.attributes[n4.name];
            void 0 !== o3 && e4.vertexAttribPointer(o3, n4.components, e4[Ny[n4.type]], false, this.itemSize, n4.offset + this.itemSize * (i3 || 0));
          }
        }
        setVertexAttribDivisor(e4, t3, i3) {
          for (let r3 = 0; r3 < this.attributes.length; r3++) {
            const n4 = t3.attributes[this.attributes[r3].name];
            void 0 !== n4 && this.instanceCount && this.instanceCount > 0 && e4.vertexAttribDivisor(n4, i3);
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class Vy {
        constructor(e4) {
          this.gl = e4.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e4) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class jy extends Vy {
        getDefault() {
          return hi.transparent;
        }
        set(e4) {
          const t3 = this.current;
          (e4.r !== t3.r || e4.g !== t3.g || e4.b !== t3.b || e4.a !== t3.a || this.dirty) && (this.gl.clearColor(e4.r, e4.g, e4.b, e4.a), this.current = e4, this.dirty = false);
        }
      }
      class Gy extends Vy {
        getDefault() {
          return 1;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.clearDepth(e4), this.current = e4, this.dirty = false);
        }
      }
      class qy extends Vy {
        getDefault() {
          return 0;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.clearStencil(e4), this.current = e4, this.dirty = false);
        }
      }
      class Zy extends Vy {
        getDefault() {
          return [true, true, true, true];
        }
        set(e4) {
          const t3 = this.current;
          (e4[0] !== t3[0] || e4[1] !== t3[1] || e4[2] !== t3[2] || e4[3] !== t3[3] || this.dirty) && (this.gl.colorMask(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
        }
      }
      class $y extends Vy {
        getDefault() {
          return true;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.depthMask(e4), this.current = e4, this.dirty = false);
        }
      }
      class Wy extends Vy {
        getDefault() {
          return 255;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.stencilMask(e4), this.current = e4, this.dirty = false);
        }
      }
      class Hy extends Vy {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e4) {
          const t3 = this.current;
          (e4.func !== t3.func || e4.ref !== t3.ref || e4.mask !== t3.mask || this.dirty) && (this.gl.stencilFunc(e4.func, e4.ref, e4.mask), this.current = e4, this.dirty = false);
        }
      }
      class Xy extends Vy {
        getDefault() {
          const e4 = this.gl;
          return [e4.KEEP, e4.KEEP, e4.KEEP];
        }
        set(e4) {
          const t3 = this.current;
          (e4[0] !== t3[0] || e4[1] !== t3[1] || e4[2] !== t3[2] || this.dirty) && (this.gl.stencilOp(e4[0], e4[1], e4[2]), this.current = e4, this.dirty = false);
        }
      }
      class Yy extends Vy {
        getDefault() {
          return false;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          e4 ? t3.enable(t3.STENCIL_TEST) : t3.disable(t3.STENCIL_TEST), this.current = e4, this.dirty = false;
        }
      }
      class Ky extends Vy {
        getDefault() {
          return [0, 1];
        }
        set(e4) {
          const t3 = this.current;
          (e4[0] !== t3[0] || e4[1] !== t3[1] || this.dirty) && (this.gl.depthRange(e4[0], e4[1]), this.current = e4, this.dirty = false);
        }
      }
      class Jy extends Vy {
        getDefault() {
          return false;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          e4 ? t3.enable(t3.DEPTH_TEST) : t3.disable(t3.DEPTH_TEST), this.current = e4, this.dirty = false;
        }
      }
      class Qy extends Vy {
        getDefault() {
          return this.gl.LESS;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.depthFunc(e4), this.current = e4, this.dirty = false);
        }
      }
      class ex extends Vy {
        getDefault() {
          return false;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          e4 ? t3.enable(t3.BLEND) : t3.disable(t3.BLEND), this.current = e4, this.dirty = false;
        }
      }
      class tx extends Vy {
        getDefault() {
          const e4 = this.gl;
          return [e4.ONE, e4.ZERO, e4.ONE, e4.ZERO];
        }
        set(e4) {
          const t3 = this.current;
          (e4[0] !== t3[0] || e4[1] !== t3[1] || e4[2] !== t3[2] || e4[3] !== t3[3] || this.dirty) && (this.gl.blendFuncSeparate(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
        }
      }
      class ix extends Vy {
        getDefault() {
          return hi.transparent;
        }
        set(e4) {
          const t3 = this.current;
          (e4.r !== t3.r || e4.g !== t3.g || e4.b !== t3.b || e4.a !== t3.a || this.dirty) && (this.gl.blendColor(e4.r, e4.g, e4.b, e4.a), this.current = e4, this.dirty = false);
        }
      }
      class rx extends Vy {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e4, e4), this.current = e4, this.dirty = false);
        }
      }
      class nx extends Vy {
        getDefault() {
          return false;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          e4 ? t3.enable(t3.CULL_FACE) : t3.disable(t3.CULL_FACE), this.current = e4, this.dirty = false;
        }
      }
      class ox extends Vy {
        getDefault() {
          return this.gl.BACK;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.cullFace(e4), this.current = e4, this.dirty = false);
        }
      }
      class sx extends Vy {
        getDefault() {
          return this.gl.CCW;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.frontFace(e4), this.current = e4, this.dirty = false);
        }
      }
      let ax = class extends Vy {
        getDefault() {
          return null;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.useProgram(e4), this.current = e4, this.dirty = false);
        }
      };
      class lx extends Vy {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e4) {
          (e4 !== this.current || this.dirty) && (this.gl.activeTexture(e4), this.current = e4, this.dirty = false);
        }
      }
      class cx extends Vy {
        getDefault() {
          const e4 = this.gl;
          return [0, 0, e4.drawingBufferWidth, e4.drawingBufferHeight];
        }
        set(e4) {
          const t3 = this.current;
          (e4[0] !== t3[0] || e4[1] !== t3[1] || e4[2] !== t3[2] || e4[3] !== t3[3] || this.dirty) && (this.gl.viewport(e4[0], e4[1], e4[2], e4[3]), this.current = e4, this.dirty = false);
        }
      }
      class hx extends Vy {
        getDefault() {
          return null;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.bindFramebuffer(t3.FRAMEBUFFER, e4), this.current = e4, this.dirty = false;
        }
      }
      class ux extends Vy {
        getDefault() {
          return null;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.bindRenderbuffer(t3.RENDERBUFFER, e4), this.current = e4, this.dirty = false;
        }
      }
      class dx extends Vy {
        getDefault() {
          return null;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.bindTexture(t3.TEXTURE_2D, e4), this.current = e4, this.dirty = false;
        }
      }
      class px extends Vy {
        getDefault() {
          return null;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.bindBuffer(t3.ARRAY_BUFFER, e4), this.current = e4, this.dirty = false;
        }
      }
      class fx extends Vy {
        getDefault() {
          return null;
        }
        set(e4) {
          const t3 = this.gl;
          t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, e4), this.current = e4, this.dirty = false;
        }
      }
      class mx extends Vy {
        getDefault() {
          return null;
        }
        set(e4) {
          this.gl && (e4 !== this.current || this.dirty) && (this.gl.bindVertexArray(e4), this.current = e4, this.dirty = false);
        }
      }
      class _x extends Vy {
        getDefault() {
          return 4;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.pixelStorei(t3.UNPACK_ALIGNMENT, e4), this.current = e4, this.dirty = false;
        }
      }
      class gx extends Vy {
        getDefault() {
          return false;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e4), this.current = e4, this.dirty = false;
        }
      }
      class yx extends Vy {
        getDefault() {
          return false;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          const t3 = this.gl;
          t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, e4), this.current = e4, this.dirty = false;
        }
      }
      class xx extends Vy {
        constructor(e4, t3) {
          super(e4), this.context = e4, this.parent = t3;
        }
        getDefault() {
          return null;
        }
      }
      class vx extends xx {
        setDirty() {
          this.dirty = true;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t3 = this.gl;
          t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e4, 0), this.current = e4, this.dirty = false;
        }
      }
      class bx extends xx {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t3 = this.gl;
          t3.framebufferRenderbuffer(t3.FRAMEBUFFER, this.attachment(), t3.RENDERBUFFER, e4), this.current = e4, this.dirty = false;
        }
      }
      class wx extends xx {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e4) {
          if (e4 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t3 = this.gl;
          t3.framebufferTexture2D(t3.FRAMEBUFFER, this.attachment(), t3.TEXTURE_2D, e4, 0), this.current = e4, this.dirty = false;
        }
      }
      class Tx extends bx {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      class Ex {
        constructor(e4, t3, i3, r3, n4) {
          this.context = e4, this.width = t3, this.height = i3;
          const o3 = this.framebuffer = e4.gl.createFramebuffer();
          r3 && (this.colorAttachment = new vx(e4, o3)), n4 && (this.depthAttachmentType = n4, this.depthAttachment = "renderbuffer" === n4 ? new bx(e4, o3) : new wx(e4, o3));
        }
        destroy() {
          const e4 = this.context.gl;
          if (this.colorAttachment) {
            const t3 = this.colorAttachment.get();
            t3 && e4.deleteTexture(t3);
          }
          if (this.depthAttachment && this.depthAttachmentType)
            if ("renderbuffer" === this.depthAttachmentType) {
              const t3 = this.depthAttachment.get();
              t3 && e4.deleteRenderbuffer(t3);
            } else {
              const t3 = this.depthAttachment.get();
              t3 && e4.deleteTexture(t3);
            }
          e4.deleteFramebuffer(this.framebuffer);
        }
      }
      class Mx {
        constructor(e4, t3, i3) {
          this.func = e4, this.mask = t3, this.range = i3;
        }
      }
      Mx.ReadOnly = false, Mx.ReadWrite = true, Mx.disabled = new Mx(519, Mx.ReadOnly, [0, 1]);
      const Ax = 7680;
      class Sx {
        constructor(e4, t3, i3, r3, n4, o3) {
          this.test = e4, this.ref = t3, this.mask = i3, this.fail = r3, this.depthFail = n4, this.pass = o3;
        }
      }
      Sx.disabled = new Sx({ func: 519, mask: 0 }, 0, 0, Ax, Ax, Ax);
      const Ix = 771;
      class Cx {
        constructor(e4, t3, i3, r3) {
          this.blendFunction = e4, this.blendColor = t3, this.mask = i3, this.blendEquation = r3;
        }
      }
      Cx.Replace = [1, 0, 1, 0], Cx.disabled = new Cx(Cx.Replace, hi.transparent, [false, false, false, false]), Cx.unblended = new Cx(Cx.Replace, hi.transparent, [true, true, true, true]), Cx.alphaBlended = new Cx([1, Ix, 1, Ix], hi.transparent, [true, true, true, true]), Cx.multiply = new Cx([774, 0, 774, 0], hi.transparent, [true, true, true, true]);
      const zx = 1029, Px = 2305;
      class Dx {
        constructor(e4, t3, i3) {
          this.enable = e4, this.mode = t3, this.frontFace = i3;
        }
      }
      Dx.disabled = new Dx(false, zx, Px), Dx.backCCW = new Dx(true, zx, Px), Dx.backCW = new Dx(true, zx, 2304), Dx.frontCW = new Dx(true, 1028, 2304), Dx.frontCCW = new Dx(true, 1028, Px);
      class Rx {
        constructor(e4, t3) {
          this.gl = e4, this.clearColor = new jy(this), this.clearDepth = new Gy(this), this.clearStencil = new qy(this), this.colorMask = new Zy(this), this.depthMask = new $y(this), this.stencilMask = new Wy(this), this.stencilFunc = new Hy(this), this.stencilOp = new Xy(this), this.stencilTest = new Yy(this), this.depthRange = new Ky(this), this.depthTest = new Jy(this), this.depthFunc = new Qy(this), this.blend = new ex(this), this.blendFunc = new tx(this), this.blendColor = new ix(this), this.blendEquation = new rx(this), this.cullFace = new nx(this), this.cullFaceSide = new ox(this), this.frontFace = new sx(this), this.program = new ax(this), this.activeTexture = new lx(this), this.viewport = new cx(this), this.bindFramebuffer = new hx(this), this.bindRenderbuffer = new ux(this), this.bindTexture = new dx(this), this.bindVertexBuffer = new px(this), this.bindElementBuffer = new fx(this), this.bindVertexArrayOES = new mx(this), this.pixelStoreUnpack = new _x(this), this.pixelStoreUnpackPremultiplyAlpha = new gx(this), this.pixelStoreUnpackFlipY = new yx(this), this.options = t3 ? { ...t3 } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e4.getExtension("EXT_texture_filter_anisotropic") || e4.getExtension("MOZ_EXT_texture_filter_anisotropic") || e4.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e4.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e4.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e4.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e4.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e4.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e4.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e4.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e4.getParameter(e4.MAX_TEXTURE_SIZE);
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e4, t3, i3) {
          return new Fy(this, e4, t3, i3);
        }
        createVertexBuffer(e4, t3, i3, r3, n4) {
          return new Uy(this, e4, t3, i3, r3, n4);
        }
        createRenderbuffer(e4, t3, i3) {
          const r3 = this.gl, n4 = r3.createRenderbuffer();
          return this.bindRenderbuffer.set(n4), r3.renderbufferStorage(r3.RENDERBUFFER, e4, t3, i3), this.bindRenderbuffer.set(null), n4;
        }
        createFramebuffer(e4, t3, i3, r3) {
          return new Ex(this, e4, t3, i3, r3);
        }
        clear({ color: e4, depth: t3, stencil: i3, colorMask: r3 }) {
          const n4 = this.gl;
          let o3 = 0;
          e4 && (o3 |= n4.COLOR_BUFFER_BIT, this.clearColor.set(e4), this.colorMask.set(r3 || [true, true, true, true])), void 0 !== t3 && (o3 |= n4.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t3), this.depthMask.set(true)), void 0 !== i3 && (o3 |= n4.STENCIL_BUFFER_BIT, this.clearStencil.set(i3), this.stencilMask.set(255)), n4.clear(o3);
        }
        setCullFace(e4) {
          false === e4.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e4.mode), this.frontFace.set(e4.frontFace));
        }
        setDepthMode(e4) {
          e4.func !== this.gl.ALWAYS || e4.mask ? (this.depthTest.set(true), this.depthFunc.set(e4.func), this.depthMask.set(e4.mask), this.depthRange.set(e4.range)) : this.depthTest.set(false);
        }
        setStencilMode(e4) {
          e4.test.func !== this.gl.ALWAYS || e4.mask ? (this.stencilTest.set(true), this.stencilMask.set(e4.mask), this.stencilOp.set([e4.fail, e4.depthFail, e4.pass]), this.stencilFunc.set({ func: e4.test.func, ref: e4.ref, mask: e4.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(e4) {
          x2(e4.blendFunction, Cx.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e4.blendFunction), this.blendColor.set(e4.blendColor), e4.blendEquation ? this.blendEquation.set(e4.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(e4.mask);
        }
        unbindVAO() {
          this.bindVertexArrayOES.set(null);
        }
      }
      class Lx extends zt {
        constructor(e4, t3, i3) {
          super(), this.id = e4, this._onlySymbols = i3, t3.on("data", (e5) => {
            "source" === e5.dataType && "metadata" === e5.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e5.dataType && "content" === e5.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
          }), t3.on("error", () => {
            this._sourceErrored = true;
          }), this._source = t3, this._tiles = {}, this._cache = new By(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t3.minTileCacheSize, this._maxTileCacheSize = t3.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Fm(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
        }
        onAdd(e4) {
          this.map = e4, this._minTileCacheSize = void 0 === this._minTileCacheSize && e4 ? e4._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e4 ? e4._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          for (const e4 in this._tiles) {
            const t3 = this._tiles[e4];
            if ("errored" !== t3.state && ("loaded" !== t3.state || !t3.bucketsLoaded()))
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const e4 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, e4 && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(e4, t3) {
          return e4.isSymbolTile = this._onlySymbols, e4.isExtraShadowCaster = this._shadowCasterTiles[e4.tileID.key], this._source.loadTile(e4, t3);
        }
        _unloadTile(e4) {
          if (this._source.unloadTile)
            return this._source.unloadTile(e4, () => {
            });
        }
        _abortTile(e4) {
          if (this._source.abortTile)
            return this._source.abortTile(e4, () => {
            });
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e4) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const t3 in this._tiles) {
            const i3 = this._tiles[t3];
            i3.upload(e4), i3.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
          }
        }
        getIds() {
          return L2(this._tiles).map((e4) => e4.tileID).sort(kx).map((e4) => e4.key);
        }
        getRenderableIds(e4, t3) {
          const i3 = [];
          for (const r3 in this._tiles)
            this._isIdRenderable(+r3, e4, t3) && i3.push(this._tiles[r3]);
          return e4 ? i3.sort((e5, t4) => {
            const i4 = e5.tileID, r3 = t4.tileID, n4 = new y2(i4.canonical.x, i4.canonical.y)._rotate(this.transform.angle), o3 = new y2(r3.canonical.x, r3.canonical.y)._rotate(this.transform.angle);
            return i4.overscaledZ - r3.overscaledZ || o3.y - n4.y || o3.x - n4.x;
          }).map((e5) => e5.tileID.key) : i3.map((e5) => e5.tileID).sort(kx).map((e5) => e5.key);
        }
        hasRenderableParent(e4) {
          const t3 = this.findLoadedParent(e4, 0);
          return !!t3 && this._isIdRenderable(t3.tileID.key);
        }
        _isIdRenderable(e4, t3, i3) {
          return this._tiles[e4] && this._tiles[e4].hasData() && !this._coveredTiles[e4] && (t3 || !this._tiles[e4].holdingForFade()) && (i3 || !this._shadowCasterTiles[e4]);
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const e4 in this._tiles)
              "errored" !== this._tiles[e4].state && this._reloadTile(+e4, "reloading");
          }
        }
        _reloadTile(e4, t3) {
          const i3 = this._tiles[e4];
          i3 && ("loading" !== i3.state && (i3.state = t3), this._loadTile(i3, this._tileLoaded.bind(this, i3, e4, t3)));
        }
        _tileLoaded(e4, t3, i3, r3) {
          if (r3)
            if (e4.state = "errored", 404 !== r3.status)
              this._source.fire(new Ct(r3, { tile: e4 }));
            else {
              if (!(e4.tileID.key in this._loadedParentTiles))
                return void this._source.fire(new It("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id }));
              if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                const e5 = this.map.painter.terrain;
                this.update(this.transform, e5.getScaledDemTileSize(), true), e5.resetTileLookupCache(this.id);
              } else
                this.update(this.transform);
            }
          else
            e4.timeAdded = dt.now(), "expired" === i3 && (e4.refreshedUponExpiration = true), this._setTileReloadTimer(t3, e4), "raster-dem" === this._source.type && e4.dem && this._backfillDEM(e4), this._state.initializeTileState(e4, this.map ? this.map.painter : null), this._source.fire(new It("data", { dataType: "source", tile: e4, coord: e4.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(e4) {
          const t3 = this.getRenderableIds();
          for (let r3 = 0; r3 < t3.length; r3++) {
            const n4 = t3[r3];
            if (e4.neighboringTiles && e4.neighboringTiles[n4]) {
              const t4 = this.getTileByID(n4);
              i3(e4, t4), i3(t4, e4);
            }
          }
          function i3(e5, t4) {
            if (!e5.dem || e5.dem.borderReady)
              return;
            e5.needsHillshadePrepare = true, e5.needsDEMTextureUpload = true;
            let i4 = t4.tileID.canonical.x - e5.tileID.canonical.x;
            const r3 = t4.tileID.canonical.y - e5.tileID.canonical.y, n4 = Math.pow(2, e5.tileID.canonical.z), o3 = t4.tileID.key;
            0 === i4 && 0 === r3 || Math.abs(r3) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + n4) ? i4 += n4 : 1 === Math.abs(i4 - n4) && (i4 -= n4)), t4.dem && e5.dem && (e5.dem.backfillBorder(t4.dem, i4, r3), e5.neighboringTiles && e5.neighboringTiles[o3] && (e5.neighboringTiles[o3].backfilled = true)));
          }
        }
        getTile(e4) {
          return this.getTileByID(e4.key);
        }
        getTileByID(e4) {
          return this._tiles[e4];
        }
        _retainLoadedChildren(e4, t3, i3, r3) {
          for (const n4 in this._tiles) {
            let o3 = this._tiles[n4];
            if (r3[n4] || !o3.hasData() || o3.tileID.overscaledZ <= t3 || o3.tileID.overscaledZ > i3)
              continue;
            let s6 = o3.tileID;
            for (; o3 && o3.tileID.overscaledZ > t3 + 1; ) {
              const e5 = o3.tileID.scaledTo(o3.tileID.overscaledZ - 1);
              o3 = this._tiles[e5.key], o3 && o3.hasData() && (s6 = e5);
            }
            let a3 = s6;
            for (; a3.overscaledZ > t3; )
              if (a3 = a3.scaledTo(a3.overscaledZ - 1), e4[a3.key]) {
                r3[s6.key] = s6;
                break;
              }
          }
        }
        findLoadedParent(e4, t3) {
          if (e4.key in this._loadedParentTiles) {
            const i3 = this._loadedParentTiles[e4.key];
            return i3 && i3.tileID.overscaledZ >= t3 ? i3 : null;
          }
          for (let i3 = e4.overscaledZ - 1; i3 >= t3; i3--) {
            const t4 = e4.scaledTo(i3), r3 = this._getLoadedTile(t4);
            if (r3)
              return r3;
          }
        }
        _getLoadedTile(e4) {
          const t3 = this._tiles[e4.key];
          return t3 && t3.hasData() ? t3 : this._cache.getByKey(this._source.reparseOverscaled ? e4.wrapped().key : e4.canonical.key);
        }
        updateCacheSize(e4, t3) {
          t3 = t3 || this._source.tileSize;
          const i3 = Math.ceil(e4.width / t3) + 1, r3 = Math.ceil(e4.height / t3) + 1, n4 = Math.floor(i3 * r3 * 5), o3 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, n4) : n4, s6 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o3) : o3;
          this._cache.setMaxSize(s6);
        }
        handleWrapJump(e4) {
          const t3 = Math.round((e4 - (void 0 === this._prevLng ? e4 : this._prevLng)) / 360);
          if (this._prevLng = e4, t3) {
            const e5 = {};
            for (const i3 in this._tiles) {
              const r3 = this._tiles[i3];
              r3.tileID = r3.tileID.unwrapTo(r3.tileID.wrap + t3), e5[r3.tileID.key] = r3;
            }
            this._tiles = e5;
            for (const e6 in this._timers)
              clearTimeout(this._timers[e6]), delete this._timers[e6];
            for (const e6 in this._tiles)
              this._setTileReloadTimer(+e6, this._tiles[e6]);
          }
        }
        update(e4, t3, i3, r3) {
          if (this.transform = e4, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
            return;
          if (this.usedForTerrain && !i3)
            return;
          let n4;
          if (this.updateCacheSize(e4, t3), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n4 = e4.getVisibleUnwrappedCoordinates(this._source.tileID).map((e5) => new qu(e5.canonical.z, e5.wrap, e5.canonical.z, e5.canonical.x, e5.canonical.y)) : (n4 = e4.coveringTiles({ tileSize: t3 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !i3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n4 = n4.filter((e5) => this._source.hasTile(e5)))) : n4 = [], n4.length > 0 && this.castsShadows && r3 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !Ox(this._source.type)) {
            const o4 = e4.coveringZoomLevel({ tileSize: t3 || this._source.tileSize, roundZoom: this._source.roundZoom && !i3 }), s7 = Math.min(o4, this._source.maxzoom), a3 = e4.extendTileCoverForShadows(n4, r3, s7);
            for (const e5 of a3)
              this._shadowCasterTiles[e5.key] = true, n4.push(e5);
          }
          const o3 = this._updateRetainedTiles(n4);
          if (Ox(this._source.type) && 0 !== n4.length) {
            const e5 = {}, t4 = {}, i4 = Object.keys(o3);
            for (const r5 of i4) {
              const i5 = o3[r5], n5 = this._tiles[r5];
              if (!n5 || n5.fadeEndTime && n5.fadeEndTime <= dt.now())
                continue;
              const s7 = this.findLoadedParent(i5, Math.max(i5.overscaledZ - Lx.maxOverzooming, this._source.minzoom));
              s7 && (this._addTile(s7.tileID), e5[s7.tileID.key] = s7.tileID), t4[r5] = i5;
            }
            const r4 = n4[n4.length - 1].overscaledZ;
            for (const e6 in this._tiles) {
              const i5 = this._tiles[e6];
              if (o3[e6] || !i5.hasData())
                continue;
              let n5 = i5.tileID;
              for (; n5.overscaledZ > r4; ) {
                n5 = n5.scaledTo(n5.overscaledZ - 1);
                const r5 = this._tiles[n5.key];
                if (r5 && r5.hasData() && t4[n5.key]) {
                  o3[e6] = i5.tileID;
                  break;
                }
              }
            }
            for (const t5 in e5)
              o3[t5] || (this._coveredTiles[t5] = true, o3[t5] = e5[t5]);
          }
          for (const e5 in o3)
            this._tiles[e5].clearFadeHold();
          const s6 = function(e5, t4) {
            const i4 = [];
            for (const r4 in e5)
              r4 in t4 || i4.push(r4);
            return i4;
          }(this._tiles, o3);
          for (const e5 of s6) {
            const t4 = this._tiles[e5];
            t4.hasSymbolBuckets && !t4.holdingForFade() ? t4.setHoldDuration(this.map._fadeDuration) : t4.hasSymbolBuckets && !t4.symbolFadeFinished() || this._removeTile(+e5);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const e4 in this._tiles)
            this._tiles[e4].holdingForFade() && this._removeTile(+e4);
        }
        _updateRetainedTiles(e4) {
          const t3 = {};
          if (0 === e4.length)
            return t3;
          const i3 = {}, r3 = e4.reduce((e5, t4) => Math.min(e5, t4.overscaledZ), 1 / 0), n4 = e4[0].overscaledZ, o3 = Math.max(n4 - Lx.maxOverzooming, this._source.minzoom), s6 = Math.max(n4 + Lx.maxUnderzooming, this._source.minzoom), a3 = {};
          for (const i4 of e4) {
            const e5 = this._addTile(i4);
            t3[i4.key] = i4, e5.hasData() || r3 < this._source.maxzoom && (a3[i4.key] = i4);
          }
          this._retainLoadedChildren(a3, r3, s6, t3);
          for (const r4 of e4) {
            let e5 = this._tiles[r4.key];
            if (e5.hasData())
              continue;
            if (r4.canonical.z >= this._source.maxzoom) {
              const e6 = r4.children(this._source.maxzoom)[0], i4 = this.getTile(e6);
              if (i4 && i4.hasData()) {
                t3[e6.key] = e6;
                continue;
              }
            } else {
              const e6 = r4.children(this._source.maxzoom);
              if (t3[e6[0].key] && t3[e6[1].key] && t3[e6[2].key] && t3[e6[3].key])
                continue;
            }
            let n5 = e5.wasRequested();
            for (let s7 = r4.overscaledZ - 1; s7 >= o3; --s7) {
              const o4 = r4.scaledTo(s7);
              if (i3[o4.key])
                break;
              if (i3[o4.key] = true, e5 = this.getTile(o4), !e5 && n5 && (e5 = this._addTile(o4)), e5 && (t3[o4.key] = o4, n5 = e5.wasRequested(), e5.hasData()))
                break;
            }
          }
          return t3;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e4 in this._tiles) {
            const t3 = [];
            let i3, r3 = this._tiles[e4].tileID;
            for (; r3.overscaledZ > 0; ) {
              if (r3.key in this._loadedParentTiles) {
                i3 = this._loadedParentTiles[r3.key];
                break;
              }
              t3.push(r3.key);
              const e5 = r3.scaledTo(r3.overscaledZ - 1);
              if (i3 = this._getLoadedTile(e5), i3)
                break;
              r3 = e5;
            }
            for (const e5 of t3)
              this._loadedParentTiles[e5] = i3;
          }
        }
        _addTile(e4) {
          let t3 = this._tiles[e4.key];
          if (t3)
            return true !== t3.isExtraShadowCaster || !!this._shadowCasterTiles[e4.key] || this._reloadTile(e4.key, "reloading"), t3;
          t3 = this._cache.getAndRemove(e4), t3 && (this._setTileReloadTimer(e4.key, t3), t3.tileID = e4, this._state.initializeTileState(t3, this.map ? this.map.painter : null), this._cacheTimers[e4.key] && (clearTimeout(this._cacheTimers[e4.key]), delete this._cacheTimers[e4.key], this._setTileReloadTimer(e4.key, t3)));
          const i3 = Boolean(t3);
          if (!i3) {
            const i4 = this.map ? this.map.painter : null;
            t3 = new Oy(e4, this._source.tileSize * e4.overscaleFactor(), this.transform.tileZoom, i4, this._isRaster), this._loadTile(t3, this._tileLoaded.bind(this, t3, e4.key, t3.state));
          }
          return t3 ? (t3.uses++, this._tiles[e4.key] = t3, i3 || this._source.fire(new It("dataloading", { tile: t3, coord: t3.tileID, dataType: "source" })), t3) : null;
        }
        _setTileReloadTimer(e4, t3) {
          e4 in this._timers && (clearTimeout(this._timers[e4]), delete this._timers[e4]);
          const i3 = t3.getExpiryTimeout();
          i3 && (this._timers[e4] = setTimeout(() => {
            this._reloadTile(e4, "expired"), delete this._timers[e4];
          }, i3));
        }
        _removeTile(e4) {
          const t3 = this._tiles[e4];
          t3 && (t3.uses--, delete this._tiles[e4], this._timers[e4] && (clearTimeout(this._timers[e4]), delete this._timers[e4]), t3.uses > 0 || (t3.hasData() && "reloading" !== t3.state ? this._cache.add(t3.tileID, t3, t3.getExpiryTimeout()) : (t3.aborted = true, this._abortTile(t3), this._unloadTile(t3))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const e4 in this._tiles)
            this._removeTile(+e4);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(e4, t3, i3) {
          const r3 = [], n4 = this.transform;
          if (!n4)
            return r3;
          const o3 = "globe" === n4.projection.name, s6 = Kd(n4.center.lng);
          for (const a3 in this._tiles) {
            const l3 = this._tiles[a3];
            if (i3 && l3.clearQueryDebugViz(), l3.holdingForFade())
              continue;
            let c3;
            if (o3) {
              const e5 = l3.tileID.canonical;
              if (0 === e5.z) {
                const t4 = [Math.abs(z(s6, ...Bx(e5, -1)) - s6), Math.abs(z(s6, ...Bx(e5, 1)) - s6)];
                c3 = [0, 2 * t4.indexOf(Math.min(...t4)) - 1];
              } else {
                const t4 = [Math.abs(z(s6, ...Bx(e5, -1)) - s6), Math.abs(z(s6, ...Bx(e5, 0)) - s6), Math.abs(z(s6, ...Bx(e5, 1)) - s6)];
                c3 = [t4.indexOf(Math.min(...t4)) - 1];
              }
            } else
              c3 = [0];
            for (const i4 of c3) {
              const o4 = e4.containsTile(l3, n4, t3, i4);
              o4 && r3.push(o4);
            }
          }
          return r3;
        }
        getShadowCasterCoordinates() {
          return this._getRenderableCoordinates(false, true);
        }
        getVisibleCoordinates(e4) {
          return this._getRenderableCoordinates(e4);
        }
        _getRenderableCoordinates(e4, t3) {
          const i3 = this.getRenderableIds(e4, t3).map((e5) => this._tiles[e5].tileID), r3 = "globe" === this.transform.projection.name;
          for (const e5 of i3)
            e5.projMatrix = this.transform.calculateProjMatrix(e5.toUnwrapped()), e5.expandedProjMatrix = r3 ? this.transform.calculateProjMatrix(e5.toUnwrapped(), false, true) : e5.projMatrix;
          return i3;
        }
        sortCoordinatesByDistance(e4) {
          const t3 = e4.slice(), i3 = this.transform._camera.position, r3 = this.transform._camera.forward(), n4 = {};
          for (const e5 of t3) {
            const t4 = 1 / (1 << e5.canonical.z);
            n4[e5.key] = ((e5.canonical.x + 0.5) * t4 + e5.wrap - i3[0]) * r3[0] + ((e5.canonical.y + 0.5) * t4 - i3[1]) * r3[1] - i3[2] * r3[2];
          }
          return t3.sort((e5, t4) => n4[e5.key] - n4[t4.key]), t3;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (Ox(this._source.type))
            for (const e4 in this._tiles) {
              const t3 = this._tiles[e4];
              if (void 0 !== t3.fadeEndTime && t3.fadeEndTime >= dt.now())
                return true;
            }
          return false;
        }
        setFeatureState(e4, t3, i3) {
          this._state.updateState(e4 = e4 || "_geojsonTileLayer", t3, i3);
        }
        removeFeatureState(e4, t3, i3) {
          this._state.removeFeatureState(e4 = e4 || "_geojsonTileLayer", t3, i3);
        }
        getFeatureState(e4, t3) {
          return this._state.getState(e4 = e4 || "_geojsonTileLayer", t3);
        }
        setDependencies(e4, t3, i3) {
          const r3 = this._tiles[e4];
          r3 && r3.setDependencies(t3, i3);
        }
        reloadTilesForDependencies(e4, t3) {
          for (const i3 in this._tiles)
            this._tiles[i3].hasDependency(e4, t3) && this._reloadTile(+i3, "reloading");
          this._cache.filter((i3) => !i3.hasDependency(e4, t3));
        }
        _preloadTiles(e4, t3) {
          if (!this._sourceLoaded) {
            const i4 = () => {
              this._sourceLoaded && (this._source.off("data", i4), this._preloadTiles(e4, t3));
            };
            return void this._source.on("data", i4);
          }
          const i3 = /* @__PURE__ */ new Map(), r3 = Array.isArray(e4) ? e4 : [e4], n4 = this.map.painter.terrain, o3 = this.usedForTerrain && n4 ? n4.getScaledDemTileSize() : this._source.tileSize;
          for (const e5 of r3) {
            const t4 = e5.coveringTiles({ tileSize: o3, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const e6 of t4)
              i3.set(e6.key, e6);
            this.usedForTerrain && e5.updateElevation(false);
          }
          R2(Array.from(i3.values()), (e5, t4) => {
            const i4 = new Oy(e5, this._source.tileSize * e5.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(i4, (e6) => {
              "raster-dem" === this._source.type && i4.dem && this._backfillDEM(i4), t4(e6, i4);
            });
          }, t3);
        }
      }
      function kx(e4, t3) {
        const i3 = Math.abs(2 * e4.wrap) - +(e4.wrap < 0), r3 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0);
        return e4.overscaledZ - t3.overscaledZ || r3 - i3 || t3.canonical.y - e4.canonical.y || t3.canonical.x - e4.canonical.x;
      }
      function Ox(e4) {
        return "raster" === e4 || "image" === e4 || "video" === e4 || "custom" === e4;
      }
      function Bx(e4, t3) {
        const i3 = 1 << e4.z;
        return [e4.x / i3 + t3, (e4.x + 1) / i3 + t3];
      }
      Lx.maxOverzooming = 10, Lx.maxUnderzooming = 3;
      const Fx = Ia([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Nx = Ia([{ name: "a_color_3f", components: 3, type: "Float32" }]), Ux = Ia([{ name: "a_color_4f", components: 4, type: "Float32" }]), Vx = Ia([{ name: "a_uv_2f", components: 2, type: "Float32" }]), jx = Ia([{ name: "a_normal_3f", components: 3, type: "Float32" }]), Gx = Ia([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), qx = Ia([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]);
      class Zx {
        constructor(e4 = 0, t3 = 0, i3 = 0, r3 = 0) {
          if (isNaN(e4) || e4 < 0 || isNaN(t3) || t3 < 0 || isNaN(i3) || i3 < 0 || isNaN(r3) || r3 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e4, this.bottom = t3, this.left = i3, this.right = r3;
        }
        interpolate(e4, t3, i3) {
          return null != t3.top && null != e4.top && (this.top = Kr(e4.top, t3.top, i3)), null != t3.bottom && null != e4.bottom && (this.bottom = Kr(e4.bottom, t3.bottom, i3)), null != t3.left && null != e4.left && (this.left = Kr(e4.left, t3.left, i3)), null != t3.right && null != e4.right && (this.right = Kr(e4.right, t3.right, i3)), this;
        }
        getCenter(e4, t3) {
          const i3 = z((this.left + e4 - this.right) / 2, 0, e4), r3 = z((this.top + t3 - this.bottom) / 2, 0, t3);
          return new y2(i3, r3);
        }
        equals(e4) {
          return this.top === e4.top && this.bottom === e4.bottom && this.left === e4.left && this.right === e4.right;
        }
        clone() {
          return new Zx(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function $x(e4, t3) {
        const i3 = ne(e4, 3);
        Au.fromQuat(e4, t3), oe(e4, 3, i3);
      }
      function Wx(e4, t3) {
        const i3 = Iu.identity([]);
        return Iu.rotateZ(i3, i3, -t3), Iu.rotateX(i3, i3, -e4), i3;
      }
      function Hx(e4, t3) {
        const i3 = [e4[0], e4[1], 0], r3 = [t3[0], t3[1], 0];
        if (Du.length(i3) >= 1e-15) {
          const e5 = Du.normalize([], i3);
          Du.scale(r3, e5, Du.dot(r3, e5)), t3[0] = r3[0], t3[1] = r3[1];
        }
        const n4 = Du.cross([], t3, e4);
        if (Du.len(n4) < 1e-15)
          return null;
        const o3 = Math.atan2(-n4[1], n4[0]);
        return Wx(Math.atan2(Math.sqrt(e4[0] * e4[0] + e4[1] * e4[1]), -e4[2]), o3);
      }
      class Xx {
        constructor(e4, t3) {
          this.position = e4, this.orientation = t3;
        }
        get position() {
          return this._position;
        }
        set position(e4) {
          if (e4) {
            const t3 = e4 instanceof lp ? e4 : new lp(e4[0], e4[1], e4[2]);
            this._renderWorldCopies && (t3.x = D(t3.x, 0, 1)), this._position = t3;
          } else
            this._position = null;
        }
        lookAtPoint(e4, t3) {
          if (this.orientation = null, !this.position)
            return;
          const i3 = this.position, r3 = this._elevation ? this._elevation.getAtPointOrZero(lp.fromLngLat(e4)) : 0, n4 = lp.fromLngLat(e4, r3), o3 = [n4.x - i3.x, n4.y - i3.y, n4.z - i3.z];
          t3 || (t3 = [0, 0, 1]), t3[2] = Math.abs(t3[2]), this.orientation = Hx(o3, t3);
        }
        setPitchBearing(e4, t3) {
          this.orientation = Wx(w2(e4), w2(-t3));
        }
      }
      class Yx {
        constructor(e4, t3) {
          this._transform = Au.identity([]), this.orientation = t3, this.position = e4;
        }
        get mercatorPosition() {
          const e4 = this.position;
          return new lp(e4[0], e4[1], e4[2]);
        }
        get position() {
          const e4 = ne(this._transform, 3);
          return [e4[0], e4[1], e4[2]];
        }
        set position(e4) {
          var t3;
          e4 && oe(this._transform, 3, [(t3 = e4)[0], t3[1], t3[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(e4) {
          this._orientation = e4 || Iu.identity([]), e4 && $x(this._transform, this._orientation);
        }
        getPitchBearing() {
          const e4 = this.forward(), t3 = this.right();
          return { bearing: Math.atan2(-t3[1], t3[0]), pitch: Math.atan2(Math.sqrt(e4[0] * e4[0] + e4[1] * e4[1]), -e4[2]) };
        }
        setPitchBearing(e4, t3) {
          this._orientation = Wx(e4, t3), $x(this._transform, this._orientation);
        }
        forward() {
          const e4 = ne(this._transform, 2);
          return [-e4[0], -e4[1], -e4[2]];
        }
        up() {
          const e4 = ne(this._transform, 1);
          return [-e4[0], -e4[1], -e4[2]];
        }
        right() {
          const e4 = ne(this._transform, 0);
          return [e4[0], e4[1], e4[2]];
        }
        getCameraToWorld(e4, t3) {
          const i3 = new Float64Array(16);
          return Au.invert(i3, this.getWorldToCamera(e4, t3)), i3;
        }
        getCameraToWorldMercator() {
          return this._transform;
        }
        getWorldToCameraPosition(e4, t3, i3) {
          const r3 = this.position;
          Du.scale(r3, r3, -e4);
          const n4 = new Float64Array(16);
          return Au.fromScaling(n4, [i3, i3, i3]), Au.translate(n4, n4, r3), n4[10] *= t3, n4;
        }
        getWorldToCamera(e4, t3) {
          const i3 = new Float64Array(16), r3 = new Float64Array(4), n4 = this.position;
          return Iu.conjugate(r3, this._orientation), Du.scale(n4, n4, -e4), Au.fromQuat(i3, r3), Au.translate(i3, i3, n4), i3[1] *= -1, i3[5] *= -1, i3[9] *= -1, i3[13] *= -1, i3[8] *= t3, i3[9] *= t3, i3[10] *= t3, i3[11] *= t3, i3;
        }
        getCameraToClipPerspective(e4, t3, i3, r3) {
          const n4 = new Float64Array(16);
          return Au.perspective(n4, e4, t3, i3, r3), n4;
        }
        getCameraToClipOrthographic(e4, t3, i3, r3, n4, o3) {
          const s6 = new Float64Array(16);
          return Au.ortho(s6, e4, t3, i3, r3, n4, o3), s6;
        }
        getDistanceToElevation(e4, t3 = false) {
          const i3 = 0 === e4 ? 0 : Qd(e4, t3 ? tp(this.position[1]) : this.position[1]), r3 = this.forward();
          return (i3 - this.position[2]) / r3[2];
        }
        clone() {
          return new Yx([...this.position], [...this.orientation]);
        }
      }
      function Kx(e4, t3) {
        const i3 = Qx(e4.projection, e4.zoom, e4.width, e4.height), r3 = function(e5, t4, i4, r4, n5) {
          const o3 = new Wd(i4.lng - 180 * ev, i4.lat), s6 = new Wd(i4.lng + 180 * ev, i4.lat), a3 = e5.project(o3.lng, o3.lat), l3 = e5.project(s6.lng, s6.lat), c3 = -Math.atan2(l3.y - a3.y, l3.x - a3.x), h3 = lp.fromLngLat(i4);
          h3.y = z(h3.y, -1 + ev, 1 - ev);
          const u3 = h3.toLngLat(), d3 = e5.project(u3.lng, u3.lat), p3 = lp.fromLngLat(u3);
          p3.x += ev;
          const f3 = p3.toLngLat(), m3 = e5.project(f3.lng, f3.lat), _3 = iv(m3.x - d3.x, m3.y - d3.y, c3), g3 = lp.fromLngLat(u3);
          g3.y += ev;
          const y3 = g3.toLngLat(), x3 = e5.project(y3.lng, y3.lat), v3 = iv(x3.x - d3.x, x3.y - d3.y, c3), b3 = Math.abs(_3.x) / Math.abs(v3.y), w3 = Au.identity([]);
          Au.rotateZ(w3, w3, -c3 * (1 - (n5 ? 0 : r4)));
          const T3 = Au.identity([]);
          return Au.scale(T3, T3, [1, 1 - (1 - b3) * r4, 1]), T3[4] = -v3.x / v3.y * r4, Au.rotateZ(T3, T3, c3), Au.multiply(T3, w3, T3), T3;
        }(e4.projection, 0, e4.center, i3, t3), n4 = Jx(e4);
        return Au.scale(r3, r3, [n4, n4, 1]), r3;
      }
      function Jx(e4) {
        const t3 = e4.projection, i3 = Qx(e4.projection, e4.zoom, e4.width, e4.height), r3 = tv(t3, e4.center), n4 = tv(t3, Wd.convert(t3.center));
        return Math.pow(2, r3 * i3 + (1 - i3) * n4);
      }
      function Qx(e4, t3, i3, r3, n4 = 1 / 0) {
        const o3 = e4.range;
        if (!o3)
          return 0;
        const s6 = Math.min(n4, Math.max(i3, r3)), a3 = Math.log(s6 / 1024) / Math.LN2;
        return P2(o3[0] + a3, o3[1] + a3, t3);
      }
      const ev = 1 / 4e4;
      function tv(e4, t3) {
        const i3 = z(t3.lat, -rp, rp), r3 = new Wd(t3.lng - 180 * ev, i3), n4 = new Wd(t3.lng + 180 * ev, i3), o3 = e4.project(r3.lng, i3), s6 = e4.project(n4.lng, i3), a3 = lp.fromLngLat(r3), l3 = lp.fromLngLat(n4), c3 = s6.x - o3.x, h3 = s6.y - o3.y, u3 = l3.x - a3.x, d3 = l3.y - a3.y, p3 = Math.sqrt((u3 * u3 + d3 * d3) / (c3 * c3 + h3 * h3));
        return Math.log(p3) / Math.LN2;
      }
      function iv(e4, t3, i3) {
        const r3 = Math.cos(i3), n4 = Math.sin(i3);
        return { x: e4 * r3 - t3 * n4, y: e4 * n4 + t3 * r3 };
      }
      function rv(e4, t3, i3) {
        return t3 * (cr / (e4.tileSize * Math.pow(2, i3 - e4.tileID.overscaledZ)));
      }
      const nv = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, ov = Math.tan(85 * Math.PI / 180);
      function sv(e4, t3, i3, r3, n4, o3, s6) {
        const a3 = Au.create();
        if (i3)
          if ("globe" === o3.name) {
            const e5 = function(e6, t4) {
              const { x: i4, y: r4 } = e6.point, n5 = zd(i4, r4, e6.worldSize / e6._pixelsPerMercatorPixel, 0, 0);
              return Au.multiply(n5, n5, Sd(fd(t4)));
            }(n4, t3);
            Au.multiply(a3, a3, e5);
          } else {
            const e5 = bu.invert([], s6);
            a3[0] = e5[0], a3[1] = e5[1], a3[4] = e5[2], a3[5] = e5[3], r3 || Au.rotateZ(a3, a3, n4.angle);
          }
        else
          Au.multiply(a3, n4.labelPlaneMatrix, e4);
        return a3;
      }
      function av(e4, t3, i3, r3, n4, o3, s6) {
        const a3 = sv(e4, t3, i3, r3, n4, o3, s6);
        return "globe" === o3.name && i3 || (a3[2] = a3[6] = a3[10] = a3[14] = 0), a3;
      }
      function lv(e4, t3, i3, r3, n4, o3, s6) {
        if (i3) {
          if ("globe" === o3.name) {
            const a3 = sv(e4, t3, i3, r3, n4, o3, s6);
            return Au.invert(a3, a3), Au.multiply(a3, e4, a3), a3;
          }
          {
            const t4 = Au.clone(e4), i4 = Au.identity([]);
            return i4[0] = s6[0], i4[1] = s6[1], i4[4] = s6[2], i4[5] = s6[3], Au.multiply(t4, t4, i4), r3 || Au.rotateZ(t4, t4, -n4.angle), t4;
          }
        }
        return n4.glCoordMatrix;
      }
      function cv(e4, t3, i3, r3) {
        const n4 = [e4, t3, i3, 1];
        i3 ? yu.transformMat4(n4, n4, r3) : vv(n4, n4, r3);
        const o3 = n4[3];
        return n4[0] /= o3, n4[1] /= o3, n4[2] /= o3, n4;
      }
      function hv(e4, t3) {
        return Math.min(0.5 + e4 / t3 * 0.5, 1.5);
      }
      function uv(e4, t3) {
        const i3 = e4[0] / e4[3], r3 = e4[1] / e4[3];
        return i3 >= -t3[0] && i3 <= t3[0] && r3 >= -t3[1] && r3 <= t3[1];
      }
      function dv(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3) {
        const h3 = i3.transform, u3 = r3 ? e4.textSizeData : e4.iconSizeData, d3 = m_(u3, i3.transform.zoom), p3 = "globe" === h3.projection.name, f3 = [256 / i3.width * 2 + 1, 256 / i3.height * 2 + 1], m3 = r3 ? e4.text.dynamicLayoutVertexArray : e4.icon.dynamicLayoutVertexArray;
        m3.clear();
        let _3 = null;
        p3 && (_3 = r3 ? e4.text.globeExtVertexArray : e4.icon.globeExtVertexArray);
        const g3 = e4.lineVertexArray, x3 = r3 ? e4.text.placedSymbolArray : e4.icon.placedSymbolArray, v3 = i3.transform.width / i3.transform.height;
        let b3, w3 = false;
        for (let r4 = 0; r4 < x3.length; r4++) {
          const p4 = x3.get(r4), { numGlyphs: T3, writingMode: E3 } = p4;
          if (E3 !== A_.vertical || w3 || b3 === A_.horizontal || (w3 = true), b3 = E3, (p4.hidden || E3 === A_.vertical) && !w3) {
            xv(T3, m3);
            continue;
          }
          w3 = false;
          const M3 = new y2(p4.tileAnchorX, p4.tileAnchorY);
          let { x: A3, y: S3, z: I3 } = h3.projection.projectTilePoint(M3.x, M3.y, c3.canonical);
          if (l3) {
            const [e5, t4, i4] = l3(M3);
            A3 += e5, S3 += t4, I3 += i4;
          }
          const C3 = [A3, S3, I3, 1];
          if (yu.transformMat4(C3, C3, t3), !uv(C3, f3)) {
            xv(T3, m3);
            continue;
          }
          const z2 = C3[3], P3 = hv(i3.transform.getCameraToCenterDistance(h3.projection), z2), D2 = f_(u3, d3, p4), R3 = s6 ? D2 / P3 : D2 * P3, L3 = cv(A3, S3, I3, n4);
          if (L3[3] <= 0) {
            xv(T3, m3);
            continue;
          }
          let k3 = {};
          const O2 = s6 ? null : l3, B2 = mv(p4, R3, false, a3, t3, n4, o3, e4.glyphOffsetArray, g3, m3, _3, L3, M3, k3, v3, O2, h3.projection, c3, s6);
          w3 = B2.useVertical, O2 && B2.needsFlipping && (k3 = {}), (B2.notEnoughRoom || w3 || B2.needsFlipping && mv(p4, R3, true, a3, t3, n4, o3, e4.glyphOffsetArray, g3, m3, _3, L3, M3, k3, v3, O2, h3.projection, c3, s6).notEnoughRoom) && xv(T3, m3);
        }
        r3 ? (e4.text.dynamicLayoutVertexBuffer.updateData(m3), _3 && e4.text.globeExtVertexBuffer && e4.text.globeExtVertexBuffer.updateData(_3)) : (e4.icon.dynamicLayoutVertexBuffer.updateData(m3), _3 && e4.icon.globeExtVertexBuffer && e4.icon.globeExtVertexBuffer.updateData(_3));
      }
      function pv(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3) {
        const { lineStartIndex: _3, glyphStartIndex: g3, segment: y3 } = a3, x3 = g3 + a3.numGlyphs, v3 = _3 + a3.lineLength, b3 = t3.getoffsetX(g3), w3 = t3.getoffsetX(x3 - 1), T3 = yv(e4 * b3, i3, r3, n4, o3, s6, y3, _3, v3, l3, c3, h3, u3, d3, true, p3, f3, m3);
        if (!T3)
          return null;
        const E3 = yv(e4 * w3, i3, r3, n4, o3, s6, y3, _3, v3, l3, c3, h3, u3, d3, true, p3, f3, m3);
        return E3 ? { first: T3, last: E3 } : null;
      }
      function fv(e4, t3, i3, r3) {
        return e4 === A_.horizontal && Math.abs(r3) > Math.abs(i3) ? { useVertical: true } : e4 === A_.vertical ? r3 > 0 ? { needsFlipping: true } : null : t3 !== nv.unknown && function(e5, t4) {
          return 0 === e5 || Math.abs(t4 / e5) > ov;
        }(i3, r3) ? t3 === nv.flipRequired ? { needsFlipping: true } : null : i3 < 0 ? { needsFlipping: true } : null;
      }
      function mv(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, x3) {
        const v3 = t3 / 24, b3 = e4.lineOffsetX * v3, w3 = e4.lineOffsetY * v3, { lineStartIndex: T3, glyphStartIndex: E3, numGlyphs: M3, segment: A3, writingMode: S3, flipState: I3 } = e4, C3 = T3 + e4.lineLength, z2 = (e5) => {
          if (h3) {
            const [t5, i5, r5] = e5.up, n5 = c3.length;
            uy(h3, n5 + 0, t5, i5, r5), uy(h3, n5 + 1, t5, i5, r5), uy(h3, n5 + 2, t5, i5, r5), uy(h3, n5 + 3, t5, i5, r5);
          }
          const [t4, i4, r4] = e5.point;
          dy(c3, t4, i4, r4, e5.angle);
        };
        if (M3 > 1) {
          const t4 = pv(v3, a3, b3, w3, i3, u3, d3, e4, l3, o3, p3, m3, false, _3, g3, x3);
          if (!t4)
            return { notEnoughRoom: true };
          if (r3 && !i3) {
            let [i4, r4, n5] = t4.first.point, [o4, a4, l4] = t4.last.point;
            [i4, r4] = cv(i4, r4, n5, s6), [o4, a4] = cv(o4, a4, l4, s6);
            const c4 = fv(S3, I3, (o4 - i4) * f3, a4 - r4);
            if (e4.flipState = c4 && c4.needsFlipping ? nv.flipRequired : nv.flipNotRequired, c4)
              return c4;
          }
          z2(t4.first);
          for (let e5 = E3 + 1; e5 < E3 + M3 - 1; e5++) {
            const t5 = yv(v3 * a3.getoffsetX(e5), b3, w3, i3, u3, d3, A3, T3, C3, l3, o3, p3, m3, false, false, _3, g3, x3);
            if (!t5)
              return c3.length -= 4 * (e5 - E3), { notEnoughRoom: true };
            z2(t5);
          }
          z2(t4.last);
        } else {
          if (r3 && !i3) {
            const t5 = cv(d3.x, d3.y, 0, n4), i4 = T3 + A3 + 1, r4 = new y2(l3.getx(i4), l3.gety(i4)), o4 = cv(r4.x, r4.y, 0, n4), s7 = o4[3] > 0 ? o4 : gv(d3, r4, t5, 1, n4, void 0, _3, g3.canonical), a4 = fv(S3, I3, (s7[0] - t5[0]) * f3, s7[1] - t5[1]);
            if (e4.flipState = a4 && a4.needsFlipping ? nv.flipRequired : nv.flipNotRequired, a4)
              return a4;
          }
          const t4 = yv(v3 * a3.getoffsetX(E3), b3, w3, i3, u3, d3, A3, T3, C3, l3, o3, p3, m3, false, false, _3, g3, x3);
          if (!t4)
            return { notEnoughRoom: true };
          z2(t4);
        }
        return {};
      }
      function _v(e4, t3, i3, r3, n4) {
        const { x: o3, y: s6, z: a3 } = r3.projectTilePoint(e4.x, e4.y, t3);
        if (!n4)
          return cv(o3, s6, a3, i3);
        const [l3, c3, h3] = n4(e4);
        return cv(o3 + l3, s6 + c3, a3 + h3, i3);
      }
      function gv(e4, t3, i3, r3, n4, o3, s6, a3) {
        const l3 = _v(e4.sub(t3)._unit()._add(e4), a3, n4, s6, o3);
        return Du.sub(l3, i3, l3), Du.normalize(l3, l3), Du.scaleAndAdd(l3, i3, l3, r3);
      }
      function yv(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3) {
        const x3 = r3 ? e4 - t3 : e4 + t3;
        let v3 = x3 > 0 ? 1 : -1, b3 = 0;
        r3 && (v3 *= -1, b3 = Math.PI), v3 < 0 && (b3 += Math.PI);
        let w3 = a3 + s6 + (v3 > 0 ? 0 : 1) | 0, T3 = n4, E3 = n4, M3 = 0, A3 = 0;
        const S3 = Math.abs(x3), I3 = [], C3 = [];
        let z2 = o3, P3 = z2;
        const D2 = () => gv(P3, z2, E3, S3 - M3 + 1, h3, d3, m3, _3.canonical);
        for (; M3 + A3 <= S3; ) {
          if (w3 += v3, w3 < a3 || w3 >= l3)
            return null;
          if (E3 = T3, P3 = z2, I3.push(E3), p3 && C3.push(P3), z2 = new y2(c3.getx(w3), c3.gety(w3)), T3 = u3[w3], !T3) {
            const e5 = _v(z2, _3.canonical, h3, m3, d3);
            T3 = e5[3] > 0 ? u3[w3] = e5 : D2();
          }
          M3 += A3, A3 = Du.distance(E3, T3);
        }
        f3 && d3 && (u3[w3] && (T3 = D2(), A3 = Du.distance(E3, T3)), u3[w3] = T3);
        const R3 = (S3 - M3) / A3, L3 = z2.sub(P3)._mult(R3)._add(P3), k3 = Du.sub([], T3, E3), O2 = Du.scaleAndAdd([], E3, k3, R3);
        let B2 = [0, 0, 1], F2 = k3[0], N3 = k3[1];
        if (g3 && (B2 = m3.upVector(_3.canonical, L3.x, L3.y), 0 !== B2[0] || 0 !== B2[1] || 1 !== B2[2])) {
          const e5 = [B2[2], 0, -B2[0]], t4 = Du.cross([], B2, e5);
          Du.normalize(e5, e5), Du.normalize(t4, t4), F2 = Du.dot(k3, e5), N3 = Du.dot(k3, t4);
        }
        if (i3) {
          const e5 = Du.cross([], B2, k3);
          Du.normalize(e5, e5), Du.scaleAndAdd(O2, O2, e5, i3 * v3);
        }
        const U2 = b3 + Math.atan2(N3, F2);
        return I3.push(O2), p3 && C3.push(L3), { point: O2, angle: U2, path: I3, tilePath: C3, up: B2 };
      }
      function xv(e4, t3) {
        const i3 = t3.length, r3 = i3 + 4 * e4;
        t3.resize(r3), t3.float32.fill(-1 / 0, 4 * i3, 4 * r3);
      }
      function vv(e4, t3, i3) {
        const r3 = t3[0], n4 = t3[1];
        return e4[0] = i3[0] * r3 + i3[4] * n4 + i3[12], e4[1] = i3[1] * r3 + i3[5] * n4 + i3[13], e4[3] = i3[3] * r3 + i3[7] * n4 + i3[15], e4;
      }
      const bv = (e4, t3, i3) => (1 - i3) * e4 + i3 * t3, wv = (e4) => e4 * e4 * e4 * e4 * e4;
      class Tv {
        constructor(e4, t3, i3, r3, n4, o3, s6) {
          this.tileSize = 512, this._renderWorldCopies = void 0 === n4 || n4, this._minZoom = e4 || 0, this._maxZoom = t3 || 22, this._minPitch = null == i3 ? 0 : i3, this._maxPitch = null == r3 ? 60 : r3, this.setProjection(o3), this.setMaxBounds(s6), this.width = 0, this.height = 0, this._center = new Wd(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Zx(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Yx(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false;
        }
        clone() {
          const e4 = new Tv(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return e4._elevation = this._elevation, e4._centerAltitude = this._centerAltitude, e4._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e4.tileSize = this.tileSize, e4.mercatorFromTransition = this.mercatorFromTransition, e4.width = this.width, e4.height = this.height, e4.cameraElevationReference = this.cameraElevationReference, e4._center = this._center, e4._setZoom(this.zoom), e4._seaLevelZoom = this._seaLevelZoom, e4.angle = this.angle, e4._fov = this._fov, e4._pitch = this._pitch, e4._nearZ = this._nearZ, e4._farZ = this._farZ, e4._averageElevation = this._averageElevation, e4._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e4._unmodified = this._unmodified, e4._edgeInsets = this._edgeInsets.clone(), e4._camera = this._camera.clone(), e4._calcMatrices(), e4.freezeTileCoverage = this.freezeTileCoverage, e4.frustumCorners = this.frustumCorners, e4;
        }
        get isOrthographic() {
          return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e4) {
          this._elevation !== e4 && (this._elevation = e4, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        get depthOcclusionForSymbolsAndCircles() {
          return "globe" !== this.projection.name && !this.isOrthographic;
        }
        updateElevation(e4, t3 = false) {
          const i3 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (null == this._seaLevelZoom || i3) && this._updateCameraOnTerrain(), (e4 || i3) && this._constrainCamera(t3), this._calcMatrices();
        }
        getProjection() {
          return O(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(e4) {
          this.projectionOptions = e4 || { name: "mercator" };
          const t3 = this.projection ? this.getProjection() : void 0;
          this.projection = ty(this.projectionOptions);
          const i3 = !x2(t3, this.getProjection());
          return i3 && this._calcMatrices(), this.mercatorFromTransition = false, i3;
        }
        setOrthographicProjectionAtLowPitch(e4) {
          return this._orthographicProjectionAtLowPitch !== e4 && (this._orthographicProjectionAtLowPitch = e4, this._calcMatrices(), true);
        }
        setMercatorFromTransition() {
          const e4 = this.projection.name;
          this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = ty({ name: "mercator" });
          const t3 = e4 !== this.projection.name;
          return t3 && this._calcMatrices(), t3;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e4) {
          this._minZoom !== e4 && (this._minZoom = e4, this.zoom = Math.max(this.zoom, e4));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e4) {
          this._maxZoom !== e4 && (this._maxZoom = e4, this.zoom = Math.min(this.zoom, e4));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e4) {
          this._minPitch !== e4 && (this._minPitch = e4, this.pitch = Math.max(this.pitch, e4));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e4) {
          this._maxPitch !== e4 && (this._maxPitch = e4, this.pitch = Math.min(this.pitch, e4));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
        }
        set renderWorldCopies(e4) {
          void 0 === e4 ? e4 = true : null === e4 && (e4 = false), this._renderWorldCopies = e4;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const e4 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e4));
        }
        get cameraWorldSize() {
          const e4 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e4));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return Qd(1, this.center.lat) * this.cameraWorldSizeForFog;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new y2(this.width, this.height);
        }
        get bearing() {
          return D(this.rotation, -180, 180);
        }
        set bearing(e4) {
          this.rotation = e4;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(e4) {
          const t3 = -e4 * Math.PI / 180;
          this.angle !== t3 && (this._unmodified = false, this.angle = t3, this._calcMatrices(), this.rotationMatrix = bu.create(), bu.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(e4) {
          const t3 = z(e4, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== t3 && (this._unmodified = false, this._pitch = t3, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const e4 = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / e4);
        }
        set fov(e4) {
          e4 = Math.max(0.01, Math.min(60, e4)), this._fov !== e4 && (this._unmodified = false, this._fov = w2(e4), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(e4) {
          this._averageElevation = e4, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e4) {
          const t3 = Math.min(Math.max(e4, this.minZoom), this.maxZoom);
          this._zoom !== t3 && (this._unmodified = false, this._setZoom(t3), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(e4) {
          this._zoom = e4, this.scale = this.zoomScale(e4), this.tileZoom = Math.floor(e4), this.zoomFraction = e4 - this.tileZoom;
        }
        _updateCameraOnTerrain() {
          const e4 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t3 = this.elevation && e4 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
          if (!this._elevation || e4 === Number.NEGATIVE_INFINITY && (!t3 || !this._centerAltitude))
            return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const i3 = this._elevation;
          t3 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i3.exaggeration() && this._centerAltitudeValidForExaggeration !== i3.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i3.exaggeration(), this._centerAltitudeValidForExaggeration = i3.exaggeration()) : (this._centerAltitude = e4 || 0, this._centerAltitudeValidForExaggeration = i3.exaggeration()), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const e4 = this._elevation, t3 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], i3 = this.horizonLineFromTop();
          let r3 = 0, n4 = 0;
          for (let o3 = 0; o3 < t3.length; o3++) {
            const s6 = new y2(t3[o3][0] * this.width, i3 + t3[o3][1] * (this.height - i3)), a3 = e4.pointCoordinate(s6);
            if (!a3)
              continue;
            const l3 = 1 / Math.hypot(a3[0] - this._camera.position[0], a3[1] - this._camera.position[1]);
            r3 += a3[3] * l3, n4 += l3;
          }
          return 0 === n4 ? NaN : r3 / n4;
        }
        get center() {
          return this._center;
        }
        set center(e4) {
          e4.lat === this._center.lat && e4.lng === this._center.lng || (this._unmodified = false, this._center = e4, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (null == this._seaLevelZoom || !this._elevation)
            return;
          const e4 = this._seaLevelZoom, t3 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i3 = this.pixelsPerMeter / this.worldSize * t3, r3 = this._mercatorZfromZoom(e4), n4 = this._mercatorZfromZoom(this._maxZoom), o3 = Math.max(r3 - i3, n4);
          this._setZoom(this._zoomFromMercatorZ(o3));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e4) {
          this._edgeInsets.equals(e4) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e4, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(e4) {
          const t3 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, e4.toAltitude()));
          let i3;
          i3 = e4.z < this._camera.position[2] ? [t3.x, t3.y, t3.z] : [e4.x, e4.y, e4.z];
          const r3 = Du.length(Du.sub([], this._camera.position, i3));
          return z(this._zoomFromMercatorZ(r3), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(e4) {
          if (!this.height)
            return;
          if (!e4.position && !e4.orientation)
            return;
          this._updateCameraState();
          let t3 = false;
          if (e4.orientation && !Iu.exactEquals(e4.orientation, this._camera.orientation) && (t3 = this._setCameraOrientation(e4.orientation)), e4.position) {
            const i3 = [e4.position.x, e4.position.y, e4.position.z];
            Du.exactEquals(i3, this._camera.position) || (this._setCameraPosition(i3), t3 = true);
          }
          t3 && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const e4 = this._camera.position, t3 = new Xx();
          return t3.position = new lp(e4[0], e4[1], e4[2]), t3.orientation = this._camera.orientation, t3._elevation = this.elevation, t3._renderWorldCopies = this.renderWorldCopies, t3;
        }
        _setCameraOrientation(e4) {
          if (!Iu.length(e4))
            return false;
          Iu.normalize(e4, e4);
          const t3 = Du.transformQuat([], [0, 0, -1], e4), i3 = Du.transformQuat([], [0, -1, 0], e4);
          if (i3[2] < 0)
            return false;
          const r3 = Hx(t3, i3);
          return !!r3 && (this._camera.orientation = r3, true);
        }
        _setCameraPosition(e4) {
          const t3 = this.zoomScale(this.minZoom) * this.tileSize, i3 = this.zoomScale(this.maxZoom) * this.tileSize, r3 = this.cameraToCenterDistance;
          e4[2] = z(e4[2], r3 / i3, r3 / t3), this._camera.position = e4;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(e4) {
          return this._edgeInsets.equals(e4);
        }
        interpolatePadding(e4, t3, i3) {
          this._unmodified = false, this._edgeInsets.interpolate(e4, t3, i3), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e4) {
          const t3 = (e4.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e4.tileSize));
          return Math.max(0, t3);
        }
        getVisibleUnwrappedCoordinates(e4) {
          const t3 = [new Gu(0, e4)];
          if (this.renderWorldCopies) {
            const i3 = this.pointCoordinate(new y2(0, 0)), r3 = this.pointCoordinate(new y2(this.width, 0)), n4 = this.pointCoordinate(new y2(this.width, this.height)), o3 = this.pointCoordinate(new y2(0, this.height)), s6 = Math.floor(Math.min(i3.x, r3.x, n4.x, o3.x)), a3 = Math.floor(Math.max(i3.x, r3.x, n4.x, o3.x)), l3 = 1;
            for (let i4 = s6 - l3; i4 <= a3 + l3; i4++)
              0 !== i4 && t3.push(new Gu(i4, e4));
          }
          return t3;
        }
        isLODDisabled(e4) {
          return (!e4 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
        }
        extendTileCoverForShadows(e4, t3, i3) {
          let r3 = [];
          if (0 === t3[0] && 0 === t3[1])
            return r3;
          for (const i4 of e4) {
            const e5 = i4.canonical, n5 = i4.overscaledZ, o3 = i4.wrap, s6 = 1 << e5.z, a3 = e5.x + 1 < s6, l3 = e5.x > 0, c3 = e5.y + 1 < s6, h3 = e5.y > 0, u3 = i4.wrap - (l3 ? 0 : 1), d3 = i4.wrap + (a3 ? 0 : 1), p3 = l3 ? e5.x - 1 : s6 - 1, f3 = a3 ? e5.x + 1 : 0;
            t3[0] < 0 ? (r3.push(new qu(n5, d3, e5.z, f3, e5.y)), t3[1] < 0 && c3 && (r3.push(new qu(n5, o3, e5.z, e5.x, e5.y + 1)), r3.push(new qu(n5, d3, e5.z, f3, e5.y + 1))), t3[1] > 0 && h3 && (r3.push(new qu(n5, o3, e5.z, e5.x, e5.y - 1)), r3.push(new qu(n5, d3, e5.z, f3, e5.y - 1)))) : t3[0] > 0 ? (r3.push(new qu(n5, u3, e5.z, p3, e5.y)), t3[1] < 0 && c3 && (r3.push(new qu(n5, o3, e5.z, e5.x, e5.y + 1)), r3.push(new qu(n5, u3, e5.z, p3, e5.y + 1))), t3[1] > 0 && h3 && (r3.push(new qu(n5, o3, e5.z, e5.x, e5.y - 1)), r3.push(new qu(n5, u3, e5.z, p3, e5.y - 1)))) : t3[1] < 0 && c3 ? r3.push(new qu(n5, o3, e5.z, e5.x, e5.y + 1)) : h3 && r3.push(new qu(n5, o3, e5.z, e5.x, e5.y - 1));
          }
          if (r3.length > 1) {
            r3.sort((e6, t5) => e6.overscaledZ - t5.overscaledZ || e6.wrap - t5.wrap || e6.canonical.z - t5.canonical.z || e6.canonical.x - t5.canonical.x || e6.canonical.y - t5.canonical.y);
            let e5 = 0, t4 = 0;
            for (; t4 < r3.length; )
              r3[t4].equals(r3[e5]) ? ++t4 : r3[++e5] = r3[t4++];
            r3.length = e5 + 1;
          }
          const n4 = [];
          for (const e5 of r3)
            r3.some((t4) => e5.isChildOf(t4)) || n4.push(e5);
          return r3 = n4.filter((t4) => !e4.some((e5) => !!(t4.overscaledZ < i3 && e5.isChildOf(t4)) || t4.equals(e5) || t4.isChildOf(e5))), r3;
        }
        coveringTiles(e4) {
          let t3 = this.coveringZoomLevel(e4);
          const i3 = t3, r3 = this.elevation && this.elevation.exaggeration(), n4 = r3 && !e4.isTerrainDEM, o3 = "mercator" === this.projection.name;
          if (void 0 !== e4.minzoom && t3 < e4.minzoom)
            return [];
          void 0 !== e4.maxzoom && t3 > e4.maxzoom && (t3 = e4.maxzoom);
          const s6 = this.locationCoordinate(this.center), a3 = this.center.lat, l3 = 1 << t3, c3 = [l3 * s6.x, l3 * s6.y, 0], h3 = "globe" === this.projection.name, u3 = !h3, d3 = Qu.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t3, u3), p3 = h3 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f3 = l3 * Qd(1, this.center.lat), m3 = this._camera.position[2] / Qd(1, this.center.lat), _3 = [l3 * p3.x, l3 * p3.y, m3 * (u3 ? 1 : f3)], g3 = h3 || r3, y3 = this.cameraToCenterDistance / e4.tileSize * (e4.roundZoom ? 1 : 0.502), x3 = this.isLODDisabled(true) ? t3 : 0;
          let v3;
          if (this._elevation && e4.isTerrainDEM)
            v3 = 1e4 * this._elevation.exaggeration();
          else if (this._elevation) {
            const e5 = this._elevation.getMinMaxForVisibleTiles();
            v3 = e5 ? e5.max : this._centerAltitude;
          } else
            v3 = this._centerAltitude;
          const b3 = e4.isTerrainDEM ? -v3 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, w3 = this.projection.isReprojectedInTileSpace ? Jx(this) : 1, T3 = (e5) => {
            const t4 = 1 / 4e4, i4 = new lp(e5.x + t4, e5.y, e5.z), r4 = new lp(e5.x, e5.y + t4, e5.z), n5 = e5.toLngLat(), o4 = i4.toLngLat(), s7 = r4.toLngLat(), a4 = this.locationCoordinate(n5), l4 = this.locationCoordinate(o4), c4 = this.locationCoordinate(s7), h4 = Math.hypot(l4.x - a4.x, l4.y - a4.y), u4 = Math.hypot(c4.x - a4.x, c4.y - a4.y);
            return Math.sqrt(h4 * u4) * w3 / t4;
          }, M3 = (e5) => {
            const t4 = v3, i4 = b3;
            return { aabb: Dg(this, l3, 0, 0, 0, e5, i4, t4, this.projection), zoom: 0, x: 0, y: 0, minZ: i4, maxZ: t4, wrap: e5, fullyVisible: false };
          }, A3 = [];
          let S3 = [];
          const I3 = t3, C3 = e4.reparseOverscaled ? i3 : t3, z2 = (e5) => e5 * e5, P3 = z2((m3 - this._centerAltitude) * f3), D2 = (e5) => {
            if (!this._elevation || !e5.tileID || !o3)
              return;
            const t4 = this._elevation.getMinMaxForTile(e5.tileID), i4 = e5.aabb;
            t4 ? (i4.min[2] = t4.min, i4.max[2] = t4.max, i4.center[2] = (i4.min[2] + i4.max[2]) / 2) : (e5.shouldSplit = R3(e5), e5.shouldSplit || (i4.min[2] = i4.max[2] = i4.center[2] = this._centerAltitude));
          }, R3 = (e5) => {
            if (e5.zoom < x3)
              return true;
            if (e5.zoom === I3)
              return false;
            if (null != e5.shouldSplit)
              return e5.shouldSplit;
            const t4 = e5.aabb.distanceX(_3), r4 = e5.aabb.distanceY(_3);
            let o4 = P3, s7 = 1;
            if (h3) {
              o4 = z2(e5.aabb.distanceZ(_3));
              const t5 = Math.pow(2, e5.zoom), i4 = tp((e5.y + 1) / t5), r5 = tp(e5.y / t5), n5 = Math.min(Math.max(a3, i4), r5), l5 = Yd(n5) / Yd(a3);
              if (s7 = n5 === a3 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, l5 / this._mercatorScaleRatio), this.zoom <= td && e5.zoom === I3 - 1 && l5 >= 0.9)
                return true;
            } else if (n4 && (o4 = z2(e5.aabb.distanceZ(_3) * f3)), this.projection.isReprojectedInTileSpace && i3 <= 5) {
              const t5 = Math.pow(2, e5.zoom), i4 = T3(new lp((e5.x + 0.5) / t5, (e5.y + 0.5) / t5));
              s7 = i4 > 0.85 ? 1 : i4;
            }
            const l4 = t4 * t4 + r4 * r4 + o4, c4 = z2((1 << I3 - e5.zoom) * y3 * s7 * ((e6, t5) => {
              if (t5 * z2(0.707) < e6)
                return 1;
              const i4 = Math.sqrt(t5 / e6);
              return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            })(Math.max(o4, P3), l4));
            return l4 < c4;
          };
          if (this.renderWorldCopies)
            for (let e5 = 1; e5 <= 3; e5++)
              A3.push(M3(-e5)), A3.push(M3(e5));
          for (A3.push(M3(0)); A3.length > 0; ) {
            const i4 = A3.pop(), r4 = i4.x, s7 = i4.y;
            let a4 = i4.fullyVisible;
            const u4 = () => "globe" === this.projection.name && (0 === i4.y || i4.y === (1 << i4.zoom) - 1);
            if (!a4) {
              let e5 = g3 ? i4.aabb.intersects(d3) : i4.aabb.intersectsFlat(d3);
              if (0 === e5 && u4()) {
                const t4 = new ju(i4.zoom, r4, s7);
                e5 = yd(this, l3, t4, true).intersects(d3);
              }
              if (0 === e5)
                continue;
              a4 = 2 === e5;
            }
            if (i4.zoom !== I3 && R3(i4))
              for (let e5 = 0; e5 < 4; e5++) {
                const t4 = (r4 << 1) + e5 % 2, c4 = (s7 << 1) + (e5 >> 1), u5 = { aabb: o3 ? i4.aabb.quadrant(e5) : Dg(this, l3, i4.zoom + 1, t4, c4, i4.wrap, i4.minZ, i4.maxZ, this.projection), zoom: i4.zoom + 1, x: t4, y: c4, wrap: i4.wrap, fullyVisible: a4, tileID: void 0, shouldSplit: void 0, minZ: i4.minZ, maxZ: i4.maxZ };
                n4 && !h3 && (u5.tileID = new qu(i4.zoom + 1 === I3 ? C3 : i4.zoom + 1, i4.wrap, i4.zoom + 1, t4, c4), D2(u5)), A3.push(u5);
              }
            else {
              const n5 = i4.zoom === I3 ? C3 : i4.zoom;
              if (e4.minzoom && e4.minzoom > n5)
                continue;
              if (!a4) {
                let e5 = g3 ? i4.aabb.intersectsPrecise(d3) : i4.aabb.intersectsPreciseFlat(d3);
                if (0 === e5 && u4()) {
                  const t4 = new ju(i4.zoom, r4, s7);
                  e5 = yd(this, l3, t4, true).intersectsPrecise(d3);
                }
                if (0 === e5)
                  continue;
              }
              const o4 = c3[0] - (0.5 + r4 + (i4.wrap << i4.zoom)) * (1 << t3 - i4.zoom), h4 = c3[1] - 0.5 - s7, p4 = i4.tileID ? i4.tileID : new qu(n5, i4.wrap, i4.zoom, r4, s7);
              S3.push({ tileID: p4, distanceSq: o4 * o4 + h4 * h4 });
            }
          }
          if (this.fogCullDistSq) {
            const t4 = this.fogCullDistSq, i4 = this.horizonLineFromTop();
            S3 = S3.filter((r4) => {
              const n5 = [0, 0, 0, 1], o4 = [cr, cr, 0, 1], s7 = this.calculateFogTileMatrix(r4.tileID.toUnwrapped());
              yu.transformMat4(n5, n5, s7), yu.transformMat4(o4, o4, s7);
              const a4 = function(e5, t5, i5) {
                let r5 = 0;
                for (let i6 = 0; i6 < 2; ++i6) {
                  const n6 = 0;
                  e5[i6] > n6 && (r5 += (e5[i6] - n6) * (e5[i6] - n6)), t5[i6] < n6 && (r5 += (n6 - t5[i6]) * (n6 - t5[i6]));
                }
                return r5;
              }(yu.min([], n5, o4), yu.max([], n5, o4));
              if (0 === a4)
                return true;
              let l4 = false;
              const c4 = this._elevation;
              if (c4 && a4 > t4 && 0 !== i4) {
                const t5 = this.calculateProjMatrix(r4.tileID.toUnwrapped());
                let n6;
                e4.isTerrainDEM || (n6 = c4.getMinMaxForTile(r4.tileID)), n6 || (n6 = { min: b3, max: v3 });
                const o5 = function(e5) {
                  const t6 = Math.round((e5 + 45 + 360) % 360 / 90) % 4;
                  return E2[t6];
                }(this.rotation), s8 = [o5[0] * cr, o5[1] * cr, n6.max];
                Du.transformMat4(s8, s8, t5), l4 = (1 - s8[1]) * this.height * 0.5 < i4;
              }
              return a4 < t4 || l4;
            });
          }
          return S3.sort((e5, t4) => e5.distanceSq - t4.distanceSq).map((e5) => e5.tileID);
        }
        resize(e4, t3) {
          this.width = e4, this.height = t3, this.pixelsToGLUnits = [2 / e4, -2 / t3], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e4) {
          return Math.pow(2, e4);
        }
        scaleZoom(e4) {
          return Math.log(e4) / Math.LN2;
        }
        project(e4) {
          const t3 = z(e4.lat, -rp, rp), i3 = this.projection.project(e4.lng, t3);
          return new y2(i3.x * this.worldSize, i3.y * this.worldSize);
        }
        unproject(e4) {
          return this.projection.unproject(e4.x / this.worldSize, e4.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / Qd(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(e4, t3) {
          let i3, r3;
          const n4 = this.centerPoint;
          if ("globe" === this.projection.name) {
            const e5 = this.worldSize;
            i3 = (t3.x - n4.x) / e5, r3 = (t3.y - n4.y) / e5;
          } else {
            const e5 = this.pointCoordinate(t3), o4 = this.pointCoordinate(n4);
            i3 = e5.x - o4.x, r3 = e5.y - o4.y;
          }
          const o3 = this.locationCoordinate(e4);
          this.setLocation(new lp(o3.x - i3, o3.y - r3));
        }
        setLocation(e4) {
          this.center = this.coordinateLocation(e4), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(e4) {
          return this.projection.locationPoint(this, e4);
        }
        locationPoint3D(e4) {
          return this.projection.locationPoint(this, e4, true);
        }
        pointLocation(e4) {
          return this.coordinateLocation(this.pointCoordinate(e4));
        }
        pointLocation3D(e4) {
          return this.coordinateLocation(this.pointCoordinate3D(e4));
        }
        locationCoordinate(e4, t3) {
          const i3 = t3 ? Qd(t3, e4.lat) : void 0, r3 = this.projection.project(e4.lng, e4.lat);
          return new lp(r3.x, r3.y, i3);
        }
        coordinateLocation(e4) {
          return this.projection.unproject(e4.x, e4.y);
        }
        pointRayIntersection(e4, t3) {
          const i3 = null != t3 ? t3 : this._centerAltitude, r3 = [e4.x, e4.y, 0, 1], n4 = [e4.x, e4.y, 1, 1];
          yu.transformMat4(r3, r3, this.pixelMatrixInverse), yu.transformMat4(n4, n4, this.pixelMatrixInverse);
          const o3 = n4[3];
          yu.scale(r3, r3, 1 / r3[3]), yu.scale(n4, n4, 1 / o3);
          const s6 = r3[2], a3 = n4[2];
          return { p0: r3, p1: n4, t: s6 === a3 ? 0 : (i3 - s6) / (a3 - s6) };
        }
        screenPointToMercatorRay(e4) {
          const t3 = [e4.x, e4.y, 0, 1], i3 = [e4.x, e4.y, 1, 1];
          return yu.transformMat4(t3, t3, this.pixelMatrixInverse), yu.transformMat4(i3, i3, this.pixelMatrixInverse), yu.scale(t3, t3, 1 / t3[3]), yu.scale(i3, i3, 1 / i3[3]), t3[2] = Qd(t3[2], this._center.lat) * this.worldSize, i3[2] = Qd(i3[2], this._center.lat) * this.worldSize, yu.scale(t3, t3, 1 / this.worldSize), yu.scale(i3, i3, 1 / this.worldSize), new Wu([t3[0], t3[1], t3[2]], Du.normalize([], Du.sub([], i3, t3)));
        }
        rayIntersectionCoordinate(e4) {
          const { p0: t3, p1: i3, t: r3 } = e4, n4 = Qd(t3[2], this._center.lat), o3 = Qd(i3[2], this._center.lat);
          return new lp(Kr(t3[0], i3[0], r3) / this.worldSize, Kr(t3[1], i3[1], r3) / this.worldSize, Kr(n4, o3, r3));
        }
        pointCoordinate(e4, t3 = this._centerAltitude) {
          return this.projection.pointCoordinate(this, e4.x, e4.y, t3);
        }
        pointCoordinate3D(e4) {
          if (!this.elevation)
            return this.pointCoordinate(e4);
          let t3 = this.projection.pointCoordinate3D(this, e4.x, e4.y);
          if (t3)
            return new lp(t3[0], t3[1], t3[2]);
          let i3 = 0, r3 = this.horizonLineFromTop();
          if (e4.y > r3)
            return this.pointCoordinate(e4);
          const n4 = 0.02 * r3, o3 = e4.clone();
          for (let e5 = 0; e5 < 10 && r3 - i3 > n4; e5++) {
            o3.y = Kr(i3, r3, 0.66);
            const e6 = this.projection.pointCoordinate3D(this, o3.x, o3.y);
            e6 ? (r3 = o3.y, t3 = e6) : i3 = o3.y;
          }
          return t3 ? new lp(t3[0], t3[1], t3[2]) : this.pointCoordinate(e4);
        }
        isPointAboveHorizon(e4) {
          return this.projection.isPointAboveHorizon(this, e4);
        }
        isPointOnSurface(e4) {
          if (e4.y < 0 || e4.y > this.height || e4.x < 0 || e4.x > this.width)
            return false;
          if (this.elevation || this.zoom >= id)
            return !this.isPointAboveHorizon(e4);
          const t3 = this.pointCoordinate(e4);
          return t3.y >= 0 && t3.y <= 1;
        }
        _coordinatePoint(e4, t3) {
          const i3 = t3 && this.elevation ? this.elevation.getAtPointOrZero(e4, this._centerAltitude) : this._centerAltitude, r3 = [e4.x * this.worldSize, e4.y * this.worldSize, i3 + e4.toAltitude(), 1];
          return yu.transformMat4(r3, r3, this.pixelMatrix), r3[3] > 0 ? new y2(r3[0] / r3[3], r3[1] / r3[3]) : new y2(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: e4, left: t3 } = this._edgeInsets, i3 = this.height - this._edgeInsets.bottom, r3 = this.width - this._edgeInsets.right, n4 = this.pointLocation3D(new y2(t3, e4)), o3 = this.pointLocation3D(new y2(r3, e4)), s6 = this.pointLocation3D(new y2(r3, i3)), a3 = this.pointLocation3D(new y2(t3, i3));
          let l3 = Math.min(n4.lng, o3.lng, s6.lng, a3.lng), c3 = Math.max(n4.lng, o3.lng, s6.lng, a3.lng), h3 = Math.min(n4.lat, o3.lat, s6.lat, a3.lat), u3 = Math.max(n4.lat, o3.lat, s6.lat, a3.lat);
          const d3 = Math.pow(2, -this.zoom) / 16 * 270, p3 = "globe" === this.projection.name ? 1 : 4, f3 = (e5, t4, i4, r4, n5) => {
            const o4 = (e5 + i4) / 2, s7 = (t4 + r4) / 2, a4 = new y2(o4, s7), { lng: m3, lat: _3 } = this.pointLocation3D(a4), g3 = Math.max(0, l3 - m3, h3 - _3, m3 - c3, _3 - u3);
            l3 = Math.min(l3, m3), c3 = Math.max(c3, m3), h3 = Math.min(h3, _3), u3 = Math.max(u3, _3), (n5 < p3 || g3 > d3) && (f3(e5, t4, o4, s7, n5 + 1), f3(o4, s7, i4, r4, n5 + 1));
          };
          if (f3(t3, e4, r3, e4, 1), f3(r3, e4, r3, i3, 1), f3(r3, i3, t3, i3, 1), f3(t3, i3, t3, e4, 1), "globe" === this.projection.name) {
            const [e5, t4] = function(e6) {
              const t5 = Au.identity(new Float64Array(16));
              Au.multiply(t5, e6.pixelMatrix, e6.globeMatrix);
              const i4 = [0, ad, 0], r4 = [0, ld, 0];
              return Du.transformMat4(i4, i4, t5), Du.transformMat4(r4, r4, t5), [i4[0] > 0 && i4[0] <= e6.width && i4[1] > 0 && i4[1] <= e6.height && !Nd(e6, new Wd(e6.center.lat, 90)), r4[0] > 0 && r4[0] <= e6.width && r4[1] > 0 && r4[1] <= e6.height && !Nd(e6, new Wd(e6.center.lat, -90))];
            }(this);
            e5 ? (u3 = 90, c3 = 180, l3 = -180) : t4 && (h3 = -90, c3 = 180, l3 = -180);
          }
          return new sc(new Wd(l3, h3), new Wd(c3, u3));
        }
        _getBoundsRectangular(e4, t3) {
          const { top: i3, left: r3 } = this._edgeInsets, n4 = this.height - this._edgeInsets.bottom, o3 = this.width - this._edgeInsets.right, s6 = new y2(r3, i3), a3 = new y2(o3, i3), l3 = new y2(o3, n4), c3 = new y2(r3, n4);
          let h3 = this.pointCoordinate(s6, e4), u3 = this.pointCoordinate(a3, e4);
          const d3 = this.pointCoordinate(l3, t3), p3 = this.pointCoordinate(c3, t3), f3 = (e5, t4) => (t4.y - e5.y) / (t4.x - e5.x);
          return h3.y > 1 && u3.y >= 0 ? h3 = new lp((1 - p3.y) / f3(p3, h3) + p3.x, 1) : h3.y < 0 && u3.y <= 1 && (h3 = new lp(-p3.y / f3(p3, h3) + p3.x, 0)), u3.y > 1 && h3.y >= 0 ? u3 = new lp((1 - d3.y) / f3(d3, u3) + d3.x, 1) : u3.y < 0 && h3.y <= 1 && (u3 = new lp(-d3.y / f3(d3, u3) + d3.x, 0)), new sc().extend(this.coordinateLocation(h3)).extend(this.coordinateLocation(u3)).extend(this.coordinateLocation(p3)).extend(this.coordinateLocation(d3));
        }
        _getBoundsRectangularTerrain() {
          const e4 = this.elevation;
          if (!e4.visibleDemTiles.length || e4.isUsingMockSource())
            return this._getBoundsRectangular(0, 0);
          const t3 = e4.visibleDemTiles.reduce((e5, t4) => {
            if (t4.dem) {
              const i3 = t4.dem.tree;
              e5.min = Math.min(e5.min, i3.minimums[0]), e5.max = Math.max(e5.max, i3.maximums[0]);
            }
            return e5;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBoundsRectangular(t3.min * e4.exaggeration(), t3.max * e4.exaggeration());
        }
        getBounds() {
          return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(e4 = true) {
          const t3 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i3 = this.height / 2 - t3 * (1 - this._horizonShift);
          return e4 ? Math.max(0, i3) : i3;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(e4) {
          this.maxBounds = e4, this.minLat = -rp, this.maxLat = rp, this.minLng = -180, this.maxLng = 180, e4 && (this.minLat = e4.getSouth(), this.maxLat = e4.getNorth(), this.minLng = e4.getWest(), this.maxLng = e4.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = Kd(this.minLng) * this.tileSize, this.worldMaxX = Kd(this.maxLng) * this.tileSize, this.worldMinY = Jd(this.maxLat) * this.tileSize, this.worldMaxY = Jd(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(e4, t3) {
          return this.projection.createTileMatrix(this, t3, e4);
        }
        calculateDistanceTileData(e4) {
          const t3 = e4.key, i3 = this._distanceTileDataCache;
          if (i3[t3])
            return i3[t3];
          const r3 = e4.canonical, n4 = 1 / this.height, o3 = this.cameraWorldSize, s6 = o3 / this.zoomScale(r3.z), a3 = (r3.x + Math.pow(2, r3.z) * e4.wrap) * s6, l3 = r3.y * s6, c3 = this.point;
          c3.x *= o3 / this.worldSize, c3.y *= o3 / this.worldSize;
          const h3 = this.angle, u3 = Math.sin(-h3), d3 = -Math.cos(-h3);
          return i3[t3] = { bearing: [u3, d3], center: [(c3.x - a3) * n4, (c3.y - l3) * n4], scale: s6 / cr * n4 }, i3[t3];
        }
        calculateFogTileMatrix(e4) {
          const t3 = e4.key, i3 = this._fogTileMatrixCache;
          if (i3[t3])
            return i3[t3];
          const r3 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, e4);
          return Au.multiply(r3, this.worldToFogMatrix, r3), i3[t3] = new Float32Array(r3), i3[t3];
        }
        calculateProjMatrix(e4, t3 = false, i3 = false) {
          const r3 = e4.key;
          let n4;
          if (n4 = i3 ? this._expandedProjMatrixCache : t3 ? this._alignedProjMatrixCache : this._projMatrixCache, n4[r3])
            return n4[r3];
          const o3 = this.calculatePosMatrix(e4, this.worldSize);
          let s6;
          return s6 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i3 ? this.expandedFarZProjMatrix : t3 ? this.alignedProjMatrix : this.projMatrix, Au.multiply(o3, s6, o3), n4[r3] = new Float32Array(o3), n4[r3];
        }
        calculatePixelsToTileUnitsMatrix(e4) {
          const t3 = e4.tileID.key, i3 = this._pixelsToTileUnitsCache;
          if (i3[t3])
            return i3[t3];
          const r3 = function(e5, t4) {
            const { scale: i4 } = e5.tileTransform, r4 = i4 * cr / (e5.tileSize * Math.pow(2, t4.zoom - e5.tileID.overscaledZ + e5.tileID.canonical.z));
            return bu.scale(new Float32Array(4), t4.inverseAdjustmentMatrix, [r4, r4]);
          }(e4, this);
          return i3[t3] = r3, i3[t3];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if ("globe" === this.projection.name) {
            const e4 = 1 / this.worldSize, t3 = Au.fromScaling([], [e4, e4, e4]);
            return Au.multiply(t3, t3, this.globeMatrix), t3;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || "globe" === this.projection.name)
            return;
          const e4 = this._elevation;
          this._updateCameraState();
          const t3 = Qd(1, this._center.lat) * this.worldSize, i3 = this._computeCameraPosition(t3), r3 = this._camera.forward(), n4 = Qd(1, this._center.lat);
          i3[2] /= n4, r3[2] /= n4, Du.normalize(r3, r3);
          const o3 = e4.raycast(i3, r3, e4.exaggeration());
          if (o3) {
            const e5 = Du.scaleAndAdd([], i3, r3, o3), t4 = new lp(e5[0], e5[1], Qd(e5[2], tp(e5[1]))), s6 = (t4.z + Du.length([t4.x - i3[0], t4.y - i3[1], t4.z - i3[2] * n4])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(s6), this._centerAltitude = t4.toAltitude(), this._center = this.coordinateLocation(t4), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(e4 = false) {
          if (!this._elevation)
            return;
          const t3 = this._elevation, i3 = Qd(1, this._center.lat) * this.worldSize, r3 = this._computeCameraPosition(i3), n4 = t3.getAtPointOrZero(new lp(...r3)), o3 = this.pixelsPerMeter / this.worldSize * n4, s6 = this._minimumHeightOverTerrain(), a3 = r3[2] - o3;
          if (a3 <= s6)
            if (a3 < 0 || e4) {
              const e5 = this.locationCoordinate(this._center, this._centerAltitude), t4 = [r3[0], r3[1], e5.z - r3[2]], i4 = Du.length(t4);
              t4[2] -= (s6 - a3) / this._pixelsPerMercatorPixel;
              const n5 = Du.length(t4);
              if (0 === n5)
                return;
              Du.scale(t4, t4, i4 / n5 * this._pixelsPerMercatorPixel), this._camera.position = [r3[0], r3[1], e5.z * this._pixelsPerMercatorPixel - t4[2]], this._updateStateFromCamera();
            } else
              this._isCameraConstrained = true;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          const e4 = "globe" === this.projection.name || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || e4) {
            const t4 = this.center;
            return t4.lat = z(t4.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !e4) && (t4.lng = z(t4.lng, this.minLng, this.maxLng)), this.center = t4, void (this._constraining = false);
          }
          const t3 = this._unmodified, { x: i3, y: r3 } = this.point;
          let n4 = 0, o3 = i3, s6 = r3;
          const a3 = this.width / 2, l3 = this.height / 2, c3 = this.worldMinY * this.scale, h3 = this.worldMaxY * this.scale;
          if (r3 - l3 < c3 && (s6 = c3 + l3), r3 + l3 > h3 && (s6 = h3 - l3), h3 - c3 < this.height && (n4 = Math.max(n4, this.height / (h3 - c3)), s6 = (h3 + c3) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const e5 = this.worldMinX * this.scale, t4 = this.worldMaxX * this.scale, r4 = this.worldSize / 2 - (e5 + t4) / 2;
            o3 = (i3 + r4 + this.worldSize) % this.worldSize - r4, o3 - a3 < e5 && (o3 = e5 + a3), o3 + a3 > t4 && (o3 = t4 - a3), t4 - e5 < this.width && (n4 = Math.max(n4, this.width / (t4 - e5)), o3 = (t4 + e5) / 2);
          }
          o3 === i3 && s6 === r3 || (this.center = this.unproject(new y2(o3, s6))), n4 && (this.zoom += this.scaleZoom(n4)), this._constrainCamera(), this._unmodified = t3, this._constraining = false;
        }
        _minZoomForBounds() {
          let e4 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (e4 = Math.max(e4, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e4;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const e4 = this.centerOffset, t3 = "globe" === this.projection.name, i3 = this.pixelsPerMeter;
          "globe" === this.projection.name && (this._mercatorScaleRatio = Qd(1, this.center.lat) / Qd(1, 45));
          const r3 = Qx(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r3), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const n4 = "meters" === this.projection.zAxisUnit ? i3 : 1, o3 = this._camera.getWorldToCamera(this.worldSize, n4);
          let s6;
          const a3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          if (a3[8] = 2 * -e4.x / this.width, a3[9] = 2 * e4.y / this.height, this.isOrthographic) {
            let t4 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), i4 = t4 * this.aspect, r4 = -i4, n5 = -t4;
            i4 -= e4.x, r4 -= e4.x, t4 += e4.y, n5 += e4.y, s6 = this._camera.getCameraToClipOrthographic(r4, i4, n5, t4, this._nearZ, this._farZ), ((e5, t5, i5, r5) => {
              for (let n6 = 0; n6 < 16; n6++)
                e5[n6] = bv(t5[n6], i5[n6], r5);
            })(s6, s6, a3, wv(this.pitch >= 15 ? 1 : this.pitch / 15));
          } else
            s6 = a3;
          const l3 = Au.mul([], a3, o3);
          let c3 = Au.mul([], s6, o3);
          if (this.projection.isReprojectedInTileSpace) {
            const e5 = this.locationCoordinate(this.center), t4 = Au.identity([]);
            Au.translate(t4, t4, [e5.x * this.worldSize, e5.y * this.worldSize, 0]), Au.multiply(t4, t4, Kx(this)), Au.translate(t4, t4, [-e5.x * this.worldSize, -e5.y * this.worldSize, 0]), Au.multiply(c3, c3, t4), Au.multiply(l3, l3, t4), this.inverseAdjustmentMatrix = function(e6) {
              const t5 = Kx(e6, true);
              return bu.invert([], [t5[0], t5[1], t5[4], t5[5]]);
            }(this);
          } else
            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          if (this.mercatorMatrix = Au.scale([], c3, [this.worldSize, this.worldSize, this.worldSize / n4, 1]), this.projMatrix = c3, this.invProjMatrix = Au.invert(new Float64Array(16), this.projMatrix), t3) {
            const t4 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
            t4[8] = 2 * -e4.x / this.width, t4[9] = 2 * e4.y / this.height, this.expandedFarZProjMatrix = Au.mul([], t4, o3);
          } else
            this.expandedFarZProjMatrix = this.projMatrix;
          const h3 = Au.invert([], s6);
          this.frustumCorners = Hu.fromInvProjectionMatrix(h3, this.horizonLineFromTop(), this.height), this.cameraFrustum = Qu.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !t3);
          const u3 = new Float32Array(16);
          Au.identity(u3), Au.scale(u3, u3, [1, -1, 1]), Au.rotateX(u3, u3, this._pitch), Au.rotateZ(u3, u3, this.angle);
          const d3 = Au.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
          this.starsProjMatrix = Au.clone(d3);
          const p3 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          d3[8] = 2 * -e4.x / this.width, d3[9] = 2 * (e4.y + p3) / this.height, this.skyboxMatrix = Au.multiply(u3, d3, u3);
          const f3 = this.point, m3 = f3.x, _3 = f3.y, g3 = this.width % 2 / 2, y3 = this.height % 2 / 2, x3 = Math.cos(this.angle), v3 = Math.sin(this.angle), b3 = m3 - Math.round(m3) + x3 * g3 + v3 * y3, w3 = _3 - Math.round(_3) + x3 * y3 + v3 * g3, T3 = new Float64Array(c3);
          if (Au.translate(T3, T3, [b3 > 0.5 ? b3 - 1 : b3, w3 > 0.5 ? w3 - 1 : w3, 0]), this.alignedProjMatrix = T3, c3 = Au.create(), Au.scale(c3, c3, [this.width / 2, -this.height / 2, 1]), Au.translate(c3, c3, [1, -1, 0]), this.labelPlaneMatrix = c3, c3 = Au.create(), Au.scale(c3, c3, [1, -1, 1]), Au.translate(c3, c3, [-1, -1, 0]), Au.scale(c3, c3, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = c3, this.pixelMatrix = Au.multiply(new Float64Array(16), this.labelPlaneMatrix, l3), this._calcFogMatrices(), this._distanceTileDataCache = {}, c3 = Au.invert(new Float64Array(16), this.pixelMatrix), !c3)
            throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = c3, "globe" === this.projection.name || this.mercatorFromTransition) {
            this.globeMatrix = function(e6) {
              const { x: t4, y: i4 } = e6.point, { lng: r4, lat: n5 } = e6._center;
              return zd(t4, i4, e6.worldSize, r4, n5);
            }(this);
            const e5 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = Du.transformMat4(e5, e5, o3), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else
            this.globeMatrix = c3;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const e4 = this.cameraWorldSizeForFog, t3 = this.cameraPixelsPerMeter, i3 = this._camera.position, r3 = 1 / this.height / this._pixelsPerMercatorPixel, n4 = [e4, e4, t3];
          Du.scale(n4, n4, r3), Du.scale(i3, i3, -1), Du.multiply(i3, i3, n4);
          const o3 = Au.create();
          Au.translate(o3, o3, i3), Au.scale(o3, o3, n4), this.mercatorFogMatrix = o3, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(e4, t3, r3);
        }
        _computeCameraPosition(e4) {
          const t3 = (e4 = e4 || this.pixelsPerMeter) / this.pixelsPerMeter, i3 = this._camera.forward(), r3 = this.point, n4 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t3 - e4 / this.worldSize * this._centerAltitude;
          return [r3.x / this.worldSize - i3[0] * n4, r3.y / this.worldSize - i3[1] * n4, e4 / this.worldSize * this._centerAltitude - i3[2] * n4];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(e4) {
          const t3 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), i3 = this._camera.position[2], r3 = e4[2];
          let n4 = 1;
          this.projection.wrap && (this.center = this.center.wrap()), r3 > 0 && (n4 = Math.min((t3 - i3) / r3, 1)), this._camera.position = Du.scaleAndAdd([], this._camera.position, e4, n4), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const e4 = this._camera.position, t3 = this._camera.forward(), { pitch: i3, bearing: r3 } = this._camera.getPitchBearing(), n4 = Qd(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, o3 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(w2(this._maxPitch)), s6 = Math.max((e4[2] - n4) / Math.cos(i3), o3), a3 = this._zoomFromMercatorZ(s6);
          Du.scaleAndAdd(e4, e4, t3, s6), this._pitch = z(i3, w2(this.minPitch), w2(this.maxPitch)), this.angle = D(r3, -Math.PI, Math.PI), this._setZoom(z(a3, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new lp(e4[0], e4[1], e4[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(e4) {
          return Math.pow(2, e4) * this.tileSize;
        }
        _mercatorZfromZoom(e4) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(e4);
        }
        _minimumHeightOverTerrain() {
          const e4 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
          return this._mercatorZfromZoom(e4);
        }
        _zoomFromMercatorZ(e4) {
          return this.scaleZoom(this.cameraToCenterDistance / (e4 * this.tileSize));
        }
        zoomFromMercatorZAdjusted(e4) {
          let t3 = 0, i3 = id, r3 = 0, n4 = 1 / 0;
          for (; i3 - t3 > 1e-6 && i3 > t3; ) {
            const o3 = t3 + 0.5 * (i3 - t3), s6 = this.tileSize * Math.pow(2, o3), a3 = this.getCameraToCenterDistance(this.projection, o3, s6), l3 = this.scaleZoom(a3 / (e4 * this.tileSize)), c3 = Math.abs(o3 - l3);
            c3 < n4 && (n4 = c3, r3 = o3), o3 < l3 ? t3 = o3 : i3 = o3;
          }
          return r3;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (H2("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(e4, t3) {
          const i3 = Math.min(e4.x, t3.x), r3 = Math.max(e4.x, t3.x), n4 = Math.min(e4.y, t3.y), o3 = Math.max(e4.y, t3.y);
          if (n4 < this.horizonLineFromTop(false))
            return true;
          if ("mercator" !== this.projection.name)
            return false;
          const s6 = [new y2(i3, n4), new y2(r3, o3), new y2(i3, o3), new y2(r3, n4)], a3 = this.renderWorldCopies ? -3 : 0, l3 = this.renderWorldCopies ? 4 : 1;
          for (const e5 of s6) {
            const t4 = this.pointRayIntersection(e5);
            if (t4.t < 0)
              return true;
            const i4 = this.rayIntersectionCoordinate(t4);
            if (i4.x < a3 || i4.y < 0 || i4.x > l3 || i4.y > 1)
              return true;
          }
          return false;
        }
        isHorizonVisible() {
          return this.pitch + T2(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new y2(0, 0), new y2(this.width, this.height));
        }
        zoomDeltaToMovement(e4, t3) {
          const i3 = Du.length(Du.sub([], this._camera.position, e4)), r3 = this._zoomFromMercatorZ(i3) + t3;
          return i3 - this._mercatorZfromZoom(r3);
        }
        getCameraPoint() {
          if ("globe" === this.projection.name) {
            const e4 = function([e5, t3, i3], r3) {
              const n4 = [e5, t3, i3, 1];
              yu.transformMat4(n4, n4, r3);
              const o3 = n4[3] = Math.max(n4[3], 1e-6);
              return n4[0] /= o3, n4[1] /= o3, n4[2] /= o3, n4;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new y2(e4[0], e4[1]);
          }
          {
            const e4 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new y2(0, e4));
          }
        }
        getCameraToCenterDistance(e4, t3 = this.zoom, i3 = this.worldSize) {
          const r3 = Qx(e4, t3, this.width, this.height, 1024), n4 = e4.pixelSpaceConversion(this.center.lat, i3, r3);
          let o3 = 0.5 / Math.tan(0.5 * this._fov) * this.height * n4;
          return this.isOrthographic && (o3 = bv(1, o3, wv(this.pitch >= 15 ? 1 : this.pitch / 15))), o3;
        }
        getWorldToCameraMatrix() {
          const e4 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
          return "globe" === this.projection.name && Au.multiply(e4, e4, this.globeMatrix), e4;
        }
        getFrustum(e4) {
          return Qu.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, e4, "meters" === this.projection.zAxisUnit);
        }
      }
      function Ev(e4, t3, i3) {
        Au.identity(e4), Au.rotateZ(e4, e4, w2(t3[2])), Au.rotateX(e4, e4, w2(t3[0])), Au.rotateY(e4, e4, w2(t3[1])), Au.scale(e4, e4, i3), Au.multiply(e4, e4, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
      }
      function Mv(e4, t3, i3, r3, n4, o3, s6, a3) {
        const l3 = [i3[0] - t3[0], i3[1] - t3[1], 0], c3 = [r3[0] - t3[0], r3[1] - t3[1], 0];
        if (Du.length(l3) < 1e-12 || Du.length(c3) < 1e-12)
          return Iu.identity(e4);
        const h3 = Du.cross([], l3, c3);
        Du.normalize(h3, h3), Du.subtract(c3, r3, t3), l3[2] = (o3 - n4) * a3, c3[2] = (s6 - n4) * a3;
        const u3 = l3;
        return Du.cross(u3, l3, c3), Du.normalize(u3, u3), Iu.rotationTo(e4, h3, u3);
      }
      function Av(e4, t3, i3 = false) {
        const r3 = Dd(t3.zoom), n4 = function(e5, t4, i4) {
          const r4 = t4.worldSize, n5 = [e5[12], e5[13], e5[14]], o3 = tp(n5[1] / r4), s6 = ep(n5[0] / r4), a3 = Au.identity([]), l3 = Qd(1, o3) * r4, c3 = Qd(1, 0) * r4 * op(o3, t4.zoom), h3 = 1 / Id(r4);
          let u3 = c3 * h3;
          if (i4) {
            const e6 = Qx(t4.projection, t4.zoom, t4.width, t4.height, 1024);
            u3 = h3 * t4.projection.pixelSpaceConversion(t4.center.lat, r4, e6);
          }
          const d3 = wd(o3, s6);
          Du.add(d3, d3, Du.scale([], Du.normalize([], d3), l3 * u3 * n5[2]));
          const p3 = function(e6) {
            const t5 = [e6[0], e6[1], e6[2]];
            let i5 = [0, 1, 0];
            const r5 = Du.cross([], i5, t5);
            return Du.cross(i5, t5, r5), 0 === Du.squaredLength(i5) && (i5 = [0, 1, 0], Du.cross(r5, t5, i5)), Du.normalize(r5, r5), Du.normalize(i5, i5), Du.normalize(t5, t5), [r5[0], r5[1], r5[2], 0, i5[0], i5[1], i5[2], 0, t5[0], t5[1], t5[2], 0, e6[0], e6[1], e6[2], 1];
          }(d3);
          Au.scale(a3, a3, [u3, u3, u3 * l3]), Au.translate(a3, a3, [-n5[0], -n5[1], -n5[2]]);
          const f3 = Au.multiply([], t4.globeMatrix, p3);
          return Au.multiply(f3, f3, a3), Au.multiply(f3, f3, e5), f3;
        }(e4, t3, i3);
        if (r3 > 0) {
          const i4 = function(e5, t4) {
            const i5 = t4.worldSize, r4 = Qd(1, 0) * i5 * op(t4.center.lat, t4.zoom) / Id(i5), n5 = Qd(1, t4.center.lat) * i5, o3 = Au.identity([]);
            return Au.rotateY(o3, o3, w2(t4.center.lng)), Au.rotateX(o3, o3, w2(t4.center.lat)), Au.translate(o3, o3, [0, 0, rd]), Au.scale(o3, o3, [r4, r4, r4 * n5]), Au.translate(o3, o3, [t4.point.x - 0.5 * i5, t4.point.y - 0.5 * i5, 0]), Au.multiply(o3, o3, e5), Au.multiply(o3, t4.globeMatrix, o3);
          }(e4, t3);
          return function(e5, t4, i5) {
            const r4 = (e6, t5, i6) => {
              const r5 = Du.length(e6), n6 = Du.length(t5), o4 = md(e6, t5, i6);
              return Du.scale(o4, o4, 1 / Du.length(o4) * Kr(r5, n6, i6));
            }, n5 = r4([e5[0], e5[1], e5[2]], [t4[0], t4[1], t4[2]], i5), o3 = r4([e5[4], e5[5], e5[6]], [t4[4], t4[5], t4[6]], i5), s6 = r4([e5[8], e5[9], e5[10]], [t4[8], t4[9], t4[10]], i5), a3 = md([e5[12], e5[13], e5[14]], [t4[12], t4[13], t4[14]], i5);
            return [n5[0], n5[1], n5[2], 0, o3[0], o3[1], o3[2], 0, s6[0], s6[1], s6[2], 0, a3[0], a3[1], a3[2], 1];
          }(n4, i4, r3);
        }
        return n4;
      }
      const Sv = 64, Iv = [1, 1, 1];
      class Cv {
        constructor(e4, t3, i3, r3) {
          this.id = e4, this.position = null != t3 ? new Wd(t3[0], t3[1]) : new Wd(0, 0), this.orientation = null != i3 ? i3 : [0, 0, 0], this.nodes = r3, this.uploaded = false, this.aabb = new ed([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
        }
        _applyTransformations(e4, t3) {
          if (Au.multiply(e4.matrix, t3, e4.matrix), e4.meshes)
            for (const t4 of e4.meshes) {
              const i3 = ed.applyTransform(t4.aabb, e4.matrix);
              this.aabb.encapsulate(i3);
            }
          if (e4.children)
            for (const t4 of e4.children)
              this._applyTransformations(t4, e4.matrix);
        }
        computeBoundsAndApplyParent() {
          const e4 = Au.identity([]);
          for (const t3 of this.nodes)
            this._applyTransformations(t3, e4);
        }
        _positionModelOnTerrain(e4, t3) {
          const i3 = e4.elevation;
          if (!i3)
            return 0;
          const r3 = ed.projectAabbCorners(this.aabb, this.matrix), n4 = Qd(1, this.position.lat) * e4.worldSize, o3 = function(e5, t4) {
            const i4 = [0, 0, 1], r4 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
            for (const n5 of r4) {
              const r5 = e5[n5.corners[0]], o4 = e5[n5.corners[1]], s7 = e5[n5.corners[2]], a4 = [o4[0] - r5[0], o4[1] - r5[1], t4 * (o4[2] - r5[2])], l4 = Du.cross(a4, a4, [s7[0] - r5[0], s7[1] - r5[1], t4 * (s7[2] - r5[2])]);
              Du.normalize(l4, l4), n5.dotProductWithUp = Du.dot(l4, i4);
            }
            return r4.sort((e6, t5) => e6.dotProductWithUp - t5.dotProductWithUp), r4[0].corners;
          }(r3, n4), s6 = r3[o3[0]], a3 = r3[o3[1]], l3 = r3[o3[2]], c3 = r3[o3[3]], h3 = i3.getAtPointOrZero(new lp(s6[0] / e4.worldSize, s6[1] / e4.worldSize), 0), u3 = i3.getAtPointOrZero(new lp(a3[0] / e4.worldSize, a3[1] / e4.worldSize), 0), d3 = i3.getAtPointOrZero(new lp(l3[0] / e4.worldSize, l3[1] / e4.worldSize), 0), p3 = i3.getAtPointOrZero(new lp(c3[0] / e4.worldSize, c3[1] / e4.worldSize), 0), f3 = (h3 + p3) / 2, m3 = (u3 + d3) / 2;
          return f3 > m3 ? u3 < d3 ? Mv(t3, a3, c3, s6, u3, p3, h3, n4) : Mv(t3, l3, s6, c3, d3, h3, p3, n4) : h3 < p3 ? Mv(t3, s6, a3, l3, h3, u3, d3, n4) : Mv(t3, c3, l3, a3, p3, d3, u3, n4), Math.max(f3, m3);
        }
        computeModelMatrix(e4, t3, i3, r3, n4, o3, s6 = false) {
          const a3 = e4.transform, l3 = a3.zoom, c3 = a3.project(this.position), h3 = op(this.position.lat, l3), u3 = 1 / h3;
          Au.identity(this.matrix), Au.translate(this.matrix, this.matrix, [c3.x + r3[0] * u3, c3.y + r3[1] * u3, r3[2]]);
          let d3 = 1, p3 = 1;
          const f3 = a3.worldSize;
          if (s6) {
            if ("mercator" === a3.projection.name) {
              let e5 = 0;
              a3.elevation && (e5 = a3.elevation.getAtPointOrZero(new lp(c3.x / f3, c3.y / f3), 0));
              const t4 = yu.transformMat4([], [c3.x, c3.y, e5, 1], a3.projMatrix)[3] / a3.cameraToCenterDistance;
              d3 = t4, p3 = t4 * op(a3.center.lat, l3);
            } else if ("globe" === a3.projection.name) {
              const e5 = Av(this.matrix, a3), t4 = Au.multiply([], a3.projMatrix, e5), i4 = [0, 0, 0, 1];
              yu.transformMat4(i4, i4, t4);
              const r4 = i4[3] / a3.cameraToCenterDistance, n5 = Dd(l3), o4 = a3.projection.pixelsPerMeter(this.position.lat, f3) * op(this.position.lat, l3), s7 = a3.projection.pixelsPerMeter(a3.center.lat, f3) * op(a3.center.lat, l3);
              d3 = r4 / Kr(o4, np(a3.center.lat), n5), p3 = r4 * h3 / o4, d3 *= s7, p3 *= s7;
            }
          } else
            d3 = u3;
          Au.scale(this.matrix, this.matrix, [d3, d3, p3]);
          const m3 = [...this.matrix], _3 = this.orientation, g3 = [];
          if (Ev(g3, [_3[0] + t3[0], _3[1] + t3[1], _3[2] + t3[2]], i3), Au.multiply(this.matrix, m3, g3), n4 && a3.elevation) {
            let e5 = 0;
            const t4 = [];
            if (o3 && a3.elevation) {
              e5 = this._positionModelOnTerrain(a3, t4);
              const i4 = Au.fromQuat([], t4), r4 = Au.multiply([], i4, g3);
              Au.multiply(this.matrix, m3, r4);
            } else
              e5 = a3.elevation.getAtPointOrZero(new lp(c3.x / f3, c3.y / f3), 0);
            0 !== e5 && (this.matrix[14] += e5);
          }
        }
        upload(e4) {
          if (!this.uploaded) {
            for (const t3 of this.nodes)
              Dv(t3, e4);
            for (const e5 of this.nodes)
              Rv(e5);
            this.uploaded = true;
          }
        }
        destroy() {
          for (const e4 of this.nodes)
            Lv(e4);
        }
      }
      function zv(e4, t3, i3 = false) {
        e4.uploaded || (e4.gfxTexture = new My(t3, e4.image, i3 ? t3.gl.R8 : t3.gl.RGBA, { useMipmap: e4.sampler.minFilter >= t3.gl.NEAREST_MIPMAP_NEAREST }), e4.uploaded = true, e4.image = null);
      }
      function Pv(e4, t3, i3) {
        e4.indexBuffer = t3.createIndexBuffer(e4.indexArray, false, true), e4.vertexBuffer = t3.createVertexBuffer(e4.vertexArray, Fx.members, false, true), e4.normalArray && (e4.normalBuffer = t3.createVertexBuffer(e4.normalArray, jx.members, false, true)), e4.texcoordArray && (e4.texcoordBuffer = t3.createVertexBuffer(e4.texcoordArray, Vx.members, false, true)), e4.colorArray && (e4.colorBuffer = t3.createVertexBuffer(e4.colorArray, (12 === e4.colorArray.bytesPerElement ? Nx : Ux).members, false, true)), e4.featureArray && (e4.pbrBuffer = t3.createVertexBuffer(e4.featureArray, qx.members, true)), e4.segments = xl.simpleSegment(0, 0, e4.vertexArray.length, e4.indexArray.length);
        const r3 = e4.material;
        r3.pbrMetallicRoughness.baseColorTexture && zv(r3.pbrMetallicRoughness.baseColorTexture, t3), r3.pbrMetallicRoughness.metallicRoughnessTexture && zv(r3.pbrMetallicRoughness.metallicRoughnessTexture, t3), r3.normalTexture && zv(r3.normalTexture, t3), r3.occlusionTexture && zv(r3.occlusionTexture, t3, i3), r3.emissionTexture && zv(r3.emissionTexture, t3);
      }
      function Dv(e4, t3, i3) {
        if (e4.meshes)
          for (const r3 of e4.meshes)
            Pv(r3, t3, i3);
        if (e4.children)
          for (const r3 of e4.children)
            Dv(r3, t3, i3);
      }
      function Rv(e4) {
        if (e4.meshes)
          for (const t3 of e4.meshes)
            t3.indexArray.destroy(), t3.vertexArray.destroy(), t3.colorArray && t3.colorArray.destroy(), t3.normalArray && t3.normalArray.destroy(), t3.texcoordArray && t3.texcoordArray.destroy(), t3.featureArray && t3.featureArray.destroy();
        if (e4.children)
          for (const t3 of e4.children)
            Rv(t3);
      }
      function Lv(e4) {
        if (e4.meshes)
          for (const i3 of e4.meshes)
            i3.vertexBuffer && (i3.vertexBuffer.destroy(), i3.indexBuffer.destroy(), i3.normalBuffer && i3.normalBuffer.destroy(), i3.texcoordBuffer && i3.texcoordBuffer.destroy(), i3.colorBuffer && i3.colorBuffer.destroy(), i3.pbrBuffer && i3.pbrBuffer.destroy(), i3.segments.destroy(), i3.material && ((t3 = i3.material).pbrMetallicRoughness.baseColorTexture && t3.pbrMetallicRoughness.baseColorTexture.gfxTexture && t3.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), t3.pbrMetallicRoughness.metallicRoughnessTexture && t3.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && t3.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), t3.normalTexture && t3.normalTexture.gfxTexture && t3.normalTexture.gfxTexture.destroy(), t3.emissionTexture && t3.emissionTexture.gfxTexture && t3.emissionTexture.gfxTexture.destroy(), t3.occlusionTexture && t3.occlusionTexture.gfxTexture && t3.occlusionTexture.gfxTexture.destroy()));
        var t3;
        if (e4.children)
          for (const t4 of e4.children)
            Lv(t4);
      }
      class kv {
        constructor(e4, t3) {
          this.feature = e4, this.instancedDataOffset = t3, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
        }
      }
      class Ov {
        constructor() {
          this.instancedDataArray = new rl(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
        }
      }
      class Bv {
        constructor(e4) {
          this.zoom = e4.zoom, this.canonical = e4.canonical, this.layers = e4.layers, this.layerIds = this.layers.map((e5) => e5.fqid), this.projection = e4.projection, this.index = e4.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((e5) => e5.isStateDependent()).map((e5) => e5.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 };
        }
        populate(e4, t3, i3, r3) {
          this.tileToMeter = ap(i3);
          const n4 = this.layers[0]._featureFilter.needGeometry;
          this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
          for (const { feature: o3, id: s6, index: a3, sourceLayerIndex: l3 } of e4) {
            const e5 = gp(o3, n4);
            if (!this.layers[0]._featureFilter.filter(new oa(this.zoom), e5, i3))
              continue;
            const c3 = { id: s6, sourceLayerIndex: l3, index: a3, geometry: n4 ? e5.geometry : _p(o3, i3, r3), properties: o3.properties, type: o3.type, patterns: {} }, h3 = this.addFeature(c3, c3.geometry, e5);
            h3 && t3.featureIndex.insert(o3, c3.geometry, a3, l3, this.index, this.instancesPerModel[h3].instancedDataArray.length);
          }
          this.lookup = null;
        }
        update(e4, t3, i3, r3) {
          for (const t4 in this.instancesPerModel) {
            const i4 = this.instancesPerModel[t4];
            for (const t5 in e4)
              i4.idToFeaturesIndex.hasOwnProperty(t5) && this.evaluate(i4.features[i4.idToFeaturesIndex[t5]], e4[t5], i4, true);
          }
          this.maxHeight = 0;
        }
        updateZoomBasedPaintProperties() {
          if (!this.hasZoomDependentProperties)
            return false;
          let e4 = false;
          for (const t3 in this.instancesPerModel) {
            const i3 = this.instancesPerModel[t3];
            for (const t4 of i3.features) {
              const r3 = this.layers[0], n4 = t4.feature, o3 = this.canonical, s6 = r3.paint.get("model-rotation").evaluate(n4, {}, o3), a3 = r3.paint.get("model-scale").evaluate(n4, {}, o3), l3 = r3.paint.get("model-translation").evaluate(n4, {}, o3);
              Du.exactEquals(t4.rotation, s6) && Du.exactEquals(t4.scale, a3) && Du.exactEquals(t4.translation, l3) || (this.evaluate(t4, t4.featureStates, i3, true), e4 = true);
            }
          }
          return e4;
        }
        isEmpty() {
          for (const e4 in this.instancesPerModel)
            if (0 !== this.instancesPerModel[e4].instancedDataArray.length)
              return false;
          return true;
        }
        uploadPending() {
          return !this.uploaded;
        }
        upload(e4) {
          if (!this.uploaded)
            for (const t3 in this.instancesPerModel) {
              const i3 = this.instancesPerModel[t3];
              i3.instancedDataArray.length < 0 || 0 === i3.instancedDataArray.length || (i3.instancedDataBuffer ? i3.instancedDataBuffer.updateData(i3.instancedDataArray) : i3.instancedDataBuffer = e4.createVertexBuffer(i3.instancedDataArray, Gx.members, true, void 0, this.instanceCount));
            }
          this.uploaded = true;
        }
        destroy() {
          for (const e4 in this.instancesPerModel) {
            const t3 = this.instancesPerModel[e4];
            0 !== t3.instancedDataArray.length && t3.instancedDataBuffer && t3.instancedDataBuffer.destroy();
          }
        }
        addFeature(e4, t3, i3) {
          const r3 = this.layers[0], n4 = r3.layout.get("model-id").evaluate(i3, {}, this.canonical);
          if (!n4)
            return H2(`modelId is not evaluated for layer ${r3.id} and it is not going to get rendered.`), n4;
          this.instancesPerModel[n4] || (this.instancesPerModel[n4] = new Ov());
          const o3 = this.instancesPerModel[n4], s6 = o3.instancedDataArray, a3 = new kv(i3, s6.length);
          for (const e5 of t3)
            for (const t4 of e5) {
              if (t4.x < 0 || t4.x >= cr || t4.y < 0 || t4.y >= cr)
                continue;
              const e6 = (this.lookupDim - 1) / cr, i4 = this.lookupDim * (t4.y * e6 | 0) + t4.x * e6 | 0;
              if (this.lookup) {
                if (0 !== this.lookup[i4])
                  continue;
                this.lookup[i4] = 1;
              }
              this.instanceCount++;
              const r4 = s6.length;
              s6.resize(r4 + 1), o3.instancesEvaluatedElevation.push(0), s6.float32[16 * r4] = t4.x, s6.float32[16 * r4 + 1] = t4.y;
            }
          return a3.instancedDataCount = o3.instancedDataArray.length - a3.instancedDataOffset, a3.instancedDataCount > 0 && (e4.id && (o3.idToFeaturesIndex[e4.id] = o3.features.length), o3.features.push(a3), this.evaluate(a3, {}, o3, false)), n4;
        }
        evaluate(e4, t3, i3, r3) {
          const n4 = this.layers[0], o3 = e4.feature, s6 = this.canonical, a3 = e4.rotation = n4.paint.get("model-rotation").evaluate(o3, t3, s6), l3 = e4.scale = n4.paint.get("model-scale").evaluate(o3, t3, s6), c3 = e4.translation = n4.paint.get("model-translation").evaluate(o3, t3, s6), h3 = n4.paint.get("model-color").evaluate(o3, t3, s6);
          h3.a = n4.paint.get("model-color-mix-intensity").evaluate(o3, t3, s6);
          const u3 = [];
          this.maxVerticalOffset < c3[2] && (this.maxVerticalOffset = c3[2]), this.maxScale = Math.max(Math.max(this.maxScale, l3[0]), Math.max(l3[1], l3[2])), Ev(u3, a3, l3);
          const d3 = Math.round(100 * h3.a) + h3.b / 1.05;
          for (let t4 = 0; t4 < e4.instancedDataCount; ++t4) {
            const n5 = e4.instancedDataOffset + t4, o4 = 16 * n5, a4 = i3.instancedDataArray.float32;
            let l4 = 0;
            r3 && (l4 = a4[o4 + 6] - i3.instancesEvaluatedElevation[n5]);
            const p3 = 0 | a4[o4 + 1];
            a4[o4] = (0 | a4[o4]) + h3.r / 1.05, a4[o4 + 1] = p3 + h3.g / 1.05, a4[o4 + 2] = d3, a4[o4 + 3] = 1 / (s6.z > 10 ? this.tileToMeter : ap(s6, p3)), a4[o4 + 4] = c3[0], a4[o4 + 5] = c3[1], a4[o4 + 6] = c3[2] + l4, a4[o4 + 7] = u3[0], a4[o4 + 8] = u3[1], a4[o4 + 9] = u3[2], a4[o4 + 10] = u3[4], a4[o4 + 11] = u3[5], a4[o4 + 12] = u3[6], a4[o4 + 13] = u3[8], a4[o4 + 14] = u3[9], a4[o4 + 15] = u3[10], i3.instancesEvaluatedElevation[n5] = c3[2];
          }
        }
      }
      Rs(Bv, "ModelBucket", { omit: ["layers"] }), Rs(Ov, "PerModelAttributes"), Rs(kv, "ModelFeature");
      const Fv = new ga({ visibility: new fa(Pt.layout_model.visibility), "model-id": new ma(Pt.layout_model["model-id"]) });
      var Nv = { paint: new ga({ "model-opacity": new fa(Pt.paint_model["model-opacity"]), "model-rotation": new ma(Pt.paint_model["model-rotation"]), "model-scale": new ma(Pt.paint_model["model-scale"]), "model-translation": new ma(Pt.paint_model["model-translation"]), "model-color": new ma(Pt.paint_model["model-color"]), "model-color-mix-intensity": new ma(Pt.paint_model["model-color-mix-intensity"]), "model-type": new fa(Pt.paint_model["model-type"]), "model-cast-shadows": new fa(Pt.paint_model["model-cast-shadows"]), "model-receive-shadows": new fa(Pt.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new fa(Pt.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new ma(Pt.paint_model["model-emissive-strength"]), "model-roughness": new ma(Pt.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new ma(Pt.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new fa(Pt.paint_model["model-cutoff-fade-range"]) }), layout: Fv };
      const Uv = new Float32Array(262144), Vv = new Uint8Array(262144);
      function jv(e4) {
        let t3 = 0;
        if (e4.meshes)
          for (const i3 of e4.meshes)
            t3 = Math.max(t3, i3.aabb.max[2]);
        if (e4.children)
          for (const i3 of e4.children)
            t3 = Math.max(t3, jv(i3));
        return t3;
      }
      const Gv = ["", "wall", "door", "roof", "window", "lamp", "logo"];
      class qv {
        constructor(e4) {
          this.node = e4, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.feature = { type: "Point", id: e4.id, geometry: [], properties: { height: jv(e4) } };
        }
      }
      class Zv {
        constructor(e4, t3, i3, r3) {
          this.nodes = e4, this.id = t3, this.modelTraits |= 1, this.uploaded = false, this.hasPattern = false, i3 && (this.modelTraits |= 4), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = r3, this.dirty = true, this.needsUpload = false;
        }
        update() {
          console.log("Update 3D model bucket");
        }
        populate() {
          console.log("populate 3D model bucket");
        }
        uploadPending() {
          return !this.uploaded || this.needsUpload;
        }
        upload(e4) {
          if (!this.needsUpload)
            return;
          const t3 = this.getNodesInfo();
          for (const i3 of t3) {
            const t4 = i3.node;
            this.uploaded ? this.updatePbrBuffer(t4) : Dv(t4, e4, true);
          }
          for (const e5 of t3)
            Rv(e5.node);
          this.uploaded = true, this.needsUpload = false;
        }
        updatePbrBuffer(e4) {
          let t3 = false;
          if (!e4.meshes)
            return t3;
          for (const i3 of e4.meshes)
            i3.pbrBuffer && (i3.pbrBuffer.updateData(i3.featureArray), t3 = true);
          return t3;
        }
        needsReEvaluation(e4, t3, i3) {
          const r3 = e4.transform.projectionOptions, n4 = e4.style.getBrightness(), o3 = this.brightness !== n4;
          return !!(!this.uploaded || this.dirty || r3.name !== this.projection.name || $v(i3.paint.get("model-color").value, o3) || $v(i3.paint.get("model-color-mix-intensity").value, o3) || $v(i3.paint.get("model-roughness").value, o3) || $v(i3.paint.get("model-emissive-strength").value, o3) || $v(i3.paint.get("model-height-based-emissive-strength-multiplier").value, o3)) && (this.projection = r3, this.brightness = n4, true);
        }
        evaluateScale(e4, t3) {
          if (e4.transform.zoom === this.zoom)
            return;
          this.zoom = e4.transform.zoom;
          const i3 = this.getNodesInfo(), r3 = this.id.canonical;
          for (const e5 of i3) {
            const i4 = e5.feature;
            e5.evaluatedScale = t3.paint.get("model-scale").evaluate(i4, {}, r3);
          }
        }
        evaluate(e4) {
          const t3 = this.getNodesInfo();
          for (const i3 of t3) {
            if (!i3.node.meshes)
              continue;
            const t4 = i3.feature, r3 = i3.node.meshes && i3.node.meshes[0].featureData, n4 = i3.evaluatedColor[2], o3 = i3.evaluatedRMEA[2], s6 = this.id.canonical;
            if (i3.hasTranslucentParts = false, r3) {
              for (let r4 = 0; r4 < Gv.length; r4++) {
                const n5 = Gv[r4];
                n5.length && (t4.properties.part = n5);
                const o4 = e4.paint.get("model-color").evaluate(t4, {}, s6), a3 = e4.paint.get("model-color-mix-intensity").evaluate(t4, {}, s6);
                i3.evaluatedColor[r4] = [o4.r, o4.g, o4.b, a3], i3.evaluatedRMEA[r4][0] = e4.paint.get("model-roughness").evaluate(t4, {}, s6), i3.evaluatedRMEA[r4][2] = e4.paint.get("model-emissive-strength").evaluate(t4, {}, s6), i3.evaluatedRMEA[r4][3] = o4.a, i3.emissionHeightBasedParams[r4] = e4.paint.get("model-height-based-emissive-strength-multiplier").evaluate(t4, {}, s6), !i3.hasTranslucentParts && o4.a < 1 && (i3.hasTranslucentParts = true);
              }
              delete t4.properties.part, Hv(i3, n4 !== i3.evaluatedColor[2] || o3 !== i3.evaluatedRMEA[2]);
            }
            i3.evaluatedScale = e4.paint.get("model-scale").evaluate(t4, {}, s6), this.updatePbrBuffer(i3.node) || (this.needsUpload = true);
          }
          this.dirty = false;
        }
        elevationUpdate(e4, t3, i3, r3) {
          const n4 = e4.findDEMTileFor(i3);
          if (n4 && (n4.tileID.canonical !== this.terrainTile || t3 !== this.terrainExaggeration)) {
            if (n4.dem && n4.tileID.overscaledZ !== this.elevationReadFromZ) {
              this.elevationReadFromZ = n4.tileID.overscaledZ;
              const t4 = Jm.create(e4, i3, n4);
              if (!t4)
                return;
              4 & this.modelTraits && this.updateDEM(e4, t4, i3, r3);
              for (const e5 of this.getNodesInfo()) {
                const i4 = e5.node;
                if (!i4.footprint || !i4.footprint.vertices || !i4.footprint.vertices.length)
                  continue;
                const r4 = i4.footprint.vertices;
                let n5 = t4.getElevationAt(r4[0].x, r4[0].y, true, true);
                for (let e6 = 1; e6 < r4.length; e6++)
                  n5 = Math.min(n5, t4.getElevationAt(r4[e6].x, r4[e6].y, true, true));
                i4.elevation = n5;
              }
            }
            this.terrainTile = n4.tileID.canonical, this.terrainExaggeration = t3;
          }
        }
        updateDEM(e4, t3, i3, r3) {
          let n4 = t3._dem._modifiedForSources[r3];
          if (void 0 === n4 && (t3._dem._modifiedForSources[r3] = [], n4 = t3._dem._modifiedForSources[r3]), n4.includes(i3.canonical))
            return;
          const o3 = t3._dem.dim;
          n4.push(i3.canonical);
          let s6 = false;
          for (const e5 of this.getNodesInfo()) {
            const i4 = e5.node;
            if (!i4.footprint || !i4.footprint.grid)
              continue;
            const r4 = i4.footprint.grid, n5 = t3.tileCoordToPixel(r4.min.x, r4.min.y), a3 = t3.tileCoordToPixel(r4.max.x, r4.max.y), l3 = Math.min(Math.min(o3 - a3.y, n5.x), Math.min(n5.y, o3 - a3.x));
            if (l3 < 0)
              continue;
            const c3 = z(l3, 2, 5);
            let h3 = Math.max(0, n5.x - c3), u3 = Math.max(0, n5.y - c3), d3 = Math.min(a3.x + c3, o3 - 1), p3 = Math.min(a3.y + c3, o3 - 1);
            for (let e6 = u3; e6 <= p3; ++e6)
              for (let t4 = h3; t4 <= d3; ++t4)
                Vv[e6 * o3 + t4] = 255;
            let f3 = 0, m3 = 0;
            for (let e6 = 0; e6 < r4.cellsY; ++e6)
              for (let i5 = 0; i5 < r4.cellsX; ++i5) {
                if (!r4.cells[e6 * r4.cellsX + i5])
                  continue;
                const n6 = t3.tileCoordToPixel(r4.min.x + i5 / r4.xScale, r4.min.y + e6 / r4.yScale), s7 = t3.tileCoordToPixel(r4.min.x + (i5 + 1) / r4.xScale, r4.min.y + (e6 + 1) / r4.yScale);
                for (let e7 = n6.y; e7 <= Math.min(s7.y + 1, o3 - 1); ++e7)
                  for (let i6 = n6.x; i6 <= Math.min(s7.x + 1, o3 - 1); ++i6)
                    255 === Vv[e7 * o3 + i6] && (Vv[e7 * o3 + i6] = 0, f3 += t3.getElevationAtPixel(i6, e7), m3++);
              }
            const _3 = f3 / m3;
            h3 = Math.max(1, n5.x - c3), u3 = Math.max(1, n5.y - c3), d3 = Math.min(a3.x + c3, o3 - 2), p3 = Math.min(a3.y + c3, o3 - 2), s6 = true;
            for (let e6 = u3; e6 <= p3; ++e6)
              for (let i5 = h3; i5 <= d3; ++i5)
                0 === Vv[e6 * o3 + i5] && (Uv[e6 * o3 + i5] = t3._dem.set(i5, e6, _3));
            for (let e6 = 1; e6 < c3; ++e6) {
              h3 = Math.max(1, n5.x - e6), u3 = Math.max(1, n5.y - e6), d3 = Math.min(a3.x + e6, o3 - 2), p3 = Math.min(a3.y + e6, o3 - 2);
              for (let i5 = u3; i5 <= p3; ++i5)
                for (let r5 = h3; r5 <= d3; ++r5) {
                  const n6 = i5 * o3 + r5;
                  if (255 === Vv[n6]) {
                    let s7 = 0, a4 = 0, l4 = -1, h4 = -1;
                    for (let t4 = -1; t4 <= 1; ++t4)
                      for (let n7 = -1; n7 <= 1; ++n7) {
                        const c4 = (i5 + t4) * o3 + r5 + n7;
                        if (Vv[c4] >= e6)
                          continue;
                        const u4 = Uv[c4], d4 = Math.abs(u4);
                        d4 > a4 && (s7 = u4, a4 = d4, l4 = n7, h4 = t4);
                      }
                    if (a4 > 0.1) {
                      const o4 = 1 - (e6 + 0.5 * Math.abs(l4 * h4)) / c3;
                      let a5 = t3._dem.get(r5, i5) + s7 * o4;
                      const u4 = t3._dem.get(r5 + l4, i5 + h4), d4 = t3._dem.get(r5 - l4, i5 - h4, true);
                      (a5 - u4) * (a5 - d4) > 0 && (a5 = (u4 + d4) / 2), Uv[n6] = t3._dem.set(r5, i5, a5), Vv[n6] = e6;
                    }
                  }
                }
            }
          }
          s6 && (t3._demTile.needsDEMTextureUpload = true, t3._dem._timestamp = dt.now());
        }
        getNodesInfo() {
          if (!this.nodesInfo) {
            this.nodesInfo = [];
            for (const e4 of this.nodes)
              this.nodesInfo.push(new qv(e4));
            this.freeNodes();
          }
          return this.nodesInfo;
        }
        freeNodes() {
          if (this.nodes) {
            for (const e4 of this.nodes)
              Lv(e4);
            this.nodes.splice(0, this.nodes.length);
          }
        }
        destroy() {
          this.freeNodes();
          const e4 = this.getNodesInfo();
          for (const t3 of e4)
            Rv(t3.node), Lv(t3.node);
        }
        isEmpty() {
          return !this.nodes.length;
        }
        updateReplacement(e4, t3) {
          if (t3.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = t3.updateTime;
          const i3 = t3.getReplacementRegionsForTile(e4.toUnwrapped()), r3 = this.getNodesInfo();
          for (let e5 = 0; e5 < this.nodesInfo.length; e5++) {
            const t4 = r3[e5].node;
            r3[e5].hiddenByReplacement = !!t4.footprint && !i3.find((e6) => e6.footprint === t4.footprint);
          }
        }
        getHeightAtTileCoord(e4, t3) {
          const i3 = this.getNodesInfo(), r3 = [];
          for (let n4 = 0; n4 < this.nodesInfo.length; n4++) {
            const o3 = i3[n4], s6 = o3.node.meshes[0];
            if (e4 < s6.aabb.min[0] || t3 < s6.aabb.min[1] || e4 > s6.aabb.max[0] || t3 > s6.aabb.max[1])
              continue;
            const a3 = (e4 - s6.aabb.min[0]) / (s6.aabb.max[0] - s6.aabb.min[0]) * Sv | 0, l3 = Math.min(63, (t3 - s6.aabb.min[1]) / (s6.aabb.max[1] - s6.aabb.min[1]) * Sv | 0) * Sv + Math.min(63, a3);
            if (!(s6.heightmap[l3] < 0 && o3.node.footprint)) {
              if (o3.hiddenByReplacement)
                return;
              return { height: s6.heightmap[l3], maxHeight: o3.feature.properties.height, hidden: false, verticalScale: o3.evaluatedScale[2] };
            }
            if (o3.node.footprint.grid.query(new y2(e4, t3), new y2(e4, t3), r3), r3.length > 0)
              return { height: void 0, maxHeight: o3.feature.properties.height, hidden: o3.hiddenByReplacement, verticalScale: o3.evaluatedScale[2] };
          }
        }
      }
      function $v(e4, t3) {
        return !e4.isLightConstant && t3;
      }
      function Wv(e4, t3, i3, r3, n4, o3, s6, a3) {
        let l3 = (61440 & t3 | (61440 & t3) >> 4) >> 8, c3 = (3840 & t3 | (3840 & t3) >> 4) >> 4, h3 = 240 & t3 | (240 & t3) >> 4;
        i3[3] > 0 && (l3 = Kr(l3, 255 * i3[0], i3[3]), c3 = Kr(c3, 255 * i3[1], i3[3]), h3 = Kr(h3, 255 * i3[2], i3[3]));
        const u3 = l3 << 8 | c3, d3 = h3 << 8 | Math.floor(255 * r3[3]), p3 = function(e5) {
          const t4 = z(e5, 0, 2);
          return Math.min(Math.round(0.5 * t4 * 255), 255);
        }(r3[2]) << 8 | 15 * r3[0] << 4 | 15 * r3[1], f3 = z(n4[0], 0, 1), m3 = z(n4[1], 0, 1), _3 = z(n4[2], 0, 1), g3 = z(n4[3], 0, 1);
        let y3, x3, v3, b3;
        if (f3 !== m3 && s6 !== o3 && m3 !== f3) {
          const e5 = s6 - o3;
          x3 = 1 / (e5 * (m3 - f3)), v3 = -(o3 + e5 * f3) / (e5 * (m3 - f3));
          const t4 = z(n4[4], -1, 1);
          b3 = Math.pow(10, t4), y3 = 255 * _3 << 8 | 255 * g3;
        } else
          y3 = 65535, x3 = 0, v3 = 1, b3 = 1;
        if (e4.emplaceBack(u3, d3, p3, y3, x3, v3, b3), a3) {
          const e5 = a3.length;
          a3.clear();
          for (let t4 = 0; t4 < e5; t4++)
            a3.emplaceBack(u3, d3, p3, y3, x3, v3, b3);
        }
      }
      function Hv(e4, t3) {
        const i3 = e4.node;
        let r3 = 0;
        for (const n4 of i3.meshes) {
          if (i3.lights && i3.lightMeshIndex === r3)
            continue;
          if (!n4.featureData)
            continue;
          n4.featureArray = new nl(), n4.featureArray.reserve(n4.featureData.length);
          let o3 = t3;
          for (const t4 of n4.featureData) {
            let r4;
            const s6 = 65535 & t4, a3 = (15 & s6) < 8 ? 15 & s6 : 0, l3 = t4 >> 16 & 65535, c3 = e4.evaluatedRMEA[a3], h3 = e4.evaluatedColor[a3], u3 = e4.emissionHeightBasedParams[a3];
            if (o3 && 2 === a3 && i3.lights && (r4 = new nl(), r4.resize(10 * i3.lights.length)), Wv(n4.featureArray, l3, h3, c3, u3, n4.aabb.min[2], n4.aabb.max[2], r4), r4 && o3) {
              o3 = false;
              const e5 = i3.meshes[i3.lightMeshIndex];
              e5.featureArray = r4, e5.featureArray._trim();
            }
          }
          n4.featureArray._trim(), r3++;
        }
      }
      Rs(Zv, "Tiled3dModelBucket", { omit: ["layers"] }), Rs(qv, "Tiled3dModelFeature");
      class Xv {
        constructor() {
          this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [];
        }
        clear() {
          this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
        }
        get updateTime() {
          return this._updateTime;
        }
        getReplacementRegionsForTile(e4) {
          const t3 = Qv(new y2(0, 0), new y2(cr, cr), e4), i3 = [];
          for (const r3 of this._activeRegions) {
            if (r3.hiddenByOverlap)
              continue;
            if (!Jv(t3, r3))
              continue;
            const n4 = eb(r3.min, r3.max, e4);
            i3.push({ min: n4.min, max: n4.max, sourceId: this._sourceIds[r3.priority], footprint: r3.footprint, footprintTileId: r3.tileId });
          }
          return i3;
        }
        setSources(e4) {
          this._setSources(e4.map((e5) => ({ getSourceId: () => e5.cache.id, getFootprints: () => {
            const t3 = [];
            for (const i3 of e5.cache.getVisibleCoordinates()) {
              const r3 = e5.cache.getTile(i3).buckets[e5.layer];
              if (r3)
                for (const e6 of r3.getNodesInfo()) {
                  const r4 = e6.node;
                  r4.footprint && t3.push({ footprint: r4.footprint, id: i3.toUnwrapped() });
                }
            }
            return t3;
          } })));
        }
        _addSource(e4) {
          const t3 = e4.getFootprints();
          if (0 !== t3.length) {
            for (const e5 of t3) {
              if (!e5.footprint)
                continue;
              const t4 = Qv(e5.footprint.min, e5.footprint.max, e5.id);
              this._activeRegions.push({ min: t4.min, max: t4.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: e5.id, footprint: e5.footprint });
            }
            this._sourceIds.push(e4.getSourceId());
          }
        }
        _computeReplacement() {
          this._activeRegions.sort((e5, t3) => e5.priority - t3.priority || Yv(e5.min, t3.min) || Yv(e5.max, t3.max));
          let e4 = this._activeRegions.length !== this._prevRegions.length;
          if (!e4) {
            let t3 = 0, i3 = 0;
            for (; !e4 && t3 !== this._activeRegions.length; ) {
              const r3 = this._activeRegions[t3], n4 = this._prevRegions[i3];
              e4 = r3.priority !== n4.priority || !Kv(r3, n4), ++t3, ++i3;
            }
          }
          if (e4) {
            ++this._updateTime;
            const e5 = (e6) => {
              const t3 = this._activeRegions;
              if (e6 >= t3.length)
                return e6;
              const i3 = t3[e6].priority;
              for (; e6 < t3.length && t3[e6].priority === i3; )
                ++e6;
              return e6;
            };
            if (this._sourceIds.length > 1) {
              let t3 = 0, i3 = e5(t3);
              for (; t3 !== i3; ) {
                let r3 = t3;
                const n4 = t3;
                for (; r3 !== i3; ) {
                  const e6 = this._activeRegions[r3];
                  e6.hiddenByOverlap = false;
                  for (let t4 = 0; t4 < n4; t4++) {
                    const i4 = this._activeRegions[t4];
                    if (!i4.hiddenByOverlap && Jv(e6, i4) && (e6.hiddenByOverlap = ib(e6.footprint, e6.tileId, i4.footprint, i4.tileId), e6.hiddenByOverlap))
                      break;
                  }
                  ++r3;
                }
                t3 = i3, i3 = e5(t3);
              }
            }
          }
        }
        _setSources(e4) {
          [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
          for (let t3 = e4.length - 1; t3 >= 0; t3--)
            this._addSource(e4[t3]);
          this._computeReplacement();
        }
      }
      function Yv(e4, t3) {
        return e4.x - t3.x || e4.y - t3.y;
      }
      function Kv(e4, t3) {
        return 0 === Yv(e4.min, t3.min) && 0 === Yv(e4.max, t3.max);
      }
      function Jv(e4, t3) {
        return !(e4.min.x > t3.max.x || e4.max.x < t3.min.x || e4.min.y > t3.max.y || e4.max.y < t3.min.y);
      }
      function Qv(e4, t3, i3) {
        const r3 = 1 / cr, n4 = 1 / (1 << i3.canonical.z), o3 = (t3.x * r3 + i3.canonical.x) * n4 + i3.wrap, s6 = (t3.y * r3 + i3.canonical.y) * n4;
        return { min: new y2((e4.x * r3 + i3.canonical.x) * n4 + i3.wrap, (e4.y * r3 + i3.canonical.y) * n4), max: new y2(o3, s6) };
      }
      function eb(e4, t3, i3) {
        const r3 = 1 << i3.canonical.z, n4 = ((t3.x - i3.wrap) * r3 - i3.canonical.x) * cr, o3 = (t3.y * r3 - i3.canonical.y) * cr;
        return { min: new y2(((e4.x - i3.wrap) * r3 - i3.canonical.x) * cr, (e4.y * r3 - i3.canonical.y) * cr), max: new y2(n4, o3) };
      }
      function tb(e4, t3, i3, r3, n4, o3, s6) {
        const a3 = e4.indices, l3 = e4.vertices, c3 = [];
        for (let h3 = r3; h3 < r3 + n4; h3 += 3) {
          const r4 = t3[i3[h3 + 0] + o3], n5 = t3[i3[h3 + 1] + o3], u3 = t3[i3[h3 + 2] + o3], d3 = Math.min(r4.x, n5.x, u3.x), p3 = Math.max(r4.x, n5.x, u3.x), f3 = Math.min(r4.y, n5.y, u3.y), m3 = Math.max(r4.y, n5.y, u3.y);
          c3.length = 0, e4.grid.query(new y2(d3, f3), new y2(p3, m3), c3);
          for (let e5 = 0; e5 < c3.length; e5++) {
            const t4 = c3[e5];
            if (Lp(l3[a3[3 * t4 + 0]], l3[a3[3 * t4 + 1]], l3[a3[3 * t4 + 2]], r4, n5, u3, s6))
              return true;
          }
        }
        return false;
      }
      function ib(e4, t3, i3, r3) {
        if (!e4 || !i3)
          return false;
        let n4 = e4.vertices;
        if (!t3.canonical.equals(r3.canonical) || t3.wrap !== r3.wrap) {
          if (i3.vertices.length < e4.vertices.length)
            return ib(i3, r3, e4, t3);
          const o3 = t3.canonical, s6 = r3.canonical, a3 = Math.pow(2, s6.z - o3.z);
          n4 = e4.vertices.map((e5) => new y2(e5.x * o3.x * cr * a3 - s6.x * cr, e5.y * o3.y * cr * a3 - s6.y * cr));
        }
        return tb(i3, n4, e4.indices, 0, e4.indices.length, 0, 0);
      }
      const rb = hm.types, nb = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius"], ob = ["fill-extrusion-flood-light-ground-radius"], sb = Math.pow(2, 13), ab = Math.pow(2, 15) - 1, lb = new y2(0, 1), cb = 2147483648;
      function hb(e4, t3, i3, r3, n4, o3, s6, a3) {
        e4.emplaceBack((t3 << 1) + s6, (i3 << 1) + o3, (Math.floor(r3 * sb) << 1) + n4, Math.round(a3));
      }
      function ub(e4, t3, i3, r3, n4, o3) {
        e4.emplaceBack(t3.x, t3.y, (i3.x << 1) + r3, (i3.y << 1) + n4, o3);
      }
      function db(e4, t3, i3) {
        const r3 = 16384;
        e4.emplaceBack(t3.x, t3.y, t3.z, i3[0] * r3, i3[1] * r3, i3[2] * r3);
      }
      class pb {
        constructor() {
          this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
        }
      }
      class fb {
        constructor() {
          this.centroidXY = new y2(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new y2(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new y2(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
        }
        span() {
          return new y2(this.max.x - this.min.x, this.max.y - this.min.y);
        }
      }
      class mb {
        constructor() {
          this.acc = new y2(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
        }
        startRing(e4, t3) {
          e4.min.x === Number.MAX_VALUE && (e4.min.x = e4.max.x = t3.x, e4.min.y = e4.max.y = t3.y);
        }
        appendEdge(e4, t3, i3) {
          this.accCount++, this.acc._add(t3);
          let r3 = !!this.borders;
          t3.x < e4.min.x ? (e4.min.x = t3.x, r3 = true) : t3.x > e4.max.x && (e4.max.x = t3.x, r3 = true), t3.y < e4.min.y ? (e4.min.y = t3.y, r3 = true) : t3.y > e4.max.y && (e4.max.y = t3.y, r3 = true), ((0 === t3.x || t3.x === cr) && t3.x === i3.x) != ((0 === t3.y || t3.y === cr) && t3.y === i3.y) && this.processBorderOverlap(t3, i3), r3 && this.checkBorderIntersection(t3, i3);
        }
        checkBorderIntersection(e4, t3) {
          t3.x < 0 != e4.x < 0 && this.addBorderIntersection(0, Kr(t3.y, e4.y, (0 - t3.x) / (e4.x - t3.x))), t3.x > cr != e4.x > cr && this.addBorderIntersection(1, Kr(t3.y, e4.y, (cr - t3.x) / (e4.x - t3.x))), t3.y < 0 != e4.y < 0 && this.addBorderIntersection(2, Kr(t3.x, e4.x, (0 - t3.y) / (e4.y - t3.y))), t3.y > cr != e4.y > cr && this.addBorderIntersection(3, Kr(t3.x, e4.x, (cr - t3.y) / (e4.y - t3.y)));
        }
        addBorderIntersection(e4, t3) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const i3 = this.borders[e4];
          t3 < i3[0] && (i3[0] = t3), t3 > i3[1] && (i3[1] = t3);
        }
        processBorderOverlap(e4, t3) {
          if (e4.x === t3.x) {
            if (e4.y === t3.y)
              return;
            const i3 = 0 === e4.x ? 0 : 1;
            this.addBorderIntersection(i3, t3.y), this.addBorderIntersection(i3, e4.y);
          } else {
            const i3 = 0 === e4.y ? 2 : 3;
            this.addBorderIntersection(i3, t3.x), this.addBorderIntersection(i3, e4.x);
          }
        }
        centroid() {
          return 0 === this.accCount ? new y2(0, 0) : new y2(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
        }
        intersectsCount() {
          return this.borders ? this.borders.reduce((e4, t3) => e4 + +(t3[0] !== Number.MAX_VALUE), 0) : 0;
        }
      }
      function _b(e4, t3) {
        const i3 = e4.add(t3)._unit(), r3 = z(e4.x * i3.x + e4.y * i3.y, -1, 1);
        var n4, o3, s6;
        return n4 = Math.acos(r3), Math.min(4, Math.max(-4, Math.tan(n4))) / 4 * ab * ((o3 = e4).x * (s6 = t3).y - o3.y * s6.x < 0 ? -1 : 1);
      }
      const gb = [(e4) => e4.x < 0, (e4) => e4.x > cr, (e4) => e4.y < 0, (e4) => e4.y > cr];
      function yb(e4, t3, i3, r3) {
        const n4 = [4];
        if (0 === r3)
          return n4;
        i3._mult(r3);
        const o3 = e4.sub(i3), s6 = t3.sub(i3), a3 = [e4, t3, o3, s6];
        for (let e5 = 0; e5 < 4; e5++)
          for (const t4 of a3)
            if (gb[e5](t4)) {
              n4.push(e5);
              break;
            }
        return n4;
      }
      class xb {
        constructor(e4) {
          this.vertexArray = new Ra(), this.indexArray = new Wa(), this.programConfigurations = new ec(e4.layers, e4.zoom, (e5) => ob.includes(e5)), this._segments = new xl(), this.hiddenByLandmarkVertexArray = new ol(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new xl();
        }
        getDefaultSegment() {
          return this.regionSegments[4];
        }
        hasData() {
          return 0 !== this.vertexArray.length;
        }
        addData(e4, t3, i3, r3 = false) {
          const n4 = e4.length;
          if (n4 > 2) {
            let o3 = Math.max(0, this._segments.get().length - 1);
            const s6 = this._segments._prepareSegment(4 * n4, this.vertexArray.length, 2 * this._segmentToGroundQuads[o3].length);
            let a3;
            o3 !== this._segments.get().length - 1 && (o3++, this._segmentToGroundQuads[o3] = [], this._segmentToRegionTriCounts[o3] = [0, 0, 0, 0, 0]);
            {
              const t4 = e4[0], i4 = e4[1];
              a3 = _b(t4.sub(e4[n4 - 1])._perp()._unit(), i4.sub(t4)._perp()._unit());
            }
            for (let l3 = 0; l3 < n4; l3++) {
              const c3 = l3 === n4 - 1 ? 0 : l3 + 1, h3 = e4[l3], u3 = e4[c3], d3 = e4[c3 === n4 - 1 ? 0 : c3 + 1], p3 = u3.sub(h3)._perp()._unit(), f3 = _b(p3, d3.sub(u3)._perp()._unit()), m3 = a3, _3 = f3;
              if (Eb(h3, u3, t3) || r3 && Mb(h3, t3) && Mb(u3, t3)) {
                a3 = f3;
                continue;
              }
              const g3 = s6.vertexLength;
              ub(this.vertexArray, h3, u3, 1, 1, m3), ub(this.vertexArray, h3, u3, 1, 0, m3), ub(this.vertexArray, h3, u3, 0, 1, _3), ub(this.vertexArray, h3, u3, 0, 0, _3), s6.vertexLength += 4;
              const y3 = yb(h3, u3, p3, i3);
              for (const e5 of y3)
                this._segmentToGroundQuads[o3].push({ id: g3, region: e5 }), this._segmentToRegionTriCounts[o3][e5] += 2, s6.primitiveLength += 2;
              a3 = f3;
            }
          }
        }
        prepareBorderSegments() {
          if (!this.hasData())
            return;
          const e4 = this._segments.get(), t3 = e4.length;
          for (let e5 = 0; e5 < t3; e5++)
            this._segmentToGroundQuads[e5].sort((e6, t4) => e6.region - t4.region);
          for (let i3 = 0; i3 < t3; i3++) {
            const t4 = this._segmentToGroundQuads[i3], r3 = e4[i3], n4 = this._segmentToRegionTriCounts[i3];
            n4.reduce((e5, t5) => e5 + t5, 0);
            let o3 = 0;
            for (let e5 = 0; e5 <= 4; e5++) {
              const t5 = n4[e5];
              if (0 !== t5) {
                let i4 = this.regionSegments[e5];
                i4 || (i4 = this.regionSegments[e5] = new xl());
                const n5 = { vertexOffset: r3.vertexOffset, primitiveOffset: r3.primitiveOffset + o3, vertexLength: r3.vertexLength, primitiveLength: t5 };
                i4.get().push(n5);
              }
              o3 += t5;
            }
            for (let e5 = 0; e5 < t4.length; e5++) {
              const i4 = t4[e5].id;
              this.indexArray.emplaceBack(i4, i4 + 1, i4 + 3), this.indexArray.emplaceBack(i4, i4 + 3, i4 + 2);
            }
          }
          this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
        }
        addPaintPropertiesData(e4, t3, i3, r3, n4, o3) {
          this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, e4, t3, i3, r3, n4, o3);
        }
        upload(e4) {
          this.hasData() && (this.vertexBuffer = e4.createVertexBuffer(this.vertexArray, $f.members), this.indexBuffer = e4.createIndexBuffer(this.indexArray));
        }
        uploadPaintProperties(e4) {
          this.hasData() && this.programConfigurations.upload(e4);
        }
        update(e4, t3, i3, r3, n4, o3) {
          this.hasData() && this.programConfigurations.updatePaintArrays(e4, t3, i3, r3, n4, o3);
        }
        updateHiddenByLandmark(e4) {
          if (!this.hasData())
            return;
          const t3 = e4.groundVertexCount + e4.groundVertexArrayOffset;
          if (0 === e4.groundVertexCount)
            return;
          const i3 = e4.flags & cb ? 1 : 0;
          for (let r3 = e4.groundVertexArrayOffset; r3 < t3; ++r3)
            this.hiddenByLandmarkVertexArray.emplace(r3, i3);
          this._needsHiddenByLandmarkUpdate = true;
        }
        uploadHiddenByLandmark(e4) {
          this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = e4.createVertexBuffer(this.hiddenByLandmarkVertexArray, Hf.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
        }
        destroy() {
          if (this.vertexBuffer) {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
            for (let e4 = 0; e4 <= 4; e4++) {
              const t3 = this.regionSegments[e4];
              t3 && t3.destroy();
            }
          }
        }
      }
      class vb {
        constructor(e4) {
          this.zoom = e4.zoom, this.canonical = e4.canonical, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((e5) => e5.fqid), this.index = e4.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = e4.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Wa(), this.footprintVertices = new za(), this.footprintSegments = [], this.layoutVertexArray = new Da(), this.centroidVertexArray = new _l(), this.indexArray = new Wa(), this.programConfigurations = new ec(e4.layers, e4.zoom, (e5) => nb.includes(e5)), this.segments = new xl(), this.stateDependentLayerIds = this.layers.filter((e5) => e5.isStateDependent()).map((e5) => e5.id), this.groundEffect = new xb(e4), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
        }
        populate(e4, t3, i3, r3) {
          this.features = [], this.hasPattern = Uf("fill-extrusion", this.layers, t3), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = ap(i3), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
          for (const { feature: n4, id: o3, index: s6, sourceLayerIndex: a3 } of e4) {
            const e5 = this.layers[0]._featureFilter.needGeometry, l3 = gp(n4, e5);
            if (!this.layers[0]._featureFilter.filter(new oa(this.zoom), l3, i3))
              continue;
            const c3 = { id: o3, sourceLayerIndex: a3, index: s6, geometry: e5 ? l3.geometry : _p(n4, i3, r3), properties: n4.properties, type: n4.type, patterns: {} }, h3 = this.layoutVertexArray.length;
            this.hasPattern ? this.features.push(Vf("fill-extrusion", this.layers, c3, this.zoom, t3)) : this.addFeature(c3, c3.geometry, s6, i3, {}, t3.availableImages, r3, t3.brightness), t3.featureIndex.insert(n4, c3.geometry, s6, a3, this.index, h3);
          }
          this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
        }
        addFeatures(e4, t3, i3, r3, n4, o3) {
          for (const e5 of this.features) {
            const { geometry: s6 } = e5;
            this.addFeature(e5, s6, e5.index, t3, i3, r3, n4, o3);
          }
          this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
        }
        update(e4, t3, i3, r3, n4) {
          const o3 = 0 !== Object.keys(e4).length;
          if (o3 && !this.stateDependentLayers.length)
            return;
          const s6 = o3 ? this.stateDependentLayers : this.layers;
          this.programConfigurations.updatePaintArrays(e4, t3, s6, i3, r3, n4), this.groundEffect.update(e4, t3, s6, i3, r3, n4);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
        }
        upload(e4) {
          this.uploaded || (this.layoutVertexBuffer = e4.createVertexBuffer(this.layoutVertexArray, Yf), this.indexBuffer = e4.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e4.createVertexBuffer(this.layoutVertexExtArray, Xf.members, true)), this.groundEffect.upload(e4)), this.groundEffect.uploadPaintProperties(e4), this.programConfigurations.upload(e4), this.uploaded = true;
        }
        uploadCentroid(e4) {
          this.groundEffect.uploadHiddenByLandmark(e4), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = e4.createVertexBuffer(this.centroidVertexArray, Wf.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e4, {}) / this.tileToMeter, c3 = [new y2(0, 0), new y2(cr, cr)], h3 = s6.projection, u3 = "globe" === h3.name, d3 = "Polygon" === rb[e4.type], p3 = new mb();
          p3.centroidDataIndex = this.centroidData.length;
          const f3 = new fb(), m3 = this.layers[0].paint.get("fill-extrusion-base").evaluate(e4, {}, r3) <= 0, _3 = this.layers[0].paint.get("fill-extrusion-height").evaluate(e4, {}, r3);
          f3.height = _3, f3.vertexArrayOffset = this.layoutVertexArray.length, f3.groundVertexArrayOffset = this.groundEffect.vertexArray.length, u3 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Fa());
          const g3 = Ff(t3, 500);
          for (let e5 = g3.length - 1; e5 >= 0; e5--) {
            const t4 = g3[e5];
            (0 === t4.length || (x3 = t4[0]).every((e6) => e6.x <= 0) || x3.every((e6) => e6.x >= cr) || x3.every((e6) => e6.y <= 0) || x3.every((e6) => e6.y >= cr)) && g3.splice(e5, 1);
          }
          var x3;
          let v3;
          if (u3)
            v3 = Cb(g3, c3, r3);
          else {
            v3 = [];
            for (const e5 of g3)
              v3.push({ polygon: e5, bounds: c3 });
          }
          const b3 = d3 ? this.edgeRadius : 0, w3 = b3 > 0 && this.zoom < 17, T3 = (e5, t4) => {
            if (0 === e5.length)
              return false;
            const i4 = e5[e5.length - 1];
            return t4.x === i4.x && t4.y === i4.y;
          };
          for (const { polygon: e5, bounds: t4 } of v3) {
            let i4 = 0, n5 = 0;
            for (const t5 of e5)
              d3 && !t5[0].equals(t5[t5.length - 1]) && t5.push(t5[0]), n5 += d3 ? t5.length - 1 : t5.length;
            const o4 = this.segments.prepareSegment((d3 ? 5 : 4) * n5, this.layoutVertexArray, this.indexArray);
            f3.footprintSegIdx < 0 && (f3.footprintSegIdx = this.footprintSegments.length), f3.polygonSegIdx < 0 && (f3.polygonSegIdx = this.polygonSegments.length);
            const s7 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, a4 = new pb();
            if (a4.vertexOffset = this.footprintVertices.length, a4.indexOffset = 3 * this.footprintIndices.length, a4.ringIndices = [], d3) {
              const n6 = [], s8 = [];
              i4 = o4.vertexLength;
              for (let i5 = 0; i5 < e5.length; i5++) {
                const c5 = e5[i5];
                c5.length && 0 !== i5 && s8.push(n6.length / 2);
                const d4 = [];
                let p4, f4;
                p4 = c5[1].sub(c5[0])._perp()._unit(), a4.ringIndices.push(c5.length - 1);
                for (let e6 = 1; e6 < c5.length; e6++) {
                  const t5 = c5[e6], i6 = c5[e6 === c5.length - 1 ? 1 : e6 + 1], s9 = t5.clone();
                  if (b3) {
                    f4 = i6.sub(t5)._perp()._unit();
                    const e7 = p4.add(f4)._unit(), r4 = b3 * Math.min(4, 1 / (p4.x * e7.x + p4.y * e7.y));
                    s9.x += r4 * e7.x, s9.y += r4 * e7.y, s9.x = Math.round(s9.x), s9.y = Math.round(s9.y), p4 = f4;
                  }
                  !m3 || 0 !== b3 && !w3 || T3(d4, s9) || d4.push(s9), hb(this.layoutVertexArray, s9.x, s9.y, 0, 0, 1, 1, 0), o4.vertexLength++, this.footprintVertices.emplaceBack(t5.x, t5.y), n6.push(t5.x, t5.y), u3 && db(this.layoutVertexExtArray, h3.projectTilePoint(s9.x, s9.y, r3), h3.upVector(r3, s9.x, s9.y));
                }
                m3 && (0 === b3 || w3) && (0 !== d4.length && T3(d4, d4[0]) && d4.pop(), this.groundEffect.addData(d4, t4, l3));
              }
              const c4 = Bf(n6, s8);
              for (let e6 = 0; e6 < c4.length; e6 += 3)
                this.footprintIndices.emplaceBack(a4.vertexOffset + c4[e6 + 0], a4.vertexOffset + c4[e6 + 1], a4.vertexOffset + c4[e6 + 2]), this.indexArray.emplaceBack(i4 + c4[e6], i4 + c4[e6 + 2], i4 + c4[e6 + 1]), o4.primitiveLength++;
              a4.indexCount += c4.length, a4.vertexCount += this.footprintVertices.length - a4.vertexOffset;
            }
            for (let n6 = 0; n6 < e5.length; n6++) {
              const s8 = e5[n6];
              p3.startRing(f3, s8[0]);
              let a5 = s8.length > 4 && Ab(s8[s8.length - 2], s8[0], s8[1]), c4 = b3 ? wb(s8[s8.length - 2], s8[0], s8[1], b3) : 0;
              const _4 = [];
              let g4, y3, x4;
              y3 = s8[1].sub(s8[0])._perp()._unit();
              let v4 = true;
              for (let e6 = 1, n7 = 0; e6 < s8.length; e6++) {
                let l4 = s8[e6 - 1], d4 = s8[e6];
                const w4 = s8[e6 === s8.length - 1 ? 1 : e6 + 1];
                if (p3.appendEdge(f3, d4, l4), Eb(d4, l4, t4)) {
                  b3 && (y3 = w4.sub(d4)._perp()._unit(), v4 = !v4);
                  continue;
                }
                const E3 = d4.sub(l4)._perp(), M3 = E3.x / (Math.abs(E3.x) + Math.abs(E3.y)), A3 = E3.y > 0 ? 1 : 0, S3 = l4.dist(d4);
                if (n7 + S3 > 32768 && (n7 = 0), b3) {
                  x4 = w4.sub(d4)._perp()._unit();
                  let e7 = Tb(l4, d4, w4, bb(y3, x4), b3);
                  isNaN(e7) && (e7 = 0);
                  const t5 = d4.sub(l4)._unit();
                  l4 = l4.add(t5.mult(c4))._round(), d4 = d4.add(t5.mult(-e7))._round(), c4 = e7, y3 = x4, m3 && this.zoom >= 17 && (T3(_4, l4) || _4.push(l4), T3(_4, d4) || _4.push(d4));
                }
                const I3 = o4.vertexLength, C3 = s8.length > 4 && Ab(l4, d4, w4);
                let z2 = Sb(n7, a5, v4);
                if (hb(this.layoutVertexArray, l4.x, l4.y, M3, A3, 0, 0, z2), hb(this.layoutVertexArray, l4.x, l4.y, M3, A3, 0, 1, z2), n7 += S3, z2 = Sb(n7, C3, !v4), a5 = C3, hb(this.layoutVertexArray, d4.x, d4.y, M3, A3, 0, 0, z2), hb(this.layoutVertexArray, d4.x, d4.y, M3, A3, 0, 1, z2), o4.vertexLength += 4, this.indexArray.emplaceBack(I3 + 0, I3 + 1, I3 + 2), this.indexArray.emplaceBack(I3 + 1, I3 + 3, I3 + 2), o4.primitiveLength += 2, b3) {
                  const r4 = i4 + (1 === e6 ? s8.length - 2 : e6 - 2), n8 = 1 === e6 ? i4 : r4 + 1;
                  if (this.indexArray.emplaceBack(I3 + 1, r4, I3 + 3), this.indexArray.emplaceBack(r4, n8, I3 + 3), o4.primitiveLength += 2, void 0 === g4 && (g4 = I3), !Eb(w4, s8[e6], t4)) {
                    const t5 = e6 === s8.length - 1 ? g4 : o4.vertexLength;
                    this.indexArray.emplaceBack(I3 + 2, I3 + 3, t5), this.indexArray.emplaceBack(I3 + 3, t5 + 1, t5), this.indexArray.emplaceBack(I3 + 3, n8, t5 + 1), o4.primitiveLength += 3;
                  }
                  v4 = !v4;
                }
                if (u3) {
                  const e7 = this.layoutVertexExtArray, t5 = h3.projectTilePoint(l4.x, l4.y, r3), i5 = h3.projectTilePoint(d4.x, d4.y, r3), n8 = h3.upVector(r3, l4.x, l4.y), o5 = h3.upVector(r3, d4.x, d4.y);
                  db(e7, t5, n8), db(e7, t5, n8), db(e7, i5, o5), db(e7, i5, o5);
                }
              }
              d3 && (i4 += s8.length - 1), m3 && b3 && this.zoom >= 17 && (0 !== _4.length && T3(_4, _4[0]) && _4.pop(), this.groundEffect.addData(_4, t4, l3, b3 > 0));
            }
            this.footprintSegments.push(a4), s7.triangleCount = this.indexArray.length - s7.triangleArrayOffset, this.polygonSegments.push(s7), ++f3.footprintSegLen, ++f3.polygonSegLen;
          }
          if (f3.vertexCount = this.layoutVertexArray.length - f3.vertexArrayOffset, f3.groundVertexCount = this.groundEffect.vertexArray.length - f3.groundVertexArrayOffset, 0 !== f3.vertexCount) {
            if (f3.centroidXY = p3.borders ? lb : this.encodeCentroid(p3, f3), this.centroidData.push(f3), p3.borders) {
              this.featuresOnBorder.push(p3);
              const e5 = this.featuresOnBorder.length - 1;
              for (let t4 = 0; t4 < p3.borders.length; t4++)
                p3.borders[t4][0] !== Number.MAX_VALUE && this.borderFeatureIndices[t4].push(e5);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e4, i3, n4, o3, r3, a3), this.groundEffect.addPaintPropertiesData(e4, i3, n4, o3, r3, a3), this.maxHeight = Math.max(this.maxHeight, _3);
          }
        }
        sortBorders() {
          for (let e4 = 0; e4 < this.borderFeatureIndices.length; e4++)
            this.borderFeatureIndices[e4].sort((t3, i3) => this.featuresOnBorder[t3].borders[e4][0] - this.featuresOnBorder[i3].borders[e4][0]);
        }
        splitToSubtiles() {
          const e4 = [];
          for (let t4 = 0; t4 < this.centroidData.length; t4++) {
            const i4 = this.centroidData[t4], r4 = +(i4.min.y + i4.max.y > cr), n5 = 2 * r4 + (+(i4.min.x + i4.max.x > cr) ^ r4);
            for (let r5 = 0; r5 < i4.polygonSegLen; r5++) {
              const o4 = i4.polygonSegIdx + r5;
              e4.push({ centroidIdx: t4, subtile: n5, polygonSegmentIdx: o4, triangleSegmentIdx: this.polygonSegments[o4].triangleSegIdx });
            }
          }
          const t3 = new Wa();
          e4.sort((e5, t4) => e5.triangleSegmentIdx === t4.triangleSegmentIdx ? e5.subtile - t4.subtile : e5.triangleSegmentIdx - t4.triangleSegmentIdx);
          let i3 = 0, r3 = 0, n4 = 0;
          for (const t4 of e4) {
            if (t4.triangleSegmentIdx !== i3)
              break;
            n4++;
          }
          const o3 = e4.length;
          for (; r3 !== e4.length; ) {
            i3 = e4[r3].triangleSegmentIdx;
            let s6 = 0, a3 = r3, l3 = r3;
            for (let t4 = a3; t4 < n4 && e4[t4].subtile === s6; t4++)
              l3++;
            for (; a3 !== n4; ) {
              const r4 = e4[a3];
              s6 = r4.subtile;
              const o4 = this.centroidData[r4.centroidIdx].min.clone(), c3 = this.centroidData[r4.centroidIdx].max.clone(), h3 = { vertexOffset: this.segments.segments[i3].vertexOffset, primitiveOffset: t3.length, vertexLength: this.segments.segments[i3].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
              for (let i4 = a3; i4 < l3; i4++) {
                const r5 = e4[i4], n5 = this.polygonSegments[r5.polygonSegmentIdx], s7 = this.centroidData[r5.centroidIdx].min, a4 = this.centroidData[r5.centroidIdx].max, l4 = this.indexArray.uint16;
                for (let e5 = n5.triangleArrayOffset; e5 < n5.triangleArrayOffset + n5.triangleCount; e5++)
                  t3.emplaceBack(l4[3 * e5], l4[3 * e5 + 1], l4[3 * e5 + 2]);
                h3.primitiveLength += n5.triangleCount, o4.x = Math.min(o4.x, s7.x), o4.y = Math.min(o4.y, s7.y), c3.x = Math.max(c3.x, a4.x), c3.y = Math.max(c3.y, a4.y);
              }
              h3.primitiveLength > 0 && this.triangleSubSegments.push({ segment: h3, min: o4, max: c3 }), a3 = l3;
              for (let t4 = a3; t4 < n4 && e4[t4].subtile === e4[a3].subtile; t4++)
                l3++;
            }
            r3 = n4;
            for (let t4 = r3; t4 < o3 && e4[t4].triangleSegmentIdx === e4[r3].triangleSegmentIdx; t4++)
              n4++;
          }
          t3._trim(), this.indexArray = t3;
        }
        getVisibleSegments(e4, t3, i3) {
          let r3 = 0, n4 = 0;
          const o3 = 1 << e4.canonical.z;
          if (t3) {
            const i4 = t3.getMinMaxForTile(e4);
            i4 && (r3 = i4.min, n4 = i4.max);
          }
          n4 += this.maxHeight;
          const s6 = e4.toUnwrapped();
          let a3;
          const l3 = [s6.canonical.x / o3 + s6.wrap, s6.canonical.y / o3], c3 = [(s6.canonical.x + 1) / o3 + s6.wrap, (s6.canonical.y + 1) / o3], h3 = new xl(), u3 = (e5, t4, i4) => [e5[0] * (1 - i4[0]) + t4[0] * i4[0], e5[1] * (1 - i4[1]) + t4[1] * i4[1]], d3 = [], p3 = [];
          for (const e5 of this.triangleSubSegments) {
            d3[0] = e5.min.x / cr, d3[1] = e5.min.y / cr, p3[0] = e5.max.x / cr, p3[1] = e5.max.y / cr;
            const t4 = u3(l3, c3, d3), o4 = u3(l3, c3, p3);
            if (0 === new ed([t4[0], t4[1], r3], [o4[0], o4[1], n4]).intersectsPrecise(i3)) {
              a3 && (h3.segments.push(a3), a3 = void 0);
              continue;
            }
            const s7 = e5.segment;
            a3 && a3.vertexOffset !== s7.vertexOffset && (h3.segments.push(a3), a3 = void 0), a3 ? (a3.vertexLength += s7.vertexLength, a3.primitiveLength += s7.primitiveLength) : a3 = { vertexOffset: s7.vertexOffset, primitiveLength: s7.primitiveLength, vertexLength: s7.vertexLength, primitiveOffset: s7.primitiveOffset, sortKey: void 0, vaos: {} };
          }
          return a3 && h3.segments.push(a3), h3;
        }
        encodeCentroid(e4, t3) {
          const i3 = e4.centroid(), r3 = t3.span(), n4 = Math.min(7, Math.round(r3.x * this.tileToMeter / 10)), o3 = Math.min(7, Math.round(r3.y * this.tileToMeter / 10));
          return new y2(z(i3.x, 1, cr - 1) << 3 | n4, z(i3.y, 1, cr - 1) << 3 | o3);
        }
        showCentroid(e4) {
          const t3 = this.centroidData[e4.centroidDataIndex];
          t3.flags &= cb, t3.centroidXY.x = 0, t3.centroidXY.y = 0, this.writeCentroidToBuffer(t3);
        }
        writeCentroidToBuffer(e4) {
          this.groundEffect.updateHiddenByLandmark(e4);
          const t3 = e4.vertexArrayOffset, i3 = e4.vertexCount + e4.vertexArrayOffset, r3 = e4.flags & cb ? lb : e4.centroidXY, n4 = this.centroidVertexArray.geta_centroid_pos0(t3);
          if (this.centroidVertexArray.geta_centroid_pos1(t3) !== r3.y || n4 !== r3.x) {
            for (let e5 = t3; e5 < i3; ++e5)
              this.centroidVertexArray.emplace(e5, r3.x, r3.y);
            this.needsCentroidUpdate = true;
          }
        }
        createCentroidsBuffer() {
          this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
          for (const e4 of this.centroidData)
            this.writeCentroidToBuffer(e4);
        }
        updateReplacement(e4, t3) {
          if (t3.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = t3.updateTime;
          const i3 = t3.getReplacementRegionsForTile(e4.toUnwrapped());
          if (function(e5, t4) {
            if (e5.length !== t4.length)
              return false;
            for (let i4 = 0; i4 < e5.length; i4++)
              if (e5[i4].sourceId !== t4[i4].sourceId || !Kv(e5[i4], t4[i4]))
                return false;
            return true;
          }(this.activeReplacements, i3))
            return;
          if (this.activeReplacements = i3, 0 === this.centroidVertexArray.length)
            this.createCentroidsBuffer();
          else
            for (const e5 of this.centroidData)
              e5.flags &= 2147483647;
          const r3 = [];
          for (const t4 of this.activeReplacements) {
            const i4 = Math.pow(2, t4.footprintTileId.canonical.z - e4.canonical.z);
            for (const n4 of this.centroidData)
              if (!(n4.flags & cb || t4.min.x > n4.max.x || n4.min.x > t4.max.x || t4.min.y > n4.max.y || n4.min.y > t4.max.y))
                for (let o3 = 0; o3 < n4.footprintSegLen; o3++) {
                  const s6 = this.footprintSegments[n4.footprintSegIdx + o3];
                  if (r3.length = 0, zb(this.footprintVertices, s6.vertexOffset, s6.vertexCount, t4.footprintTileId.canonical, e4.canonical, r3), tb(t4.footprint, r3, this.footprintIndices.uint16, s6.indexOffset, s6.indexCount, -s6.vertexOffset, -i4)) {
                    n4.flags |= cb;
                    break;
                  }
                }
          }
          for (const e5 of this.centroidData)
            this.writeCentroidToBuffer(e5);
          this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
        }
        footprintContainsPoint(e4, t3, i3) {
          let r3 = false;
          for (let n4 = 0; n4 < i3.footprintSegLen; n4++) {
            const o3 = this.footprintSegments[i3.footprintSegIdx + n4];
            let s6 = 0;
            for (const i4 of o3.ringIndices) {
              for (let n5 = s6, a3 = i4 + s6 - 1; n5 < i4 + s6; a3 = n5++) {
                const i5 = this.footprintVertices.int16[2 * (n5 + o3.vertexOffset) + 0], s7 = this.footprintVertices.int16[2 * (n5 + o3.vertexOffset) + 1], l3 = this.footprintVertices.int16[2 * (a3 + o3.vertexOffset) + 1];
                s7 > t3 != l3 > t3 && e4 < (this.footprintVertices.int16[2 * (a3 + o3.vertexOffset) + 0] - i5) * (t3 - s7) / (l3 - s7) + i5 && (r3 = !r3);
              }
              s6 = i4;
            }
          }
          return r3;
        }
        getHeightAtTileCoord(e4, t3) {
          let i3 = Number.NEGATIVE_INFINITY, r3 = true;
          const n4 = 4 * (e4 + cr) * cr + (t3 + cr);
          if (this.partLookup.hasOwnProperty(n4)) {
            const e5 = this.partLookup[n4];
            return e5 ? { height: e5.height, hidden: !!(e5.flags & cb) } : void 0;
          }
          for (const o3 of this.centroidData)
            e4 > o3.max.x || o3.min.x > e4 || t3 > o3.max.y || o3.min.y > t3 || this.footprintContainsPoint(e4, t3, o3) && o3 && o3.height > i3 && (i3 = o3.height, this.partLookup[n4] = o3, r3 = !!(o3.flags & cb));
          if (i3 !== Number.NEGATIVE_INFINITY)
            return { height: i3, hidden: r3 };
          this.partLookup[n4] = void 0;
        }
      }
      function bb(e4, t3) {
        const i3 = e4.add(t3)._unit();
        return e4.x * i3.x + e4.y * i3.y;
      }
      function wb(e4, t3, i3, r3) {
        const n4 = t3.sub(e4)._perp()._unit(), o3 = i3.sub(t3)._perp()._unit();
        return Tb(e4, t3, i3, bb(n4, o3), r3);
      }
      function Tb(e4, t3, i3, r3, n4) {
        const o3 = Math.sqrt(1 - r3 * r3);
        return Math.min(e4.dist(t3) / 3, t3.dist(i3) / 3, n4 * o3 / r3);
      }
      function Eb(e4, t3, i3) {
        return e4.x < i3[0].x && t3.x < i3[0].x || e4.x > i3[1].x && t3.x > i3[1].x || e4.y < i3[0].y && t3.y < i3[0].y || e4.y > i3[1].y && t3.y > i3[1].y;
      }
      function Mb(e4, t3) {
        return e4.x < t3[0].x || e4.x > t3[1].x || e4.y < t3[0].y || e4.y > t3[1].y;
      }
      function Ab(e4, t3, i3) {
        if (e4.x < 0 || e4.x >= cr || t3.x < 0 || t3.x >= cr || i3.x < 0 || i3.x >= cr)
          return false;
        const r3 = i3.sub(t3), n4 = r3.perp(), o3 = e4.sub(t3);
        return (r3.x * o3.x + r3.y * o3.y) / Math.sqrt((r3.x * r3.x + r3.y * r3.y) * (o3.x * o3.x + o3.y * o3.y)) > -0.866 && n4.x * o3.x + n4.y * o3.y < 0;
      }
      function Sb(e4, t3, i3) {
        const r3 = t3 ? 2 | e4 : -3 & e4;
        return i3 ? 1 | r3 : -2 & r3;
      }
      function Ib() {
        const e4 = Math.PI / 32, t3 = Math.tan(e4), i3 = qd;
        return i3 * Math.sqrt(1 + 2 * t3 * t3) - i3;
      }
      function Cb(e4, t3, i3) {
        const r3 = 1 << i3.z, n4 = ep(i3.x / r3), o3 = ep((i3.x + 1) / r3), s6 = tp(i3.y / r3), a3 = tp((i3.y + 1) / r3);
        return function(e5, t4, i4, r4, n5 = 0, o4) {
          const s7 = [];
          if (!e5.length || !i4 || !r4)
            return s7;
          const a4 = (e6, t5) => {
            for (const i5 of e6)
              s7.push({ polygon: i5, bounds: t5 });
          }, l3 = Math.ceil(Math.log2(i4)), c3 = Math.ceil(Math.log2(r4)), h3 = l3 - c3, u3 = [];
          for (let e6 = 0; e6 < Math.abs(h3); e6++)
            u3.push(h3 > 0 ? 0 : 1);
          for (let e6 = 0; e6 < Math.min(l3, c3); e6++)
            u3.push(0), u3.push(1);
          let d3 = e5;
          if (d3 = um(d3, t4[0].y - n5, t4[1].y + n5, 1), d3 = um(d3, t4[0].x - n5, t4[1].x + n5, 0), !d3.length)
            return s7;
          const p3 = [];
          for (u3.length ? p3.push({ polygons: d3, bounds: t4, depth: 0 }) : a4(d3, t4); p3.length; ) {
            const e6 = p3.pop(), t5 = e6.depth, i5 = u3[t5], r5 = e6.bounds[0], s8 = e6.bounds[1], l4 = 0 === i5 ? r5.x : r5.y, c4 = 0 === i5 ? s8.x : s8.y, h4 = o4 ? o4(i5, l4, c4) : 0.5 * (l4 + c4), d4 = um(e6.polygons, l4 - n5, h4 + n5, i5), f3 = um(e6.polygons, h4 - n5, c4 + n5, i5);
            if (d4.length) {
              const e7 = [r5, new y2(0 === i5 ? h4 : s8.x, 1 === i5 ? h4 : s8.y)];
              u3.length > t5 + 1 ? p3.push({ polygons: d4, bounds: e7, depth: t5 + 1 }) : a4(d4, e7);
            }
            if (f3.length) {
              const e7 = [new y2(0 === i5 ? h4 : r5.x, 1 === i5 ? h4 : r5.y), s8];
              u3.length > t5 + 1 ? p3.push({ polygons: f3, bounds: e7, depth: t5 + 1 }) : a4(f3, e7);
            }
          }
          return s7;
        }(e4, t3, Math.ceil((o3 - n4) / 11.25), Math.ceil((s6 - a3) / 11.25), 1, (e5, t4, n5) => {
          if (0 === e5)
            return 0.5 * (t4 + n5);
          {
            const e6 = tp((i3.y + t4 / cr) / r3);
            return (Jd(0.5 * (tp((i3.y + n5 / cr) / r3) + e6)) * r3 - i3.y) * cr;
          }
        });
      }
      function zb(e4, t3, i3, r3, n4, o3) {
        const s6 = Math.pow(2, r3.z - n4.z);
        for (let a3 = 0; a3 < i3; a3++) {
          let i4 = e4.int16[2 * (a3 + t3) + 0], l3 = e4.int16[2 * (a3 + t3) + 1];
          i4 = (i4 + n4.x * cr) * s6 - r3.x * cr, l3 = (l3 + n4.y * cr) * s6 - r3.y * cr, o3.push(new y2(i4, l3));
        }
      }
      Rs(vb, "FillExtrusionBucket", { omit: ["layers", "features"] }), Rs(fb, "PartData"), Rs(pb, "FootprintSegment"), Rs(mb, "BorderCentroidData"), Rs(xb, "GroundEffect");
      const Pb = new ga({ visibility: new fa(Pt["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new fa(Pt["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
      var Db = { paint: new ga({ "fill-extrusion-opacity": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ma(Pt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ma(Pt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ma(Pt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ma(Pt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new ma(Pt["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new ma(Pt["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new fa(Pt["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]) }), layout: Pb };
      class Rb extends y2 {
        constructor(e4, t3, i3) {
          super(e4, t3), this.z = i3;
        }
      }
      function Lb(e4, t3) {
        return e4.x * t3.x + e4.y * t3.y;
      }
      function kb(e4, t3) {
        if (1 === e4.length) {
          let i3 = 0;
          const r3 = t3[i3++];
          let n4;
          for (; !n4 || r3.equals(n4); )
            if (n4 = t3[i3++], !n4)
              return 1 / 0;
          for (; i3 < t3.length; i3++) {
            const o3 = t3[i3], s6 = e4[0], a3 = n4.sub(r3), l3 = o3.sub(r3), c3 = s6.sub(r3), h3 = Lb(a3, a3), u3 = Lb(a3, l3), d3 = Lb(l3, l3), p3 = Lb(c3, a3), f3 = Lb(c3, l3), m3 = h3 * d3 - u3 * u3, _3 = (d3 * p3 - u3 * f3) / m3, g3 = (h3 * f3 - u3 * p3) / m3, y3 = r3.z * (1 - _3 - g3) + n4.z * _3 + o3.z * g3;
            if (isFinite(y3))
              return y3;
          }
          return 1 / 0;
        }
        {
          let e5 = 1 / 0;
          for (const i3 of t3)
            e5 = Math.min(e5, i3.z);
          return e5;
        }
      }
      function Ob(e4, t3, i3, r3, n4, o3, s6, a3) {
        const l3 = s6 * n4.getElevationAt(e4, t3, true, true), c3 = 0 !== o3[0], h3 = c3 ? 0 === o3[1] ? s6 * (o3[0] / 7 - 450) : s6 * function(e5, t4, i4) {
          const r4 = Math.floor(t4[0] / 8), n5 = Math.floor(t4[1] / 8), o4 = 10 * (t4[0] - 8 * r4), s7 = 10 * (t4[1] - 8 * n5), a4 = e5.getElevationAt(r4, n5, true, true), l4 = e5.getMeterToDEM(i4), c4 = Math.floor(0.5 * (o4 * l4 - 1)), h4 = Math.floor(0.5 * (s7 * l4 - 1)), u3 = e5.tileCoordToPixel(r4, n5), d3 = 2 * c4 + 1, p3 = 2 * h4 + 1, f3 = function(e6, t5, i5, r5, n6) {
            return [e6.getElevationAtPixel(t5, i5, true), e6.getElevationAtPixel(t5 + n6, i5, true), e6.getElevationAtPixel(t5, i5 + n6, true), e6.getElevationAtPixel(t5 + r5, i5 + n6, true)];
          }(e5, u3.x - c4, u3.y - h4, d3, p3), m3 = Math.abs(f3[0] - f3[1]), _3 = Math.abs(f3[2] - f3[3]), g3 = Math.abs(f3[0] - f3[2]) + Math.abs(f3[1] - f3[3]), y3 = Math.min(0.25, 0.5 * l4 * (m3 + _3) / d3), x3 = Math.min(0.25, 0.5 * l4 * g3 / p3);
          return a4 + Math.max(y3 * o4, x3 * s7);
        }(n4, o3, a3) : l3;
        return { base: l3 + (0 === i3) ? -1 : i3, top: c3 ? Math.max(h3 + r3, l3 + i3 + 2) : l3 + r3 };
      }
      const Bb = new ga({ "line-cap": new ma(Pt.layout_line["line-cap"]), "line-join": new ma(Pt.layout_line["line-join"]), "line-miter-limit": new fa(Pt.layout_line["line-miter-limit"]), "line-round-limit": new fa(Pt.layout_line["line-round-limit"]), "line-sort-key": new ma(Pt.layout_line["line-sort-key"]), visibility: new fa(Pt.layout_line.visibility) });
      var Fb = { paint: new ga({ "line-opacity": new ma(Pt.paint_line["line-opacity"]), "line-color": new ma(Pt.paint_line["line-color"]), "line-translate": new fa(Pt.paint_line["line-translate"]), "line-translate-anchor": new fa(Pt.paint_line["line-translate-anchor"]), "line-width": new ma(Pt.paint_line["line-width"]), "line-gap-width": new ma(Pt.paint_line["line-gap-width"]), "line-offset": new ma(Pt.paint_line["line-offset"]), "line-blur": new ma(Pt.paint_line["line-blur"]), "line-dasharray": new ma(Pt.paint_line["line-dasharray"]), "line-pattern": new ma(Pt.paint_line["line-pattern"]), "line-gradient": new _a2(Pt.paint_line["line-gradient"]), "line-trim-offset": new fa(Pt.paint_line["line-trim-offset"]), "line-emissive-strength": new fa(Pt.paint_line["line-emissive-strength"]), "line-border-width": new ma(Pt.paint_line["line-border-width"]), "line-border-color": new ma(Pt.paint_line["line-border-color"]) }), layout: Bb };
      const Nb = (e4, t3, i3, r3, n4, o3, s6) => {
        const a3 = e4.transform, l3 = a3.calculatePixelsToTileUnitsMatrix(t3);
        return { u_matrix: jb(e4, t3, i3, r3), u_pixels_to_tile_units: l3, u_device_pixel_ratio: o3, u_units_to_pixels: [1 / a3.pixelsToGLUnits[0], 1 / a3.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: n4, u_texsize: qb(i3) && t3.lineAtlasTexture ? t3.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Vb(t3, e4.transform), u_alpha_discard_threshold: 0, u_trim_offset: s6, u_emissive_strength: i3.paint.get("line-emissive-strength") };
      }, Ub = (e4, t3, i3, r3, n4) => {
        const o3 = e4.transform;
        return { u_matrix: jb(e4, t3, i3, r3), u_texsize: t3.imageAtlasTexture ? t3.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: o3.calculatePixelsToTileUnitsMatrix(t3), u_device_pixel_ratio: n4, u_image: 0, u_tile_units_to_pixels: Vb(t3, o3), u_units_to_pixels: [1 / o3.pixelsToGLUnits[0], 1 / o3.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
      };
      function Vb(e4, t3) {
        return 1 / rv(e4, 1, t3.tileZoom);
      }
      function jb(e4, t3, i3, r3) {
        return e4.translatePosMatrix(r3 || t3.tileID.projMatrix, t3, i3.paint.get("line-translate"), i3.paint.get("line-translate-anchor"));
      }
      const Gb = (e4) => {
        const t3 = [];
        qb(e4) && t3.push("RENDER_LINE_DASH"), e4.paint.get("line-gradient") && t3.push("RENDER_LINE_GRADIENT");
        const i3 = e4.paint.get("line-trim-offset");
        return 0 === i3[0] && 0 === i3[1] || t3.push("RENDER_LINE_TRIM_OFFSET"), 0 !== e4.paint.get("line-border-width").constantOr(1) && t3.push("RENDER_LINE_BORDER"), t3;
      };
      function qb(e4) {
        const t3 = e4.paint.get("line-dasharray").value;
        return t3.value || "constant" !== t3.kind;
      }
      const Zb = new class extends ma {
        possiblyEvaluate(e4, t3) {
          return t3 = new oa(Math.floor(t3.zoom), { now: t3.now, fadeDuration: t3.fadeDuration, transition: t3.transition }), super.possiblyEvaluate(e4, t3);
        }
        evaluate(e4, t3, i3, r3) {
          return t3 = k2({}, t3, { zoom: Math.floor(t3.zoom) }), super.evaluate(e4, t3, i3, r3);
        }
      }(Fb.paint.properties["line-width"].specification);
      function $b(e4, t3) {
        return t3 > 0 ? t3 + 2 * e4 : e4;
      }
      Zb.useIntegerZoom = true;
      const Wb = new ga({ visibility: new fa(Pt.layout_background.visibility) });
      var Hb = { paint: new ga({ "background-color": new fa(Pt.paint_background["background-color"]), "background-pattern": new fa(Pt.paint_background["background-pattern"]), "background-opacity": new fa(Pt.paint_background["background-opacity"]), "background-emissive-strength": new fa(Pt.paint_background["background-emissive-strength"]) }), layout: Wb };
      const Xb = new ga({ visibility: new fa(Pt.layout_raster.visibility) });
      var Yb = { paint: new ga({ "raster-opacity": new fa(Pt.paint_raster["raster-opacity"]), "raster-color": new _a2(Pt.paint_raster["raster-color"]), "raster-color-mix": new fa(Pt.paint_raster["raster-color-mix"]), "raster-color-range": new fa(Pt.paint_raster["raster-color-range"]), "raster-hue-rotate": new fa(Pt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new fa(Pt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new fa(Pt.paint_raster["raster-brightness-max"]), "raster-saturation": new fa(Pt.paint_raster["raster-saturation"]), "raster-contrast": new fa(Pt.paint_raster["raster-contrast"]), "raster-resampling": new fa(Pt.paint_raster["raster-resampling"]), "raster-fade-duration": new fa(Pt.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new fa(Pt.paint_raster["raster-emissive-strength"]), "raster-array-band": new fa(Pt.paint_raster["raster-array-band"]), "raster-elevation": new fa(Pt.paint_raster["raster-elevation"]) }), layout: Xb };
      function Kb(e4, t3, i3, r3, n4, o3, s6, a3) {
        const l3 = [e4, i3, n4, t3, r3, o3, 1, 1, 1], c3 = [s6, a3, 1], h3 = Eu.adjoint([], l3), [u3, d3, p3] = Du.transformMat3(c3, c3, Eu.transpose(h3, h3));
        return Eu.multiply(l3, [u3, 0, 0, 0, d3, 0, 0, 0, p3], l3);
      }
      class Jb extends zt {
        constructor(e4, t3, i3, r3) {
          super(), this.id = e4, this.dispatcher = i3, this.coordinates = t3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(r3), this.options = t3, this._dirty = false;
        }
        load(e4, i3) {
          if (this._loaded = i3 || false, this.fire(new It("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url)
            return e4 && (this.coordinates = e4), this._loaded = true, void this._finishLoading();
          this._imageRequest = Ie(this.map._requestManager.transformRequest(this.url, ye.Image), (i4, r3) => {
            if (this._imageRequest = null, this._loaded = true, i4)
              this.fire(new Ct(i4));
            else if (r3) {
              const { HTMLImageElement: i5 } = t2;
              this.image = r3 instanceof i5 ? dt.getImageData(r3) : r3, this._dirty = true, this.width = this.image.width, this.height = this.image.height, e4 && (this.coordinates = e4), this._finishLoading();
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e4) {
          return e4.url ? (this._imageRequest && e4.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e4.url, this.load(e4.coordinates, this._loaded), this) : this;
        }
        setTexture(e4) {
          if (!(e4.handle instanceof WebGLTexture))
            throw new Error("The provided handle is not a WebGLTexture instance");
          return this.texture = new Ay(this.map.painter.context, e4.handle), this.width = e4.dimensions[0], this.height = e4.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new It("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e4) {
          this.map = e4, this.load();
        }
        onRemove() {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Ay || this.texture.destroy();
        }
        setCoordinates(e4) {
          if (this.coordinates = e4, this._boundsArray = void 0, !e4.length)
            return this;
          this.onNorthPole = false, this.onSouthPole = false;
          let t3 = e4[0][1], i3 = e4[0][1];
          for (const r4 of e4)
            r4[1] > i3 && (i3 = r4[1]), r4[1] < t3 && (t3 = r4[1]);
          const r3 = (i3 + t3) / 2;
          if (r3 > rp ? this.onNorthPole = true : r3 < -rp && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
            const t4 = e4.map(lp.fromLngLat);
            this.tileID = function(e5) {
              let t5 = 1 / 0, i4 = 1 / 0, r4 = -1 / 0, n4 = -1 / 0;
              for (const o4 of e5)
                t5 = Math.min(t5, o4.x), i4 = Math.min(i4, o4.y), r4 = Math.max(r4, o4.x), n4 = Math.max(n4, o4.y);
              const o3 = Math.max(r4 - t5, n4 - i4), s6 = Math.max(0, Math.floor(-Math.log(o3) / Math.LN2)), a3 = Math.pow(2, s6);
              return new ju(s6, Math.floor((t5 + r4) / 2 * a3), Math.floor((i4 + n4) / 2 * a3));
            }(t4), this.minzoom = this.maxzoom = this.tileID.z;
          }
          return this.fire(new It("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0;
        }
        _prepareData(e4) {
          for (const e5 in this.tiles) {
            const t4 = this.tiles[e5];
            "loaded" !== t4.state && (t4.state = "loaded", t4.texture = this.texture);
          }
          if (this._boundsArray)
            return;
          const t3 = Pg(this.tileID, this.map.transform.projection), [i3, r3, n4, o3] = this.coordinates.map((e5) => {
            const i4 = t3.projection.project(e5[0], e5[1]);
            return Rg(t3, i4)._round();
          });
          this.perspectiveTransform = function(e5, t4, i4, r4, n5, o4, s7, a3, l3, c3) {
            const h3 = Kb(0, 0, e5, 0, 0, t4, e5, t4), u3 = Kb(i4, r4, n5, o4, s7, a3, l3, c3);
            return Eu.multiply(u3, Eu.adjoint(h3, h3), u3), [u3[6] / u3[8] * e5 / cr, u3[7] / u3[8] * t4 / cr];
          }(this.width, this.height, i3.x, i3.y, r3.x, r3.y, o3.x, o3.y, n4.x, n4.y);
          const s6 = this._boundsArray = new Da();
          s6.emplaceBack(i3.x, i3.y, 0, 0), s6.emplaceBack(r3.x, r3.y, cr, 0), s6.emplaceBack(o3.x, o3.y, 0, cr), s6.emplaceBack(n4.x, n4.y, cr, cr), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = e4.createVertexBuffer(s6, Ly.members), this.boundsSegments = xl.simpleSegment(0, 0, 4, 2);
        }
        prepare() {
          const e4 = 0 !== Object.keys(this.tiles).length;
          if (this.tileID && !e4)
            return;
          const t3 = this.map.painter.context, i3 = t3.gl;
          !this._dirty || this.texture instanceof Ay || (this.texture ? this.texture.update(this.image) : (this.texture = new My(t3, this.image, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE)), this._dirty = false), e4 && this._prepareData(t3);
        }
        loadTile(e4, t3) {
          this.tileID && this.tileID.equals(e4.tileID.canonical) ? (this.tiles[String(e4.tileID.wrap)] = e4, e4.buckets = {}, t3(null)) : (e4.state = "errored", t3(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
      }
      class Qb extends Ta {
        constructor(e4) {
          super(e4, {}), this.implementation = e4, e4.slot && (this.slot = e4.slot);
        }
        is3D() {
          return "3d" === this.implementation.renderingMode;
        }
        hasOffscreenPass() {
          return void 0 !== this.implementation.prerender;
        }
        isLayerDraped(e4) {
          return void 0 !== this.implementation.renderToTile;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
        }
        onAdd(e4) {
          this.implementation.onAdd && this.implementation.onAdd(e4, e4.painter.context.gl);
        }
        onRemove(e4) {
          this.implementation.onRemove && this.implementation.onRemove(e4, e4.painter.context.gl);
        }
      }
      const ew = new ga({ visibility: new fa(Pt.layout_sky.visibility) });
      var tw = { paint: new ga({ "sky-type": new fa(Pt.paint_sky["sky-type"]), "sky-atmosphere-sun": new fa(Pt.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new fa(Pt.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new fa(Pt.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new fa(Pt.paint_sky["sky-gradient-radius"]), "sky-gradient": new _a2(Pt.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new fa(Pt.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new fa(Pt.paint_sky["sky-atmosphere-color"]), "sky-opacity": new fa(Pt.paint_sky["sky-opacity"]) }), layout: ew };
      function iw(e4, t3, i3) {
        const r3 = [0, 0, 1], n4 = Iu.identity([]);
        return Iu.rotateY(n4, n4, i3 ? -w2(e4) + Math.PI : w2(e4)), Iu.rotateX(n4, n4, -w2(t3)), Du.transformQuat(r3, r3, n4), Du.normalize(r3, r3);
      }
      var rw = { paint: new ga({}) };
      const nw = { circle: class extends Ta {
        constructor(e4, t3) {
          super(e4, Up, t3);
        }
        createBucket(e4) {
          return new vp(e4);
        }
        queryRadius(e4) {
          const t3 = e4;
          return kp("circle-radius", this, t3) + kp("circle-stroke-width", this, t3) + Op(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = Fp(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o3.angle, e4.pixelToTileUnitsFactor), c3 = this.paint.get("circle-radius").evaluate(t3, i3) + this.paint.get("circle-stroke-width").evaluate(t3, i3);
          return qp(e4, r3, o3, s6, a3, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l3, c3);
        }
        getProgramIds() {
          return ["circle"];
        }
        getDefaultProgramParams(e4, t3) {
          const i3 = Gp(this);
          return { config: new Ql(this, t3), defines: i3, overrideFog: false };
        }
      }, heatmap: class extends Ta {
        createBucket(e4) {
          return new Xp(e4);
        }
        constructor(e4, t3) {
          super(e4, nf, t3), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e4) {
          "heatmap-color" === e4 && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = of({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(e4) {
          return kp("heatmap-radius", this, e4);
        }
        queryIntersectsFeature(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = this.paint.get("heatmap-radius").evaluate(t3, i3);
          return qp(e4, r3, o3, s6, a3, true, true, new y2(0, 0), l3);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getDefaultProgramParams(e4, t3) {
          return "heatmap" === e4 ? { config: new Ql(this, t3), overrideFog: false } : {};
        }
      }, hillshade: class extends Ta {
        constructor(e4, t3) {
          super(e4, af, t3);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
        getDefaultProgramParams(e4, t3) {
          return { overrideFog: false };
        }
      }, fill: class extends Ta {
        constructor(e4, t3) {
          super(e4, qf, t3);
        }
        getProgramIds() {
          const e4 = this.paint.get("fill-pattern"), t3 = e4 && e4.constantOr(1), i3 = [t3 ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && i3.push(t3 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), i3;
        }
        getDefaultProgramParams(e4, t3) {
          return { config: new Ql(this, t3), overrideFog: false };
        }
        recalculate(e4, t3) {
          super.recalculate(e4, t3);
          const i3 = this.paint._values["fill-outline-color"];
          "constant" === i3.value.kind && void 0 === i3.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(e4) {
          return new jf(e4);
        }
        queryRadius() {
          return Op(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(e4, t3, i3, r3, n4, o3) {
          return !e4.queryGeometry.isAboveHorizon && Tp(Bp(e4.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o3.angle, e4.pixelToTileUnitsFactor), r3);
        }
        isTileClipped() {
          return true;
        }
      }, "fill-extrusion": class extends Ta {
        constructor(e4, t3) {
          super(e4, Db, t3), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(e4) {
          return new vb(e4);
        }
        queryRadius() {
          return Op(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        hasShadowPass() {
          return true;
        }
        cutoffRange() {
          return this.paint.get("fill-extrusion-cutoff-fade-range");
        }
        canCastShadows() {
          return true;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        queryIntersectsFeature(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
          const c3 = Fp(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o3.angle, e4.pixelToTileUnitsFactor), h3 = this.paint.get("fill-extrusion-height").evaluate(t3, i3), u3 = this.paint.get("fill-extrusion-base").evaluate(t3, i3), d3 = [0, 0], p3 = a3 && o3.elevation, f3 = o3.elevation ? o3.elevation.exaggeration() : 1, m3 = e4.tile.getBucket(this);
          if (p3 && m3 instanceof vb) {
            const e5 = m3.centroidVertexArray, t4 = l3 + 1;
            t4 < e5.length && (d3[0] = e5.geta_centroid_pos0(t4), d3[1] = e5.geta_centroid_pos1(t4));
          }
          if (0 === d3[0] && 1 === d3[1])
            return false;
          "globe" === o3.projection.name && (r3 = Cb([r3], [new y2(0, 0), new y2(cr, cr)], e4.tileID.canonical).map((e5) => e5.polygon).flat());
          const _3 = p3 ? a3 : null, [g3, x3] = function(e5, t4, i4, r4, n5, o4, s7, a4, l4, c4, h4) {
            return "globe" === e5.projection.name ? function(e6, t5, i5, r5, n6, o5, s8, a5, l5, c5, h5) {
              const u4 = [], d4 = [], p4 = e6.projection.upVectorScale(h5, e6.center.lat, e6.worldSize).metersToTile, f4 = [0, 0, 0, 1], m4 = [0, 0, 0, 1], _4 = (e7, t6, i6, r6) => {
                e7[0] = t6, e7[1] = i6, e7[2] = r6, e7[3] = 1;
              }, g4 = Ib();
              i5 > 0 && (i5 += g4), r5 += g4;
              for (const g5 of t5) {
                const t6 = [], y3 = [];
                for (const u5 of g5) {
                  const d5 = u5.x + n6.x, g6 = u5.y + n6.y, x4 = e6.projection.projectTilePoint(d5, g6, h5), v4 = e6.projection.upVector(h5, u5.x, u5.y);
                  let b3 = i5, w3 = r5;
                  if (s8) {
                    const e7 = Ob(d5, g6, i5, r5, s8, a5, l5, c5);
                    b3 += e7.base, w3 += e7.top;
                  }
                  0 !== i5 ? _4(f4, x4.x + v4[0] * p4 * b3, x4.y + v4[1] * p4 * b3, x4.z + v4[2] * p4 * b3) : _4(f4, x4.x, x4.y, x4.z), _4(m4, x4.x + v4[0] * p4 * w3, x4.y + v4[1] * p4 * w3, x4.z + v4[2] * p4 * w3), Du.transformMat4(f4, f4, o5), Du.transformMat4(m4, m4, o5), t6.push(new Rb(f4[0], f4[1], f4[2])), y3.push(new Rb(m4[0], m4[1], m4[2]));
                }
                u4.push(t6), d4.push(y3);
              }
              return [u4, d4];
            }(e5, t4, i4, r4, n5, o4, s7, a4, l4, c4, h4) : s7 ? function(e6, t5, i5, r5, n6, o5, s8, a5, l5) {
              const c5 = [], h5 = [], u4 = [0, 0, 0, 1];
              for (const d4 of e6) {
                const e7 = [], p4 = [];
                for (const c6 of d4) {
                  const h6 = c6.x + r5.x, d5 = c6.y + r5.y, f4 = Ob(h6, d5, t5, i5, o5, s8, a5, l5);
                  u4[0] = h6, u4[1] = d5, u4[2] = f4.base, u4[3] = 1, yu.transformMat4(u4, u4, n6), u4[3] = Math.max(u4[3], 1e-5);
                  const m4 = new Rb(u4[0] / u4[3], u4[1] / u4[3], u4[2] / u4[3]);
                  u4[0] = h6, u4[1] = d5, u4[2] = f4.top, u4[3] = 1, yu.transformMat4(u4, u4, n6), u4[3] = Math.max(u4[3], 1e-5);
                  const _4 = new Rb(u4[0] / u4[3], u4[1] / u4[3], u4[2] / u4[3]);
                  e7.push(m4), p4.push(_4);
                }
                c5.push(e7), h5.push(p4);
              }
              return [c5, h5];
            }(t4, i4, r4, n5, o4, s7, a4, l4, c4) : function(e6, t5, i5, r5, n6) {
              const o5 = [], s8 = [], a5 = n6[8] * t5, l5 = n6[9] * t5, c5 = n6[10] * t5, h5 = n6[11] * t5, u4 = n6[8] * i5, d4 = n6[9] * i5, p4 = n6[10] * i5, f4 = n6[11] * i5;
              for (const t6 of e6) {
                const e7 = [], i6 = [];
                for (const o6 of t6) {
                  const t7 = o6.x + r5.x, s9 = o6.y + r5.y, m4 = n6[0] * t7 + n6[4] * s9 + n6[12], _4 = n6[1] * t7 + n6[5] * s9 + n6[13], g4 = n6[2] * t7 + n6[6] * s9 + n6[14], y3 = n6[3] * t7 + n6[7] * s9 + n6[15], x4 = m4 + a5, v4 = _4 + l5, b3 = g4 + c5, w3 = Math.max(y3 + h5, 1e-5), T3 = m4 + u4, E3 = _4 + d4, M3 = g4 + p4, A3 = Math.max(y3 + f4, 1e-5);
                  e7.push(new Rb(x4 / w3, v4 / w3, b3 / w3)), i6.push(new Rb(T3 / A3, E3 / A3, M3 / A3));
                }
                o5.push(e7), s8.push(i6);
              }
              return [o5, s8];
            }(t4, i4, r4, n5, o4);
          }(o3, r3, u3, h3, c3, s6, _3, d3, f3, o3.center.lat, e4.tileID.canonical), v3 = e4.queryGeometry;
          return function(e5, t4, i4) {
            let r4 = 1 / 0;
            Tp(i4, t4) && (r4 = kb(i4, t4[0]));
            for (let n5 = 0; n5 < t4.length; n5++) {
              const o4 = t4[n5], s7 = e5[n5];
              for (let e6 = 0; e6 < o4.length - 1; e6++) {
                const t5 = o4[e6], n6 = [t5, o4[e6 + 1], s7[e6 + 1], s7[e6], t5];
                bp(i4, n6) && (r4 = Math.min(r4, kb(i4, n6)));
              }
            }
            return r4 !== 1 / 0 && r4;
          }(g3, x3, v3.isPointQuery() ? v3.screenBounds : v3.screenGeometry);
        }
      }, line: class extends Ta {
        constructor(e4, t3) {
          super(e4, Fb, t3), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(e4) {
          if ("line-gradient" === e4) {
            const e5 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = e5._styleExpression && e5._styleExpression.expression instanceof Yr, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(e4, t3) {
          super.recalculate(e4, t3), this.paint._values["line-floorwidth"] = Zb.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e4);
        }
        createBucket(e4) {
          return new Ey(e4);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getDefaultProgramParams(e4, t3) {
          const i3 = Gb(this);
          return { config: new Ql(this, t3), defines: i3, overrideFog: false };
        }
        queryRadius(e4) {
          const t3 = e4, i3 = $b(kp("line-width", this, t3), kp("line-gap-width", this, t3)), r3 = kp("line-offset", this, t3);
          return i3 / 2 + Math.abs(r3) + Op(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(e4, t3, i3, r3, n4, o3) {
          if (e4.queryGeometry.isAboveHorizon)
            return false;
          const s6 = Bp(e4.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o3.angle, e4.pixelToTileUnitsFactor), a3 = e4.pixelToTileUnitsFactor / 2 * $b(this.paint.get("line-width").evaluate(t3, i3), this.paint.get("line-gap-width").evaluate(t3, i3)), l3 = this.paint.get("line-offset").evaluate(t3, i3);
          return l3 && (r3 = function(e5, t4) {
            const i4 = [], r4 = new y2(0, 0);
            for (let n5 = 0; n5 < e5.length; n5++) {
              const o4 = e5[n5], s7 = [];
              for (let e6 = 0; e6 < o4.length; e6++) {
                const i5 = o4[e6], n6 = o4[e6 + 1], a4 = 0 === e6 ? r4 : i5.sub(o4[e6 - 1])._unit()._perp(), l4 = e6 === o4.length - 1 ? r4 : n6.sub(i5)._unit()._perp(), c3 = a4._add(l4)._unit();
                c3._mult(1 / (c3.x * l4.x + c3.y * l4.y)), s7.push(c3._mult(t4)._add(i5));
              }
              i4.push(s7);
            }
            return i4;
          }(r3, l3 * e4.pixelToTileUnitsFactor)), function(e5, t4, i4) {
            for (let r4 = 0; r4 < t4.length; r4++) {
              const n5 = t4[r4];
              if (e5.length >= 3) {
                for (let t5 = 0; t5 < n5.length; t5++)
                  if (zp(e5, n5[t5]))
                    return true;
              }
              if (Ep(e5, n5, i4))
                return true;
            }
            return false;
          }(s6, r3, a3);
        }
        isTileClipped() {
          return true;
        }
      }, symbol: oy, background: class extends Ta {
        constructor(e4, t3) {
          super(e4, Hb, t3);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
        getDefaultProgramParams(e4, t3) {
          return { overrideFog: false };
        }
      }, raster: class extends Ta {
        constructor(e4, t3) {
          super(e4, Yb, t3), this._updateColorRamp();
        }
        getProgramIds() {
          return ["raster"];
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-color"].value.value;
        }
        isLayerDraped(e4) {
          return !(e4 && e4._source instanceof Jb) || !e4._source.onNorthPole && !e4._source.onSouthPole && 0 === this.paint.get("raster-elevation");
        }
        _handleSpecialPaintPropertyUpdate(e4) {
          "raster-color" !== e4 && "raster-color-range" !== e4 || this._updateColorRamp();
        }
        _updateColorRamp() {
          if (!this.hasColorMap())
            return;
          const e4 = this._transitionablePaint._values["raster-color"].value.expression, [t3, i3] = this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 });
          this.colorRamp = of({ expression: e4, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: t3, end: i3 }], resolution: 256 }), this.colorRampTexture = null;
        }
      }, sky: class extends Ta {
        constructor(e4, t3) {
          super(e4, tw, t3), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e4) {
          "sky-gradient" === e4 ? this._updateColorRamp() : "sky-atmosphere-sun" !== e4 && "sky-atmosphere-halo-color" !== e4 && "sky-atmosphere-color" !== e4 && "sky-atmosphere-sun-intensity" !== e4 || (this._skyboxInvalidated = true);
        }
        _updateColorRamp() {
          this.colorRamp = of({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(e4) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return true;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const t3 = e4.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== t3.azimuthal || this._lightPosition.polar !== t3.polar;
          }
          return false;
        }
        getCenter(e4, t3) {
          if ("atmosphere" === this.paint.get("sky-type")) {
            const i4 = this.paint.get("sky-atmosphere-sun"), r3 = !i4, n4 = e4.style.light, o3 = n4.properties.get("position");
            return r3 && "viewport" === n4.properties.get("anchor") && H2("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), r3 ? iw(o3.azimuthal, 90 - o3.polar, t3) : iw(i4[0], 90 - i4[1], t3);
          }
          const i3 = this.paint.get("sky-gradient-center");
          return iw(i3[0], 90 - i3[1], t3);
        }
        isSky() {
          return true;
        }
        markSkyboxValid(e4) {
          this._skyboxInvalidated = false, this._lightPosition = e4.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return true;
        }
        getProgramIds() {
          const e4 = this.paint.get("sky-type");
          return "atmosphere" === e4 ? ["skyboxCapture", "skybox"] : "gradient" === e4 ? ["skyboxGradient"] : null;
        }
      }, slot: class extends Ta {
        constructor(e4, t3) {
          super(e4, rw);
        }
      }, model: class extends Ta {
        constructor(e4, t3) {
          super(e4, Nv, t3);
        }
        createBucket(e4) {
          return new Bv(e4);
        }
        getProgramIds() {
          return ["model"];
        }
        is3D() {
          return true;
        }
        hasShadowPass() {
          return true;
        }
        canCastShadows() {
          return true;
        }
        hasLightBeamPass() {
          return true;
        }
        cutoffRange() {
          return this.paint.get("model-cutoff-fade-range");
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _handleOverridablePaintPropertyUpdate(e4, t3, i3) {
          return !(!this.layout || t3.isDataDriven() || i3.isDataDriven() || "model-color" !== e4 && "model-color-mix-intensity" !== e4 && "model-rotation" !== e4 && "model-scale" !== e4 && "model-translation" !== e4 && "model-emissive-strength" !== e4);
        }
        _isPropertyZoomDependent(e4) {
          const t3 = this._transitionablePaint._values[e4];
          return null != t3 && null != t3.value && null != t3.value.expression && t3.value.expression instanceof Ao;
        }
        isZoomDependent() {
          return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
        }
      } };
      function ow(e4, t3) {
        return "custom" === e4.type ? new Qb(e4) : new nw[e4.type](e4, t3);
      }
      function sw(e4) {
        const { userImage: t3 } = e4;
        return !!(t3 && t3.render && t3.render()) && (e4.data.replace(new Uint8Array(t3.data.buffer)), true);
      }
      class aw extends zt {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = true;
        }
        createScope(e4) {
          this.images[e4] = {}, this.loaded[e4] = false, this.updatedImages[e4] = {}, this.patterns[e4] = {}, this.callbackDispatchedThisFrame[e4] = {}, this.atlasImage[e4] = new ef({ width: 1, height: 1 });
        }
        isLoaded() {
          for (const e4 in this.loaded)
            if (!this.loaded[e4])
              return false;
          return true;
        }
        setLoaded(e4, t3) {
          if (this.loaded[t3] !== e4 && (this.loaded[t3] = e4, e4)) {
            for (const { ids: e5, callback: i3 } of this.requestors)
              this._notify(e5, t3, i3);
            this.requestors = [];
          }
        }
        hasImage(e4, t3) {
          return !!this.getImage(e4, t3);
        }
        getImage(e4, t3) {
          return this.images[t3][e4];
        }
        addImage(e4, t3, i3) {
          this._validate(e4, i3) && (this.images[t3][e4] = i3);
        }
        _validate(e4, t3) {
          let i3 = true;
          return this._validateStretch(t3.stretchX, t3.data && t3.data.width) || (this.fire(new Ct(new Error(`Image "${e4}" has invalid "stretchX" value`))), i3 = false), this._validateStretch(t3.stretchY, t3.data && t3.data.height) || (this.fire(new Ct(new Error(`Image "${e4}" has invalid "stretchY" value`))), i3 = false), this._validateContent(t3.content, t3) || (this.fire(new Ct(new Error(`Image "${e4}" has invalid "content" value`))), i3 = false), i3;
        }
        _validateStretch(e4, t3) {
          if (!e4)
            return true;
          let i3 = 0;
          for (const r3 of e4) {
            if (r3[0] < i3 || r3[1] < r3[0] || t3 < r3[1])
              return false;
            i3 = r3[1];
          }
          return true;
        }
        _validateContent(e4, t3) {
          return !(e4 && (4 !== e4.length || e4[0] < 0 || t3.data.width < e4[0] || e4[1] < 0 || t3.data.height < e4[1] || e4[2] < 0 || t3.data.width < e4[2] || e4[3] < 0 || t3.data.height < e4[3] || e4[2] < e4[0] || e4[3] < e4[1]));
        }
        updateImage(e4, t3, i3) {
          i3.version = this.images[t3][e4].version + 1, this.images[t3][e4] = i3, this.updatedImages[t3][e4] = true;
        }
        removeImage(e4, t3) {
          const i3 = this.images[t3][e4];
          delete this.images[t3][e4], delete this.patterns[t3][e4], i3.userImage && i3.userImage.onRemove && i3.userImage.onRemove();
        }
        listImages(e4) {
          return Object.keys(this.images[e4]);
        }
        getImages(e4, t3, i3) {
          let r3 = true;
          const n4 = !!this.loaded[t3];
          if (!n4)
            for (const i4 of e4)
              this.images[t3][i4] || (r3 = false);
          n4 || r3 ? this._notify(e4, t3, i3) : this.requestors.push({ ids: e4, scope: t3, callback: i3 });
        }
        getUpdatedImages(e4) {
          return this.updatedImages[e4];
        }
        _notify(e4, t3, i3) {
          const r3 = {};
          for (const i4 of e4) {
            this.images[t3][i4] || this.fire(new It("styleimagemissing", { id: i4 }));
            const e5 = this.images[t3][i4];
            e5 ? r3[i4] = { data: e5.data.clone(), pixelRatio: e5.pixelRatio, sdf: e5.sdf, version: e5.version, stretchX: e5.stretchX, stretchY: e5.stretchY, content: e5.content, hasRenderCallback: Boolean(e5.userImage && e5.userImage.render) } : H2(`Image "${i4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          i3(null, r3);
        }
        getPixelSize(e4) {
          const { width: t3, height: i3 } = this.atlasImage[e4];
          return { width: t3, height: i3 };
        }
        getPattern(e4, t3) {
          const i3 = this.patterns[t3][e4], r3 = this.getImage(e4, t3);
          if (!r3)
            return null;
          if (i3 && i3.position.version === r3.version)
            return i3.position;
          if (i3)
            i3.position.version = r3.version;
          else {
            const i4 = { w: r3.data.width + 2, h: r3.data.height + 2, x: 0, y: 0 }, n4 = new Q_(i4, r3);
            this.patterns[t3][e4] = { bin: i4, position: n4 };
          }
          return this._updatePatternAtlas(t3), this.patterns[t3][e4].position;
        }
        bind(e4, t3) {
          const i3 = e4.gl;
          let r3 = this.atlasTexture[t3];
          r3 ? this.dirty && (r3.update(this.atlasImage[t3]), this.dirty = false) : (r3 = new My(e4, this.atlasImage[t3], i3.RGBA), this.atlasTexture[t3] = r3), r3.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas(e4) {
          const t3 = [];
          for (const i4 in this.patterns[e4])
            t3.push(this.patterns[e4][i4].bin);
          const { w: i3, h: r3 } = K_(t3), n4 = this.atlasImage[e4];
          n4.resize({ width: i3 || 1, height: r3 || 1 });
          for (const t4 in this.patterns[e4]) {
            const { bin: i4 } = this.patterns[e4][t4], r4 = i4.x + 1, o3 = i4.y + 1, s6 = this.images[e4][t4].data, a3 = s6.width, l3 = s6.height;
            ef.copy(s6, n4, { x: 0, y: 0 }, { x: r4, y: o3 }, { width: a3, height: l3 }), ef.copy(s6, n4, { x: 0, y: l3 - 1 }, { x: r4, y: o3 - 1 }, { width: a3, height: 1 }), ef.copy(s6, n4, { x: 0, y: 0 }, { x: r4, y: o3 + l3 }, { width: a3, height: 1 }), ef.copy(s6, n4, { x: a3 - 1, y: 0 }, { x: r4 - 1, y: o3 }, { width: 1, height: l3 }), ef.copy(s6, n4, { x: 0, y: 0 }, { x: r4 + a3, y: o3 }, { width: 1, height: l3 });
          }
          this.dirty = true;
        }
        beginFrame() {
          for (const e4 in this.images)
            this.callbackDispatchedThisFrame[e4] = {};
        }
        dispatchRenderCallbacks(e4, t3) {
          for (const i3 of e4) {
            if (this.callbackDispatchedThisFrame[t3][i3])
              continue;
            this.callbackDispatchedThisFrame[t3][i3] = true;
            const e5 = this.images[t3][i3];
            sw(e5) && this.updateImage(i3, t3, e5);
          }
        }
      }
      const lw = new ga({ anchor: new fa(Pt.light.anchor), position: new class {
        constructor(e4) {
          this.specification = e4;
        }
        possiblyEvaluate(e4, t3) {
          return K(e4.expression.evaluate(t3));
        }
        interpolate(e4, t3, i3) {
          return { x: Kr(e4.x, t3.x, i3), y: Kr(e4.y, t3.y, i3), z: Kr(e4.z, t3.z, i3), azimuthal: Kr(e4.azimuthal, t3.azimuthal, i3), polar: Kr(e4.polar, t3.polar, i3) };
        }
      }(Pt.light.position), color: new fa(Pt.light.color), intensity: new fa(Pt.light.intensity) });
      class cw extends zt {
        constructor(e4, t3 = "flat") {
          super(), this._transitionable = new la(lw), this.setLight(e4, t3), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e4, t3, i3 = {}) {
          this._validate(gs, e4, i3) || (this._transitionable.setTransitionOrValue(e4), this.id = t3);
        }
        updateTransitions(e4) {
          this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e4) {
          this.properties = this._transitioning.possiblyEvaluate(e4);
        }
        _validate(e4, t3, i3) {
          return (!i3 || false !== i3.validate) && Ss(this, e4.call(ms, k2({ value: t3, style: { glyphs: true, sprite: true }, styleSpec: Pt })));
        }
      }
      const hw = new ga({ source: new fa(Pt.terrain.source), exaggeration: new fa(Pt.terrain.exaggeration) });
      let uw = class extends zt {
        constructor(e4, t3, i3, r3) {
          super(), this.scope = i3, this._transitionable = new la(hw, r3), this._transitionable.setTransitionOrValue(e4, r3), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = t3;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(e4, t3) {
          this._transitionable.setTransitionOrValue(e4, t3);
        }
        updateTransitions(e4) {
          this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e4) {
          this.properties = this._transitioning.possiblyEvaluate(e4);
        }
        getExaggeration(e4) {
          return this._transitioning.possiblyEvaluate(new oa(e4)).get("exaggeration");
        }
        isZoomDependent() {
          const e4 = this._transitionable._values.exaggeration;
          return null != e4 && null != e4.value && null != e4.value.expression && e4.value.expression instanceof Ao;
        }
      };
      const dw = 45, pw = 65, fw = 0.05;
      function mw(e4, t3, i3, r3) {
        const n4 = P2(dw, pw, i3), [o3, s6] = _w(e4, r3);
        let a3 = 1 - Math.min(1, Math.exp((t3 - o3) / (s6 - o3) * -6));
        return a3 *= a3 * a3, a3 = Math.min(1, 1.00747 * a3), a3 * n4 * e4.alpha;
      }
      function _w(e4, t3) {
        const i3 = 0.5 / Math.tan(0.5 * t3);
        return [e4.range[0] + i3, e4.range[1] + i3];
      }
      function gw(e4, t3, i3, r3, n4) {
        const o3 = Du.transformMat4([], [t3, i3, r3], n4.mercatorFogMatrix);
        return mw(e4, Du.length(o3), n4.pitch, n4._fov);
      }
      function yw(e4, t3, i3, r3, n4, o3, s6) {
        const a3 = [[i3, r3, 0], [n4, r3, 0], [n4, o3, 0], [i3, o3, 0]];
        let l3 = Number.MAX_VALUE, c3 = -Number.MAX_VALUE;
        for (const e5 of a3) {
          const i4 = Du.transformMat4([], e5, t3), r4 = Du.length(i4);
          l3 = Math.min(l3, r4), c3 = Math.max(c3, r4);
        }
        return [mw(e4, l3, s6.pitch, s6._fov), mw(e4, c3, s6.pitch, s6._fov)];
      }
      const xw = new ga({ range: new fa(Pt.fog.range), color: new fa(Pt.fog.color), "high-color": new fa(Pt.fog["high-color"]), "space-color": new fa(Pt.fog["space-color"]), "horizon-blend": new fa(Pt.fog["horizon-blend"]), "star-intensity": new fa(Pt.fog["star-intensity"]), "vertical-range": new fa(Pt.fog["vertical-range"]) });
      class vw extends zt {
        constructor(e4, t3) {
          super(), this._transitionable = new la(xw), this.set(e4), this._transitioning = this._transitionable.untransitioned(), this._transform = t3;
        }
        get state() {
          const e4 = this._transform, t3 = "globe" === e4.projection.name, i3 = Dd(e4.zoom), r3 = this.properties.get("range"), n4 = [0.5, 3];
          return { range: t3 ? [Kr(n4[0], r3[0], i3), Kr(n4[1], r3[1], i3)] : r3, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(e4, t3 = {}) {
          if (this._validate(vs, e4, t3))
            return;
          const i3 = k2({}, e4);
          for (const e5 of Object.keys(Pt.fog))
            void 0 === i3[e5] && (i3[e5] = Pt.fog[e5].default);
          this._transitionable.setTransitionOrValue(i3);
        }
        getOpacity(e4) {
          if (!this._transform.projection.supportsFog)
            return 0;
          const t3 = this.properties && this.properties.get("color") || 1;
          return ("globe" === this._transform.projection.name ? 1 : P2(dw, pw, e4)) * t3.a;
        }
        getOpacityAtLatLng(e4, t3) {
          return this._transform.projection.supportsFog ? function(e5, t4, i3) {
            const r3 = lp.fromLngLat(t4), n4 = i3.elevation ? i3.elevation.getAtPointOrZero(r3) : 0;
            return gw(e5, r3.x, r3.y, n4, i3);
          }(this.state, e4, t3) : 0;
        }
        getOpacityForTile(e4) {
          if (!this._transform.projection.supportsFog)
            return [1, 1];
          const t3 = this._transform.calculateFogTileMatrix(e4.toUnwrapped());
          return yw(this.state, t3, 0, 0, cr, cr, this._transform);
        }
        getOpacityForBounds(e4, t3, i3, r3, n4) {
          return this._transform.projection.supportsFog ? yw(this.state, e4, t3, i3, r3, n4, this._transform) : [1, 1];
        }
        getFovAdjustedRange(e4) {
          return this._transform.projection.supportsFog ? _w(this.state, e4) : [0, 1];
        }
        isVisibleOnFrustum(e4) {
          if (!this._transform.projection.supportsFog)
            return false;
          const t3 = [4, 5, 6, 7];
          for (const i3 of t3) {
            const t4 = e4.points[i3];
            let r3;
            if (t4[2] >= 0)
              r3 = t4;
            else {
              const n4 = e4.points[i3 - 4];
              r3 = Jr(n4, t4, n4[2] / (n4[2] - t4[2]));
            }
            if (gw(this.state, r3[0], r3[1], 0, this._transform) >= fw)
              return true;
          }
          return false;
        }
        updateTransitions(e4) {
          this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e4) {
          this.properties = this._transitioning.possiblyEvaluate(e4);
        }
        _validate(e4, t3, i3) {
          return (!i3 || false !== i3.validate) && Ss(this, e4.call(ms, k2({ value: t3, style: { glyphs: true, sprite: true }, styleSpec: Pt })));
        }
      }
      class bw {
        constructor(e4) {
          this._callback = e4, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class ww {
        constructor() {
          this.tasks = {}, this.taskQueue = [], j2(["process"], this), this.invoker = new bw(this.process), this.nextId = 0;
        }
        add(e4, t3) {
          const i3 = this.nextId++, r3 = function({ type: e5, isSymbolTile: t4, zoom: i4 }) {
            return i4 = i4 || 0, "message" === e5 ? 0 : "maybePrepare" !== e5 || t4 ? "parseTile" !== e5 || t4 ? "parseTile" === e5 && t4 ? 300 - i4 : "maybePrepare" === e5 && t4 ? 400 - i4 : 500 : 200 - i4 : 100 - i4;
          }(t3);
          if (0 === r3) {
            Q();
            try {
              e4();
            } finally {
            }
            return { cancel: () => {
            } };
          }
          return this.tasks[i3] = { fn: e4, metadata: t3, priority: r3, id: i3 }, this.taskQueue.push(i3), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[i3];
          } };
        }
        process() {
          Q();
          try {
            if (this.taskQueue = this.taskQueue.filter((e5) => !!this.tasks[e5]), !this.taskQueue.length)
              return;
            const e4 = this.pick();
            if (null === e4)
              return;
            const t3 = this.tasks[e4];
            if (delete this.tasks[e4], this.taskQueue.length && this.invoker.trigger(), !t3)
              return;
            t3.fn();
          } finally {
          }
        }
        pick() {
          let e4 = null, t3 = 1 / 0;
          for (let i4 = 0; i4 < this.taskQueue.length; i4++) {
            const r3 = this.tasks[this.taskQueue[i4]];
            r3.priority < t3 && (t3 = r3.priority, e4 = i4);
          }
          if (null === e4)
            return null;
          const i3 = this.taskQueue[e4];
          return this.taskQueue.splice(e4, 1), i3;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class Tw {
        constructor(e4, t3, i3) {
          this.target = e4, this.parent = t3, this.mapId = i3, this.callbacks = {}, this.cancelCallbacks = {}, j2(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new ww();
        }
        send(e4, t3, i3, r3, n4 = false, o3) {
          const s6 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          i3 && (i3.metadata = o3, this.callbacks[s6] = i3);
          const a3 = /* @__PURE__ */ new Set();
          return this.target.postMessage({ id: s6, type: e4, hasCallback: !!i3, targetMapId: r3, mustQueue: n4, sourceMapId: this.mapId, data: Os(t3, a3) }, a3), { cancel: () => {
            i3 && delete this.callbacks[s6], this.target.postMessage({ id: s6, type: "<cancel>", targetMapId: r3, sourceMapId: this.mapId });
          } };
        }
        receive(e4) {
          const t3 = e4.data, i3 = t3.id;
          if (i3 && (!t3.targetMapId || this.mapId === t3.targetMapId))
            if ("<cancel>" === t3.type) {
              const e5 = this.cancelCallbacks[i3];
              delete this.cancelCallbacks[i3], e5 && e5.cancel();
            } else if (t3.mustQueue || Q()) {
              const e5 = this.callbacks[i3];
              this.cancelCallbacks[i3] = this.scheduler.add(() => this.processTask(i3, t3), e5 && e5.metadata || { type: "message" });
            } else
              this.processTask(i3, t3);
        }
        processTask(e4, t3) {
          if ("<response>" === t3.type) {
            const i3 = this.callbacks[e4];
            delete this.callbacks[e4], i3 && (t3.error ? i3(Bs(t3.error)) : i3(null, Bs(t3.data)));
          } else {
            const i3 = /* @__PURE__ */ new Set(), r3 = t3.hasCallback ? (t4, r4) => {
              delete this.cancelCallbacks[e4], this.target.postMessage({ id: e4, type: "<response>", sourceMapId: this.mapId, error: t4 ? Os(t4) : null, data: Os(r4, i3) }, i3);
            } : (e5) => {
            }, n4 = Bs(t3.data);
            if (this.parent[t3.type])
              this.parent[t3.type](t3.sourceMapId, n4, r3);
            else if (this.parent.getWorkerSource) {
              const e5 = t3.type.split(".");
              this.parent.getWorkerSource(t3.sourceMapId, e5[0], n4.source, n4.scope)[e5[1]](n4, r3);
            } else
              r3(new Error(`Could not find function ${t3.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      }
      class Ew {
        constructor(e4, t3) {
          this.workerPool = e4, this.actors = [], this.currentActor = 0, this.id = F();
          const i3 = this.workerPool.acquire(this.id);
          for (let e5 = 0; e5 < i3.length; e5++) {
            const r3 = new Ew.Actor(i3[e5], t3, this.id);
            r3.name = `Worker ${e5}`, this.actors.push(r3);
          }
          this.ready = false, this.broadcast("checkIfReady", null, () => {
            this.ready = true;
          });
        }
        broadcast(e4, t3, i3) {
          R2(this.actors, (i4, r3) => {
            i4.send(e4, t3, r3);
          }, i3 = i3 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((e4) => {
            e4.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      Ew.Actor = Tw;
      class Mw extends zt {
        constructor(e4, t3, i3, r3) {
          super(), this.scope = i3, this._options = e4, this.properties = new pa(t3), this._transitionable = new la(t3, new Map(r3)), this._transitionable.setTransitionOrValue(e4.properties), this._transitioning = this._transitionable.untransitioned();
        }
        updateConfig(e4) {
          this._transitionable.setTransitionOrValue(this._options.properties, new Map(e4));
        }
        updateTransitions(e4) {
          this._transitioning = this._transitionable.transitioned(e4, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e4) {
          this.properties = this._transitioning.possiblyEvaluate(e4);
        }
        get() {
          return this._options.properties = this._transitionable.serialize(), this._options;
        }
        set(e4, t3) {
          this._options = e4, this._transitionable.setTransitionOrValue(e4.properties, t3);
        }
        shadowsEnabled() {
          return !!this.properties && true === this.properties.get("cast-shadows");
        }
      }
      const Aw = new ga({ color: new fa(Pt.properties_light_ambient.color), intensity: new fa(Pt.properties_light_ambient.intensity) }), Sw = new ga({ direction: new class {
        constructor(e4) {
          this.specification = e4;
        }
        possiblyEvaluate(e4, t3) {
          return function([e5, t4]) {
            const i3 = K([1, e5, t4]);
            return { x: i3.x, y: i3.y, z: i3.z };
          }(e4.expression.evaluate(t3));
        }
        interpolate(e4, t3, i3) {
          return { x: Kr(e4.x, t3.x, i3), y: Kr(e4.y, t3.y, i3), z: Kr(e4.z, t3.z, i3) };
        }
      }(Pt.properties_light_directional.direction), color: new fa(Pt.properties_light_directional.color), intensity: new fa(Pt.properties_light_directional.intensity), "cast-shadows": new fa(Pt.properties_light_directional["cast-shadows"]), "shadow-intensity": new fa(Pt.properties_light_directional["shadow-intensity"]) });
      class Iw {
        constructor(e4, t3, i3, r3) {
          this.screenBounds = e4, this.cameraPoint = t3, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i3, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, r3);
        }
        static createFromScreenPoints(e4, t3) {
          let i3, r3;
          if (e4 instanceof y2 || "number" == typeof e4[0]) {
            const n4 = y2.convert(e4);
            i3 = [n4], r3 = t3.isPointAboveHorizon(n4);
          } else {
            const n4 = y2.convert(e4[0]), o3 = y2.convert(e4[1]);
            i3 = [n4, o3], r3 = S2(n4, o3).every((e5) => t3.isPointAboveHorizon(e5));
          }
          return new Iw(i3, t3.getCameraPoint(), r3, t3);
        }
        isPointQuery() {
          return 1 === this.screenBounds.length;
        }
        bufferedScreenGeometry(e4) {
          return S2(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], e4);
        }
        bufferedCameraGeometry(e4) {
          const t3 = this.screenBounds[0], i3 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new y2(1, 1)) : this.screenBounds[1], r3 = S2(t3, i3, 0, false);
          return this.cameraPoint.y > i3.y && (this.cameraPoint.x > t3.x && this.cameraPoint.x < i3.x ? r3.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= i3.x ? r3[2] = this.cameraPoint : this.cameraPoint.x <= t3.x && (r3[3] = this.cameraPoint)), function(e5, t4) {
            const i4 = [];
            for (let r4 = 0; r4 < e5.length; r4++) {
              const n4 = D(r4 - 1, -1, e5.length - 1), o3 = D(r4 + 1, -1, e5.length - 1), s6 = e5[r4], a3 = e5[o3], l3 = e5[n4].sub(s6).unit(), c3 = a3.sub(s6).unit(), h3 = c3.angleWithSep(l3.x, l3.y), u3 = l3.add(c3).unit().mult(-1 * t4 / Math.sin(h3 / 2));
              i4.push(s6.add(u3));
            }
            return i4;
          }(r3, e4);
        }
        bufferedCameraGeometryGlobe(e4) {
          const t3 = this.screenBounds[0], i3 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new y2(1, 1)) : this.screenBounds[1], r3 = S2(t3, i3, e4), n4 = this.cameraPoint.clone();
          switch (3 * ((n4.y > t3.y) + (n4.y > i3.y)) + ((n4.x > t3.x) + (n4.x > i3.x))) {
            case 0:
              r3[0] = n4, r3[4] = n4.clone();
              break;
            case 1:
              r3.splice(1, 0, n4);
              break;
            case 2:
              r3[1] = n4;
              break;
            case 3:
              r3.splice(4, 0, n4);
              break;
            case 5:
              r3.splice(2, 0, n4);
              break;
            case 6:
              r3[3] = n4;
              break;
            case 7:
              r3.splice(3, 0, n4);
              break;
            case 8:
              r3[2] = n4;
          }
          return r3;
        }
        containsTile(e4, t3, i3, r3 = 0) {
          const n4 = e4.queryPadding / t3._pixelsPerMercatorPixel + 1, o3 = i3 ? this._bufferedCameraMercator(n4, t3) : this._bufferedScreenMercator(n4, t3);
          let s6 = e4.tileID.wrap + (o3.unwrapped ? r3 : 0);
          const a3 = o3.polygon.map((t4) => Rg(e4.tileTransform, t4, s6));
          if (!Pp(a3, 0, 0, cr, cr))
            return;
          s6 = e4.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r3 : 0);
          const l3 = this.screenGeometryMercator.polygon.map((t4) => Lg(e4.tileTransform, t4, s6)), c3 = l3.map((e5) => new y2(e5[0], e5[1])), h3 = t3.getFreeCameraOptions().position || new lp(0, 0, 0), u3 = Lg(e4.tileTransform, h3, s6), d3 = l3.map((e5) => {
            const t4 = Du.sub(e5, e5, u3);
            return Du.normalize(t4, t4), new Wu(u3, t4);
          }), p3 = rv(e4, 1, t3.zoom) * t3._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: c3, tilespaceRays: d3, bufferedTilespaceGeometry: a3, bufferedTilespaceBounds: (f3 = A2(a3), f3.min.x = z(f3.min.x, 0, cr), f3.min.y = z(f3.min.y, 0, cr), f3.max.x = z(f3.max.x, 0, cr), f3.max.y = z(f3.max.y, 0, cr), f3), tile: e4, tileID: e4.tileID, pixelToTileUnitsFactor: p3 };
          var f3;
        }
        _bufferedScreenMercator(e4, t3) {
          const i3 = Pw(e4);
          if (this._screenRaycastCache[i3])
            return this._screenRaycastCache[i3];
          {
            let r3;
            return r3 = "globe" === t3.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e4), t3) : { polygon: this.bufferedScreenGeometry(e4).map((e5) => t3.pointCoordinate3D(e5)), unwrapped: true }, this._screenRaycastCache[i3] = r3, r3;
          }
        }
        _bufferedCameraMercator(e4, t3) {
          const i3 = Pw(e4);
          if (this._cameraRaycastCache[i3])
            return this._cameraRaycastCache[i3];
          {
            let r3;
            return r3 = "globe" === t3.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e4), t3) : { polygon: this.bufferedCameraGeometry(e4).map((e5) => t3.pointCoordinate3D(e5)), unwrapped: true }, this._cameraRaycastCache[i3] = r3, r3;
          }
        }
        _projectAndResample(e4, t3) {
          const i3 = function(e5, t4) {
            const i4 = Au.multiply([], t4.pixelMatrix, t4.globeMatrix), r4 = [0, -rd, 0, 1], n4 = [0, rd, 0, 1], o3 = [0, 0, 0, 1];
            yu.transformMat4(r4, r4, i4), yu.transformMat4(n4, n4, i4), yu.transformMat4(o3, o3, i4);
            const s6 = new y2(r4[0] / r4[3], r4[1] / r4[3]), a3 = new y2(n4[0] / n4[3], n4[1] / n4[3]), l3 = zp(e5, s6) && r4[3] < o3[3], c3 = zp(e5, a3) && n4[3] < o3[3];
            if (!l3 && !c3)
              return null;
            const h3 = function(e6, t5, i5) {
              for (let r5 = 1; r5 < e6.length; r5++) {
                const n5 = zw(t5.pointCoordinate3D(e6[r5 - 1]).x), o4 = zw(t5.pointCoordinate3D(e6[r5]).x);
                if (i5 < 0) {
                  if (n5 < o4)
                    return { idx: r5, t: -n5 / (o4 - 1 - n5) };
                } else if (o4 < n5)
                  return { idx: r5, t: (1 - n5) / (o4 + 1 - n5) };
              }
              return null;
            }(e5, t4, l3 ? -1 : 1);
            if (!h3)
              return null;
            const { idx: u3, t: d3 } = h3;
            let p3 = u3 > 1 ? Cw(e5.slice(0, u3), t4) : [], f3 = u3 < e5.length ? Cw(e5.slice(u3), t4) : [];
            p3 = p3.map((e6) => new y2(zw(e6.x), e6.y)), f3 = f3.map((e6) => new y2(zw(e6.x), e6.y));
            const m3 = [...p3];
            0 === m3.length && m3.push(f3[f3.length - 1]);
            const _3 = Kr(m3[m3.length - 1].y, (0 === f3.length ? p3[0] : f3[0]).y, d3);
            let g3;
            return g3 = l3 ? [new y2(0, _3), new y2(0, 0), new y2(1, 0), new y2(1, _3)] : [new y2(1, _3), new y2(1, 1), new y2(0, 1), new y2(0, _3)], m3.push(...g3), 0 === f3.length ? m3.push(p3[0]) : m3.push(...f3), { polygon: m3.map((e6) => new lp(e6.x, e6.y)), unwrapped: false };
          }(e4, t3);
          if (i3)
            return i3;
          const r3 = function(e5, t4) {
            let i4 = false, r4 = -1 / 0, n4 = 0;
            for (let t5 = 0; t5 < e5.length - 1; t5++)
              e5[t5].x > r4 && (r4 = e5[t5].x, n4 = t5);
            for (let t5 = 0; t5 < e5.length - 1; t5++) {
              const r5 = (n4 + t5) % (e5.length - 1), o4 = e5[r5], s6 = e5[r5 + 1];
              Math.abs(o4.x - s6.x) > 0.5 && (o4.x < s6.x ? (o4.x += 1, 0 === r5 && (e5[e5.length - 1].x += 1)) : (s6.x += 1, r5 + 1 === e5.length - 1 && (e5[0].x += 1)), i4 = true);
            }
            const o3 = Kd(t4.center.lng);
            return i4 && o3 < Math.abs(o3 - 1) && e5.forEach((e6) => {
              e6.x -= 1;
            }), { polygon: e5, unwrapped: i4 };
          }(Cw(e4, t3).map((e5) => new y2(zw(e5.x), e5.y)), t3);
          return { polygon: r3.polygon.map((e5) => new lp(e5.x, e5.y)), unwrapped: r3.unwrapped };
        }
      }
      function Cw(e4, t3) {
        return hp(e4, (e5) => {
          const i3 = t3.pointCoordinate3D(e5);
          e5.x = i3.x, e5.y = i3.y;
        }, 1 / 256);
      }
      function zw(e4) {
        return e4 < 0 ? 1 + e4 % 1 : e4 % 1;
      }
      function Pw(e4) {
        return 100 * e4 | 0;
      }
      function Dw(e4, t3, i3, r3, n4) {
        const o3 = function(i4, r4) {
          if (i4)
            return n4(i4);
          if (r4) {
            e4.url && r4.tiles && e4.tiles && delete e4.tiles;
            const i5 = O(k2(r4, e4), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            r4.vector_layers && (i5.vectorLayers = r4.vector_layers, i5.vectorLayerIds = i5.vectorLayers.map((e5) => e5.id)), i5.tiles = t3.canonicalizeTileset(i5, e4.url), n4(null, i5);
          }
        };
        return e4.url ? we(t3.transformRequest(t3.normalizeSourceURL(e4.url, null, i3, r3), ye.Source), o3) : dt.frame(() => o3(null, e4));
      }
      class Rw {
        constructor(e4, t3, i3) {
          this.bounds = sc.convert(this.validateBounds(e4)), this.minzoom = t3 || 0, this.maxzoom = i3 || 24;
        }
        validateBounds(e4) {
          return Array.isArray(e4) && 4 === e4.length ? [Math.max(-180, e4[0]), Math.max(-90, e4[1]), Math.min(180, e4[2]), Math.min(90, e4[3])] : [-180, -90, 180, 90];
        }
        contains(e4) {
          const t3 = Math.pow(2, e4.z), i3 = Math.floor(Kd(this.bounds.getWest()) * t3), r3 = Math.floor(Jd(this.bounds.getNorth()) * t3), n4 = Math.ceil(Kd(this.bounds.getEast()) * t3), o3 = Math.ceil(Jd(this.bounds.getSouth()) * t3);
          return e4.x >= i3 && e4.x < n4 && e4.y >= r3 && e4.y < o3;
        }
      }
      class Lw {
        constructor(e4, t3) {
          this.width = e4, this.height = t3, this.nextRow = 0, this.image = new Qp({ width: e4, height: t3 }), this.positions = {}, this.uploaded = false;
        }
        getDash(e4, t3) {
          const i3 = this.getKey(e4, t3);
          return this.positions[i3];
        }
        trim() {
          const e4 = this.width, t3 = this.height = U(this.nextRow);
          this.image.resize({ width: e4, height: t3 });
        }
        getKey(e4, t3) {
          return e4.join(",") + t3;
        }
        getDashRanges(e4, t3, i3) {
          const r3 = [];
          let n4 = e4.length % 2 == 1 ? -e4[e4.length - 1] * i3 : 0, o3 = e4[0] * i3, s6 = true;
          r3.push({ left: n4, right: o3, isDash: s6, zeroLength: 0 === e4[0] });
          let a3 = e4[0];
          for (let t4 = 1; t4 < e4.length; t4++) {
            s6 = !s6;
            const l3 = e4[t4];
            n4 = a3 * i3, a3 += l3, o3 = a3 * i3, r3.push({ left: n4, right: o3, isDash: s6, zeroLength: 0 === l3 });
          }
          return r3;
        }
        addRoundDash(e4, t3, i3) {
          const r3 = t3 / 2;
          for (let t4 = -i3; t4 <= i3; t4++) {
            const n4 = this.width * (this.nextRow + i3 + t4);
            let o3 = 0, s6 = e4[o3];
            for (let a3 = 0; a3 < this.width; a3++) {
              a3 / s6.right > 1 && (s6 = e4[++o3]);
              const l3 = Math.abs(a3 - s6.left), c3 = Math.abs(a3 - s6.right), h3 = Math.min(l3, c3);
              let u3;
              const d3 = t4 / i3 * (r3 + 1);
              if (s6.isDash) {
                const e5 = r3 - Math.abs(d3);
                u3 = Math.sqrt(h3 * h3 + e5 * e5);
              } else
                u3 = r3 - Math.sqrt(h3 * h3 + d3 * d3);
              this.image.data[n4 + a3] = Math.max(0, Math.min(255, u3 + 128));
            }
          }
        }
        addRegularDash(e4, t3) {
          for (let t4 = e4.length - 1; t4 >= 0; --t4) {
            const i4 = e4[t4], r4 = e4[t4 + 1];
            i4.zeroLength ? e4.splice(t4, 1) : r4 && r4.isDash === i4.isDash && (r4.left = i4.left, e4.splice(t4, 1));
          }
          const i3 = e4[0], r3 = e4[e4.length - 1];
          i3.isDash === r3.isDash && (i3.left = r3.left - this.width, r3.right = i3.right + this.width);
          const n4 = this.width * this.nextRow;
          let o3 = 0, s6 = e4[o3];
          for (let i4 = 0; i4 < this.width; i4++) {
            i4 / s6.right > 1 && (s6 = e4[++o3]);
            const r4 = Math.abs(i4 - s6.left), a3 = Math.abs(i4 - s6.right), l3 = Math.min(r4, a3);
            this.image.data[n4 + i4] = Math.max(0, Math.min(255, (s6.isDash ? l3 : -l3) + t3 + 128));
          }
        }
        addDash(e4, t3) {
          const i3 = this.getKey(e4, t3);
          if (this.positions[i3])
            return this.positions[i3];
          const r3 = "round" === t3, n4 = r3 ? 7 : 0, o3 = 2 * n4 + 1;
          if (this.nextRow + o3 > this.height)
            return H2("LineAtlas out of space"), null;
          0 === e4.length && e4.push(1);
          let s6 = 0;
          for (let t4 = 0; t4 < e4.length; t4++)
            e4[t4] < 0 && (H2("Negative value is found in line dasharray, replacing values with 0"), e4[t4] = 0), s6 += e4[t4];
          if (0 !== s6) {
            const i4 = this.width / s6, o4 = this.getDashRanges(e4, this.width, i4);
            r3 ? this.addRoundDash(o4, i4, n4) : this.addRegularDash(o4, "square" === t3 ? 0.5 * i4 : 0);
          }
          const a3 = this.nextRow + n4;
          this.nextRow += o3;
          const l3 = { tl: [a3, n4], br: [s6, 0] };
          return this.positions[i3] = l3, l3;
        }
      }
      Rs(Lw, "LineAtlas");
      const kw = 1 * ng;
      class Ow {
        constructor(e4) {
          const t3 = {}, i3 = [];
          for (const r4 in e4) {
            const n5 = e4[r4], o4 = t3[r4] = {};
            for (const e5 in n5.glyphs) {
              const t4 = n5.glyphs[+e5];
              if (!t4 || 0 === t4.bitmap.width || 0 === t4.bitmap.height)
                continue;
              const r5 = t4.metrics.localGlyph ? kw : 1, s6 = { x: 0, y: 0, w: t4.bitmap.width + 2 * r5, h: t4.bitmap.height + 2 * r5 };
              i3.push(s6), o4[e5] = s6;
            }
          }
          const { w: r3, h: n4 } = K_(i3), o3 = new Qp({ width: r3 || 1, height: n4 || 1 });
          for (const i4 in e4) {
            const r4 = e4[i4];
            for (const e5 in r4.glyphs) {
              const n5 = r4.glyphs[+e5];
              if (!n5 || 0 === n5.bitmap.width || 0 === n5.bitmap.height)
                continue;
              const s6 = t3[i4][e5], a3 = n5.metrics.localGlyph ? kw : 1;
              Qp.copy(n5.bitmap, o3, { x: 0, y: 0 }, { x: s6.x + a3, y: s6.y + a3 }, n5.bitmap);
            }
          }
          this.image = o3, this.positions = t3;
        }
      }
      Rs(Ow, "GlyphAtlas");
      class Bw {
        constructor(e4) {
          this.tileID = new qu(e4.tileID.overscaledZ, e4.tileID.wrap, e4.tileID.canonical.z, e4.tileID.canonical.x, e4.tileID.canonical.y), this.tileZoom = e4.tileZoom, this.uid = e4.uid, this.zoom = e4.zoom, this.canonical = e4.tileID.canonical, this.pixelRatio = e4.pixelRatio, this.tileSize = e4.tileSize, this.source = e4.source, this.scope = e4.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = e4.showCollisionBoxes, this.collectResourceTiming = !!e4.collectResourceTiming, this.promoteId = e4.promoteId, this.isSymbolTile = e4.isSymbolTile, this.tileTransform = Pg(e4.tileID.canonical, e4.projection), this.projection = e4.projection, this.brightness = e4.brightness, this.extraShadowCaster = !!e4.extraShadowCaster;
        }
        parse(e4, t3, i3, r3, n4) {
          this.status = "parsing", this.data = e4, this.collisionBoxArray = new al();
          const o3 = new dm(Object.keys(e4.layers).sort()), s6 = new Qm(this.tileID, this.promoteId);
          s6.bucketLayerIDs = [];
          const a3 = {}, l3 = new Lw(256, 256), c3 = { featureIndex: s6, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l3, availableImages: i3, brightness: this.brightness }, h3 = t3.familiesBySource[this.source];
          for (const t4 in h3) {
            const r4 = e4.layers[t4];
            if (!r4)
              continue;
            let n5 = false, l4 = false, u4 = false;
            for (const e5 of h3[t4])
              "symbol" === e5[0].type ? n5 = true : l4 = true, e5[0].is3D() && "model" !== e5[0].type && (u4 = true);
            if (this.extraShadowCaster && !u4)
              continue;
            if (true === this.isSymbolTile && !n5)
              continue;
            if (false === this.isSymbolTile && !l4)
              continue;
            1 === r4.version && H2(`Vector tile source "${this.source}" layer "${t4}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const d4 = o3.encode(t4), p4 = [];
            for (let e5 = 0; e5 < r4.length; e5++) {
              const i4 = r4.feature(e5), n6 = s6.getId(i4, t4);
              p4.push({ feature: i4, id: n6, index: e5, sourceLayerIndex: d4 });
            }
            for (const e5 of h3[t4]) {
              const t5 = e5[0];
              (!this.extraShadowCaster || t5.is3D() && "model" !== t5.type) && (void 0 !== this.isSymbolTile && "symbol" === t5.type !== this.isSymbolTile || t5.minzoom && this.zoom < Math.floor(t5.minzoom) || t5.maxzoom && this.zoom >= t5.maxzoom || "none" !== t5.visibility && (Fw(e5, this.zoom, c3.brightness, i3), (a3[t5.id] = t5.createBucket({ index: s6.bucketLayerIDs.length, layers: e5, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: d4, sourceID: this.source, projection: this.projection.spec })).populate(p4, c3, this.tileID.canonical, this.tileTransform), s6.bucketLayerIDs.push(e5.map((e6) => e6.id))));
            }
          }
          let u3, d3, p3, f3;
          l3.trim();
          const m3 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, _3 = () => {
            if (u3)
              return this.status = "done", n4(u3);
            if (this.extraShadowCaster)
              this.status = "done", n4(null, { buckets: L2(a3).filter((e5) => !e5.isEmpty()), featureIndex: s6, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: c3.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
            else if (d3 && p3 && f3) {
              const e5 = new Ow(d3), t4 = new eg(p3, f3);
              for (const r4 in a3) {
                const n5 = a3[r4];
                n5 instanceof gy ? (Fw(n5.layers, this.zoom, c3.brightness, i3), vg(n5, d3, e5.positions, p3, t4.iconPositions, this.showCollisionBoxes, i3, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : n5.hasPattern && (n5 instanceof Ey || n5 instanceof jf || n5 instanceof vb) && (Fw(n5.layers, this.zoom, c3.brightness, i3), n5.addFeatures(c3, this.tileID.canonical, t4.patternPositions, i3, this.tileTransform, this.brightness));
              }
              this.status = "done", n4(null, { buckets: L2(a3).filter((e6) => !e6.isEmpty()), featureIndex: s6, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: e5.image, lineAtlas: l3, imageAtlas: t4, brightness: c3.brightness });
            }
          };
          if (!this.extraShadowCaster) {
            const e5 = q(c3.glyphDependencies, (e6) => Object.keys(e6).map(Number));
            Object.keys(e5).length ? r3.send("getGlyphs", { uid: this.uid, stacks: e5, scope: this.scope }, (e6, t5) => {
              u3 || (u3 = e6, d3 = t5, _3());
            }, void 0, false, m3) : d3 = {};
            const t4 = Object.keys(c3.iconDependencies);
            t4.length ? r3.send("getImages", { icons: t4, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (e6, t5) => {
              u3 || (u3 = e6, p3 = t5, _3());
            }, void 0, false, m3) : p3 = {};
            const i4 = Object.keys(c3.patternDependencies);
            i4.length ? r3.send("getImages", { icons: i4, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (e6, t5) => {
              u3 || (u3 = e6, f3 = t5, _3());
            }, void 0, false, m3) : f3 = {};
          }
          _3();
        }
      }
      function Fw(e4, t3, i3, r3) {
        const n4 = new oa(t3, { brightness: i3 });
        for (const t4 of e4)
          t4.recalculate(n4, r3);
      }
      class Nw {
        constructor(e4) {
          this.entries = {}, this.scheduler = e4;
        }
        request(e4, t3, i3, r3) {
          const n4 = this.entries[e4] = this.entries[e4] || { callbacks: [] };
          if (n4.result) {
            const [e5, i4] = n4.result;
            return this.scheduler ? this.scheduler.add(() => {
              r3(e5, i4);
            }, t3) : r3(e5, i4), () => {
            };
          }
          return n4.callbacks.push(r3), n4.cancel || (n4.cancel = i3((i4, r4) => {
            n4.result = [i4, r4];
            for (const e5 of n4.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                e5(i4, r4);
              }, t3) : e5(i4, r4);
            setTimeout(() => delete this.entries[e4], 3e3);
          })), () => {
            n4.result || (n4.callbacks = n4.callbacks.filter((e5) => e5 !== r3), n4.callbacks.length || (n4.cancel(), delete this.entries[e4]));
          };
        }
      }
      function Uw(e4, t3, i3) {
        const r3 = JSON.stringify(e4.request);
        return e4.data && (this.deduped.entries[r3] = { result: [null, e4.data] }), this.deduped.request(r3, { type: "parseTile", isSymbolTile: e4.isSymbolTile, zoom: e4.tileZoom }, (t4) => {
          const r4 = Te(e4.request, (e5, r5, n4, o3) => {
            e5 ? t4(e5) : r5 && t4(null, { vectorTile: i3 ? void 0 : new cm(new km(r5)), rawData: r5, cacheControl: n4, expires: o3 });
          });
          return () => {
            r4.cancel(), t4();
          };
        }, t3);
      }
      class Vw extends zt {
        constructor(e4, t3, i3, r3) {
          if (super(), this.id = e4, this.dispatcher = i3, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, k2(this, O(t3, ["url", "scheme", "tileSize", "promoteId"])), this._options = k2({ type: "vector" }, t3), this._collectResourceTiming = !!t3.collectResourceTiming, 512 !== this.tileSize)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r3), this._tileWorkers = {}, this._deduped = new Nw();
        }
        load(e4) {
          this._loaded = false, this.fire(new It("dataloading", { dataType: "source" }));
          const t3 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, i3 = this.map._worldview;
          this._tileJSONRequest = Dw(this._options, this.map._requestManager, t3, i3, (r3, n4) => {
            this._tileJSONRequest = null, this._loaded = true, r3 ? (t3 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t3}`), i3 && 2 !== i3.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${i3}`), this.fire(new Ct(r3))) : n4 && (k2(this, n4), n4.bounds && (this.tileBounds = new Rw(n4.bounds, this.minzoom, this.maxzoom)), Ge(n4.tiles, this.map._requestManager._customAccessToken), this.fire(new It("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new It("data", { dataType: "source", sourceDataType: "content" }))), e4 && e4(r3);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e4) {
          return !this.tileBounds || this.tileBounds.contains(e4.canonical);
        }
        onAdd(e4) {
          this.map = e4, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const e4 = va(this.id, this.scope);
          this.load(() => this.map.style.clearSource(e4));
        }
        setTiles(e4) {
          return this._options.tiles = e4, this.reload(), this;
        }
        setUrl(e4) {
          return this.url = e4, this._options.url = e4, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return k2({}, this._options);
        }
        loadTile(e4, t3) {
          const i3 = this.map._requestManager.normalizeTileURL(e4.tileID.canonical.url(this.tiles, this.scheme)), r3 = { request: this.map._requestManager.transformRequest(i3, ye.Tile), data: void 0, uid: e4.uid, tileID: e4.tileID, tileZoom: e4.tileZoom, zoom: e4.tileID.overscaledZ, tileSize: this.tileSize * e4.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: dt.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: e4.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: e4.isExtraShadowCaster };
          if (r3.request.collectResourceTiming = this._collectResourceTiming, e4.actor && "expired" !== e4.state)
            "loading" === e4.state ? e4.reloadCallback = t3 : e4.request = e4.actor.send("reloadTile", r3, n4.bind(this));
          else if (e4.actor = this._tileWorkers[i3] = this._tileWorkers[i3] || this.dispatcher.getActor(), this.dispatcher.ready)
            e4.request = e4.actor.send("loadTile", r3, n4.bind(this), void 0, true);
          else {
            const t4 = Uw.call({ deduped: this._deduped }, r3, (t5, i4) => {
              t5 || !i4 ? n4.call(this, t5) : (r3.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, e4.actor && e4.actor.send("loadTile", r3, n4.bind(this), void 0, true));
            }, true);
            e4.request = { cancel: t4 };
          }
          function n4(i4, r4) {
            return delete e4.request, e4.aborted ? t3(null) : i4 && 404 !== i4.status ? t3(i4) : (r4 && r4.resourceTiming && (e4.resourceTiming = r4.resourceTiming), this.map._refreshExpiredTiles && r4 && e4.setExpiryData(r4), e4.loadVectorData(r4, this.map.painter), ge(this.dispatcher), t3(null), void (e4.reloadCallback && (this.loadTile(e4, e4.reloadCallback), e4.reloadCallback = null)));
          }
        }
        abortTile(e4) {
          e4.request && (e4.request.cancel(), delete e4.request), e4.actor && e4.actor.send("abortTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope });
        }
        unloadTile(e4) {
          e4.actor && e4.actor.send("removeTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope }), e4.destroy();
        }
        hasTransition() {
          return false;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class jw extends zt {
        constructor(e4, t3, i3, r3) {
          super(), this.id = e4, this.dispatcher = i3, this.setEventedParent(r3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = k2({ type: "raster" }, t3), k2(this, O(t3, ["url", "scheme", "tileSize"]));
        }
        load(e4) {
          this._loaded = false, this.fire(new It("dataloading", { dataType: "source" })), this._tileJSONRequest = Dw(this._options, this.map._requestManager, null, null, (t3, i3) => {
            this._tileJSONRequest = null, this._loaded = true, t3 ? this.fire(new Ct(t3)) : i3 && (k2(this, i3), i3.bounds && (this.tileBounds = new Rw(i3.bounds, this.minzoom, this.maxzoom)), Ge(i3.tiles), this.fire(new It("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new It("data", { dataType: "source", sourceDataType: "content" }))), e4 && e4(t3);
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e4) {
          this.map = e4, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const e4 = va(this.id, this.scope);
          this.load(() => this.map.style.clearSource(e4));
        }
        setTiles(e4) {
          return this._options.tiles = e4, this.reload(), this;
        }
        setUrl(e4) {
          return this.url = e4, this._options.url = e4, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return k2({}, this._options);
        }
        hasTile(e4) {
          return !this.tileBounds || this.tileBounds.contains(e4.canonical);
        }
        loadTile(e4, t3) {
          const i3 = dt.devicePixelRatio >= 2, r3 = this.map._requestManager.normalizeTileURL(e4.tileID.canonical.url(this.tiles, this.scheme), i3, this.tileSize);
          e4.request = Ie(this.map._requestManager.transformRequest(r3, ye.Tile), (i4, r4, n4, o3) => (delete e4.request, e4.aborted ? (e4.state = "unloaded", t3(null)) : i4 ? (e4.state = "errored", t3(i4)) : r4 ? (this.map._refreshExpiredTiles && e4.setExpiryData({ cacheControl: n4, expires: o3 }), e4.setTexture(r4, this.map.painter), e4.state = "loaded", ge(this.dispatcher), void t3(null)) : t3(null)));
        }
        abortTile(e4, t3) {
          e4.request && (e4.request.cancel(), delete e4.request), t3();
        }
        unloadTile(e4, t3) {
          e4.texture && e4.texture instanceof My ? (e4.destroy(true), e4.texture && e4.texture instanceof My && this.map.painter.saveTileTexture(e4.texture)) : e4.destroy(), t3();
        }
        hasTransition() {
          return false;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      function Gw() {
        return null != xI.workerClass ? new xI.workerClass() : new t2.Worker(xI.workerUrl);
      }
      const qw = "mapboxgl_preloaded_worker_pool";
      class Zw {
        constructor() {
          this.active = {};
        }
        acquire(e4) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < Zw.workerCount; )
              this.workers.push(new Gw());
          return this.active[e4] = true, this.workers.slice();
        }
        release(e4) {
          delete this.active[e4], this.workers && 0 === this.numActive() && (this.workers.forEach((e5) => {
            e5.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[qw];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let $w;
      function Ww() {
        return $w || ($w = new Zw()), $w;
      }
      Zw.workerCount = 2;
      let Hw, Xw, Yw, Kw = null;
      function Jw() {
        return Q() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : Xw || n3.DRACO_URL;
      }
      const Qw = 5123, eT = 5126, tT = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, [Qw]: Uint16Array, 5125: Uint32Array, [eT]: Float32Array }, iT = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", [Qw]: "DT_UINT16", 5125: "DT_UINT32", [eT]: "DT_FLOAT32" }, rT = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
      function nT(e4, t3, i3) {
        const r3 = i3.json.bufferViews.length, n4 = i3.buffers.length;
        t3.bufferView = r3, i3.json.bufferViews[r3] = { buffer: n4, byteLength: e4.byteLength }, i3.buffers[n4] = e4;
      }
      const oT = "KHR_draco_mesh_compression";
      function sT(e4, t3) {
        const i3 = e4.extensions && e4.extensions[oT];
        if (!i3)
          return;
        const r3 = new Yw.Decoder(), n4 = uT(t3, i3.bufferView), o3 = new Yw.Mesh();
        if (!r3.DecodeArrayToMesh(n4, n4.byteLength, o3))
          throw new Error("Failed to decode Draco mesh");
        const s6 = t3.json.accessors[e4.indices], a3 = tT[s6.componentType], l3 = s6.count * a3.BYTES_PER_ELEMENT, c3 = Yw._malloc(l3);
        a3 === Uint16Array ? r3.GetTrianglesUInt16Array(o3, l3, c3) : r3.GetTrianglesUInt32Array(o3, l3, c3), nT(Yw.memory.buffer.slice(c3, c3 + l3), s6, t3), Yw._free(c3);
        for (const n5 of Object.keys(i3.attributes)) {
          const s7 = r3.GetAttributeByUniqueId(o3, i3.attributes[n5]), a4 = t3.json.accessors[e4.attributes[n5]], l4 = iT[a4.componentType], c4 = a4.count * rT[a4.type] * tT[a4.componentType].BYTES_PER_ELEMENT, h3 = Yw._malloc(c4);
          r3.GetAttributeDataArrayForAllPoints(o3, s7, Yw[l4], c4, h3), nT(Yw.memory.buffer.slice(h3, h3 + c4), a4, t3), Yw._free(h3);
        }
        r3.destroy(), o3.destroy(), delete e4.extensions[oT];
      }
      const aT = 1179937895, lT = new TextDecoder("utf8");
      function cT(e4, t3) {
        return new URL(e4, t3).href;
      }
      function hT(e4, t3, i3, r3) {
        return fetch(cT(e4.uri, r3)).then((e5) => e5.arrayBuffer()).then((e5) => {
          t3.buffers[i3] = e5;
        });
      }
      function uT(e4, t3) {
        const i3 = e4.json.bufferViews[t3];
        return new Uint8Array(e4.buffers[i3.buffer], i3.byteOffset || 0, i3.byteLength);
      }
      function dT(e4, i3, r3, n4) {
        if (e4.uri) {
          const o3 = cT(e4.uri, n4);
          return fetch(o3).then((e5) => e5.blob()).then((e5) => t2.createImageBitmap(e5)).then((e5) => {
            i3.images[r3] = e5;
          });
        }
        if (void 0 !== e4.bufferView) {
          const n5 = uT(i3, e4.bufferView), o3 = new t2.Blob([n5], { type: e4.mimeType });
          return t2.createImageBitmap(o3).then((e5) => {
            i3.images[r3] = e5;
          });
        }
      }
      function pT(e4, t3 = 0, i3) {
        const r3 = { json: null, images: [], buffers: [] };
        if (new Uint32Array(e4, t3, 1)[0] === aT) {
          const i4 = new Uint32Array(e4, t3);
          let n5 = 2;
          const o4 = (i4[n5++] >> 2) - 3, s7 = i4[n5++] >> 2;
          if (n5++, r3.json = JSON.parse(lT.decode(i4.subarray(n5, n5 + s7))), n5 += s7, n5 < o4) {
            const o5 = i4[n5++];
            n5++;
            const s8 = t3 + (n5 << 2);
            r3.buffers[0] = e4.slice(s8, s8 + o5);
          }
        } else
          r3.json = JSON.parse(lT.decode(new Uint8Array(e4, t3)));
        const { buffers: n4, images: o3, meshes: s6, extensionsUsed: a3 } = r3.json;
        let l3 = Promise.resolve();
        if (n4) {
          const e5 = [];
          for (let t4 = 0; t4 < n4.length; t4++) {
            const o4 = n4[t4];
            o4.uri ? e5.push(hT(o4, r3, t4, i3)) : r3.buffers[t4] || (r3.buffers[t4] = null);
          }
          l3 = Promise.all(e5);
        }
        return l3.then(() => {
          const e5 = [], t4 = a3 && a3.includes(oT);
          if (t4 && e5.push(function() {
            if (!Yw)
              return Hw || (Hw = function(e6) {
                let t5, i4 = null;
                function r4() {
                  t5 = new Uint8Array(i4.buffer);
                }
                function n5() {
                  throw new Error("Unexpected Draco error.");
                }
                const o4 = { a: { a: n5, d: function(e7, i5, r5) {
                  return t5.copyWithin(e7, i5, i5 + r5);
                }, c: function(e7) {
                  const n6 = t5.length, o5 = Math.max(e7 >>> 0, Math.ceil(1.2 * n6)), s7 = Math.ceil((o5 - n6) / 65536);
                  try {
                    return i4.grow(s7), r4(), true;
                  } catch (e8) {
                    return false;
                  }
                }, b: n5 } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(e6, o4) : e6.then((e7) => e7.arrayBuffer()).then((e7) => WebAssembly.instantiate(e7, o4))).then((e7) => {
                  const { Rb: n6, Qb: o5, P: s7, T: a4, X: l4, Ja: c3, La: h3, Qa: u3, Va: d3, Wa: p3, eb: f3, jb: m3, f: _3, e: g3, yb: y3, zb: x3, Ab: v3, Bb: b3, Db: w3, Gb: T3 } = e7.instance.exports;
                  i4 = g3;
                  const E3 = (() => {
                    let e8 = 0, i5 = 0, r5 = 0, s8 = 0;
                    return (a5) => {
                      r5 && (n6(s8), n6(e8), i5 += r5, r5 = e8 = 0), e8 || (i5 += 128, e8 = o5(i5));
                      const l5 = a5.length + 7 & -8;
                      let c4 = e8;
                      l5 >= i5 && (r5 = l5, c4 = s8 = o5(l5));
                      for (let e9 = 0; e9 < a5.length; e9++)
                        t5[c4 + e9] = a5[e9];
                      return c4;
                    };
                  })();
                  return r4(), _3(), { memory: g3, _free: n6, _malloc: o5, Mesh: class {
                    constructor() {
                      this.ptr = s7();
                    }
                    destroy() {
                      a4(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = c3();
                    }
                    destroy() {
                      m3(this.ptr);
                    }
                    DecodeArrayToMesh(e8, t6, i5) {
                      const r5 = E3(e8), n7 = h3(this.ptr, r5, t6, i5.ptr);
                      return !!l4(n7);
                    }
                    GetAttributeByUniqueId(e8, t6) {
                      return { ptr: u3(this.ptr, e8.ptr, t6) };
                    }
                    GetTrianglesUInt16Array(e8, t6, i5) {
                      d3(this.ptr, e8.ptr, t6, i5);
                    }
                    GetTrianglesUInt32Array(e8, t6, i5) {
                      p3(this.ptr, e8.ptr, t6, i5);
                    }
                    GetAttributeDataArrayForAllPoints(e8, t6, i5, r5, n7) {
                      f3(this.ptr, e8.ptr, t6.ptr, i5, r5, n7);
                    }
                  }, DT_INT8: y3(), DT_UINT8: x3(), DT_INT16: v3(), DT_UINT16: b3(), DT_UINT32: w3(), DT_FLOAT32: T3() };
                });
              }(fetch(Jw())), Hw.then((e6) => {
                Yw = e6, Hw = void 0;
              }));
          }()), o3)
            for (let t5 = 0; t5 < o3.length; t5++)
              e5.push(dT(o3[t5], r3, t5, i3));
          return (e5.length ? Promise.all(e5) : Promise.resolve()).then(() => {
            if (t4 && s6)
              for (const { primitives: e6 } of s6)
                for (const t5 of e6)
                  sT(t5, r3);
            return r3;
          });
        });
      }
      function fT(e4) {
        return fetch(e4).then((e5) => e5.arrayBuffer()).then((t3) => pT(t3, 0, e4));
      }
      class mT {
        constructor(e4, t3, i3) {
          if (this.triangleCount = t3.length / 3, this.min = new y2(0, 0), this.max = new y2(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === e4.length || 0 === i3)
            return;
          const r3 = e4.map((e5) => e5.x), n4 = e4.map((e5) => e5.y);
          this.min = new y2(Math.min(...r3), Math.min(...n4)), this.max = new y2(Math.max(...r3), Math.max(...n4));
          const o3 = this.max.sub(this.min);
          o3.x = Math.max(o3.x, 1), o3.y = Math.max(o3.y, 1);
          const s6 = Math.max(o3.x, o3.y) / i3;
          this.cellsX = Math.max(1, Math.ceil(o3.x / s6)), this.cellsY = Math.max(1, Math.ceil(o3.y / s6)), this.xScale = 1 / s6, this.yScale = 1 / s6;
          const a3 = [];
          for (let i4 = 0; i4 < this.triangleCount; i4++) {
            const r4 = e4[t3[3 * i4 + 0]].sub(this.min), n5 = e4[t3[3 * i4 + 1]].sub(this.min), o4 = e4[t3[3 * i4 + 2]].sub(this.min), l4 = _T(Math.floor(Math.min(r4.x, n5.x, o4.x)), this.xScale, this.cellsX), c3 = _T(Math.floor(Math.max(r4.x, n5.x, o4.x)), this.xScale, this.cellsX), h3 = _T(Math.floor(Math.min(r4.y, n5.y, o4.y)), this.yScale, this.cellsY), u3 = _T(Math.floor(Math.max(r4.y, n5.y, o4.y)), this.yScale, this.cellsY), d3 = new y2(0, 0), p3 = new y2(0, 0), f3 = new y2(0, 0), m3 = new y2(0, 0);
            for (let e5 = h3; e5 <= u3; ++e5) {
              d3.y = p3.y = e5 * s6, f3.y = m3.y = (e5 + 1) * s6;
              for (let t4 = l4; t4 <= c3; ++t4)
                d3.x = f3.x = t4 * s6, p3.x = m3.x = (t4 + 1) * s6, (Lp(r4, n5, o4, d3, p3, m3) || Lp(r4, n5, o4, d3, m3, f3)) && a3.push({ cellIdx: e5 * this.cellsX + t4, triIdx: i4 });
            }
          }
          if (0 === a3.length)
            return;
          a3.sort((e5, t4) => e5.cellIdx - t4.cellIdx || e5.triIdx - t4.triIdx);
          let l3 = 0;
          for (; l3 < a3.length; ) {
            const e5 = a3[l3].cellIdx, t4 = { start: this.payload.length, len: 0 };
            for (; l3 < a3.length && a3[l3].cellIdx === e5; )
              ++t4.len, this.payload.push(a3[l3++].triIdx);
            this.cells[e5] = t4;
          }
        }
        query(e4, t3, i3) {
          if (0 === this.triangleCount || 0 === this.cells.length)
            return;
          if (e4.x > this.max.x || this.min.x > t3.x)
            return;
          if (e4.y > this.max.y || this.min.y > t3.y)
            return;
          this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8)));
          for (let e5 = 0; e5 < this.lookup.length; e5++)
            this.lookup[e5] = 0;
          const r3 = _T(e4.x - this.min.x, this.xScale, this.cellsX), n4 = _T(t3.x - this.min.x, this.xScale, this.cellsX), o3 = _T(e4.y - this.min.y, this.yScale, this.cellsY), s6 = _T(t3.y - this.min.y, this.yScale, this.cellsY);
          for (let e5 = o3; e5 <= s6; e5++)
            for (let t4 = r3; t4 <= n4; t4++) {
              const r4 = this.cells[e5 * this.cellsX + t4];
              if (r4)
                for (let e6 = 0; e6 < r4.len; e6++) {
                  const t5 = this.payload[r4.start + e6], n5 = Math.floor(t5 / 8), o4 = 1 << t5 % 8;
                  if (!(this.lookup[n5] & o4) && (this.lookup[n5] |= o4, i3.push(t5), i3.length === this.triangleCount))
                    return;
                }
            }
        }
      }
      function _T(e4, t3, i3) {
        return Math.max(0, Math.min(i3 - 1, Math.floor(e4 * t3)));
      }
      function gT(e4, t3) {
        const i3 = e4.json.bufferViews[t3.bufferView];
        return new tT[t3.componentType](e4.buffers[i3.buffer], (t3.byteOffset || 0) + (i3.byteOffset || 0), t3.count * rT[t3.type]);
      }
      function yT(e4, t3, i3) {
        const r3 = e4.indices, n4 = e4.attributes, o3 = {};
        o3.indexArray = new Wa();
        const s6 = t3.json.accessors[r3], a3 = s6.count / 3;
        o3.indexArray.reserve(a3);
        const l3 = gT(t3, s6);
        for (let e5 = 0; e5 < a3; e5++)
          o3.indexArray.emplaceBack(l3[3 * e5], l3[3 * e5 + 1], l3[3 * e5 + 2]);
        o3.indexArray._trim(), o3.vertexArray = new tl();
        const c3 = t3.json.accessors[n4.POSITION];
        o3.vertexArray.reserve(c3.count);
        const h3 = gT(t3, c3);
        for (let e5 = 0; e5 < c3.count; e5++)
          o3.vertexArray.emplaceBack(h3[3 * e5], h3[3 * e5 + 1], h3[3 * e5 + 2]);
        if (o3.vertexArray._trim(), o3.aabb = new ed(c3.min, c3.max), o3.centroid = function(e5, t4) {
          const i4 = [0, 0, 0], r4 = e5.length;
          if (r4 > 0) {
            for (let n5 = 0; n5 < r4; n5++) {
              const r5 = 3 * e5[n5];
              i4[0] += t4[r5], i4[1] += t4[r5 + 1], i4[2] += t4[r5 + 2];
            }
            i4[0] /= r4, i4[1] /= r4, i4[2] /= r4;
          }
          return i4;
        }(l3, h3), void 0 !== n4.COLOR_0) {
          const e5 = t3.json.accessors[n4.COLOR_0], i4 = rT[e5.type];
          if (e5.componentType === eT) {
            o3.colorArray = 3 === i4 ? new tl() : new ka(), o3.colorArray.reserve(e5.count);
            const r4 = gT(t3, e5);
            if (3 === i4)
              for (let t4 = 0; t4 < e5.count; t4++)
                o3.colorArray.emplaceBack(r4[3 * t4], r4[3 * t4 + 1], r4[3 * t4 + 2]);
            else
              for (let t4 = 0; t4 < e5.count; t4++)
                o3.colorArray.emplaceBack(r4[4 * t4], r4[4 * t4 + 1], r4[4 * t4 + 2], r4[4 * t4 + 3]);
            o3.colorArray._trim();
          } else if (e5.componentType === Qw && 4 === i4) {
            o3.colorArray = new ka(), o3.colorArray.resize(e5.count);
            const i5 = gT(t3, e5), r4 = 1 / 65535, n5 = o3.colorArray.float32;
            for (let e6 = 0; e6 < 4 * i5.length; ++e6)
              n5[e6] = i5[e6] * r4;
          } else
            H2(`glTF color buffer parsing for accessor ${JSON.stringify(e5)} is not supported`);
        }
        if (void 0 !== n4.NORMAL) {
          o3.normalArray = new tl();
          const e5 = t3.json.accessors[n4.NORMAL];
          o3.normalArray.reserve(e5.count);
          const i4 = gT(t3, e5);
          for (let t4 = 0; t4 < e5.count; t4++)
            o3.normalArray.emplaceBack(i4[3 * t4], i4[3 * t4 + 1], i4[3 * t4 + 2]);
          o3.normalArray._trim();
        }
        if (void 0 !== n4.TEXCOORD_0 && i3.length > 0) {
          o3.texcoordArray = new il();
          const e5 = t3.json.accessors[n4.TEXCOORD_0];
          o3.texcoordArray.reserve(e5.count);
          const i4 = gT(t3, e5);
          for (let t4 = 0; t4 < e5.count; t4++)
            o3.texcoordArray.emplaceBack(i4[2 * t4], i4[2 * t4 + 1]);
          o3.texcoordArray._trim();
        }
        const u3 = e4.material;
        return o3.material = function(e5, t4) {
          const { emissiveFactor: i4 = [0, 0, 0], alphaMode: r4 = "OPAQUE", alphaCutoff: n5 = 0.5, normalTexture: o4, occlusionTexture: s7, emissiveTexture: a4, doubleSided: l4 } = e5, { baseColorFactor: c4 = [1, 1, 1, 1], metallicFactor: h4 = 1, roughnessFactor: u4 = 1, baseColorTexture: d3, metallicRoughnessTexture: p3 } = e5.pbrMetallicRoughness || {};
          return { pbrMetallicRoughness: { baseColorFactor: new hi(...c4), metallicFactor: h4, roughnessFactor: u4, baseColorTexture: d3 ? t4[d3.index] : void 0, metallicRoughnessTexture: p3 ? t4[p3.index] : void 0 }, doubleSided: l4, emissiveFactor: i4, alphaMode: r4, alphaCutoff: n5, normalTexture: o4 ? t4[o4.index] : void 0, occlusionTexture: s7 ? t4[s7.index] : void 0, emissionTexture: a4 ? t4[a4.index] : void 0, defined: void 0 === e5.defined };
        }(void 0 !== u3 ? t3.json.materials[u3] : { defined: false }, i3), void 0 !== n4._FEATURE_RGBA4444 && (o3.featureData = new Uint32Array(gT(t3, t3.json.accessors[n4._FEATURE_RGBA4444]).buffer)), o3;
      }
      function xT(e4, t3, i3) {
        const { matrix: r3, rotation: n4, translation: o3, scale: s6, mesh: a3, extras: l3, children: c3 } = e4, h3 = {};
        if (h3.matrix = r3 || Au.fromRotationTranslationScale([], n4 || [0, 0, 0, 1], o3 || [0, 0, 0], s6 || [1, 1, 1]), void 0 !== a3) {
          h3.meshes = i3[a3];
          const e5 = h3.anchor = [0, 0];
          for (const t4 of h3.meshes) {
            const { min: i4, max: r4 } = t4.aabb;
            e5[0] += i4[0] + r4[0], e5[1] += i4[1] + r4[1];
          }
          e5[0] = Math.floor(e5[0] / h3.meshes.length / 2), e5[1] = Math.floor(e5[1] / h3.meshes.length / 2);
        }
        if (l3 && (l3.id && (h3.id = l3.id), l3.lights && (h3.lights = function(e5) {
          if (!e5.length)
            return [];
          const t4 = function(e6) {
            const t5 = atob(e6), i5 = new Uint8Array(t5.length);
            for (let e7 = 0; e7 < t5.length; e7++)
              i5[e7] = t5.codePointAt(e7);
            return i5;
          }(e5), i4 = [], r4 = t4.length / 24, n5 = new Uint16Array(t4.buffer), o4 = new Float32Array(t4.buffer);
          for (let e6 = 0; e6 < r4; e6++) {
            const t5 = n5[2 * e6 * 6] / 30, r5 = n5[2 * e6 * 6 + 1] / 30, s7 = n5[2 * e6 * 6 + 10] / 100, a4 = o4[6 * e6 + 1], l4 = o4[6 * e6 + 2], c4 = o4[6 * e6 + 3], h4 = o4[6 * e6 + 4], u3 = c4 - a4, d3 = h4 - l4, p3 = Math.hypot(u3, d3);
            i4.push({ pos: [a4 + 0.5 * u3, l4 + 0.5 * d3, r5], normal: [d3 / p3, -u3 / p3, 0], width: p3, height: t5, depth: s7, points: [a4, l4, c4, h4] });
          }
          return i4;
        }(l3.lights))), c3) {
          const e5 = [];
          for (const r4 of c3)
            e5.push(xT(t3.json.nodes[r4], t3, i3));
          h3.children = e5;
        }
        return h3;
      }
      function vT(e4) {
        if (0 === e4.vertices.length || 0 === e4.indices.length)
          return null;
        const [t3, i3] = [e4.vertices[0].clone(), e4.vertices[0].clone()];
        for (let r4 = 1; r4 < e4.vertices.length; ++r4) {
          const n5 = e4.vertices[r4];
          t3.x = Math.min(t3.x, n5.x), t3.y = Math.min(t3.y, n5.y), i3.x = Math.max(i3.x, n5.x), i3.y = Math.max(i3.y, n5.y);
        }
        const r3 = Math.ceil(Math.max(i3.x - t3.x, i3.y - t3.y) / 256), n4 = Math.max(8, r3), o3 = new mT(e4.vertices, e4.indices, n4);
        return { vertices: e4.vertices, indices: e4.indices, grid: o3, min: t3, max: i3 };
      }
      function bT(e4) {
        if (!e4.extras || !e4.extras.ground)
          return null;
        const t3 = e4.extras.ground;
        if (!t3 || !Array.isArray(t3) || 0 === t3.length)
          return null;
        const i3 = t3[0];
        if (!i3 || !Array.isArray(i3) || 0 === i3.length)
          return null;
        const r3 = [];
        for (const e5 of i3) {
          if (!Array.isArray(e5) || 2 !== e5.length)
            continue;
          const t4 = e5[0], i4 = e5[1];
          "number" == typeof t4 && "number" == typeof i4 && r3.push(new y2(t4, i4));
        }
        if (r3.length < 3)
          return null;
        r3.length > 1 && r3[r3.length - 1].equals(r3[0]) && r3.pop();
        let n4 = 0;
        for (let e5 = 0; e5 < r3.length; e5++) {
          const t4 = r3[e5], i4 = r3[(e5 + 1) % r3.length], o4 = r3[(e5 + 2) % r3.length];
          n4 += (t4.x - i4.x) * (o4.y - i4.y) - (o4.x - i4.x) * (t4.y - i4.y);
        }
        n4 > 0 && r3.reverse();
        const o3 = Bf(r3.flatMap((e5) => [e5.x, e5.y]), []);
        return 0 === o3.length ? null : { vertices: r3, indices: o3 };
      }
      function wT(e4) {
        const t3 = [], i3 = [];
        let r3 = 0;
        for (const n4 of e4) {
          r3 = t3.length;
          const e5 = n4.vertexArray.float32, o3 = n4.indexArray.uint16;
          for (let i4 = 0; i4 < n4.vertexArray.length; i4++)
            t3.push(new y2(e5[3 * i4 + 0], e5[3 * i4 + 1]));
          for (let e6 = 0; e6 < 3 * n4.indexArray.length; e6++)
            i3.push(o3[e6] + r3);
        }
        if (i3.length % 3 != 0)
          return null;
        for (let e5 = 0; e5 < i3.length; e5 += 3) {
          const r4 = t3[i3[e5 + 0]], n4 = t3[i3[e5 + 1]], o3 = t3[i3[e5 + 2]];
          (r4.x - n4.x) * (o3.y - n4.y) - (o3.x - n4.x) * (r4.y - n4.y) > 0 && ([i3[e5 + 1], i3[e5 + 2]] = [i3[e5 + 2], i3[e5 + 1]]);
        }
        return { vertices: t3, indices: i3 };
      }
      function TT(e4) {
        const i3 = function(e5, i4) {
          const r4 = [], n5 = t2.WebGL2RenderingContext;
          if (e5.json.textures)
            for (const t3 of e5.json.textures) {
              const o4 = { magFilter: n5.LINEAR, minFilter: n5.NEAREST, wrapS: n5.REPEAT, wrapT: n5.REPEAT };
              void 0 !== t3.sampler && Object.assign(o4, e5.json.samplers[t3.sampler]), r4.push({ image: i4[t3.source], sampler: o4, uploaded: false });
            }
          return r4;
        }(e4, e4.images), r3 = function(e5, t3) {
          const i4 = [];
          for (const r4 of e5.json.meshes) {
            const n5 = [];
            for (const i5 of r4.primitives)
              n5.push(yT(i5, e5, t3));
            i4.push(n5);
          }
          return i4;
        }(e4, i3), { scenes: n4, scene: o3, nodes: s6 } = e4.json, a3 = n4 ? n4[o3 || 0].nodes : s6, l3 = [];
        for (const t3 of a3)
          l3.push(xT(s6[t3], e4, r3));
        return function(e5, t3, i4) {
          const r4 = {}, n5 = /* @__PURE__ */ new Set();
          for (let o4 = 0; o4 < e5.length; o4++) {
            const e6 = i4[t3[o4]];
            if (!e6.extras)
              continue;
            const s7 = e6.extras["mapbox:footprint:version"], a4 = e6.extras["mapbox:footprint:id"];
            (s7 || a4) && n5.add(o4), "1.0.0" === s7 && a4 && (r4[a4] = o4);
          }
          for (let o4 = 0; o4 < e5.length; o4++) {
            if (n5.has(o4))
              continue;
            const s7 = e5[o4], a4 = i4[t3[o4]];
            if (!a4.extras)
              continue;
            let l4 = null;
            s7.id in r4 && (l4 = wT(e5[r4[s7.id]].meshes)), l4 || (l4 = bT(a4)), l4 && (s7.footprint = vT(l4));
          }
          if (n5.size > 0) {
            const t4 = Array.from(n5.values()).sort((e6, t5) => e6 - t5);
            for (let i5 = t4.length - 1; i5 >= 0; i5--)
              e5.splice(t4[i5], 1);
          }
        }(l3, a3, e4.json.nodes), l3;
      }
      function ET(e4) {
        e4.heightmap = new Float32Array(4096), e4.heightmap.fill(-1);
        const t3 = e4.vertexArray.float32, i3 = e4.aabb.min[0] - 1, r3 = e4.aabb.min[1] - 1, n4 = Sv / (e4.aabb.max[0] - i3 + 2), o3 = Sv / (e4.aabb.max[1] - r3 + 2);
        for (let s6 = 0; s6 < t3.length; s6 += 3) {
          const a3 = t3[s6 + 2], l3 = (t3[s6 + 0] - i3) * n4 | 0, c3 = (t3[s6 + 1] - r3) * o3 | 0;
          a3 > e4.heightmap[c3 * Sv + l3] && (e4.heightmap[c3 * Sv + l3] = a3);
        }
      }
      function MT(e4, t3) {
        const i3 = {};
        i3.indexArray = new Wa(), i3.indexArray.reserve(4 * e4.length), i3.vertexArray = new tl(), i3.vertexArray.reserve(10 * e4.length), i3.colorArray = new ka(), i3.vertexArray.reserve(10 * e4.length);
        let r3 = 0;
        for (const n5 of e4) {
          const e5 = Math.min(10, Math.max(4, 1.3 * n5.height)) * t3, o4 = [-n5.normal[1], n5.normal[0], 0], s6 = Math.min(0.29, 0.1 * n5.width / n5.depth), a3 = n5.width - 2 * n5.depth * t3 * (s6 + 0.01), l3 = Du.scaleAndAdd([], n5.pos, o4, a3 / 2), c3 = Du.scaleAndAdd([], n5.pos, o4, -a3 / 2), h3 = [l3[0], l3[1], l3[2] + n5.height], u3 = [c3[0], c3[1], c3[2] + n5.height], d3 = Du.scaleAndAdd([], n5.normal, o4, s6);
          Du.scale(d3, d3, e5);
          const p3 = Du.scaleAndAdd([], n5.normal, o4, -s6);
          Du.scale(p3, p3, e5), Du.add(d3, l3, d3), Du.add(p3, c3, p3), l3[2] += 0.1, c3[2] += 0.1, i3.vertexArray.emplaceBack(d3[0], d3[1], d3[2]), i3.vertexArray.emplaceBack(p3[0], p3[1], p3[2]), i3.vertexArray.emplaceBack(l3[0], l3[1], l3[2]), i3.vertexArray.emplaceBack(c3[0], c3[1], c3[2]), i3.vertexArray.emplaceBack(h3[0], h3[1], h3[2]), i3.vertexArray.emplaceBack(u3[0], u3[1], u3[2]), i3.vertexArray.emplaceBack(l3[0], l3[1], l3[2]), i3.vertexArray.emplaceBack(c3[0], c3[1], c3[2]), i3.vertexArray.emplaceBack(d3[0], d3[1], d3[2]), i3.vertexArray.emplaceBack(p3[0], p3[1], p3[2]);
          const f3 = a3 / e5 / 2;
          i3.colorArray.emplaceBack(-f3 - s6, -1, f3, 0.8), i3.colorArray.emplaceBack(f3 + s6, -1, f3, 0.8), i3.colorArray.emplaceBack(-f3, 0, f3, 1.3), i3.colorArray.emplaceBack(f3, 0, f3, 1.3), i3.colorArray.emplaceBack(f3 + s6, -0.8, f3, 0.7), i3.colorArray.emplaceBack(f3 + s6, -0.8, f3, 0.7), i3.colorArray.emplaceBack(0, 0, f3, 1.3), i3.colorArray.emplaceBack(0, 0, f3, 1.3), i3.colorArray.emplaceBack(f3 + s6, -1.2, f3, 0.8), i3.colorArray.emplaceBack(f3 + s6, -1.2, f3, 0.8), i3.indexArray.emplaceBack(6 + r3, 4 + r3, 8 + r3), i3.indexArray.emplaceBack(7 + r3, 9 + r3, 5 + r3), i3.indexArray.emplaceBack(0 + r3, 1 + r3, 2 + r3), i3.indexArray.emplaceBack(1 + r3, 3 + r3, 2 + r3), r3 += 10;
        }
        const n4 = { defined: true, emissiveFactor: [0, 0, 0] }, o3 = {};
        return o3.baseColorFactor = hi.white, n4.pbrMetallicRoughness = o3, i3.material = n4, i3.aabb = new ed([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), i3;
      }
      Rs(mT, "TriangleGridIndex");
      const AT = { vector: Vw, raster: jw, "raster-dem": class extends jw {
        constructor(e4, t3, i3, r3) {
          super(e4, t3, i3, r3), this.type = "raster-dem", this.maxzoom = 22, this._options = k2({ type: "raster-dem" }, t3), this.encoding = t3.encoding || "mapbox";
        }
        loadTile(e4, i3) {
          const r3 = this.map._requestManager.normalizeTileURL(e4.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
          function n4(t3, r4) {
            t3 && (e4.state = "errored", i3(t3)), r4 && (e4.dem = r4, e4.dem.onDeserialize(), e4.needsHillshadePrepare = true, e4.needsDEMTextureUpload = true, e4.state = "loaded", i3(null));
          }
          e4.request = Ie(this.map._requestManager.transformRequest(r3, ye.Tile), (function(r4, o3, s6, a3) {
            if (delete e4.request, e4.aborted)
              e4.state = "unloaded", i3(null);
            else if (r4)
              e4.state = "errored", i3(r4);
            else if (o3) {
              this.map._refreshExpiredTiles && e4.setExpiryData({ cacheControl: s6, expires: a3 });
              const i4 = t2.ImageBitmap && o3 instanceof t2.ImageBitmap && ut(), r5 = 1 - (o3.width - ((l3 = o3.width) <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(l3) / Math.LN2)))) / 2;
              r5 < 1 || e4.neighboringTiles || (e4.neighboringTiles = this._getNeighboringTiles(e4.tileID));
              const c3 = i4 ? o3 : dt.getImageData(o3, r5), h3 = { uid: e4.uid, coord: e4.tileID, source: this.id, scope: this.scope, rawImageData: c3, encoding: this.encoding, padding: r5 };
              e4.actor && "expired" !== e4.state || (e4.actor = this.dispatcher.getActor(), e4.actor.send("loadDEMTile", h3, n4.bind(this), void 0, true));
            }
            var l3;
          }).bind(this));
        }
        _getNeighboringTiles(e4) {
          const t3 = e4.canonical, i3 = Math.pow(2, t3.z), r3 = (t3.x - 1 + i3) % i3, n4 = 0 === t3.x ? e4.wrap - 1 : e4.wrap, o3 = (t3.x + 1 + i3) % i3, s6 = t3.x + 1 === i3 ? e4.wrap + 1 : e4.wrap, a3 = {};
          return a3[new qu(e4.overscaledZ, n4, t3.z, r3, t3.y).key] = { backfilled: false }, a3[new qu(e4.overscaledZ, s6, t3.z, o3, t3.y).key] = { backfilled: false }, t3.y > 0 && (a3[new qu(e4.overscaledZ, n4, t3.z, r3, t3.y - 1).key] = { backfilled: false }, a3[new qu(e4.overscaledZ, e4.wrap, t3.z, t3.x, t3.y - 1).key] = { backfilled: false }, a3[new qu(e4.overscaledZ, s6, t3.z, o3, t3.y - 1).key] = { backfilled: false }), t3.y + 1 < i3 && (a3[new qu(e4.overscaledZ, n4, t3.z, r3, t3.y + 1).key] = { backfilled: false }, a3[new qu(e4.overscaledZ, e4.wrap, t3.z, t3.x, t3.y + 1).key] = { backfilled: false }, a3[new qu(e4.overscaledZ, s6, t3.z, o3, t3.y + 1).key] = { backfilled: false }), a3;
        }
      }, geojson: class extends zt {
        constructor(e4, t3, i3, r3) {
          super(), this.id = e4, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = i3.getActor(), this.setEventedParent(r3), this._data = t3.data, this._options = k2({}, t3), this._collectResourceTiming = t3.collectResourceTiming, void 0 !== t3.maxzoom && (this.maxzoom = t3.maxzoom), t3.type && (this.type = t3.type), t3.attribution && (this.attribution = t3.attribution), this.promoteId = t3.promoteId;
          const n4 = cr / this.tileSize;
          this.workerOptions = k2({ source: this.id, scope: this.scope, cluster: t3.cluster || false, geojsonVtOptions: { buffer: (void 0 !== t3.buffer ? t3.buffer : 128) * n4, tolerance: (void 0 !== t3.tolerance ? t3.tolerance : 0.375) * n4, extent: cr, maxZoom: this.maxzoom, lineMetrics: t3.lineMetrics || false, generateId: t3.generateId || false }, superclusterOptions: { maxZoom: void 0 !== t3.clusterMaxZoom ? t3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t3.clusterMinPoints || 2), extent: cr, radius: (void 0 !== t3.clusterRadius ? t3.clusterRadius : 50) * n4, log: false, generateId: t3.generateId || false }, clusterProperties: t3.clusterProperties, filter: t3.filter }, t3.workerOptions);
        }
        onAdd(e4) {
          this.map = e4, this.setData(this._data);
        }
        setData(e4) {
          return this._data = e4, this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e4, t3) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e4, source: this.id, scope: this.scope }, t3), this;
        }
        getClusterChildren(e4, t3) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: e4, source: this.id, scope: this.scope }, t3), this;
        }
        getClusterLeaves(e4, t3, i3, r3) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e4, limit: t3, offset: i3 }, r3), this;
        }
        _updateWorkerData() {
          if (this._pendingLoad)
            return void (this._coalesce = true);
          this.fire(new It("dataloading", { dataType: "source" })), this._loaded = false;
          const e4 = k2({}, this.workerOptions);
          e4.scope = this.scope;
          const t3 = this._data;
          "string" == typeof t3 ? (e4.request = this.map._requestManager.transformRequest(dt.resolveURL(t3), ye.Source), e4.request.collectResourceTiming = this._collectResourceTiming) : e4.data = JSON.stringify(t3), this._pendingLoad = this.actor.send(`${this.type}.loadData`, e4, (e5, t4) => {
            if (this._loaded = true, this._pendingLoad = null, e5)
              this.fire(new Ct(e5));
            else {
              const e6 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && t4 && t4.resourceTiming && t4.resourceTiming[this.id] && (e6.resourceTiming = t4.resourceTiming[this.id]), this.fire(new It("data", e6)), this._metadataFired = true;
            }
            this._coalesce && (this._updateWorkerData(), this._coalesce = false);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(e4, t3) {
          const i3 = e4.actor ? "reloadTile" : "loadTile";
          e4.actor = this.actor;
          const r3 = { type: this.type, uid: e4.uid, tileID: e4.tileID, tileZoom: e4.tileZoom, zoom: e4.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, scope: this.scope, pixelRatio: dt.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0 };
          e4.request = this.actor.send(i3, r3, (r4, n4) => (delete e4.request, e4.destroy(), e4.aborted ? t3(null) : r4 ? t3(r4) : (e4.loadVectorData(n4, this.map.painter, "reloadTile" === i3), t3(null))), void 0, "loadTile" === i3);
        }
        abortTile(e4) {
          e4.request && (e4.request.cancel(), delete e4.request), e4.aborted = true;
        }
        unloadTile(e4) {
          this.actor.send("removeTile", { uid: e4.uid, type: this.type, source: this.id, scope: this.scope }), e4.destroy();
        }
        onRemove() {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return k2({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }, video: class extends Jb {
        constructor(e4, t3, i3, r3) {
          super(e4, t3, i3, r3), this.roundZoom = true, this.type = "video", this.options = t3;
        }
        load() {
          this._loaded = false;
          const e4 = this.options;
          this.urls = [];
          for (const t3 of e4.urls)
            this.urls.push(this.map._requestManager.transformRequest(t3, ye.Source).url);
          !function(e5, i3) {
            const r3 = t2.document.createElement("video");
            r3.muted = true, r3.onloadstart = function() {
              i3(null, r3);
            };
            for (let i4 = 0; i4 < e5.length; i4++) {
              const n4 = t2.document.createElement("source");
              Ee(e5[i4]) || (r3.crossOrigin = "Anonymous"), n4.src = e5[i4], r3.appendChild(n4);
            }
          }(this.urls, (e5, t3) => {
            this._loaded = true, e5 ? this.fire(new Ct(e5)) : t3 && (this.video = t3, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(e4) {
          if (this.video) {
            const t3 = this.video.seekable;
            e4 < t3.start(0) || e4 > t3.end(0) ? this.fire(new Ct(new Dt(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t3.start(0)} and ${t3.end(0)}-second mark.`))) : this.video.currentTime = e4;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e4) {
          this.map || (this.map = e4, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
            return;
          const e4 = this.map.painter.context, t3 = e4.gl;
          this.texture ? this.video.paused || (this.texture.bind(t3.LINEAR, t3.CLAMP_TO_EDGE), t3.texSubImage2D(t3.TEXTURE_2D, 0, 0, 0, t3.RGBA, t3.UNSIGNED_BYTE, this.video)) : (this.texture = new My(e4, this.video, t3.RGBA), this.texture.bind(t3.LINEAR, t3.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(e4);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: Jb, model: class extends zt {
        constructor(e4, t3, i3, r3) {
          super(), this.id = e4, this.type = "model", this.models = [], this._loaded = false, this._options = t3;
        }
        load() {
          const e4 = [];
          for (const t3 in this._options.models) {
            const i3 = this._options.models[t3], r3 = fT(this.map._requestManager.transformRequest(i3.uri, ye.Model).url).then((e5) => {
              if (!e5)
                return;
              const r4 = TT(e5), n4 = new Cv(t3, i3.position, i3.orientation, r4);
              n4.computeBoundsAndApplyParent(), this.models.push(n4);
            }).catch((e5) => {
              this.fire(new Ct(new Error(`Could not load model ${t3} from ${i3.uri}: ${e5.message}`)));
            });
            e4.push(r3);
          }
          return Promise.allSettled(e4).then(() => {
            this._loaded = true, this.fire(new It("data", { dataType: "source", sourceDataType: "metadata" }));
          }).catch((e5) => {
            this.fire(new Ct(new Error(`Could not load models: ${e5.message}`)));
          });
        }
        onAdd(e4) {
          this.map = e4, this.load();
        }
        hasTransition() {
          return false;
        }
        loaded() {
          return this._loaded;
        }
        getModels() {
          return this.models;
        }
        loadTile(e4, t3) {
        }
        serialize() {
          return { type: "model" };
        }
      }, "batched-model": class extends zt {
        constructor(e4, t3, i3, r3) {
          super(), this.type = "batched-model", this.id = e4, this.tileSize = 512, this._options = t3, this.tiles = this._options.tiles, this.maxzoom = t3.maxzoom || 19, this.minzoom = t3.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i3, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(r3);
        }
        onAdd(e4) {
          this.map = e4, this.load();
        }
        load(e4) {
          this._loaded = false, this.fire(new It("dataloading", { dataType: "source" }));
          const t3 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, i3 = this.map._worldview;
          this._tileJSONRequest = Dw(this._options, this.map._requestManager, t3, i3, (r3, n4) => {
            this._tileJSONRequest = null, this._loaded = true, r3 ? (t3 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t3}`), i3 && 2 !== i3.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${i3}`), this.fire(new Ct(r3))) : n4 && (k2(this, n4), n4.bounds && (this.tileBounds = new Rw(n4.bounds, this.minzoom, this.maxzoom)), Ge(n4.tiles, this.map._requestManager._customAccessToken), this.fire(new It("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new It("data", { dataType: "source", sourceDataType: "content" }))), e4 && e4(r3);
          });
        }
        hasTransition() {
          return false;
        }
        hasTile(e4) {
          return !this.tileBounds || this.tileBounds.contains(e4.canonical);
        }
        loaded() {
          return this._loaded;
        }
        loadTile(e4, t3) {
          const i3 = this.map._requestManager.normalizeTileURL(e4.tileID.canonical.url(this.tiles, this.scheme)), r3 = { request: this.map._requestManager.transformRequest(i3, ye.Tile), data: void 0, uid: e4.uid, tileID: e4.tileID, tileZoom: e4.tileZoom, zoom: e4.tileID.overscaledZ, tileSize: this.tileSize * e4.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: e4.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0 };
          if (e4.actor && "expired" !== e4.state)
            if ("loading" === e4.state)
              e4.reloadCallback = t3;
            else {
              if (e4.buckets) {
                const t4 = Object.values(e4.buckets);
                for (const e5 of t4)
                  e5.dirty = true;
                return void (e4.state = "loaded");
              }
              e4.request = e4.actor.send("reloadTile", r3, n4.bind(this));
            }
          else
            e4.actor = this.dispatcher.getActor(), e4.request = e4.actor.send("loadTile", r3, n4.bind(this), void 0, true);
          function n4(i4, r4) {
            return e4.aborted ? t3(null) : i4 && 404 !== i4.status ? t3(i4) : (r4 && (r4.resourceTiming && (e4.resourceTiming = r4.resourceTiming), this.map._refreshExpiredTiles && e4.setExpiryData(r4), e4.buckets = { ...e4.buckets, ...r4.buckets }), e4.state = "loaded", void t3(null));
          }
        }
        serialize() {
          return k2({}, this._options);
        }
      }, canvas: class extends Jb {
        constructor(e4, i3, r3, n4) {
          super(e4, i3, r3, n4), i3.coordinates ? Array.isArray(i3.coordinates) && 4 === i3.coordinates.length && !i3.coordinates.some((e5) => !Array.isArray(e5) || 2 !== e5.length || e5.some((e6) => "number" != typeof e6)) || this.fire(new Ct(new Dt(`sources.${e4}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new Ct(new Dt(`sources.${e4}`, null, 'missing required property "coordinates"'))), i3.animate && "boolean" != typeof i3.animate && this.fire(new Ct(new Dt(`sources.${e4}`, null, 'optional "animate" property must be a boolean value'))), i3.canvas ? "string" == typeof i3.canvas || i3.canvas instanceof t2.HTMLCanvasElement || this.fire(new Ct(new Dt(`sources.${e4}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new Ct(new Dt(`sources.${e4}`, null, 'missing required property "canvas"'))), this.options = i3, this.animate = void 0 === i3.animate || i3.animate;
        }
        load() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof t2.HTMLCanvasElement ? this.options.canvas : t2.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new Ct(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e4) {
          this.map = e4, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let e4 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e4 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e4 = true), this._hasInvalidDimensions())
            return;
          if (0 === Object.keys(this.tiles).length)
            return;
          const t3 = this.map.painter.context;
          this.texture ? !e4 && !this._playing || this.texture instanceof Ay || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new My(t3, this.canvas, t3.gl.RGBA, { premultiply: true }), this._prepareData(t3);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e4 of [this.canvas.width, this.canvas.height])
            if (isNaN(e4) || e4 <= 0)
              return true;
          return false;
        }
      }, custom: class extends zt {
        constructor(e4, t3, i3, r3) {
          super(), this.id = e4, this.type = "custom", this._dataType = "raster", this._dispatcher = i3, this._implementation = t3, this.setEventedParent(r3), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new Ct(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new Ct(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Rw(this._implementation.bounds, this.minzoom, this.maxzoom)), t3.update = this._update.bind(this), t3.clearTiles = this._clearTiles.bind(this), t3.coveringTiles = this._coveringTiles.bind(this), k2(this, O(t3, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return O(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = true, this.fire(new It("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new It("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e4) {
          this._map = e4, this._loaded = false, this.fire(new It("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(e4), this.load();
        }
        onRemove(e4) {
          this._implementation.onRemove && this._implementation.onRemove(e4);
        }
        hasTile(e4) {
          if (this._implementation.hasTile) {
            const { x: t3, y: i3, z: r3 } = e4.canonical;
            return this._implementation.hasTile({ x: t3, y: i3, z: r3 });
          }
          return !this.tileBounds || this.tileBounds.contains(e4.canonical);
        }
        loadTile(e4, i3) {
          const { x: r3, y: n4, z: o3 } = e4.tileID.canonical, s6 = new t2.AbortController();
          e4.request = Promise.resolve(this._implementation.loadTile({ x: r3, y: n4, z: o3 }, { signal: s6.signal })).then((function(r4) {
            return delete e4.request, e4.aborted ? (e4.state = "unloaded", i3(null)) : void 0 === r4 ? (e4.state = "errored", i3(null)) : null === r4 ? (this.loadTileData(e4, { width: this.tileSize, height: this.tileSize, data: null }), e4.state = "loaded", i3(null)) : function(e5) {
              return e5 instanceof t2.ImageData || e5 instanceof t2.HTMLCanvasElement || e5 instanceof t2.ImageBitmap || e5 instanceof t2.HTMLImageElement;
            }(r4) ? (this.loadTileData(e4, r4), e4.state = "loaded", void i3(null)) : (e4.state = "errored", i3(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
          }).bind(this)).catch((t3) => {
            20 !== t3.code && (e4.state = "errored", i3(t3));
          }), e4.request.cancel = () => s6.abort();
        }
        loadTileData(e4, t3) {
          e4.setTexture(t3, this._map.painter);
        }
        unloadTile(e4, t3) {
          if (e4.texture && e4.texture instanceof My ? (e4.destroy(true), e4.texture && e4.texture instanceof My && this._map.painter.saveTileTexture(e4.texture)) : e4.destroy(), this._implementation.unloadTile) {
            const { x: t4, y: i3, z: r3 } = e4.tileID.canonical;
            this._implementation.unloadTile({ x: t4, y: i3, z: r3 });
          }
          t3();
        }
        abortTile(e4, t3) {
          e4.request && e4.request.cancel && (e4.request.cancel(), delete e4.request), t3();
        }
        hasTransition() {
          return false;
        }
        _coveringTiles() {
          return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e4) => ({ x: e4.canonical.x, y: e4.canonical.y, z: e4.canonical.z }));
        }
        _clearTiles() {
          const e4 = va(this.id, this.scope);
          this._map.style.clearSource(e4);
        }
        _update() {
          this.fire(new It("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, ST = function(e4, t3, i3, r3) {
        const n4 = new AT[t3.type](e4, t3, i3, r3);
        if (n4.id !== e4)
          throw new Error(`Expected Source id to be ${e4} instead of ${n4.id}`);
        return j2(["load", "abort", "unload", "serialize", "prepare"], n4), n4;
      };
      function IT(e4, t3) {
        const i3 = Au.identity([]);
        return Au.scale(i3, i3, [0.5 * e4.width, 0.5 * -e4.height, 1]), Au.translate(i3, i3, [1, -1, 0]), Au.multiply(i3, i3, e4.calculateProjMatrix(t3.toUnwrapped())), Float32Array.from(i3);
      }
      function CT(e4, t3, i3, r3, n4, o3, s6, a3 = false) {
        const l3 = e4.tilesIn(r3, s6, a3);
        l3.sort(PT);
        const c3 = [];
        for (const r4 of l3)
          c3.push({ wrappedTileID: r4.tile.tileID.wrapped().key, queryResults: r4.tile.queryRenderedFeatures(t3, i3, e4._state, r4, n4, o3, IT(e4.transform, r4.tile.tileID), a3) });
        const h3 = function(e5) {
          const t4 = {}, i4 = {};
          for (const r4 of e5) {
            const e6 = r4.queryResults, n5 = r4.wrappedTileID, o4 = i4[n5] = i4[n5] || {};
            for (const i5 in e6) {
              const r5 = e6[i5], n6 = o4[i5] = o4[i5] || {}, s7 = t4[i5] = t4[i5] || [];
              for (const e7 of r5)
                n6[e7.featureIndex] || (n6[e7.featureIndex] = true, s7.push(e7));
            }
          }
          return t4;
        }(c3);
        for (const t4 in h3)
          h3[t4].forEach((t5) => {
            const i4 = t5.feature, r4 = i4.layer;
            r4 && "background" !== r4.type && "sky" !== r4.type && "slot" !== r4.type && (i4.source = r4.source, r4["source-layer"] && (i4.sourceLayer = r4["source-layer"]), i4.state = void 0 !== i4.id ? e4.getFeatureState(r4["source-layer"], i4.id) : {});
          });
        return h3;
      }
      function zT(e4, t3) {
        const i3 = e4.getRenderableIds().map((t4) => e4.getTileByID(t4)), r3 = [], n4 = {};
        for (let e5 = 0; e5 < i3.length; e5++) {
          const o3 = i3[e5], s6 = o3.tileID.canonical.key;
          n4[s6] || (n4[s6] = true, o3.querySourceFeatures(r3, t3));
        }
        return r3;
      }
      function PT(e4, t3) {
        const i3 = e4.tileID, r3 = t3.tileID;
        return i3.overscaledZ - r3.overscaledZ || i3.canonical.y - r3.canonical.y || i3.wrap - r3.wrap || i3.canonical.x - r3.canonical.x;
      }
      class DT {
        constructor(e4) {
          this.style = e4;
        }
        processLayersChanged() {
          this.layers = [];
          for (const e4 in this.style._mergedLayers) {
            const t3 = this.style._mergedLayers[e4];
            if ("fill-extrusion" === t3.type)
              this.layers.push(t3);
            else if ("model" === t3.type) {
              const e5 = this.style.getLayerSource(t3);
              e5 && "batched-model" === e5.type && this.layers.push(t3);
            }
          }
        }
        updateZOffset(e4, t3) {
          this.currentBuildingBuckets = [];
          for (let e5 = 0; e5 < this.layers.length; ++e5) {
            const i4 = this.layers[e5], r3 = this.style.getLayerSourceCache(i4);
            let n4 = 1;
            "fill-extrusion" === i4.type && (n4 = i4.paint.get("fill-extrusion-opacity") > 0 ? i4.paint.get("fill-extrusion-vertical-scale") : 0);
            let o3 = r3 ? r3.getTile(t3) : null;
            if (!o3 && r3 && t3.canonical.z > r3.getSource().minzoom) {
              let e6 = t3.scaledTo(Math.min(r3.getSource().maxzoom, t3.overscaledZ - 1));
              for (; e6.overscaledZ >= r3.getSource().minzoom && (o3 = r3.getTile(e6), !o3 && 0 !== e6.overscaledZ); )
                e6 = e6.scaledTo(e6.overscaledZ - 1);
            }
            this.currentBuildingBuckets.push({ bucket: o3 ? o3.getBucket(i4) : null, tileID: o3 ? o3.tileID : t3, verticalScale: n4 });
          }
          e4.hasAnyZOffset = false;
          let i3 = false;
          for (let r3 = 0; r3 < e4.symbolInstances.length; r3++) {
            const n4 = e4.symbolInstances.get(r3), o3 = n4.zOffset, s6 = this._getHeightAtTileOffset(t3, n4.tileAnchorX, n4.tileAnchorY);
            n4.zOffset = -1 !== s6 ? s6 : o3, i3 || o3 === n4.zOffset || (i3 = true), e4.hasAnyZOffset || 0 === n4.zOffset || (e4.hasAnyZOffset = true);
          }
          i3 && (e4.zOffsetBuffersNeedUpload = true, e4.zOffsetSortDirty = true);
        }
        _mapCoordToOverlappingTile(e4, t3, i3, r3) {
          let n4 = t3, o3 = i3;
          if (e4.canonical.z !== r3.canonical.z) {
            const s6 = r3.canonical, a3 = 1 / (1 << e4.canonical.z - s6.z);
            n4 = (t3 + e4.canonical.x * cr) * a3 - s6.x * cr | 0, o3 = (i3 + e4.canonical.y * cr) * a3 - s6.y * cr | 0;
          }
          return { tileX: n4, tileY: o3 };
        }
        _getHeightAtTileOffset(e4, t3, i3) {
          let r3;
          for (let n4 = 0; n4 < this.layers.length; ++n4) {
            if ("fill-extrusion" !== this.layers[n4].type)
              continue;
            const { bucket: o3, tileID: s6, verticalScale: a3 } = this.currentBuildingBuckets[n4];
            if (!o3)
              continue;
            const { tileX: l3, tileY: c3 } = this._mapCoordToOverlappingTile(e4, t3, i3, s6), h3 = o3.getHeightAtTileCoord(l3, c3);
            if (h3 && void 0 !== h3.height) {
              if (!h3.hidden)
                return h3.height * a3;
              r3 = h3.height;
            }
          }
          for (let n4 = 0; n4 < this.layers.length; ++n4) {
            if ("model" !== this.layers[n4].type)
              continue;
            const { bucket: o3, tileID: s6 } = this.currentBuildingBuckets[n4];
            if (!o3)
              continue;
            const { tileX: a3, tileY: l3 } = this._mapCoordToOverlappingTile(e4, t3, i3, s6), c3 = o3.getHeightAtTileCoord(a3, l3);
            if (c3 && !c3.hidden)
              return void 0 === c3.height && void 0 !== r3 ? Math.min(c3.maxHeight, r3) * c3.verticalScale : (c3.height || 0) * c3.verticalScale;
          }
          return -1;
        }
      }
      var RT = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function LT(e4, t3) {
        const i3 = {};
        for (const t4 in e4)
          "ref" !== t4 && (i3[t4] = e4[t4]);
        return RT.forEach((e5) => {
          e5 in t3 && (i3[e5] = t3[e5]);
        }), i3;
      }
      function kT(e4) {
        e4 = e4.slice();
        const t3 = /* @__PURE__ */ Object.create(null);
        for (let i3 = 0; i3 < e4.length; i3++)
          t3[e4[i3].id] = e4[i3];
        for (let i3 = 0; i3 < e4.length; i3++)
          "ref" in e4[i3] && (e4[i3] = LT(e4[i3], t3[e4[i3].ref]));
        return e4;
      }
      const OT = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", setImportUrl: "setImportUrl", setImportData: "setImportData", setImportConfig: "setImportConfig" };
      function BT(e4, t3, i3) {
        i3.push({ command: OT.addSource, args: [e4, t3[e4]] });
      }
      function FT(e4, t3, i3) {
        t3.push({ command: OT.removeSource, args: [e4] }), i3[e4] = true;
      }
      function NT(e4, t3, i3, r3) {
        FT(e4, i3, r3), BT(e4, t3, i3);
      }
      function UT(e4, t3, i3) {
        let r3;
        for (r3 in e4[i3])
          if (e4[i3].hasOwnProperty(r3) && "data" !== r3 && !x2(e4[i3][r3], t3[i3][r3]))
            return false;
        for (r3 in t3[i3])
          if (t3[i3].hasOwnProperty(r3) && "data" !== r3 && !x2(e4[i3][r3], t3[i3][r3]))
            return false;
        return true;
      }
      function VT(e4, t3, i3, r3, n4, o3) {
        let s6;
        for (s6 in t3 = t3 || {}, e4 = e4 || {})
          e4.hasOwnProperty(s6) && (x2(e4[s6], t3[s6]) || i3.push({ command: o3, args: [r3, s6, t3[s6], n4] }));
        for (s6 in t3)
          t3.hasOwnProperty(s6) && !e4.hasOwnProperty(s6) && (x2(e4[s6], t3[s6]) || i3.push({ command: o3, args: [r3, s6, t3[s6], n4] }));
      }
      function jT(e4) {
        return e4.id;
      }
      function GT(e4, t3) {
        return e4[t3.id] = t3, e4;
      }
      class qT {
        constructor(e4, t3) {
          this.reset(e4, t3);
        }
        reset(e4, t3) {
          this.points = e4 || [], this._distances = [0];
          for (let e5 = 1; e5 < this.points.length; e5++)
            this._distances[e5] = this._distances[e5 - 1] + this.points[e5].dist(this.points[e5 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(e4) {
          if (1 === this.points.length)
            return this.points[0];
          e4 = z(e4, 0, 1);
          let t3 = 1, i3 = this._distances[t3];
          const r3 = e4 * this.paddedLength + this.padding;
          for (; i3 < r3 && t3 < this._distances.length; )
            i3 = this._distances[++t3];
          const n4 = t3 - 1, o3 = this._distances[n4], s6 = i3 - o3, a3 = s6 > 0 ? (r3 - o3) / s6 : 0;
          return this.points[n4].mult(1 - a3).add(this.points[t3].mult(a3));
        }
      }
      class ZT {
        constructor(e4, t3, i3) {
          const r3 = this.boxCells = [], n4 = this.circleCells = [];
          this.xCellCount = Math.ceil(e4 / i3), this.yCellCount = Math.ceil(t3 / i3);
          for (let e5 = 0; e5 < this.xCellCount * this.yCellCount; e5++)
            r3.push([]), n4.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e4, this.height = t3, this.xScale = this.xCellCount / e4, this.yScale = this.yCellCount / t3, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e4, t3, i3, r3, n4) {
          this._forEachCell(t3, i3, r3, n4, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e4), this.bboxes.push(t3), this.bboxes.push(i3), this.bboxes.push(r3), this.bboxes.push(n4);
        }
        insertCircle(e4, t3, i3, r3) {
          this._forEachCell(t3 - r3, i3 - r3, t3 + r3, i3 + r3, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e4), this.circles.push(t3), this.circles.push(i3), this.circles.push(r3);
        }
        _insertBoxCell(e4, t3, i3, r3, n4, o3) {
          this.boxCells[n4].push(o3);
        }
        _insertCircleCell(e4, t3, i3, r3, n4, o3) {
          this.circleCells[n4].push(o3);
        }
        _query(e4, t3, i3, r3, n4, o3) {
          if (i3 < 0 || e4 > this.width || r3 < 0 || t3 > this.height)
            return !n4 && [];
          const s6 = [];
          if (e4 <= 0 && t3 <= 0 && this.width <= i3 && this.height <= r3) {
            if (n4)
              return true;
            for (let e5 = 0; e5 < this.boxKeys.length; e5++)
              s6.push({ key: this.boxKeys[e5], x1: this.bboxes[4 * e5], y1: this.bboxes[4 * e5 + 1], x2: this.bboxes[4 * e5 + 2], y2: this.bboxes[4 * e5 + 3] });
            for (let e5 = 0; e5 < this.circleKeys.length; e5++) {
              const t4 = this.circles[3 * e5], i4 = this.circles[3 * e5 + 1], r4 = this.circles[3 * e5 + 2];
              s6.push({ key: this.circleKeys[e5], x1: t4 - r4, y1: i4 - r4, x2: t4 + r4, y2: i4 + r4 });
            }
            return o3 ? s6.filter(o3) : s6;
          }
          return this._forEachCell(e4, t3, i3, r3, this._queryCell, s6, { hitTest: n4, seenUids: { box: {}, circle: {} } }, o3), n4 ? s6.length > 0 : s6;
        }
        _queryCircle(e4, t3, i3, r3, n4) {
          const o3 = e4 - i3, s6 = e4 + i3, a3 = t3 - i3, l3 = t3 + i3;
          if (s6 < 0 || o3 > this.width || l3 < 0 || a3 > this.height)
            return !r3 && [];
          const c3 = [];
          return this._forEachCell(o3, a3, s6, l3, this._queryCellCircle, c3, { hitTest: r3, circle: { x: e4, y: t3, radius: i3 }, seenUids: { box: {}, circle: {} } }, n4), r3 ? c3.length > 0 : c3;
        }
        query(e4, t3, i3, r3, n4) {
          return this._query(e4, t3, i3, r3, false, n4);
        }
        hitTest(e4, t3, i3, r3, n4) {
          return this._query(e4, t3, i3, r3, true, n4);
        }
        hitTestCircle(e4, t3, i3, r3) {
          return this._queryCircle(e4, t3, i3, true, r3);
        }
        _queryCell(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = s6.seenUids, c3 = this.boxCells[n4];
          if (null !== c3) {
            const n5 = this.bboxes;
            for (const h4 of c3)
              if (!l3.box[h4]) {
                l3.box[h4] = true;
                const c4 = 4 * h4;
                if (e4 <= n5[c4 + 2] && t3 <= n5[c4 + 3] && i3 >= n5[c4 + 0] && r3 >= n5[c4 + 1] && (!a3 || a3(this.boxKeys[h4]))) {
                  if (s6.hitTest)
                    return o3.push(true), true;
                  o3.push({ key: this.boxKeys[h4], x1: n5[c4], y1: n5[c4 + 1], x2: n5[c4 + 2], y2: n5[c4 + 3] });
                }
              }
          }
          const h3 = this.circleCells[n4];
          if (null !== h3) {
            const n5 = this.circles;
            for (const c4 of h3)
              if (!l3.circle[c4]) {
                l3.circle[c4] = true;
                const h4 = 3 * c4;
                if (this._circleAndRectCollide(n5[h4], n5[h4 + 1], n5[h4 + 2], e4, t3, i3, r3) && (!a3 || a3(this.circleKeys[c4]))) {
                  if (s6.hitTest)
                    return o3.push(true), true;
                  {
                    const e5 = n5[h4], t4 = n5[h4 + 1], i4 = n5[h4 + 2];
                    o3.push({ key: this.circleKeys[c4], x1: e5 - i4, y1: t4 - i4, x2: e5 + i4, y2: t4 + i4 });
                  }
                }
              }
          }
        }
        _queryCellCircle(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = s6.circle, c3 = s6.seenUids, h3 = this.boxCells[n4];
          if (null !== h3) {
            const e5 = this.bboxes;
            for (const t4 of h3)
              if (!c3.box[t4]) {
                c3.box[t4] = true;
                const i4 = 4 * t4;
                if (this._circleAndRectCollide(l3.x, l3.y, l3.radius, e5[i4 + 0], e5[i4 + 1], e5[i4 + 2], e5[i4 + 3]) && (!a3 || a3(this.boxKeys[t4])))
                  return o3.push(true), true;
              }
          }
          const u3 = this.circleCells[n4];
          if (null !== u3) {
            const e5 = this.circles;
            for (const t4 of u3)
              if (!c3.circle[t4]) {
                c3.circle[t4] = true;
                const i4 = 3 * t4;
                if (this._circlesCollide(e5[i4], e5[i4 + 1], e5[i4 + 2], l3.x, l3.y, l3.radius) && (!a3 || a3(this.circleKeys[t4])))
                  return o3.push(true), true;
              }
          }
        }
        _forEachCell(e4, t3, i3, r3, n4, o3, s6, a3) {
          const l3 = this._convertToXCellCoord(e4), c3 = this._convertToYCellCoord(t3), h3 = this._convertToXCellCoord(i3), u3 = this._convertToYCellCoord(r3);
          for (let d3 = l3; d3 <= h3; d3++)
            for (let l4 = c3; l4 <= u3; l4++)
              if (n4.call(this, e4, t3, i3, r3, this.xCellCount * l4 + d3, o3, s6, a3))
                return;
        }
        _convertToXCellCoord(e4) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e4 * this.xScale)));
        }
        _convertToYCellCoord(e4) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e4 * this.yScale)));
        }
        _circlesCollide(e4, t3, i3, r3, n4, o3) {
          const s6 = r3 - e4, a3 = n4 - t3, l3 = i3 + o3;
          return l3 * l3 > s6 * s6 + a3 * a3;
        }
        _circleAndRectCollide(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = (o3 - r3) / 2, l3 = Math.abs(e4 - (r3 + a3));
          if (l3 > a3 + i3)
            return false;
          const c3 = (s6 - n4) / 2, h3 = Math.abs(t3 - (n4 + c3));
          if (h3 > c3 + i3)
            return false;
          if (l3 <= a3 || h3 <= c3)
            return true;
          const u3 = l3 - a3, d3 = h3 - c3;
          return u3 * u3 + d3 * d3 <= i3 * i3;
        }
      }
      const $T = 100;
      class WT {
        constructor(e4, t3, i3 = new ZT(e4.width + 200, e4.height + 200, 25), r3 = new ZT(e4.width + 200, e4.height + 200, 25)) {
          this.transform = e4, this.grid = i3, this.ignoredGrid = r3, this.pitchfactor = Math.cos(e4._pitch) * e4.cameraToCenterDistance, this.screenRightBoundary = e4.width + $T, this.screenBottomBoundary = e4.height + $T, this.gridRightBoundary = e4.width + 200, this.gridBottomBoundary = e4.height + 200, this.fogState = t3;
        }
        placeCollisionBox(e4, t3, i3, r3, n4, o3, s6, a3) {
          let l3 = i3.projectedAnchorX, c3 = i3.projectedAnchorY, h3 = i3.projectedAnchorZ;
          const u3 = i3.elevation, d3 = i3.tileID, p3 = e4.getProjection();
          if (u3 && d3) {
            const [e5, t4, r4] = p3.upVector(d3.canonical, i3.tileAnchorX, i3.tileAnchorY), n5 = p3.upVectorScale(d3.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            l3 += e5 * u3 * n5, c3 += t4 * u3 * n5, h3 += r4 * u3 * n5;
          }
          const f3 = this.projectAndGetPerspectiveRatio(s6, l3, c3, h3, i3.tileID, "globe" === p3.name || !!u3 || this.transform.pitch > 0, p3), m3 = o3 * f3.perspectiveRatio, _3 = (i3.x1 * t3 + r3.x - i3.padding) * m3 + f3.point.x, g3 = (i3.y1 * t3 + r3.y - i3.padding) * m3 + f3.point.y, y3 = (i3.x2 * t3 + r3.x + i3.padding) * m3 + f3.point.x, x3 = (i3.y2 * t3 + r3.y + i3.padding) * m3 + f3.point.y, v3 = f3.perspectiveRatio <= 0.55 || f3.occluded;
          return !this.isInsideGrid(_3, g3, y3, x3) || !n4 && this.grid.hitTest(_3, g3, y3, x3, a3) || v3 ? { box: [], offscreen: false, occluded: f3.occluded } : { box: [_3, g3, y3, x3], offscreen: this.isOffscreen(_3, g3, y3, x3), occluded: false };
        }
        placeCollisionCircles(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3) {
          const m3 = [], _3 = this.transform.elevation, g3 = e4.getProjection(), x3 = _3 ? _3.getAtTileOffsetFunc(f3, this.transform.center.lat, this.transform.worldSize, g3) : null, v3 = new y2(i3.tileAnchorX, i3.tileAnchorY);
          let { x: b3, y: w3, z: T3 } = g3.projectTilePoint(v3.x, v3.y, f3.canonical);
          if (x3) {
            const [e5, t4, i4] = x3(v3);
            b3 += e5, w3 += t4, T3 += i4;
          }
          const E3 = "globe" === g3.name, M3 = this.projectAndGetPerspectiveRatio(s6, b3, w3, T3, f3, E3 || !!_3 || this.transform.pitch > 0, g3), { perspectiveRatio: A3 } = M3, S3 = (h3 ? o3 / A3 : o3 * A3) / u_, I3 = cv(b3, w3, T3, a3), C3 = M3.signedDistanceFromCamera > 0 ? pv(S3, n4, i3.lineOffsetX * S3, i3.lineOffsetY * S3, false, I3, v3, i3, r3, a3, {}, _3 && !h3 ? x3 : null, h3 && !!_3, g3, f3, h3) : null;
          let z2 = false, P3 = false, D2 = true;
          if (C3 && !M3.occluded) {
            const e5 = 0.5 * d3 * A3 + p3, i4 = new y2(-100, -100), r4 = new y2(this.screenRightBoundary, this.screenBottomBoundary), n5 = new qT(), { first: o4, last: s7 } = C3, a4 = o4.path.length;
            let h4 = [];
            for (let e6 = a4 - 1; e6 >= 1; e6--)
              h4.push(o4.path[e6]);
            for (let e6 = 1; e6 < s7.path.length; e6++)
              h4.push(s7.path[e6]);
            const f4 = 2.5 * e5;
            l3 && (h4 = h4.map(([e6, t4, i5], r5) => (x3 && !E3 && (i5 = x3(r5 < a4 - 1 ? o4.tilePath[a4 - 1 - r5] : s7.tilePath[r5 - a4 + 2])[2]), cv(e6, t4, i5, l3))), h4.some((e6) => e6[3] <= 0) && (h4 = []));
            let _4 = [];
            if (h4.length > 0) {
              let e6 = 1 / 0, t4 = -1 / 0, n6 = 1 / 0, o5 = -1 / 0;
              for (const i5 of h4)
                e6 = Math.min(e6, i5[0]), n6 = Math.min(n6, i5[1]), t4 = Math.max(t4, i5[0]), o5 = Math.max(o5, i5[1]);
              t4 >= i4.x && e6 <= r4.x && o5 >= i4.y && n6 <= r4.y && (_4 = [h4.map((e7) => new y2(e7[0], e7[1]))], (e6 < i4.x || t4 > r4.x || n6 < i4.y || o5 > r4.y) && (_4 = Y_(_4, i4.x, i4.y, r4.x, r4.y)));
            }
            for (const i5 of _4) {
              n5.reset(i5, 0.25 * e5);
              let r5 = 0;
              r5 = n5.length <= 0.5 * e5 ? 1 : Math.ceil(n5.paddedLength / f4) + 1;
              for (let i6 = 0; i6 < r5; i6++) {
                const o5 = i6 / Math.max(r5 - 1, 1), s8 = n5.lerp(o5), a5 = s8.x + $T, l4 = s8.y + $T;
                m3.push(a5, l4, e5, 0);
                const h5 = a5 - e5, d4 = l4 - e5, p4 = a5 + e5, f5 = l4 + e5;
                if (D2 = D2 && this.isOffscreen(h5, d4, p4, f5), P3 = P3 || this.isInsideGrid(h5, d4, p4, f5), !t3 && this.grid.hitTestCircle(a5, l4, e5, u3) && (z2 = true, !c3))
                  return { circles: [], offscreen: false, collisionDetected: z2, occluded: false };
              }
            }
          }
          return { circles: !c3 && z2 || !P3 ? [] : m3, offscreen: D2, collisionDetected: z2, occluded: M3.occluded };
        }
        queryRenderedSymbols(e4) {
          if (0 === e4.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
            return {};
          const t3 = [];
          let i3 = 1 / 0, r3 = 1 / 0, n4 = -1 / 0, o3 = -1 / 0;
          for (const s7 of e4) {
            const e5 = new y2(s7.x + $T, s7.y + $T);
            i3 = Math.min(i3, e5.x), r3 = Math.min(r3, e5.y), n4 = Math.max(n4, e5.x), o3 = Math.max(o3, e5.y), t3.push(e5);
          }
          const s6 = this.grid.query(i3, r3, n4, o3).concat(this.ignoredGrid.query(i3, r3, n4, o3)), a3 = {}, l3 = {};
          for (const e5 of s6) {
            const i4 = e5.key;
            void 0 === a3[i4.bucketInstanceId] && (a3[i4.bucketInstanceId] = {}), a3[i4.bucketInstanceId][i4.featureIndex] || bp(t3, [new y2(e5.x1, e5.y1), new y2(e5.x2, e5.y1), new y2(e5.x2, e5.y2), new y2(e5.x1, e5.y2)]) && (a3[i4.bucketInstanceId][i4.featureIndex] = true, void 0 === l3[i4.bucketInstanceId] && (l3[i4.bucketInstanceId] = []), l3[i4.bucketInstanceId].push(i4.featureIndex));
          }
          return l3;
        }
        insertCollisionBox(e4, t3, i3, r3, n4) {
          (t3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i3, featureIndex: r3, collisionGroupID: n4 }, e4[0], e4[1], e4[2], e4[3]);
        }
        insertCollisionCircles(e4, t3, i3, r3, n4) {
          const o3 = t3 ? this.ignoredGrid : this.grid, s6 = { bucketInstanceId: i3, featureIndex: r3, collisionGroupID: n4 };
          for (let t4 = 0; t4 < e4.length; t4 += 4)
            o3.insertCircle(s6, e4[t4], e4[t4 + 1], e4[t4 + 2]);
        }
        projectAndGetPerspectiveRatio(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = [t3, i3, r3, 1];
          let l3 = false;
          if (r3 || this.transform.pitch > 0) {
            if (yu.transformMat4(a3, a3, e4), this.fogState && n4 && "globe" !== s6.name) {
              const e5 = function(e6, t4, i4, r4, n5, o4) {
                const s7 = o4.calculateFogTileMatrix(n5), a4 = [t4, i4, r4];
                return Du.transformMat4(a4, a4, s7), mw(e6, Du.length(a4), o4.pitch, o4._fov);
              }(this.fogState, t3, i3, r3, n4.toUnwrapped(), this.transform);
              l3 = e5 > 0.9;
            }
          } else
            vv(a3, a3, e4);
          const c3 = a3[3];
          return { point: new y2((a3[0] / c3 + 1) / 2 * this.transform.width + $T, (-a3[1] / c3 + 1) / 2 * this.transform.height + $T), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(s6) / c3 * 0.5, 1.5), signedDistanceFromCamera: c3, occluded: o3 && a3[2] > c3 || l3 };
        }
        isOffscreen(e4, t3, i3, r3) {
          return i3 < $T || e4 >= this.screenRightBoundary || r3 < $T || t3 > this.screenBottomBoundary;
        }
        isInsideGrid(e4, t3, i3, r3) {
          return i3 >= 0 && e4 < this.gridRightBoundary && r3 >= 0 && t3 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const e4 = Au.identity([]);
          return Au.translate(e4, e4, [-100, -100, 0]), e4;
        }
      }
      function HT(e4, t3, i3) {
        const r3 = t3.createTileMatrix(e4, e4.worldSize, i3.toUnwrapped());
        return Au.multiply(new Float32Array(16), e4.projMatrix, r3);
      }
      function XT(e4, t3, i3) {
        if (t3.projection.name === i3.projection.name)
          return e4.projMatrix;
        const r3 = i3.clone();
        return r3.setProjection(t3.projection), HT(r3, t3.getProjection(), e4);
      }
      function YT(e4, t3, i3) {
        return t3.name === i3.projection.name ? e4.projMatrix : HT(i3, t3, e4);
      }
      class KT {
        constructor(e4, t3, i3, r3) {
          this.opacity = e4 ? Math.max(0, Math.min(1, e4.opacity + (e4.placed ? t3 : -t3))) : r3 && i3 ? 1 : 0, this.placed = i3;
        }
        isHidden() {
          return 0 === this.opacity && !this.placed;
        }
      }
      class JT {
        constructor(e4, t3, i3, r3, n4, o3 = false) {
          this.text = new KT(e4 ? e4.text : null, t3, i3, n4), this.icon = new KT(e4 ? e4.icon : null, t3, r3, n4), this.clipped = o3;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class QT {
        constructor(e4, t3, i3, r3 = false) {
          this.text = e4, this.icon = t3, this.skipFade = i3, this.clipped = r3;
        }
      }
      class eE {
        constructor() {
          this.invProjMatrix = Au.create(), this.viewportMatrix = Au.create(), this.circles = [];
        }
      }
      class tE {
        constructor(e4, t3, i3, r3, n4) {
          this.bucketInstanceId = e4, this.featureIndex = t3, this.sourceLayerIndex = i3, this.bucketIndex = r3, this.tileID = n4;
        }
      }
      class iE {
        constructor(e4) {
          this.crossSourceCollisions = e4, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e4) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[e4]) {
            const t3 = ++this.maxGroupID;
            this.collisionGroups[e4] = { ID: t3, predicate: (e5) => e5.collisionGroupID === t3 };
          }
          return this.collisionGroups[e4];
        }
      }
      function rE(e4, t3, i3, r3, n4) {
        const { horizontalAlign: o3, verticalAlign: s6 } = F_(e4), a3 = -(o3 - 0.5) * t3, l3 = -(s6 - 0.5) * i3, c3 = xg(e4, r3);
        return new y2(a3 + c3[0] * n4, l3 + c3[1] * n4);
      }
      function nE(e4, t3, i3, r3, n4) {
        const o3 = new y2(e4, t3);
        return i3 && o3._rotate(r3 ? n4 : -n4), o3;
      }
      class oE {
        constructor(e4, t3, i3, r3, n4, o3) {
          this.transform = e4.clone(), this.projection = e4.projection.name, this.collisionIndex = new WT(this.transform, n4), this.buildingIndex = o3, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t3, this.retainedQueryData = {}, this.collisionGroups = new iE(i3), this.collisionCircleArrays = {}, this.prevPlacement = r3, r3 && (r3.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(e4, t3, i3, r3) {
          const n4 = i3.getBucket(t3), o3 = i3.latestFeatureIndex;
          if (!n4 || !o3 || t3.fqid !== n4.layerIds[0])
            return;
          const s6 = n4.layers[0].layout, a3 = i3.collisionBoxArray, l3 = Math.pow(2, this.transform.zoom - i3.tileID.overscaledZ), c3 = i3.tileSize / cr, h3 = i3.tileID.toUnwrapped();
          this.transform.setProjection(n4.projection);
          const u3 = (d3 = i3.tileID, p3 = n4.getProjection(), f3 = this.transform, p3.name === this.projection ? f3.calculateProjMatrix(d3.toUnwrapped()) : HT(f3, p3, d3));
          var d3, p3, f3;
          const m3 = "map" === s6.get("text-pitch-alignment"), _3 = "map" === s6.get("text-rotation-alignment");
          t3.compileFilter();
          const g3 = t3.dynamicFilter(), y3 = t3.dynamicFilterNeedsFeature(), x3 = this.transform.calculatePixelsToTileUnitsMatrix(i3), v3 = av(u3, i3.tileID.canonical, m3, _3, this.transform, n4.getProjection(), x3);
          let b3 = null;
          if (m3) {
            const e5 = lv(u3, i3.tileID.canonical, m3, _3, this.transform, n4.getProjection(), x3);
            b3 = Au.multiply([], this.transform.labelPlaneMatrix, e5);
          }
          let w3 = null;
          g3 && i3.latestFeatureIndex && (w3 = { unwrappedTileID: h3, dynamicFilter: g3, dynamicFilterNeedsFeature: y3, featureIndex: i3.latestFeatureIndex }), this.retainedQueryData[n4.bucketInstanceId] = new tE(n4.bucketInstanceId, o3, n4.sourceLayerIndex, n4.index, i3.tileID);
          const T3 = { bucket: n4, layout: s6, posMatrix: u3, textLabelPlaneMatrix: v3, labelToScreenMatrix: b3, clippingData: w3, scale: l3, textPixelRatio: c3, holdingForFade: i3.holdingForFade(), collisionBoxArray: a3, partiallyEvaluatedTextSize: m_(n4.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: m_(n4.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n4.sourceID) };
          if (r3)
            for (const t4 of n4.sortKeyRanges) {
              const { sortKey: i4, symbolInstanceStart: r4, symbolInstanceEnd: n5 } = t4;
              e4.push({ sortKey: i4, symbolInstanceStart: r4, symbolInstanceEnd: n5, parameters: T3 });
            }
          else
            e4.push({ symbolInstanceStart: 0, symbolInstanceEnd: n4.symbolInstances.length, parameters: T3 });
        }
        attemptAnchorPlacement(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3) {
          const { textOffset0: y3, textOffset1: x3, crossTileID: v3 } = u3, b3 = [y3, x3], w3 = rE(e4, i3, r3, b3, n4), T3 = this.collisionIndex.placeCollisionBox(p3, n4, t3, nE(w3.x, w3.y, o3, s6, this.transform.angle), h3, a3, l3, c3.predicate);
          if (m3) {
            const e5 = p3.getSymbolInstanceIconSize(g3, this.transform.zoom, u3.placedIconSymbolIndex);
            if (0 === this.collisionIndex.placeCollisionBox(p3, e5, m3, nE(w3.x, w3.y, o3, s6, this.transform.angle), h3, a3, l3, c3.predicate).box.length)
              return;
          }
          if (T3.box.length > 0) {
            let t4;
            return this.prevPlacement && this.prevPlacement.variableOffsets[v3] && this.prevPlacement.placements[v3] && this.prevPlacement.placements[v3].text && (t4 = this.prevPlacement.variableOffsets[v3].anchor), this.variableOffsets[v3] = { textOffset: b3, width: i3, height: r3, anchor: e4, textScale: n4, prevAnchor: t4 }, this.markUsedJustification(p3, e4, u3, f3), p3.allowVerticalPlacement && (this.markUsedOrientation(p3, f3, u3), this.placedOrientations[v3] = f3), { shift: w3, placedGlyphBoxes: T3 };
          }
        }
        placeLayerBucketPart(e4, t3, i3, r3) {
          const { bucket: n4, layout: o3, posMatrix: s6, textLabelPlaneMatrix: a3, labelToScreenMatrix: l3, clippingData: c3, textPixelRatio: h3, holdingForFade: u3, collisionBoxArray: d3, partiallyEvaluatedTextSize: p3, partiallyEvaluatedIconSize: f3, collisionGroup: m3 } = e4.parameters, _3 = o3.get("text-optional"), g3 = o3.get("icon-optional"), x3 = o3.get("text-allow-overlap"), v3 = o3.get("icon-allow-overlap"), b3 = "map" === o3.get("text-rotation-alignment"), w3 = "map" === o3.get("text-pitch-alignment"), T3 = "viewport-y" === o3.get("symbol-z-order"), E3 = o3.get("symbol-z-elevate");
          this.transform.setProjection(n4.projection);
          let M3 = x3 && (v3 || !n4.hasIconData() || g3), A3 = v3 && (x3 || !n4.hasTextData() || _3);
          !n4.collisionArrays && d3 && n4.deserializeCollisionBoxes(d3), i3 && r3 && n4.updateCollisionDebugBuffers(this.transform.zoom, d3);
          const S3 = (e5, r4, d4) => {
            const { crossTileID: T4, numVerticalGlyphVertices: E4 } = e5;
            if (c3) {
              const i4 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
              let r5 = null;
              if (c3.dynamicFilterNeedsFeature) {
                const t4 = this.retainedQueryData[n4.bucketInstanceId];
                r5 = c3.featureIndex.loadFeature({ featureIndex: e5.featureIndex, bucketIndex: t4.bucketIndex, sourceLayerIndex: t4.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (!(0, c3.dynamicFilter)(i4, r5, this.retainedQueryData[n4.bucketInstanceId].tileID.canonical, new y2(e5.tileAnchorX, e5.tileAnchorY), this.transform.calculateDistanceTileData(c3.unwrappedTileID)))
                return this.placements[T4] = new QT(false, false, false, true), void t3.add(T4);
            }
            if (t3.has(T4))
              return;
            if (u3)
              return void (this.placements[T4] = new QT(false, false, false));
            let S4 = false, I3 = false, C3 = true, z2 = false, P3 = false, D2 = null, R3 = { box: null, offscreen: null, occluded: null }, L3 = { box: null, offscreen: null, occluded: null }, k3 = null, O2 = null, B2 = null, F2 = 0, N3 = 0, U2 = 0;
            d4.textFeatureIndex ? F2 = d4.textFeatureIndex : e5.useRuntimeCollisionCircles && (F2 = e5.featureIndex), d4.verticalTextFeatureIndex && (N3 = d4.verticalTextFeatureIndex);
            const V3 = (t4) => {
              t4.tileID = this.retainedQueryData[n4.bucketInstanceId].tileID;
              const i4 = this.transform.elevation;
              t4.elevation = e5.zOffset + (i4 ? i4.getAtTileOffset(t4.tileID, t4.tileAnchorX, t4.tileAnchorY) : 0);
            }, j3 = d4.textBox;
            if (j3) {
              V3(j3);
              const t4 = (t5) => {
                let i5 = A_.horizontal;
                if (n4.allowVerticalPlacement && !t5 && this.prevPlacement) {
                  const t6 = this.prevPlacement.placedOrientations[T4];
                  t6 && (this.placedOrientations[T4] = t6, i5 = t6, this.markUsedOrientation(n4, i5, e5));
                }
                return i5;
              }, i4 = (e6, t5) => {
                if (n4.allowVerticalPlacement && E4 > 0 && d4.verticalTextBox) {
                  for (const i5 of n4.writingModes)
                    if (i5 === A_.vertical ? (R3 = t5(), L3 = R3) : R3 = e6(), R3 && R3.box && R3.box.length)
                      break;
                } else
                  R3 = e6();
              };
              if (o3.get("text-variable-anchor")) {
                let a4 = o3.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[T4]) {
                  const e6 = this.prevPlacement.variableOffsets[T4];
                  a4.indexOf(e6.anchor) > 0 && (a4 = a4.filter((t5) => t5 !== e6.anchor), a4.unshift(e6.anchor));
                }
                const l4 = (t5, i5, o4) => {
                  const l5 = n4.getSymbolInstanceTextSize(p3, e5, this.transform.zoom, r4), c5 = (t5.x2 - t5.x1) * l5 + 2 * t5.padding, u4 = (t5.y2 - t5.y1) * l5 + 2 * t5.padding, d5 = e5.hasIconTextFit && !v3 ? i5 : null;
                  d5 && V3(d5);
                  let _4 = { box: [], offscreen: false, occluded: false };
                  const g4 = x3 ? 2 * a4.length : a4.length;
                  for (let i6 = 0; i6 < g4; ++i6) {
                    const g5 = this.attemptAnchorPlacement(a4[i6 % a4.length], t5, c5, u4, l5, b3, w3, h3, s6, m3, i6 >= a4.length, e5, r4, n4, o4, d5, p3, f3);
                    if (g5 && (_4 = g5.placedGlyphBoxes, _4 && _4.box && _4.box.length)) {
                      S4 = true, D2 = g5.shift;
                      break;
                    }
                  }
                  return _4;
                };
                i4(() => l4(j3, d4.iconBox, A_.horizontal), () => {
                  const e6 = d4.verticalTextBox;
                  return e6 && V3(e6), n4.allowVerticalPlacement && !(R3 && R3.box && R3.box.length) && E4 > 0 && e6 ? l4(e6, d4.verticalIconBox, A_.vertical) : { box: null, offscreen: null, occluded: null };
                }), R3 && (S4 = R3.box, C3 = R3.offscreen, z2 = R3.occluded);
                const c4 = t4(!(!R3 || !R3.box));
                if (!S4 && this.prevPlacement) {
                  const t5 = this.prevPlacement.variableOffsets[T4];
                  t5 && (this.variableOffsets[T4] = t5, this.markUsedJustification(n4, t5.anchor, e5, c4));
                }
              } else {
                const o4 = (t5, i5) => {
                  const o5 = n4.getSymbolInstanceTextSize(p3, e5, this.transform.zoom, r4), a4 = this.collisionIndex.placeCollisionBox(n4, o5, t5, new y2(0, 0), x3, h3, s6, m3.predicate);
                  return a4 && a4.box && a4.box.length && (this.markUsedOrientation(n4, i5, e5), this.placedOrientations[T4] = i5), a4;
                };
                i4(() => o4(j3, A_.horizontal), () => {
                  const e6 = d4.verticalTextBox;
                  return n4.allowVerticalPlacement && E4 > 0 && e6 ? (V3(e6), o4(e6, A_.vertical)) : { box: null, offscreen: null, occluded: null };
                }), t4(!!(R3 && R3.box && R3.box.length));
              }
            }
            if (k3 = R3, S4 = k3 && k3.box && k3.box.length > 0, C3 = k3 && k3.offscreen, z2 = k3 && k3.occluded, e5.useRuntimeCollisionCircles) {
              const t4 = n4.text.placedSymbolArray.get(e5.centerJustifiedTextSymbolIndex >= 0 ? e5.centerJustifiedTextSymbolIndex : e5.verticalPlacedTextSymbolIndex), r5 = f_(n4.textSizeData, p3, t4), c4 = o3.get("text-padding");
              O2 = this.collisionIndex.placeCollisionCircles(n4, x3, t4, n4.lineVertexArray, n4.glyphOffsetArray, r5, s6, a3, l3, i3, w3, m3.predicate, e5.collisionCircleDiameter * r5 / u_, c4, this.retainedQueryData[n4.bucketInstanceId].tileID), S4 = x3 || O2.circles.length > 0 && !O2.collisionDetected, C3 = C3 && O2.offscreen, z2 = O2.occluded;
            }
            if (d4.iconFeatureIndex && (U2 = d4.iconFeatureIndex), d4.iconBox) {
              const t4 = (t5) => {
                V3(t5);
                const i4 = e5.hasIconTextFit && D2 ? nE(D2.x, D2.y, b3, w3, this.transform.angle) : new y2(0, 0), r5 = n4.getSymbolInstanceIconSize(f3, this.transform.zoom, e5.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(n4, r5, t5, i4, v3, h3, s6, m3.predicate);
              };
              L3 && L3.box && L3.box.length && d4.verticalIconBox ? (B2 = t4(d4.verticalIconBox), I3 = B2.box.length > 0) : (B2 = t4(d4.iconBox), I3 = B2.box.length > 0), C3 = C3 && B2.offscreen, P3 = B2.occluded;
            }
            const G2 = _3 || 0 === e5.numHorizontalGlyphVertices && 0 === E4, q2 = g3 || 0 === e5.numIconVertices;
            if (G2 || q2 ? q2 ? G2 || (I3 = I3 && S4) : S4 = I3 && S4 : I3 = S4 = I3 && S4, S4 && k3 && k3.box && this.collisionIndex.insertCollisionBox(k3.box, o3.get("text-ignore-placement"), n4.bucketInstanceId, L3 && L3.box && N3 ? N3 : F2, m3.ID), I3 && B2 && this.collisionIndex.insertCollisionBox(B2.box, o3.get("icon-ignore-placement"), n4.bucketInstanceId, U2, m3.ID), O2 && (S4 && this.collisionIndex.insertCollisionCircles(O2.circles, o3.get("text-ignore-placement"), n4.bucketInstanceId, F2, m3.ID), i3)) {
              const e6 = n4.bucketInstanceId;
              let t4 = this.collisionCircleArrays[e6];
              void 0 === t4 && (t4 = this.collisionCircleArrays[e6] = new eE());
              for (let e7 = 0; e7 < O2.circles.length; e7 += 4)
                t4.circles.push(O2.circles[e7 + 0]), t4.circles.push(O2.circles[e7 + 1]), t4.circles.push(O2.circles[e7 + 2]), t4.circles.push(O2.collisionDetected ? 1 : 0);
            }
            const Z3 = "globe" !== n4.projection.name;
            M3 = M3 && (Z3 || !z2), A3 = A3 && (Z3 || !P3), this.placements[T4] = new QT(S4 || M3, I3 || A3, C3 || n4.justReloaded), t3.add(T4);
          };
          if (E3 && this.buildingIndex && (this.buildingIndex.updateZOffset(n4, this.retainedQueryData[n4.bucketInstanceId].tileID), n4.updateZOffset()), T3) {
            const e5 = n4.getSortedSymbolIndexes(this.transform.angle);
            for (let t4 = e5.length - 1; t4 >= 0; --t4) {
              const i4 = e5[t4];
              S3(n4.symbolInstances.get(i4), i4, n4.collisionArrays[i4]);
            }
            n4.hasAnyZOffset && H2(`${n4.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
          } else if (n4.hasAnyZOffset) {
            const e5 = n4.getSortedIndexesByZOffset();
            for (let t4 = 0; t4 < e5.length; ++t4) {
              const i4 = e5[t4];
              S3(n4.symbolInstances.get(i4), i4, n4.collisionArrays[i4]);
            }
          } else
            for (let t4 = e4.symbolInstanceStart; t4 < e4.symbolInstanceEnd; t4++)
              S3(n4.symbolInstances.get(t4), t4, n4.collisionArrays[t4]);
          if (i3 && n4.bucketInstanceId in this.collisionCircleArrays) {
            const e5 = this.collisionCircleArrays[n4.bucketInstanceId];
            Au.invert(e5.invProjMatrix, s6), e5.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          n4.justReloaded = false;
        }
        markUsedJustification(e4, t3, i3, r3) {
          const { leftJustifiedTextSymbolIndex: n4, centerJustifiedTextSymbolIndex: o3, rightJustifiedTextSymbolIndex: s6, verticalPlacedTextSymbolIndex: a3, crossTileID: l3 } = i3, c3 = bg(t3), h3 = r3 === A_.vertical ? a3 : "left" === c3 ? n4 : "center" === c3 ? o3 : "right" === c3 ? s6 : -1;
          n4 >= 0 && (e4.text.placedSymbolArray.get(n4).crossTileID = h3 >= 0 && n4 !== h3 ? 0 : l3), o3 >= 0 && (e4.text.placedSymbolArray.get(o3).crossTileID = h3 >= 0 && o3 !== h3 ? 0 : l3), s6 >= 0 && (e4.text.placedSymbolArray.get(s6).crossTileID = h3 >= 0 && s6 !== h3 ? 0 : l3), a3 >= 0 && (e4.text.placedSymbolArray.get(a3).crossTileID = h3 >= 0 && a3 !== h3 ? 0 : l3);
        }
        markUsedOrientation(e4, t3, i3) {
          const r3 = t3 === A_.horizontal || t3 === A_.horizontalOnly ? t3 : 0, n4 = t3 === A_.vertical ? t3 : 0, { leftJustifiedTextSymbolIndex: o3, centerJustifiedTextSymbolIndex: s6, rightJustifiedTextSymbolIndex: a3, verticalPlacedTextSymbolIndex: l3 } = i3, c3 = e4.text.placedSymbolArray;
          o3 >= 0 && (c3.get(o3).placedOrientation = r3), s6 >= 0 && (c3.get(s6).placedOrientation = r3), a3 >= 0 && (c3.get(a3).placedOrientation = r3), l3 >= 0 && (c3.get(l3).placedOrientation = n4);
        }
        commit(e4) {
          this.commitTime = e4, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t3 = this.prevPlacement;
          let i3 = false;
          this.prevZoomAdjustment = t3 ? t3.zoomAdjustment(this.transform.zoom) : 0;
          const r3 = t3 ? t3.symbolFadeChange(e4) : 1, n4 = t3 ? t3.opacities : {}, o3 = t3 ? t3.variableOffsets : {}, s6 = t3 ? t3.placedOrientations : {};
          for (const e5 in this.placements) {
            const t4 = this.placements[e5], o4 = n4[e5];
            o4 ? (this.opacities[e5] = new JT(o4, r3, t4.text, t4.icon, null, t4.clipped), i3 = i3 || t4.text !== o4.text.placed || t4.icon !== o4.icon.placed) : (this.opacities[e5] = new JT(null, r3, t4.text, t4.icon, t4.skipFade, t4.clipped), i3 = i3 || t4.text || t4.icon);
          }
          for (const e5 in n4) {
            const t4 = n4[e5];
            if (!this.opacities[e5]) {
              const n5 = new JT(t4, r3, false, false);
              n5.isHidden() || (this.opacities[e5] = n5, i3 = i3 || t4.text.placed || t4.icon.placed);
            }
          }
          for (const e5 in o3)
            this.variableOffsets[e5] || !this.opacities[e5] || this.opacities[e5].isHidden() || (this.variableOffsets[e5] = o3[e5]);
          for (const e5 in s6)
            this.placedOrientations[e5] || !this.opacities[e5] || this.opacities[e5].isHidden() || (this.placedOrientations[e5] = s6[e5]);
          i3 ? this.lastPlacementChangeTime = e4 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t3 ? t3.lastPlacementChangeTime : e4);
        }
        updateLayerOpacities(e4, t3) {
          const i3 = /* @__PURE__ */ new Set();
          for (const r3 of t3) {
            const t4 = r3.getBucket(e4);
            t4 && r3.latestFeatureIndex && e4.fqid === t4.layerIds[0] && (this.updateBucketOpacities(t4, i3, r3.collisionBoxArray), t4.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(t4, r3.tileID), t4.updateZOffset()));
          }
        }
        updateBucketOpacities(e4, t3, i3) {
          e4.hasTextData() && e4.text.opacityVertexArray.clear(), e4.hasIconData() && e4.icon.opacityVertexArray.clear(), e4.hasIconCollisionBoxData() && e4.iconCollisionBox.collisionVertexArray.clear(), e4.hasTextCollisionBoxData() && e4.textCollisionBox.collisionVertexArray.clear();
          const r3 = e4.layers[0].layout, n4 = !!e4.layers[0].dynamicFilter(), o3 = new JT(null, 0, false, false, true), s6 = r3.get("text-allow-overlap"), a3 = r3.get("icon-allow-overlap"), l3 = r3.get("text-variable-anchor"), c3 = "map" === r3.get("text-rotation-alignment"), h3 = "map" === r3.get("text-pitch-alignment"), u3 = new JT(null, 0, s6 && (a3 || !e4.hasIconData() || r3.get("icon-optional")), a3 && (s6 || !e4.hasTextData() || r3.get("text-optional")), true);
          !e4.collisionArrays && i3 && (e4.hasIconCollisionBoxData() || e4.hasTextCollisionBoxData()) && e4.deserializeCollisionBoxes(i3);
          const d3 = (e5, t4, i4) => {
            for (let r4 = 0; r4 < t4 / 4; r4++)
              e5.opacityVertexArray.emplaceBack(i4);
          };
          let p3 = 0;
          for (let i4 = 0; i4 < e4.symbolInstances.length; i4++) {
            const r4 = e4.symbolInstances.get(i4), { numHorizontalGlyphVertices: s7, numVerticalGlyphVertices: a4, crossTileID: f3, numIconVertices: m3 } = r4, _3 = t3.has(f3);
            let g3 = this.opacities[f3];
            _3 ? g3 = o3 : g3 || (g3 = u3, this.opacities[f3] = g3), t3.add(f3);
            const x3 = s7 > 0 || a4 > 0, v3 = m3 > 0, b3 = this.placedOrientations[f3], w3 = b3 === A_.vertical, T3 = b3 === A_.horizontal || b3 === A_.horizontalOnly;
            if (!x3 && !v3 || g3.isHidden() || p3++, x3) {
              const t4 = fE(g3.text);
              d3(e4.text, s7, w3 ? mE : t4), d3(e4.text, a4, T3 ? mE : t4);
              const i5 = g3.text.isHidden(), { leftJustifiedTextSymbolIndex: n5, centerJustifiedTextSymbolIndex: o4, rightJustifiedTextSymbolIndex: l4, verticalPlacedTextSymbolIndex: c4 } = r4, h4 = e4.text.placedSymbolArray, u4 = i5 || w3 ? 1 : 0;
              n5 >= 0 && (h4.get(n5).hidden = u4), o4 >= 0 && (h4.get(o4).hidden = u4), l4 >= 0 && (h4.get(l4).hidden = u4), c4 >= 0 && (h4.get(c4).hidden = i5 || T3 ? 1 : 0);
              const p4 = this.variableOffsets[f3];
              p4 && this.markUsedJustification(e4, p4.anchor, r4, b3);
              const m4 = this.placedOrientations[f3];
              m4 && (this.markUsedJustification(e4, "left", r4, m4), this.markUsedOrientation(e4, m4, r4));
            }
            if (v3) {
              const t4 = fE(g3.icon), { placedIconSymbolIndex: i5, verticalPlacedIconSymbolIndex: n5 } = r4, o4 = e4.icon.placedSymbolArray, s8 = g3.icon.isHidden() ? 1 : 0;
              i5 >= 0 && (d3(e4.icon, m3, w3 ? mE : t4), o4.get(i5).hidden = s8), n5 >= 0 && (d3(e4.icon, r4.numVerticalIconVertices, T3 ? mE : t4), o4.get(n5).hidden = s8);
            }
            if (e4.hasIconCollisionBoxData() || e4.hasTextCollisionBoxData()) {
              const t4 = e4.collisionArrays[i4];
              if (t4) {
                let i5 = new y2(0, 0), o4 = true;
                if (t4.textBox || t4.verticalTextBox) {
                  if (l3) {
                    const e5 = this.variableOffsets[f3];
                    e5 ? (i5 = rE(e5.anchor, e5.width, e5.height, e5.textOffset, e5.textScale), c3 && i5._rotate(h3 ? this.transform.angle : -this.transform.angle)) : o4 = false;
                  }
                  n4 && (o4 = !g3.clipped), t4.textBox && sE(e4.textCollisionBox.collisionVertexArray, g3.text.placed, !o4 || w3, i5.x, i5.y), t4.verticalTextBox && sE(e4.textCollisionBox.collisionVertexArray, g3.text.placed, !o4 || T3, i5.x, i5.y);
                }
                const s8 = o4 && Boolean(!T3 && t4.verticalIconBox);
                t4.iconBox && sE(e4.iconCollisionBox.collisionVertexArray, g3.icon.placed, s8, r4.hasIconTextFit ? i5.x : 0, r4.hasIconTextFit ? i5.y : 0), t4.verticalIconBox && sE(e4.iconCollisionBox.collisionVertexArray, g3.icon.placed, !s8, r4.hasIconTextFit ? i5.x : 0, r4.hasIconTextFit ? i5.y : 0);
              }
            }
          }
          if (e4.fullyClipped = 0 === p3, e4.sortFeatures(this.transform.angle), this.retainedQueryData[e4.bucketInstanceId] && (this.retainedQueryData[e4.bucketInstanceId].featureSortOrder = e4.featureSortOrder), e4.hasTextData() && e4.text.opacityVertexBuffer && e4.text.opacityVertexBuffer.updateData(e4.text.opacityVertexArray), e4.hasIconData() && e4.icon.opacityVertexBuffer && e4.icon.opacityVertexBuffer.updateData(e4.icon.opacityVertexArray), e4.hasIconCollisionBoxData() && e4.iconCollisionBox.collisionVertexBuffer && e4.iconCollisionBox.collisionVertexBuffer.updateData(e4.iconCollisionBox.collisionVertexArray), e4.hasTextCollisionBoxData() && e4.textCollisionBox.collisionVertexBuffer && e4.textCollisionBox.collisionVertexBuffer.updateData(e4.textCollisionBox.collisionVertexArray), e4.bucketInstanceId in this.collisionCircleArrays) {
            const t4 = this.collisionCircleArrays[e4.bucketInstanceId];
            e4.placementInvProjMatrix = t4.invProjMatrix, e4.placementViewportMatrix = t4.viewportMatrix, e4.collisionCircleArray = t4.circles, delete this.collisionCircleArrays[e4.bucketInstanceId];
          }
        }
        symbolFadeChange(e4) {
          return 0 === this.fadeDuration ? 1 : (e4 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e4) {
          return Math.max(0, (this.transform.zoom - e4) / 1.5);
        }
        hasTransitions(e4) {
          return this.stale || e4 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e4, t3) {
          const i3 = this.zoomAtLastRecencyCheck === t3 ? 1 - this.zoomAdjustment(t3) : 1;
          return this.zoomAtLastRecencyCheck = t3, this.commitTime + this.fadeDuration * i3 > e4;
        }
        setStale() {
          this.stale = true;
        }
      }
      function sE(e4, t3, i3, r3, n4) {
        e4.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, r3 || 0, n4 || 0), e4.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, r3 || 0, n4 || 0), e4.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, r3 || 0, n4 || 0), e4.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, r3 || 0, n4 || 0);
      }
      const aE = Math.pow(2, 25), lE = Math.pow(2, 24), cE = Math.pow(2, 17), hE = Math.pow(2, 16), uE = Math.pow(2, 9), dE = Math.pow(2, 8), pE = Math.pow(2, 1);
      function fE(e4) {
        if (0 === e4.opacity && !e4.placed)
          return 0;
        if (1 === e4.opacity && e4.placed)
          return 4294967295;
        const t3 = e4.placed ? 1 : 0, i3 = Math.floor(127 * e4.opacity);
        return i3 * aE + t3 * lE + i3 * cE + t3 * hE + i3 * uE + t3 * dE + i3 * pE + t3;
      }
      const mE = 0;
      class _E {
        constructor(e4) {
          this._sortAcrossTiles = "viewport-y" !== e4.layout.get("symbol-z-order") && void 0 !== e4.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
        }
        continuePlacement(e4, t3, i3, r3, n4) {
          const o3 = this._bucketParts;
          for (; this._currentTileIndex < e4.length; )
            if (t3.getBucketParts(o3, r3, e4[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, n4())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o3.sort((e5, t4) => e5.sortKey - t4.sortKey)); this._currentPartIndex < o3.length; ) {
            const e5 = o3[this._currentPartIndex];
            if (t3.placeLayerBucketPart(e5, this._seenCrossTileIDs, i3, 0 === e5.symbolInstanceStart), this._currentPartIndex++, n4())
              return true;
          }
          return false;
        }
      }
      class gE {
        constructor(e4, t3, i3, r3, n4, o3, s6, a3, l3) {
          this.placement = new oE(e4, n4, o3, s6, a3, l3), this._currentPlacementIndex = t3.length - 1, this._forceFullPlacement = i3, this._showCollisionBoxes = r3, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(e4, t3, i3, r3) {
          const n4 = dt.now(), o3 = () => {
            const e5 = dt.now() - n4;
            return !this._forceFullPlacement && e5 > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const n5 = t3[e4[this._currentPlacementIndex]], s6 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === n5.type && (!n5.minzoom || n5.minzoom <= s6) && (!n5.maxzoom || n5.maxzoom > s6)) {
              const e5 = n5, t4 = e5.layout.get("symbol-z-elevate"), s7 = this._inProgressLayer = this._inProgressLayer || new _E(e5), a3 = va(n5.source, n5.scope);
              if (s7.continuePlacement(t4 ? r3[a3] : i3[a3], this.placement, this._showCollisionBoxes, n5, o3))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e4) {
          return this.placement.commit(e4), this.placement;
        }
      }
      const yE = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class xE {
        static from(e4) {
          if (!(e4 instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [t3, i3] = new Uint8Array(e4, 0, 2);
          if (219 !== t3)
            throw new Error("Data does not appear to be in a KDBush format.");
          const r3 = i3 >> 4;
          if (1 !== r3)
            throw new Error(`Got v${r3} data when expected v1.`);
          const n4 = yE[15 & i3];
          if (!n4)
            throw new Error("Unrecognized array type.");
          const [o3] = new Uint16Array(e4, 2, 1), [s6] = new Uint32Array(e4, 4, 1);
          return new xE(s6, o3, n4, e4);
        }
        constructor(e4, t3 = 64, i3 = Float64Array, r3) {
          if (isNaN(e4) || e4 < 0)
            throw new Error(`Unpexpected numItems value: ${e4}.`);
          this.numItems = +e4, this.nodeSize = Math.min(Math.max(+t3, 2), 65535), this.ArrayType = i3, this.IndexArrayType = e4 < 65536 ? Uint16Array : Uint32Array;
          const n4 = yE.indexOf(this.ArrayType), o3 = 2 * e4 * this.ArrayType.BYTES_PER_ELEMENT, s6 = e4 * this.IndexArrayType.BYTES_PER_ELEMENT, a3 = (8 - s6 % 8) % 8;
          if (n4 < 0)
            throw new Error(`Unexpected typed array class: ${i3}.`);
          r3 && r3 instanceof ArrayBuffer ? (this.data = r3, this.ids = new this.IndexArrayType(this.data, 8, e4), this.coords = new this.ArrayType(this.data, 8 + s6 + a3, 2 * e4), this._pos = 2 * e4, this._finished = true) : (this.data = new ArrayBuffer(8 + o3 + s6 + a3), this.ids = new this.IndexArrayType(this.data, 8, e4), this.coords = new this.ArrayType(this.data, 8 + s6 + a3, 2 * e4), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + n4]), new Uint16Array(this.data, 2, 1)[0] = t3, new Uint32Array(this.data, 4, 1)[0] = e4);
        }
        add(e4, t3) {
          const i3 = this._pos >> 1;
          return this.ids[i3] = i3, this.coords[this._pos++] = e4, this.coords[this._pos++] = t3, i3;
        }
        finish() {
          const e4 = this._pos >> 1;
          if (e4 !== this.numItems)
            throw new Error(`Added ${e4} items when expected ${this.numItems}.`);
          return vE(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(e4, t3, i3, r3) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n4, coords: o3, nodeSize: s6 } = this, a3 = [0, n4.length - 1, 0], l3 = [];
          for (; a3.length; ) {
            const c3 = a3.pop() || 0, h3 = a3.pop() || 0, u3 = a3.pop() || 0;
            if (h3 - u3 <= s6) {
              for (let s7 = u3; s7 <= h3; s7++) {
                const a4 = o3[2 * s7], c4 = o3[2 * s7 + 1];
                a4 >= e4 && a4 <= i3 && c4 >= t3 && c4 <= r3 && l3.push(n4[s7]);
              }
              continue;
            }
            const d3 = u3 + h3 >> 1, p3 = o3[2 * d3], f3 = o3[2 * d3 + 1];
            p3 >= e4 && p3 <= i3 && f3 >= t3 && f3 <= r3 && l3.push(n4[d3]), (0 === c3 ? e4 <= p3 : t3 <= f3) && (a3.push(u3), a3.push(d3 - 1), a3.push(1 - c3)), (0 === c3 ? i3 >= p3 : r3 >= f3) && (a3.push(d3 + 1), a3.push(h3), a3.push(1 - c3));
          }
          return l3;
        }
        within(e4, t3, i3) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: r3, coords: n4, nodeSize: o3 } = this, s6 = [0, r3.length - 1, 0], a3 = [], l3 = i3 * i3;
          for (; s6.length; ) {
            const c3 = s6.pop() || 0, h3 = s6.pop() || 0, u3 = s6.pop() || 0;
            if (h3 - u3 <= o3) {
              for (let i4 = u3; i4 <= h3; i4++)
                EE(n4[2 * i4], n4[2 * i4 + 1], e4, t3) <= l3 && a3.push(r3[i4]);
              continue;
            }
            const d3 = u3 + h3 >> 1, p3 = n4[2 * d3], f3 = n4[2 * d3 + 1];
            EE(p3, f3, e4, t3) <= l3 && a3.push(r3[d3]), (0 === c3 ? e4 - i3 <= p3 : t3 - i3 <= f3) && (s6.push(u3), s6.push(d3 - 1), s6.push(1 - c3)), (0 === c3 ? e4 + i3 >= p3 : t3 + i3 >= f3) && (s6.push(d3 + 1), s6.push(h3), s6.push(1 - c3));
          }
          return a3;
        }
      }
      function vE(e4, t3, i3, r3, n4, o3) {
        if (n4 - r3 <= i3)
          return;
        const s6 = r3 + n4 >> 1;
        bE(e4, t3, s6, r3, n4, o3), vE(e4, t3, i3, r3, s6 - 1, 1 - o3), vE(e4, t3, i3, s6 + 1, n4, 1 - o3);
      }
      function bE(e4, t3, i3, r3, n4, o3) {
        for (; n4 > r3; ) {
          if (n4 - r3 > 600) {
            const s7 = n4 - r3 + 1, a4 = i3 - r3 + 1, l4 = Math.log(s7), c3 = 0.5 * Math.exp(2 * l4 / 3), h3 = 0.5 * Math.sqrt(l4 * c3 * (s7 - c3) / s7) * (a4 - s7 / 2 < 0 ? -1 : 1);
            bE(e4, t3, i3, Math.max(r3, Math.floor(i3 - a4 * c3 / s7 + h3)), Math.min(n4, Math.floor(i3 + (s7 - a4) * c3 / s7 + h3)), o3);
          }
          const s6 = t3[2 * i3 + o3];
          let a3 = r3, l3 = n4;
          for (wE(e4, t3, r3, i3), t3[2 * n4 + o3] > s6 && wE(e4, t3, r3, n4); a3 < l3; ) {
            for (wE(e4, t3, a3, l3), a3++, l3--; t3[2 * a3 + o3] < s6; )
              a3++;
            for (; t3[2 * l3 + o3] > s6; )
              l3--;
          }
          t3[2 * r3 + o3] === s6 ? wE(e4, t3, r3, l3) : (l3++, wE(e4, t3, l3, n4)), l3 <= i3 && (r3 = l3 + 1), i3 <= l3 && (n4 = l3 - 1);
        }
      }
      function wE(e4, t3, i3, r3) {
        TE(e4, i3, r3), TE(t3, 2 * i3, 2 * r3), TE(t3, 2 * i3 + 1, 2 * r3 + 1);
      }
      function TE(e4, t3, i3) {
        const r3 = e4[t3];
        e4[t3] = e4[i3], e4[i3] = r3;
      }
      function EE(e4, t3, i3, r3) {
        const n4 = e4 - i3, o3 = t3 - r3;
        return n4 * n4 + o3 * o3;
      }
      const ME = 512 / cr / 2;
      class AE {
        constructor(e4, t3, i3) {
          this.tileID = e4, this.bucketInstanceId = i3, this.index = new xE(t3.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
          const r3 = e4.canonical.x * cr, n4 = e4.canonical.y * cr;
          for (let e5 = 0; e5 < t3.length; e5++) {
            const { key: i4, crossTileID: o3, tileAnchorX: s6, tileAnchorY: a3 } = t3.get(e5), l3 = Math.floor((r3 + s6) * ME), c3 = Math.floor((n4 + a3) * ME);
            this.index.add(l3, c3), this.keys.push(i4), this.crossTileIDs.push(o3);
          }
          this.index.finish();
        }
        findMatches(e4, t3, i3) {
          const r3 = this.tileID.canonical.z < t3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t3.canonical.z), n4 = ME / Math.pow(2, t3.canonical.z - this.tileID.canonical.z), o3 = t3.canonical.x * cr, s6 = t3.canonical.y * cr;
          for (let t4 = 0; t4 < e4.length; t4++) {
            const a3 = e4.get(t4);
            if (a3.crossTileID)
              continue;
            const { key: l3, tileAnchorX: c3, tileAnchorY: h3 } = a3, u3 = Math.floor((o3 + c3) * n4), d3 = Math.floor((s6 + h3) * n4), p3 = this.index.range(u3 - r3, d3 - r3, u3 + r3, d3 + r3);
            for (const e5 of p3) {
              const t5 = this.crossTileIDs[e5];
              if (this.keys[e5] === l3 && !i3.has(t5)) {
                i3.add(t5), a3.crossTileID = t5;
                break;
              }
            }
          }
        }
      }
      class SE {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class IE {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e4) {
          const t3 = Math.round((e4 - this.lng) / 360);
          if (0 !== t3)
            for (const e5 in this.indexes) {
              const i3 = this.indexes[e5], r3 = {};
              for (const e6 in i3) {
                const n4 = i3[e6];
                n4.tileID = n4.tileID.unwrapTo(n4.tileID.wrap + t3), r3[n4.tileID.key] = n4;
              }
              this.indexes[e5] = r3;
            }
          this.lng = e4;
        }
        addBucket(e4, t3, i3) {
          if (this.indexes[e4.overscaledZ] && this.indexes[e4.overscaledZ][e4.key]) {
            if (this.indexes[e4.overscaledZ][e4.key].bucketInstanceId === t3.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(e4.overscaledZ, this.indexes[e4.overscaledZ][e4.key]);
          }
          for (let e5 = 0; e5 < t3.symbolInstances.length; e5++)
            t3.symbolInstances.get(e5).crossTileID = 0;
          this.usedCrossTileIDs[e4.overscaledZ] || (this.usedCrossTileIDs[e4.overscaledZ] = /* @__PURE__ */ new Set());
          const r3 = this.usedCrossTileIDs[e4.overscaledZ];
          for (const i4 in this.indexes) {
            const n4 = this.indexes[i4];
            if (Number(i4) > e4.overscaledZ)
              for (const i5 in n4) {
                const o3 = n4[i5];
                o3.tileID.isChildOf(e4) && o3.findMatches(t3.symbolInstances, e4, r3);
              }
            else {
              const o3 = n4[e4.scaledTo(Number(i4)).key];
              o3 && o3.findMatches(t3.symbolInstances, e4, r3);
            }
          }
          for (let e5 = 0; e5 < t3.symbolInstances.length; e5++) {
            const n4 = t3.symbolInstances.get(e5);
            n4.crossTileID || (n4.crossTileID = i3.generate(), r3.add(n4.crossTileID));
          }
          return void 0 === this.indexes[e4.overscaledZ] && (this.indexes[e4.overscaledZ] = {}), this.indexes[e4.overscaledZ][e4.key] = new AE(e4, t3.symbolInstances, t3.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e4, t3) {
          for (const i3 of t3.crossTileIDs)
            this.usedCrossTileIDs[e4].delete(i3);
        }
        removeStaleBuckets(e4) {
          let t3 = false;
          for (const i3 in this.indexes) {
            const r3 = this.indexes[i3];
            for (const n4 in r3)
              e4[r3[n4].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, r3[n4]), delete r3[n4], t3 = true);
          }
          return t3;
        }
      }
      class CE {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new SE(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e4, t3, i3, r3) {
          let n4 = this.layerIndexes[e4.fqid];
          void 0 === n4 && (n4 = this.layerIndexes[e4.fqid] = new IE());
          let o3 = false;
          const s6 = {};
          "globe" !== r3.name && n4.handleWrapJump(i3);
          for (const i4 of t3) {
            const t4 = i4.getBucket(e4);
            t4 && e4.fqid === t4.layerIds[0] && (t4.bucketInstanceId || (t4.bucketInstanceId = ++this.maxBucketInstanceId), n4.addBucket(i4.tileID, t4, this.crossTileIDs) && (o3 = true), s6[t4.bucketInstanceId] = true);
          }
          return n4.removeStaleBuckets(s6) && (o3 = true), o3;
        }
        pruneUnusedLayers(e4) {
          const t3 = {};
          e4.forEach((e5) => {
            t3[e5] = true;
          });
          for (const e5 in this.layerIndexes)
            t3[e5] || delete this.layerIndexes[e5];
        }
      }
      var zE = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w-0.0001;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", PE = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", DE = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture(u_depth,uv-df.xz)),unpack_depth(texture(u_depth,uv+df.xz)),unpack_depth(texture(u_depth,uv-df.zy)),unpack_depth(texture(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", RE = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", LE = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", kE = "#ifdef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);vec4 _raTexLinearCoord(vec2 texCoord,vec2 texResolution,out vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return (texCoord.xxyy+vec2(1.5,0.5).xyxy)/texResolution.xxyy;}vec2 _raTexLinearMix(vec2 fxy,vec4 colorMix,float colorOffset,vec4 t00,vec4 t10,vec4 t01,vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(vec2 texCoord,vec2 texResolution,vec4 colorMix,float colorOffset) {vec2 fxy;vec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texture(u_image0,c.yz),texture(u_image0,c.xz),texture(u_image0,c.yw),texture(u_image0,c.xw)\n);}vec2 raTexture2D_image1_linear(vec2 texCoord,vec2 texResolution,vec4 colorMix,float colorOffset) {vec2 fxy;vec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texture(u_image1,c.yz),texture(u_image1,c.xz),texture(u_image1,c.yw),texture(u_image1,c.xw)\n);}vec2 raTexture2D_image0_nearest(vec2 texCoord,vec2 texResolution,vec4 colorMix,float colorOffset) {vec4 t=texture(u_image0,texCoord);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(vec2 texCoord,vec2 texResolution,vec4 colorMix,float colorOffset) {vec4 t=texture(u_image1,texCoord);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", OE = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", BE = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef NATIVE\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
      const FE = [];
      qE(zE, FE);
      const NE = { "_prelude_fog.vertex.glsl": RE, "_prelude_terrain.vertex.glsl": DE, "_prelude_shadow.vertex.glsl": OE, "_prelude_fog.fragment.glsl": LE, "_prelude_shadow.fragment.glsl": BE, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE", "_prelude_raster_array.glsl": kE }, UE = {};
      ZE("", DE), ZE(LE, RE), ZE(BE, OE), ZE(kE, "");
      const VE = ZE("\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif", "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}"), jE = zE;
      var GE = { background: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), circle: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: ZE("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ZE('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: ZE("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: ZE("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in float a_size_scale;in vec2 a_padding;in float a_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(a_z_offset+elevation(a_anchor_pos)),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: ZE("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ZE("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), fill: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutline: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;out vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in vec2 v_pos;in vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;out vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nuniform float u_emissive_strength;in float v_height;void main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,v_depth);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,u_emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef RENDER_CUTOFF\ncolor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\n#ifdef RENDER_CUTOFF\ninvariant gl_Position;\n#endif\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), fillExtrusionDepth: ZE("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nout vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: ZE('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,v_depth));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);v_depth=gl_Position.w;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: ZE("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;HANDLE_WIREFRAME_DEBUG;\n#endif\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;\n#ifdef FORCE_ABS_FL_GROUND_RADIUS\nfl_ground_radius=abs(flood_light_ground_radius);\n#endif\nfloat flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: ZE("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {    \nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trimmed,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), linePattern: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), raster: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform vec4 u_tl_br;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#elif defined(PROJECTION_GLOBE_VIEW)\nin vec2 a_pos;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;void main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec2 globe_tl=vec2(u_tl_br.x,u_tl_br.y);vec2 globe_br=vec2(u_tl_br.z,u_tl_br.w);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=1.0-((mercatorY-globe_br.y)/(globe_tl.y-globe_br.y));float mercatorX=mercatorXfromLng(latLng[1]);float uvX=(mercatorX-globe_br.x)/(globe_tl.x-globe_br.x);vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);uv=vec2(uvX,uvY);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\nuv=a_texture_pos/8192.0;\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), symbolIcon: ZE('#include "_prelude_lighting.glsl"\nuniform sampler2D u_texture;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\nin float v_fade_opacity;in vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nuniform mediump float u_icon_saturation;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nlowp float alpha=opacity*v_fade_opacity;vec4 out_color;\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b)*alpha;\n#else\nout_color=texture(u_texture,v_tex_a)*alpha;\n#endif\n#ifdef SATURATION\nvec3 luma=vec3(dot(out_color.rgb,vec3(0.2126,0.7152,0.0722)));out_color.rgb=mix(luma,out_color.rgb,u_icon_saturation);\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nv_tex_a=a_tex/u_texsize;\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\nv_fade_opacity=out_fade_opacity;}'), symbolSDF: ZE('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\nuniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;in float v_draw_halo;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}'), symbolTextAndIcon: ZE('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;in float v_draw_halo;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nfloat out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}'), terrainRaster: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,v_depth,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}'), terrainDepth: ZE("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: ZE('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', PE), skyboxGradient: ZE('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', PE), skyboxCapture: ZE("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: ZE('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: ZE('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;bool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;highp float depth=unpack_depth(texture(u_depthTexture,coord));return v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\ntexColor.rgb=sRGBToLinear(texColor.rgb);if(u_baseTextureIsAlpha) {if (texColor.w < 0.5) {discard;}albedo*=mix(vec4(texColor.rgb,texColor.a),vec4(texColor.a),float(u_baseTextureIsAlpha));} else {albedo*=texColor;}\n#endif\nreturn vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 diffuse=getDiffuseShadedColor(getBaseColor().rgb,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(diffuse,1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nao=(texture(u_occlusionTexture,uv_2f).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);color=mix(color,v_color_mix.rgb,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=u_matrix*pos;pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=local_pos;\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1);v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: ZE("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=u_matrix*pos;\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: ZE("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}") };
      function qE(e4, t3) {
        const i3 = e4.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
        for (let e5 of i3)
          if (e5 = e5.trim(), "#" === e5[0] && e5.includes("if") && !e5.includes("endif")) {
            e5 = e5.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const i4 = e5.split(" ");
            for (const e6 of i4)
              t3.includes(e6) || t3.push(e6);
          }
      }
      function ZE(e4, t3) {
        const i3 = /#include\s+"([^"]+)"/g, r3 = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
        let n4 = t3.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
        n4 && (n4 = n4.map((e5) => {
          const t4 = e5.split(" ");
          return t4[t4.length - 1];
        }), n4 = [...new Set(n4)]);
        const o3 = {}, s6 = [], a3 = [];
        e4 = e4.replace(i3, (e5, t4) => (a3.push(t4), "")), t3 = t3.replace(i3, (e5, t4) => (s6.push(t4), ""));
        let l3 = [...FE];
        qE(e4, l3), qE(t3, l3);
        for (const e5 of [...s6, ...a3])
          NE[e5] || console.error(`Undefined include: ${e5}`), UE[e5] || (UE[e5] = [], qE(NE[e5], UE[e5])), l3 = [...l3, ...UE[e5]];
        return { fragmentSource: e4 = e4.replace(r3, (e5, t4, i4, r4, n5) => (o3[n5] = true, "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${n5}
in ${i4} ${r4} ${n5};
#else
uniform ${i4} ${r4} u_${n5};
#endif
` : "initialize" === t4 ? `
#ifdef HAS_UNIFORM_u_${n5}
    ${i4} ${r4} ${n5} = u_${n5};
#endif
` : "define-attribute" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${n5}
    in ${i4} ${r4} ${n5};
#endif
` : "initialize-attribute" === t4 ? "" : void 0)), vertexSource: t3 = t3.replace(r3, (e5, t4, i4, r4, n5) => {
          const s7 = "float" === r4 ? "vec2" : r4, a4 = n5.match(/color/) ? "color" : s7;
          return "define-attribute-vertex-shader-only" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${n5}
in ${i4} ${r4} a_${n5};
#endif
` : o3[n5] ? "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${n5}
uniform lowp float u_${n5}_t;
in ${i4} ${s7} a_${n5};
out ${i4} ${r4} ${n5};
#else
uniform ${i4} ${r4} u_${n5};
#endif
` : "initialize" === t4 ? "vec4" === a4 ? `
#ifndef HAS_UNIFORM_u_${n5}
    ${n5} = a_${n5};
#else
    ${i4} ${r4} ${n5} = u_${n5};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n5}
    ${n5} = unpack_mix_${a4}(a_${n5}, u_${n5}_t);
#else
    ${i4} ${r4} ${n5} = u_${n5};
#endif
` : "define-attribute" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${n5}
    in ${i4} ${r4} a_${n5};
    out ${i4} ${r4} ${n5};
#endif
` : "initialize-attribute" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${n5}
    ${n5} = a_${n5};
#endif
` : void 0 : "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${n5}
uniform lowp float u_${n5}_t;
in ${i4} ${s7} a_${n5};
#else
uniform ${i4} ${r4} u_${n5};
#endif
` : "define-instanced" === t4 ? "mat4" === a4 ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${n5}0;
in vec4 a_${n5}1;
in vec4 a_${n5}2;
in vec4 a_${n5}3;
#else
uniform ${i4} ${r4} u_${n5};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${i4} ${s7} a_${n5};
#else
uniform ${i4} ${r4} u_${n5};
#endif
` : "initialize-attribute-custom" === t4 ? `
#ifdef HAS_ATTRIBUTE_a_${n5}
    ${i4} ${r4} ${n5} = a_${n5};
#endif
` : "vec4" === a4 ? `
#ifndef HAS_UNIFORM_u_${n5}
    ${i4} ${r4} ${n5} = a_${n5};
#else
    ${i4} ${r4} ${n5} = u_${n5};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n5}
    ${i4} ${r4} ${n5} = unpack_mix_${a4}(a_${n5}, u_${n5}_t);
#else
    ${i4} ${r4} ${n5} = u_${n5};
#endif
`;
        }), staticAttributes: n4, usedDefines: l3, vertexIncludes: s6, fragmentIncludes: a3 };
      }
      class $E {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(e4, t3, i3, r3, n4, o3, s6, a3) {
          this.context = e4;
          let l3 = this.boundPaintVertexBuffers.length !== r3.length;
          for (let e5 = 0; !l3 && e5 < r3.length; e5++)
            this.boundPaintVertexBuffers[e5] !== r3[e5] && (l3 = true);
          let c3 = this.boundDynamicVertexBuffers.length !== s6.length;
          for (let e5 = 0; !c3 && e5 < s6.length; e5++)
            this.boundDynamicVertexBuffers[e5] !== s6[e5] && (c3 = true);
          if (!this.vao || this.boundProgram !== t3 || this.boundLayoutVertexBuffer !== i3 || l3 || c3 || this.boundIndexBuffer !== n4 || this.boundVertexOffset !== o3)
            this.freshBind(t3, i3, r3, n4, o3, s6, a3);
          else {
            e4.bindVertexArrayOES.set(this.vao);
            for (const i4 of s6)
              i4 && (i4.bind(), a3 && i4.instanceCount && i4.setVertexAttribDivisor(e4.gl, t3, a3));
            n4 && n4.dynamicDraw && n4.bind();
          }
        }
        freshBind(e4, t3, i3, r3, n4, o3, s6) {
          const a3 = e4.numAttributes, l3 = this.context, c3 = l3.gl;
          this.vao && this.destroy(), this.vao = l3.gl.createVertexArray(), l3.bindVertexArrayOES.set(this.vao), this.boundProgram = e4, this.boundLayoutVertexBuffer = t3, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = r3, this.boundVertexOffset = n4, this.boundDynamicVertexBuffers = o3, t3.enableAttributes(c3, e4), t3.bind(), t3.setVertexAttribPointers(c3, e4, n4);
          for (const t4 of i3)
            t4.enableAttributes(c3, e4), t4.bind(), t4.setVertexAttribPointers(c3, e4, n4);
          for (const t4 of o3)
            t4 && (t4.enableAttributes(c3, e4), t4.bind(), t4.setVertexAttribPointers(c3, e4, n4), s6 && t4.instanceCount && t4.setVertexAttribDivisor(c3, e4, s6));
          r3 && r3.bind(), l3.currentNumAttributes = a3;
        }
        destroy() {
          this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      function WE(e4, t3) {
        const i3 = Math.pow(2, t3.canonical.z), r3 = t3.canonical.y;
        return [new lp(0, r3 / i3).toLngLat().lat, new lp(0, (r3 + 1) / i3).toLngLat().lat];
      }
      function HE(e4, t3, i3, r3, n4, o3, s6) {
        const a3 = e4.context, l3 = a3.gl, c3 = i3.hillshadeFBO;
        if (!c3)
          return;
        e4.prepareDrawTile();
        const h3 = e4.isTileAffectedByFog(t3), u3 = e4.getOrCreateProgram("hillshade", { overrideFog: h3 });
        a3.activeTexture.set(l3.TEXTURE0), l3.bindTexture(l3.TEXTURE_2D, c3.colorAttachment.get());
        const d3 = ((e5, t4, i4, r4) => {
          const n5 = i4.paint.get("hillshade-shadow-color"), o4 = i4.paint.get("hillshade-highlight-color"), s7 = i4.paint.get("hillshade-accent-color"), a4 = i4.paint.get("hillshade-emissive-strength");
          let l4 = w2(i4.paint.get("hillshade-illumination-direction"));
          if ("viewport" === i4.paint.get("hillshade-illumination-anchor"))
            l4 -= e5.transform.angle;
          else if (e5.style && e5.style.enable3dLights() && e5.style.directionalLight) {
            const t5 = e5.style.directionalLight.properties.get("direction");
            l4 = w2(J(t5.x, t5.y, t5.z)[1]);
          }
          const c4 = !e5.options.moving;
          return { u_matrix: r4 || e5.transform.calculateProjMatrix(t4.tileID.toUnwrapped(), c4), u_image: 0, u_latrange: WE(0, t4.tileID), u_light: [i4.paint.get("hillshade-exaggeration"), l4], u_shadow: n5, u_highlight: o4, u_emissive_strength: a4, u_accent: s7 };
        })(e4, i3, r3, e4.terrain ? t3.projMatrix : null);
        e4.uploadCommonUniforms(a3, u3, t3.toUnwrapped());
        const { tileBoundsBuffer: p3, tileBoundsIndexBuffer: f3, tileBoundsSegments: m3 } = e4.getTileBoundsBuffers(i3);
        u3.draw(e4, l3.TRIANGLES, n4, o3, s6, Dx.disabled, d3, r3.id, p3, f3, m3);
      }
      function XE(e4, t3, i3) {
        if (!t3.needsDEMTextureUpload)
          return;
        const r3 = e4.context, n4 = r3.gl;
        r3.pixelStoreUnpackPremultiplyAlpha.set(false), t3.demTexture = t3.demTexture || e4.getTileTexture(i3.stride);
        const o3 = i3.getPixels();
        t3.demTexture ? t3.demTexture.update(o3, { premultiply: false }) : t3.demTexture = new My(r3, o3, n4.R32F, { premultiply: false }), t3.needsDEMTextureUpload = false;
      }
      function YE(e4, t3, i3) {
        const r3 = e4.context, n4 = r3.gl;
        if (!t3.dem)
          return;
        const o3 = t3.dem;
        if (r3.activeTexture.set(n4.TEXTURE1), XE(e4, t3, o3), !t3.demTexture)
          return;
        t3.demTexture.bind(n4.NEAREST, n4.CLAMP_TO_EDGE);
        const s6 = o3.dim;
        r3.activeTexture.set(n4.TEXTURE0);
        let a3 = t3.hillshadeFBO;
        if (!a3) {
          const e5 = new My(r3, { width: s6, height: s6, data: null }, n4.RGBA);
          e5.bind(n4.LINEAR, n4.CLAMP_TO_EDGE), a3 = t3.hillshadeFBO = r3.createFramebuffer(s6, s6, true, "renderbuffer"), a3.colorAttachment.set(e5.texture);
        }
        r3.bindFramebuffer.set(a3.framebuffer), r3.viewport.set([0, 0, s6, s6]);
        const { tileBoundsBuffer: l3, tileBoundsIndexBuffer: c3, tileBoundsSegments: h3 } = e4.getMercatorTileBoundsBuffers(), u3 = [];
        e4.linearFloatFilteringSupported() && u3.push("TERRAIN_DEM_FLOAT_FORMAT"), e4.getOrCreateProgram("hillshadePrepare", { defines: u3 }).draw(e4, n4.TRIANGLES, Mx.disabled, Sx.disabled, Cx.unblended, Dx.disabled, ((e5, t4) => {
          const i4 = t4.stride, r4 = Au.create();
          return Au.ortho(r4, 0, cr, -cr, 0, 0, 1), Au.translate(r4, r4, [0, -cr, 0]), { u_matrix: r4, u_image: 1, u_dimension: [i4, i4], u_zoom: e5.overscaledZ };
        })(t3.tileID, o3), i3.id, l3, c3, h3), t3.needsHillshadePrepare = false;
      }
      const KE = (e4) => ({ u_matrix: new jl(e4), u_image0: new kl(e4), u_skirt_height: new Ol(e4), u_ground_shadow_factor: new Fl(e4) }), JE = (e4, t3, i3) => ({ u_matrix: e4, u_image0: 0, u_skirt_height: t3, u_ground_shadow_factor: i3 }), QE = (e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3) => ({ u_proj_matrix: Float32Array.from(e4), u_globe_matrix: t3, u_normalize_matrix: Float32Array.from(r3), u_merc_matrix: i3, u_zoom_transition: n4, u_merc_center: o3, u_image0: 0, u_frustum_tl: s6, u_frustum_tr: a3, u_frustum_br: l3, u_frustum_bl: c3, u_globe_pos: h3, u_globe_radius: u3, u_viewport: d3, u_grid_matrix: f3 ? Float32Array.from(f3) : new Float32Array(9), u_skirt_height: p3 }), eM = (e4, t3) => {
        if (t3 > 0 && e4.terrain && H2("Cutoff is currently disabled on terrain"), t3 <= 0 || e4.terrain)
          return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 0] } };
        const i3 = e4.transform, r3 = Math.max(Math.abs(i3._zoom - (e4.minCutoffZoom - 1)), 1), n4 = i3.isLODDisabled(false) ? P2(60, 45, i3.pitch) : P2(30, 15, i3.pitch), o3 = i3._farZ - i3._nearZ, s6 = t3 * i3.height, a3 = ((1 - (l3 = n4)) * (0.75 * i3.cameraToCenterDistance) + l3 * (i3._farZ + s6)) * r3;
        var l3;
        return { shouldRenderCutoff: n4 < 1, uniformValues: { u_cutoff_params: [i3._nearZ, i3._farZ, (a3 - i3._nearZ) / o3, (a3 - s6 - i3._nearZ) / o3] } };
      };
      function tM(e4, t3) {
        return null != e4 && null != t3 && !(!e4.hasData() || !t3.hasData()) && null != e4.demTexture && null != t3.demTexture && e4.tileID.key !== t3.tileID.key;
      }
      const iM = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(e4, t3, i3, r3, n4) {
          if (e4 in this.operations) {
            const t4 = this.operations[e4];
            t4.to.tileID.key !== i3.tileID.key && (t4.queued = i3);
          } else
            this.operations[e4] = { startTime: r3, phase: 0, duration: n4, from: t3, to: i3, queued: null };
        }
        getMorphValuesForProxy(e4) {
          if (!(e4 in this.operations))
            return null;
          const t3 = this.operations[e4];
          return { from: t3.from, to: t3.to, phase: t3.phase };
        }
        update(e4) {
          for (const t3 in this.operations) {
            const i3 = this.operations[t3];
            for (i3.phase = (e4 - i3.startTime) / i3.duration; i3.phase >= 1 || !this._validOp(i3); )
              if (!this._nextOp(i3, e4)) {
                delete this.operations[t3];
                break;
              }
          }
        }
        _nextOp(e4, t3) {
          return !!e4.queued && (e4.from = e4.to, e4.to = e4.queued, e4.queued = null, e4.phase = 0, e4.startTime = t3, true);
        }
        _validOp(e4) {
          return e4.from.hasData() && e4.to.hasData();
        }
      }(), rM = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
      function nM(e4, t3, i3) {
        if (0 === t3)
          return 0;
        const r3 = t3 < 1 && 514 === i3 ? 0.25 / t3 : 1;
        return 6 * Math.pow(1.5, 22 - e4) * Math.max(t3, 1) * r3;
      }
      function oM(e4, t3) {
        const i3 = 1 << e4.z;
        return !t3 && (0 === e4.x || e4.x === i3 - 1) || 0 === e4.y || e4.y === i3 - 1;
      }
      const sM = (e4) => ({ u_matrix: e4 });
      function aM(e4, t3, i3, r3, n4) {
        if (n4 > 0) {
          const o3 = dt.now(), s6 = (o3 - e4.timeAdded) / n4, a3 = t3 ? (o3 - t3.timeAdded) / n4 : -1, l3 = i3.getSource(), c3 = r3.coveringZoomLevel({ tileSize: l3.tileSize, roundZoom: l3.roundZoom }), h3 = !t3 || Math.abs(t3.tileID.overscaledZ - c3) > Math.abs(e4.tileID.overscaledZ - c3), u3 = h3 && e4.refreshedUponExpiration ? 1 : z(h3 ? s6 : 1 - a3, 0, 1);
          return e4.refreshedUponExpiration && s6 >= 1 && (e4.refreshedUponExpiration = false), t3 ? { opacity: 1, mix: 1 - u3 } : { opacity: u3, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class lM extends Lx {
        constructor(e4) {
          const t3 = { type: "raster-dem", maxzoom: e4.transform.maxZoom }, i3 = new Ew(Ww(), null), r3 = ST("mock-dem", t3, i3, e4.style);
          super("mock-dem", r3, false), r3.setEventedParent(this), this._sourceLoaded = true;
        }
        _loadTile(e4, t3) {
          e4.state = "loaded", t3(null);
        }
      }
      class cM extends Lx {
        constructor(e4) {
          const t3 = ST("proxy", { type: "geojson", maxzoom: e4.transform.maxZoom }, new Ew(Ww(), null), e4.style);
          super("proxy", t3, false), t3.setEventedParent(this), this.map = this.getSource().map = e4, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(e4, t3, i3) {
          if (e4.freezeTileCoverage)
            return;
          this.transform = e4;
          const r3 = e4.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t4, i4) => {
            if (t4[i4.key] = "", !this._tiles[i4.key]) {
              const t5 = new Oy(i4, this._source.tileSize * i4.overscaleFactor(), e4.tileZoom);
              t5.state = "loaded", this._tiles[i4.key] = t5;
            }
            return t4;
          }, {});
          for (const e5 in this._tiles)
            e5 in r3 || (this.freeFBO(e5), this._tiles[e5].unloadVectorData(), delete this._tiles[e5]);
        }
        freeFBO(e4) {
          const t3 = this.proxyCachedFBO[e4];
          if (void 0 !== t3) {
            const i3 = Object.values(t3);
            this.renderCachePool.push(...i3), delete this.proxyCachedFBO[e4];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((e4) => e4.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class hM extends qu {
        constructor(e4, t3, i3) {
          super(e4.overscaledZ, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y), this.proxyTileKey = t3, this.projMatrix = i3;
        }
      }
      class uM extends Km {
        constructor(e4, t3) {
          super(), this.painter = e4, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [i3, r3, n4] = function(e5) {
            const t4 = new za(), i4 = new Wa(), r4 = 131;
            t4.reserve(17161), i4.reserve(33800);
            const n5 = cr / 128, o4 = cr + n5 / 2, s7 = o4 + n5;
            for (let e6 = -n5; e6 < s7; e6 += n5)
              for (let i5 = -n5; i5 < s7; i5 += n5) {
                const r5 = i5 < 0 || i5 > o4 || e6 < 0 || e6 > o4 ? 24575 : 0, n6 = z(Math.round(i5), 0, cr), s8 = z(Math.round(e6), 0, cr);
                t4.emplaceBack(n6 + r5, s8);
              }
            const a3 = (e6, t5) => {
              const n6 = t5 * r4 + e6;
              i4.emplaceBack(n6 + 1, n6, n6 + r4), i4.emplaceBack(n6 + r4, n6 + r4 + 1, n6 + 1);
            };
            for (let e6 = 1; e6 < 129; e6++)
              for (let t5 = 1; t5 < 129; t5++)
                a3(t5, e6);
            return [0, 129].forEach((e6) => {
              for (let t5 = 0; t5 < 130; t5++)
                a3(t5, e6), a3(e6, t5);
            }), [t4, i4, 32768];
          }(), o3 = e4.context;
          this.gridBuffer = o3.createVertexBuffer(i3, Nu.members), this.gridIndexBuffer = o3.createIndexBuffer(r3), this.gridSegments = xl.simpleSegment(0, 0, i3.length, r3.length), this.gridNoSkirtSegments = xl.simpleSegment(0, 0, i3.length, n4), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new cM(t3.map), this.orthoMatrix = Au.create(), Au.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, cr, 0, cr, 0, 1);
          const s6 = o3.gl;
          this._overlapStencilMode = new Sx({ func: s6.GEQUAL, mask: 255 }, 0, 255, s6.KEEP, s6.KEEP, s6.REPLACE), this._previousZoom = e4.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = t3, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new lM(t3.map), this._pendingGroundEffectLayers = [];
        }
        set style(e4) {
          e4.on("data", this._onStyleDataEvent.bind(this)), this._style = e4, this._style.map.on("moveend", () => {
            this._clearLineLayersFromRenderCache();
          });
        }
        update(e4, t3, i3) {
          if (e4 && e4.terrain) {
            this._style !== e4 && (this.style = e4, this._evaluationZoom = void 0);
            const r3 = e4.terrain.properties, n4 = 0 === e4.terrain.drapeRenderMode, o3 = e4.terrain.isZoomDependent();
            this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = dt.now();
            const s6 = e4.terrain && e4.terrain.scope, a3 = r3.get("source"), l3 = n4 ? this._mockSourceCache : e4.getSourceCache(a3, s6);
            if (!l3)
              return void H2(`Couldn't find terrain source "${a3}".`);
            if (this.sourceCache = l3, this._exaggeration = o3 ? this.calculateExaggeration(t3) : r3.get("exaggeration"), !t3.projection.requiresDraping && o3 && 0 === this._exaggeration)
              return void this._disable();
            this.enabled = true;
            const c3 = () => {
              this.sourceCache.used && H2(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const e5 = this.getScaledDemTileSize();
              this.sourceCache.update(t3, e5, true), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, c3(), this._initializing = true), c3(), t3.updateElevation(true, i3), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(t3), this._emptyDEMTextureDirty = true, this._previousZoom = t3.zoom;
          } else
            this._disable();
        }
        calculateExaggeration(e4) {
          const t3 = this._previousCameraAltitude, i3 = e4.getFreeCameraOptions().position.z / e4.pixelsPerMeter * e4.worldSize;
          this._previousCameraAltitude = i3;
          const r3 = null != t3 ? i3 - t3 : Number.MAX_VALUE;
          if (Math.abs(r3) < 2)
            return this._exaggeration;
          const n4 = e4.zoom, o3 = this._style.terrain;
          if (!this._previousUpdateTimestamp)
            return o3.getExaggeration(n4);
          let s6 = n4 - this._previousZoom;
          const a3 = this._previousUpdateTimestamp;
          let l3 = n4;
          null != this._evaluationZoom && (l3 = this._evaluationZoom, Math.abs(n4 - l3) > 0.5 && (s6 = 0.5 * (n4 - l3 + s6)), s6 * r3 < 0 && (l3 += s6)), this._evaluationZoom = l3;
          const c3 = o3.getExaggeration(l3), h3 = c3 === o3.getExaggeration(Math.max(0, l3 - 0.1));
          if (h3 && Math.abs(c3 - this._exaggeration) < 0.01)
            return c3;
          let u3 = Math.min(0.1, 375e-5 * (this._updateTimestamp - a3));
          return (h3 || c3 < 0.1 || Math.abs(s6) < 1e-4) && (u3 = Math.min(0.2, 4 * u3)), Kr(this._exaggeration, c3, u3);
        }
        resetTileLookupCache(e4) {
          this._findCoveringTileCache[e4] = {};
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _onStyleDataEvent(e4) {
          e4.coord && "source" === e4.dataType ? this._clearRenderCacheForTile(e4.sourceCacheId, e4.coord) : "style" === e4.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
        }
        _disable() {
          if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const e4 in this._style._mergedSourceCaches)
              this._style._mergedSourceCaches[e4].usedForTerrain = false;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e4) => e4.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this._exaggeration;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const e4 = 2 * this.proxySourceCache.getSource().tileSize;
          return [e4, e4];
        }
        set useVertexMorphing(e4) {
          this._useVertexMorphing = e4;
        }
        updateTileBinding(e4) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const t3 = this.proxySourceCache, i3 = this.painter.transform;
          this._initializing && (this._initializing = 0 === i3._centerAltitude && -1 === this.getAtPointOrZero(lp.fromLngLat(i3.center), -1), this._emptyDEMTextureDirty = !this._initializing);
          const r3 = this.proxyCoords = t3.getIds().map((e5) => {
            const r4 = t3.getTileByID(e5).tileID;
            return r4.projMatrix = i3.calculateProjMatrix(r4.toUnwrapped()), r4;
          });
          !function(e5, t4) {
            const i4 = t4.transform.pointCoordinate(t4.transform.getCameraPoint()), r4 = new y2(i4.x, i4.y);
            e5.sort((e6, t5) => {
              if (t5.overscaledZ - e6.overscaledZ)
                return t5.overscaledZ - e6.overscaledZ;
              const i5 = new y2(e6.canonical.x + (1 << e6.canonical.z) * e6.wrap, e6.canonical.y), n5 = new y2(t5.canonical.x + (1 << t5.canonical.z) * t5.wrap, t5.canonical.y), o4 = r4.mult(1 << e6.canonical.z);
              return o4.x -= 0.5, o4.y -= 0.5, o4.distSqr(i5) - o4.distSqr(n5);
            });
          }(r3, this.painter);
          const n4 = this.proxyToSource || {};
          this.proxyToSource = {}, r3.forEach((e5) => {
            this.proxyToSource[e5.key] = {};
          }), this.terrainTileForTile = {};
          const o3 = this._style._mergedSourceCaches;
          for (const t4 in o3) {
            const i4 = o3[t4];
            if (!i4.used)
              continue;
            if (i4 !== this.sourceCache && this.resetTileLookupCache(i4.id), this._setupProxiedCoordsForOrtho(i4, e4[t4], n4), i4.usedForTerrain)
              continue;
            const r4 = e4[t4];
            i4.getSource().reparseOverscaled && this._assignTerrainTiles(r4);
          }
          this.proxiedCoords[t3.id] = r3.map((e5) => new hM(e5, e5.key, this.orthoMatrix)), this._assignTerrainTiles(r3), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n4), this.renderingToTexture = false;
          const s6 = {};
          this._visibleDemTiles = [];
          for (const e5 of this.proxyCoords) {
            const t4 = this.terrainTileForTile[e5.key];
            if (!t4)
              continue;
            const i4 = t4.tileID.key;
            i4 in s6 || (this._visibleDemTiles.push(t4), s6[i4] = i4);
          }
        }
        _assignTerrainTiles(e4) {
          this._initializing || e4.forEach((e5) => {
            if (this.terrainTileForTile[e5.key])
              return;
            const t3 = this._findTileCoveringTileID(e5, this.sourceCache);
            t3 && (this.terrainTileForTile[e5.key] = t3);
          });
        }
        _prepareDEMTextures() {
          const e4 = this.painter.context, t3 = e4.gl;
          for (const i3 in this.terrainTileForTile) {
            const r3 = this.terrainTileForTile[i3], n4 = r3.dem;
            !n4 || r3.demTexture && !r3.needsDEMTextureUpload || (e4.activeTexture.set(t3.TEXTURE1), XE(this.painter, r3, n4));
          }
        }
        _prepareDemTileUniforms(e4, t3, i3, r3) {
          if (!t3 || null == t3.demTexture)
            return false;
          const n4 = e4.tileID.canonical, o3 = Math.pow(2, t3.tileID.canonical.z - n4.z), s6 = r3 || "";
          return i3[`u_dem_tl${s6}`] = [n4.x * o3 % 1, n4.y * o3 % 1], i3[`u_dem_scale${s6}`] = o3, true;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        get emptyDepthBufferTexture() {
          const e4 = this.painter.context, t3 = e4.gl;
          if (!this._emptyDepthBufferTexture) {
            const i3 = new ef({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
            this._emptyDepthBufferTexture = new My(e4, i3, t3.RGBA, { premultiply: false });
          }
          return this._emptyDepthBufferTexture;
        }
        _getLoadedAreaMinimum() {
          let e4 = 0;
          const t3 = this._visibleDemTiles.reduce((t4, i3) => {
            if (!i3.dem)
              return t4;
            const r3 = i3.dem.tree.minimums[0];
            return r3 > 0 && e4++, t4 + r3;
          }, 0);
          return e4 ? t3 / e4 : 0;
        }
        _updateEmptyDEMTexture() {
          const e4 = this.painter.context, t3 = e4.gl;
          e4.activeTexture.set(t3.TEXTURE2);
          const i3 = this._getLoadedAreaMinimum(), [r3, n4] = (() => {
            const e5 = new tf({ width: 1, height: 1 }, new Float32Array([i3]));
            return [t3.R32F, e5];
          })();
          this._emptyDEMTextureDirty = false;
          let o3 = this._emptyDEMTexture;
          return o3 ? o3.update(n4, { premultiply: false }) : o3 = this._emptyDEMTexture = new My(e4, n4, r3, { premultiply: false }), o3;
        }
        setupElevationDraw(e4, t3, i3) {
          const r3 = this.painter.context, n4 = r3.gl, o3 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 };
          o3.u_exaggeration = this.exaggeration();
          let s6 = null, a3 = null, l3 = 1;
          if (i3 && i3.morphing && this._useVertexMorphing) {
            const t4 = i3.morphing.srcDemTile, r4 = i3.morphing.dstDemTile;
            l3 = i3.morphing.phase, t4 && r4 && (this._prepareDemTileUniforms(e4, t4, o3, "_prev") && (a3 = t4), this._prepareDemTileUniforms(e4, r4, o3) && (s6 = r4));
          }
          const c3 = (e5) => e5 && e5.demTexture && this.painter.linearFloatFilteringSupported() ? n4.LINEAR : n4.NEAREST, h3 = (e5) => {
            o3.u_dem_size = 1 === e5.size[0] ? 1 : e5.size[0] - 2;
          };
          if (a3 && s6)
            r3.activeTexture.set(n4.TEXTURE2), s6.demTexture.bind(c3(s6), n4.CLAMP_TO_EDGE), r3.activeTexture.set(n4.TEXTURE4), a3.demTexture.bind(c3(a3), n4.CLAMP_TO_EDGE), s6.demTexture && h3(s6.demTexture), o3.u_dem_lerp = l3;
          else {
            s6 = this.terrainTileForTile[e4.tileID.key], r3.activeTexture.set(n4.TEXTURE2);
            const t4 = this._prepareDemTileUniforms(e4, s6, o3) ? s6.demTexture : this.emptyDEMTexture;
            t4.bind(c3(s6), n4.CLAMP_TO_EDGE), h3(t4);
          }
          if (r3.activeTexture.set(n4.TEXTURE3), i3 && i3.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n4.NEAREST, n4.CLAMP_TO_EDGE), this._depthFBO && (o3.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n4.NEAREST, n4.CLAMP_TO_EDGE), o3.u_depth_size_inv = [1, 1]), i3 && i3.useMeterToDem && s6) {
            const e5 = (1 << s6.tileID.canonical.z) * Qd(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            o3.u_meter_to_dem = e5;
          }
          if (i3 && i3.labelPlaneMatrixInv && (o3.u_label_plane_matrix_inv = i3.labelPlaneMatrixInv), t3.setTerrainUniformValues(r3, o3), "globe" === this.painter.transform.projection.name) {
            const n5 = this.globeUniformValues(this.painter.transform, e4.tileID.canonical, i3 && i3.useDenormalizedUpVectorScale);
            t3.setGlobeUniformValues(r3, n5);
          }
        }
        globeUniformValues(e4, t3, i3) {
          const r3 = e4.projection;
          return { u_tile_tl_up: r3.upVector(t3, 0, 0), u_tile_tr_up: r3.upVector(t3, cr, 0), u_tile_br_up: r3.upVector(t3, cr, cr), u_tile_bl_up: r3.upVector(t3, 0, cr), u_tile_up_scale: i3 ? hd(1) : r3.upVectorScale(t3, e4.center.lat, e4.worldSize).metersToTile };
        }
        renderToBackBuffer(e4) {
          const t3 = this.painter, i3 = this.painter.context;
          0 !== e4.length && (i3.bindFramebuffer.set(null), i3.viewport.set([0, 0, t3.width, t3.height]), t3.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(e5, t4, i4, r3, n4) {
            if ("globe" === e5.transform.projection.name)
              !function(e6, t5, i5, r4, n5) {
                const o3 = e6.context, s6 = o3.gl;
                let a3, l3;
                const c3 = e6.transform, h3 = Ld(e6, o3, c3), u3 = (t6, i6) => {
                  if (l3 === i6)
                    return;
                  const r5 = [rM[i6], "PROJECTION_GLOBE_VIEW"];
                  h3 && r5.push("CUSTOM_ANTIALIASING");
                  const n6 = e6.isTileAffectedByFog(t6);
                  a3 = e6.getOrCreateProgram("globeRaster", { defines: r5, overrideFog: n6 }), l3 = i6;
                }, d3 = e6.colorModeForRenderPass(), p3 = new Mx(s6.LEQUAL, Mx.ReadWrite, e6.depthRangeFor3D);
                iM.update(n5);
                const f3 = Pd(c3), m3 = [Kd(c3.center.lng), Jd(c3.center.lat)], _3 = e6.globeSharedBuffers, g3 = [c3.width * dt.devicePixelRatio, c3.height * dt.devicePixelRatio], y3 = Float32Array.from(c3.globeMatrix), x3 = { useDenormalizedUpVectorScale: true };
                {
                  const c4 = e6.transform, h4 = nM(c4.zoom, t5.exaggeration(), t5.sourceCache._source.tileSize);
                  l3 = -1;
                  const v3 = s6.TRIANGLES;
                  for (const l4 of r4) {
                    const r5 = i5.getTile(l4), b3 = Sx.disabled, w3 = t5.prevTerrainTileForTile[l4.key], T3 = t5.terrainTileForTile[l4.key];
                    tM(w3, T3) && iM.newMorphing(l4.key, w3, T3, n5, 250), o3.activeTexture.set(s6.TEXTURE0), r5.texture && r5.texture.bind(s6.LINEAR, s6.CLAMP_TO_EDGE);
                    const E3 = iM.getMorphValuesForProxy(l4.key), A3 = E3 ? 1 : 0;
                    E3 && Lt(x3, { morphing: { srcDemTile: E3.from, dstDemTile: E3.to, phase: M2(E3.phase) } });
                    const S3 = xd(l4.canonical), I3 = Od(S3.getCenter().lat), C3 = kd(l4.canonical, S3, I3, c4.worldSize / c4._pixelsPerMercatorPixel), z2 = Ad(fd(l4.canonical)), P3 = QE(c4.expandedFarZProjMatrix, y3, f3, z2, Dd(c4.zoom), m3, c4.frustumCorners.TL, c4.frustumCorners.TR, c4.frustumCorners.BR, c4.frustumCorners.BL, c4.globeCenterInViewSpace, c4.globeRadius, g3, h4, C3);
                    if (u3(l4, A3), a3 && (t5.setupElevationDraw(r5, a3, x3), e6.uploadCommonUniforms(o3, a3, l4.toUnwrapped()), _3)) {
                      const [t6, i6, r6] = _3.getGridBuffers(I3, 0 !== h4);
                      a3.draw(e6, v3, p3, b3, d3, Dx.backCCW, P3, "globe_raster", t6, i6, r6);
                    }
                  }
                }
                if (_3 && (e6.renderDefaultNorthPole || e6.renderDefaultSouthPole)) {
                  const n6 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  h3 && n6.push("CUSTOM_ANTIALIASING"), a3 = e6.getOrCreateProgram("globeRaster", { defines: n6 });
                  for (const n7 of r4) {
                    const { x: r5, y: l4, z: h4 } = n7.canonical, u4 = 0 === l4, f4 = l4 === (1 << h4) - 1, [y4, v3, b3, w3] = _3.getPoleBuffers(h4, false);
                    if (w3 && (u4 || f4)) {
                      const l5 = i5.getTile(n7);
                      o3.activeTexture.set(s6.TEXTURE0), l5.texture && l5.texture.bind(s6.LINEAR, s6.CLAMP_TO_EDGE);
                      let _4 = Rd(h4, r5, c3);
                      const T3 = Ad(fd(n7.canonical)), E3 = (t6, i6) => t6.draw(e6, s6.TRIANGLES, p3, Sx.disabled, d3, Dx.disabled, QE(c3.expandedFarZProjMatrix, _4, _4, T3, 0, m3, c3.frustumCorners.TL, c3.frustumCorners.TR, c3.frustumCorners.BR, c3.frustumCorners.BL, c3.globeCenterInViewSpace, c3.globeRadius, g3, 0), "globe_pole_raster", i6, b3, w3);
                      t5.setupElevationDraw(l5, a3, x3), e6.uploadCommonUniforms(o3, a3, n7.toUnwrapped()), u4 && e6.renderDefaultNorthPole && E3(a3, y4), f4 && e6.renderDefaultSouthPole && (_4 = Au.scale(Au.create(), _4, [1, -1, 1]), E3(a3, v3));
                    }
                  }
                }
              }(e5, t4, i4, r3, n4);
            else {
              const o3 = e5.context, s6 = o3.gl;
              let a3, l3;
              const c3 = e5.shadowRenderer, h3 = eM(e5, e5.longestCutoffRange), u3 = (t5) => {
                if (l3 === t5)
                  return;
                const i5 = [];
                i5.push(rM[t5]), h3.shouldRenderCutoff && i5.push("RENDER_CUTOFF"), a3 = e5.getOrCreateProgram("terrainRaster", { defines: i5 }), l3 = t5;
              }, d3 = e5.colorModeForRenderPass(), p3 = new Mx(s6.LEQUAL, Mx.ReadWrite, e5.depthRangeFor3D);
              iM.update(n4);
              const f3 = e5.transform, m3 = nM(f3.zoom, t4.exaggeration(), t4.sourceCache._source.tileSize);
              let _3 = [0, 0, 0];
              if (c3) {
                const t5 = e5.style.directionalLight, i5 = e5.style.ambientLight;
                t5 && i5 && (_3 = WA(t5, i5));
              }
              {
                l3 = -1;
                const g3 = s6.TRIANGLES, [y3, x3] = [t4.gridIndexBuffer, t4.gridSegments];
                for (const l4 of r3) {
                  const r4 = i4.getTile(l4), v3 = Sx.disabled, b3 = t4.prevTerrainTileForTile[l4.key], w3 = t4.terrainTileForTile[l4.key];
                  tM(b3, w3) && iM.newMorphing(l4.key, b3, w3, n4, 250), o3.activeTexture.set(s6.TEXTURE0), r4.texture && r4.texture.bind(s6.LINEAR, s6.CLAMP_TO_EDGE);
                  const T3 = iM.getMorphValuesForProxy(l4.key), E3 = T3 ? 1 : 0;
                  let A3;
                  T3 && (A3 = { morphing: { srcDemTile: T3.from, dstDemTile: T3.to, phase: M2(T3.phase) } });
                  const S3 = JE(l4.projMatrix, oM(l4.canonical, f3.renderWorldCopies) ? m3 / 10 : m3, _3);
                  if (u3(E3), !a3)
                    continue;
                  t4.setupElevationDraw(r4, a3, A3);
                  const I3 = l4.toUnwrapped();
                  c3 && c3.setupShadows(I3, a3), e5.uploadCommonUniforms(o3, a3, I3, null, h3), a3.draw(e5, g3, p3, v3, d3, Dx.backCCW, S3, "terrain_raster", t4.gridBuffer, y3, x3);
                }
              }
            }
          }(t3, this, this.proxySourceCache, e4, this._updateTimestamp), this.renderingToTexture = true, t3.gpuTimingDeferredRenderEnd(), e4.splice(0, e4.length));
        }
        renderBatch(e4) {
          if (0 === this._drapedRenderBatches.length)
            return e4 + 1;
          this.renderingToTexture = true;
          const t3 = this.painter, i3 = this.painter.context, r3 = this.proxySourceCache, n4 = this.proxiedCoords[r3.id], o3 = this._drapedRenderBatches.shift(), s6 = t3.style.order, a3 = [];
          let l3 = 0;
          for (const c3 of n4) {
            const n5 = r3.getTileByID(c3.proxyTileKey), h3 = r3.proxyCachedFBO[c3.key] ? r3.proxyCachedFBO[c3.key][e4] : void 0, u3 = void 0 !== h3 ? r3.renderCache[h3] : this.pool[l3++], d3 = void 0 !== h3;
            if (n5.texture = u3.tex, d3 && !u3.dirty) {
              a3.push(n5.tileID);
              continue;
            }
            let p3;
            i3.bindFramebuffer.set(u3.fb.framebuffer), this.renderedToTile = false, u3.dirty && (i3.clear({ color: hi.transparent, stencil: 0 }), u3.dirty = false);
            for (let e5 = o3.start; e5 <= o3.end; ++e5) {
              const r4 = t3.style._mergedLayers[s6[e5]];
              if (r4.isHidden(t3.transform.zoom))
                continue;
              const n6 = t3.style.getLayerSourceCache(r4), o4 = n6 ? this.proxyToSource[c3.key][n6.id] : [c3];
              if (!o4)
                continue;
              const a4 = o4;
              i3.viewport.set([0, 0, u3.fb.width, u3.fb.height]), p3 !== (n6 ? n6.id : null) && (this._setupStencil(u3, o4, r4, n6), p3 = n6 ? n6.id : null), t3.renderLayer(t3, n6, r4, a4);
            }
            if (0 === this._drapedRenderBatches.length)
              for (const e5 of this._pendingGroundEffectLayers) {
                const r4 = t3.style._mergedLayers[s6[e5]];
                if (r4.isHidden(t3.transform.zoom))
                  continue;
                const n6 = t3.style.getLayerSourceCache(r4), o4 = n6 ? this.proxyToSource[c3.key][n6.id] : [c3];
                if (!o4)
                  continue;
                const a4 = o4;
                i3.viewport.set([0, 0, u3.fb.width, u3.fb.height]), p3 !== (n6 ? n6.id : null) && (this._setupStencil(u3, o4, r4, n6), p3 = n6 ? n6.id : null), t3.renderLayer(t3, n6, r4, a4);
              }
            this.renderedToTile ? (u3.dirty = true, a3.push(n5.tileID)) : d3 || --l3, 5 === l3 && (l3 = 0, this.renderToBackBuffer(a3));
          }
          return this.renderToBackBuffer(a3), this.renderingToTexture = false, i3.bindFramebuffer.set(null), i3.viewport.set([0, 0, t3.width, t3.height]), o3.end + 1;
        }
        postRender() {
        }
        isLayerOrderingCorrect(e4) {
          const t3 = e4.order.length;
          let i3 = -1, r3 = t3;
          for (let n4 = 0; n4 < t3; ++n4)
            this._style.isLayerDraped(e4._mergedLayers[e4.order[n4]]) ? i3 = Math.max(i3, n4) : r3 = Math.min(r3, n4);
          return r3 > i3;
        }
        getMinElevationBelowMSL() {
          let e4 = 0;
          return this._visibleDemTiles.filter((e5) => e5.dem).forEach((t3) => {
            e4 = Math.min(e4, t3.dem.tree.minimums[0]);
          }), 0 === e4 ? e4 : (e4 - 30) * this._exaggeration;
        }
        raycast(e4, t3, i3) {
          if (!this._visibleDemTiles)
            return null;
          const r3 = this._visibleDemTiles.filter((e5) => e5.dem).map((r4) => {
            const n4 = r4.tileID, o3 = 1 << n4.overscaledZ, { x: s6, y: a3 } = n4.canonical, l3 = s6 / o3, c3 = (s6 + 1) / o3, h3 = a3 / o3, u3 = (a3 + 1) / o3;
            return { minx: l3, miny: h3, maxx: c3, maxy: u3, t: r4.dem.tree.raycastRoot(l3, h3, c3, u3, e4, t3, i3), tile: r4 };
          });
          r3.sort((e5, t4) => (null !== e5.t ? e5.t : Number.MAX_VALUE) - (null !== t4.t ? t4.t : Number.MAX_VALUE));
          for (const n4 of r3) {
            if (null == n4.t)
              return null;
            const r4 = n4.tile.dem.tree.raycast(n4.minx, n4.miny, n4.maxx, n4.maxy, e4, t3, i3);
            if (null != r4)
              return r4;
          }
          return null;
        }
        _createFBO() {
          const e4 = this.painter.context, t3 = e4.gl, i3 = this.drapeBufferSize;
          e4.activeTexture.set(t3.TEXTURE0);
          const r3 = new My(e4, { width: i3[0], height: i3[1], data: null }, t3.RGBA);
          r3.bind(t3.LINEAR, t3.CLAMP_TO_EDGE);
          const n4 = e4.createFramebuffer(i3[0], i3[1], true, null);
          return n4.colorAttachment.set(r3.texture), n4.depthAttachment = new Tx(e4, n4.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = e4.createRenderbuffer(e4.gl.DEPTH_STENCIL, i3[0], i3[1]), this._stencilRef = 0, n4.depthAttachment.set(this._sharedDepthStencil), e4.clear({ stencil: 0 })) : n4.depthAttachment.set(this._sharedDepthStencil), e4.extTextureFilterAnisotropic && t3.texParameterf(t3.TEXTURE_2D, e4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e4.extTextureFilterAnisotropicMax), { fb: n4, tex: r3, dirty: false };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._style.hasLightTransitions())
            return true;
          for (const e4 in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[e4].hasTransition())
              return true;
          return this._style.order.some((e4) => {
            const t3 = this._style._mergedLayers[e4], i3 = t3.isHidden(this.painter.transform.zoom);
            return "custom" === t3.type ? !i3 && t3.shouldRedrape() : !i3 && t3.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let e4 = false;
          for (const t4 of this._style.getSources())
            if (t4 instanceof Vw) {
              e4 = true;
              break;
            }
          if (!e4)
            return;
          const t3 = {};
          for (let e5 = 0; e5 < this._style.order.length; ++e5) {
            const i3 = this._style._mergedLayers[this._style.order[e5]], r3 = this._style.getLayerSourceCache(i3);
            if (r3 && !t3[r3.id] && !i3.isHidden(this.painter.transform.zoom) && "line" === i3.type && i3.widthExpression() instanceof Ao) {
              t3[r3.id] = true;
              for (const e6 of this.proxyCoords) {
                const t4 = this.proxyToSource[e6.key][r3.id];
                if (t4)
                  for (const e7 of t4)
                    this._clearRenderCacheForTile(r3.id, e7);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let e4 = false;
          for (const t4 in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[t4]._source instanceof jw) {
              e4 = true;
              break;
            }
          if (!e4)
            return;
          const t3 = {};
          for (let e5 = 0; e5 < this._style.order.length; ++e5) {
            const i3 = this._style._mergedLayers[this._style.order[e5]], r3 = this._style.getLayerSourceCache(i3);
            if (!r3 || t3[r3.id])
              continue;
            if (i3.isHidden(this.painter.transform.zoom) || "raster" !== i3.type)
              continue;
            const n4 = i3.paint.get("raster-fade-duration");
            for (const e6 of this.proxyCoords) {
              const t4 = this.proxyToSource[e6.key][r3.id];
              if (t4)
                for (const e7 of t4) {
                  const t5 = aM(r3.getTile(e7), r3.findLoadedParent(e7, 0), r3, this.painter.transform, n4);
                  (1 !== t5.opacity || 0 !== t5.mix) && this._clearRenderCacheForTile(r3.id, e7);
                }
            }
          }
        }
        _setupDrapedRenderBatches() {
          const e4 = this._style.order, t3 = e4.length;
          if (0 === t3)
            return;
          const i3 = [];
          this._pendingGroundEffectLayers = [];
          let r3, n4 = 0, o3 = this._style._mergedLayers[e4[n4]];
          for (; !this._style.isLayerDraped(o3) && o3.isHidden(this.painter.transform.zoom) && ++n4 < t3; )
            o3 = this._style._mergedLayers[e4[n4]];
          for (; n4 < t3; ++n4) {
            const t4 = this._style._mergedLayers[e4[n4]];
            t4.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t4) ? void 0 === r3 && (r3 = n4) : ("fill-extrusion" === t4.type && this._pendingGroundEffectLayers.push(n4), void 0 !== r3 && (i3.push({ start: r3, end: n4 - 1 }), r3 = void 0)));
          }
          if (void 0 !== r3 && i3.push({ start: r3, end: n4 - 1 }), 0 !== i3.length) {
            const e5 = i3[i3.length - 1], t4 = this._pendingGroundEffectLayers.every((t5) => t5 > e5.end);
            t4 || H2("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
          }
          this._drapedRenderBatches = i3;
        }
        _setupRenderCache(e4) {
          const t3 = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
            if (this.invalidateRenderCache = false, t3.renderCache.length > t3.renderCachePool.length) {
              const e5 = Object.values(t3.proxyCachedFBO);
              t3.proxyCachedFBO = {};
              for (let i4 = 0; i4 < e5.length; ++i4) {
                const r4 = Object.values(e5[i4]);
                t3.renderCachePool.push(...r4);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const i3 = this.proxyCoords, r3 = this._tilesDirty;
          for (let n5 = i3.length - 1; n5 >= 0; n5--) {
            const o3 = i3[n5];
            if (t3.getTileByID(o3.key), void 0 !== t3.proxyCachedFBO[o3.key]) {
              const i4 = e4[o3.key], n6 = this.proxyToSource[o3.key];
              let s6 = 0;
              for (const e5 in n6) {
                const t4 = n6[e5], o4 = i4[e5];
                if (!o4 || o4.length !== t4.length || t4.some((t5, i5) => t5 !== o4[i5] || r3[e5] && r3[e5].hasOwnProperty(t5.key))) {
                  s6 = -1;
                  break;
                }
                ++s6;
              }
              for (const e5 in t3.proxyCachedFBO[o3.key])
                t3.renderCache[t3.proxyCachedFBO[o3.key][e5]].dirty = s6 < 0 || s6 !== Object.values(i4).length;
            }
          }
          const n4 = [...this._drapedRenderBatches];
          n4.sort((e5, t4) => t4.end - t4.start - (e5.end - e5.start));
          for (const e5 of n4)
            for (const r4 of i3) {
              if (t3.proxyCachedFBO[r4.key])
                continue;
              let i4 = t3.renderCachePool.pop();
              void 0 === i4 && t3.renderCache.length < 50 && (i4 = t3.renderCache.length, t3.renderCache.push(this._createFBO())), void 0 !== i4 && (t3.proxyCachedFBO[r4.key] = {}, t3.proxyCachedFBO[r4.key][e5.start] = i4, t3.renderCache[i4].dirty = true);
            }
          this._tilesDirty = {};
        }
        _setupStencil(e4, t3, i3, r3) {
          if (!r3 || !this._sourceTilesOverlap[r3.id])
            return void (this._overlapStencilType && (this._overlapStencilType = false));
          const n4 = this.painter.context, o3 = n4.gl;
          if (t3.length <= 1)
            return void (this._overlapStencilType = false);
          let s6;
          if (i3.isTileClipped())
            s6 = t3.length, this._overlapStencilMode.test = { func: o3.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(t3[0].overscaledZ > t3[t3.length - 1].overscaledZ))
              return void (this._overlapStencilType = false);
            s6 = 1, this._overlapStencilMode.test = { func: o3.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + s6 > 255 && (n4.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s6, this._overlapStencilMode.ref = this._stencilRef, i3.isTileClipped() && this._renderTileClippingMasks(t3, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
        }
        stencilModeForRTTOverlap(e4) {
          return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e4.key]), this._overlapStencilMode) : Sx.disabled;
        }
        _renderTileClippingMasks(e4, t3) {
          const i3 = this.painter, r3 = this.painter.context, n4 = r3.gl;
          i3._tileClippingMaskIDs = {}, r3.setColorMode(Cx.disabled), r3.setDepthMode(Mx.disabled);
          const o3 = i3.getOrCreateProgram("clippingMask");
          for (const r4 of e4) {
            const e5 = i3._tileClippingMaskIDs[r4.key] = --t3;
            o3.draw(i3, n4.TRIANGLES, Mx.disabled, new Sx({ func: n4.ALWAYS, mask: 0 }, e5, 255, n4.KEEP, n4.KEEP, n4.REPLACE), Cx.disabled, Dx.disabled, sM(r4.projMatrix), "$clipping", i3.tileExtentBuffer, i3.quadTriangleIndexBuffer, i3.tileExtentSegments);
          }
        }
        pointCoordinate(e4) {
          const t3 = this.painter.transform;
          if (e4.x < 0 || e4.x > t3.width || e4.y < 0 || e4.y > t3.height)
            return null;
          const i3 = [e4.x, e4.y, 1, 1];
          yu.transformMat4(i3, i3, t3.pixelMatrixInverse), yu.scale(i3, i3, 1 / i3[3]), i3[0] /= t3.worldSize, i3[1] /= t3.worldSize;
          const r3 = t3._camera.position, n4 = Qd(1, t3.center.lat), o3 = [r3[0], r3[1], r3[2] / n4, 0], s6 = Du.subtract([], i3.slice(0, 3), o3);
          Du.normalize(s6, s6);
          const a3 = this.raycast(o3, s6, this._exaggeration);
          return null !== a3 && a3 ? (Du.scaleAndAdd(o3, o3, s6, a3), o3[3] = o3[2], o3[2] *= n4, o3) : null;
        }
        drawDepth() {
          const e4 = this.painter, t3 = e4.context, i3 = this.proxySourceCache, r3 = Math.ceil(e4.width), n4 = Math.ceil(e4.height);
          if (!this._depthFBO || this._depthFBO.width === r3 && this._depthFBO.height === n4 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
            const e5 = t3.gl, i4 = t3.createFramebuffer(r3, n4, true, "renderbuffer");
            t3.activeTexture.set(e5.TEXTURE0);
            const o3 = new My(t3, { width: r3, height: n4, data: null }, e5.RGBA);
            o3.bind(e5.NEAREST, e5.CLAMP_TO_EDGE), i4.colorAttachment.set(o3.texture);
            const s6 = t3.createRenderbuffer(t3.gl.DEPTH_COMPONENT16, r3, n4);
            i4.depthAttachment.set(s6), this._depthFBO = i4, this._depthTexture = o3;
          }
          t3.bindFramebuffer.set(this._depthFBO.framebuffer), t3.viewport.set([0, 0, r3, n4]), function(e5, t4, i4, r4) {
            if ("globe" === e5.transform.projection.name)
              return;
            const n5 = e5.context, o3 = n5.gl;
            n5.clear({ depth: 1 });
            const s6 = e5.getOrCreateProgram("terrainDepth"), a3 = new Mx(o3.LESS, Mx.ReadWrite, e5.depthRangeFor3D);
            for (const n6 of r4) {
              const r5 = i4.getTile(n6), l3 = JE(n6.projMatrix, 0, [0, 0, 0]);
              t4.setupElevationDraw(r5, s6), s6.draw(e5, o3.TRIANGLES, a3, Sx.disabled, Cx.unblended, Dx.backCCW, l3, "terrain_depth", t4.gridBuffer, t4.gridIndexBuffer, t4.gridNoSkirtSegments);
            }
          }(e4, this, i3, this.proxyCoords);
        }
        _setupProxiedCoordsForOrtho(e4, t3, i3) {
          if (e4.getSource() instanceof Jb)
            return this._setupProxiedCoordsForImageSource(e4, t3, i3);
          this._findCoveringTileCache[e4.id] = this._findCoveringTileCache[e4.id] || {};
          const r3 = this.proxiedCoords[e4.id] = [], n4 = this.proxyCoords;
          for (let t4 = 0; t4 < n4.length; t4++) {
            const o4 = n4[t4], s6 = this._findTileCoveringTileID(o4, e4);
            if (s6) {
              const t5 = this._createProxiedId(o4, s6, i3[o4.key] && i3[o4.key][e4.id]);
              r3.push(t5), this.proxyToSource[o4.key][e4.id] = [t5];
            }
          }
          let o3 = false;
          for (let n5 = 0; n5 < t3.length; n5++) {
            const s6 = e4.getTile(t3[n5]);
            if (!s6 || !s6.hasData())
              continue;
            const a3 = this._findTileCoveringTileID(s6.tileID, this.proxySourceCache);
            if (a3 && a3.tileID.canonical.z !== s6.tileID.canonical.z) {
              const t4 = this.proxyToSource[a3.tileID.key][e4.id], n6 = this._createProxiedId(a3.tileID, s6, i3[a3.tileID.key] && i3[a3.tileID.key][e4.id]);
              t4 ? t4.splice(t4.length - 1, 0, n6) : this.proxyToSource[a3.tileID.key][e4.id] = [n6], r3.push(n6), o3 = true;
            }
          }
          this._sourceTilesOverlap[e4.id] = o3;
        }
        _setupProxiedCoordsForImageSource(e4, t3, i3) {
          if (!e4.getSource().loaded())
            return;
          const r3 = this.proxiedCoords[e4.id] = [], n4 = this.proxyCoords, o3 = e4.getSource(), s6 = o3.tileID;
          if (!s6)
            return;
          const a3 = new y2(s6.x, s6.y)._div(1 << s6.z), l3 = o3.coordinates.map(lp.fromLngLat).reduce((e5, t4) => (e5.min.x = Math.min(e5.min.x, t4.x - a3.x), e5.min.y = Math.min(e5.min.y, t4.y - a3.y), e5.max.x = Math.max(e5.max.x, t4.x - a3.x), e5.max.y = Math.max(e5.max.y, t4.y - a3.y), e5), { min: new y2(Number.MAX_VALUE, Number.MAX_VALUE), max: new y2(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c3 = (e5, t4) => {
            const i4 = e5.wrap + e5.canonical.x / (1 << e5.canonical.z), r4 = e5.canonical.y / (1 << e5.canonical.z), n5 = cr / (1 << e5.canonical.z), o4 = t4.wrap + t4.canonical.x / (1 << t4.canonical.z), s7 = t4.canonical.y / (1 << t4.canonical.z);
            return i4 + n5 < o4 + l3.min.x || i4 > o4 + l3.max.x || r4 + n5 < s7 + l3.min.y || r4 > s7 + l3.max.y;
          };
          for (let o4 = 0; o4 < n4.length; o4++) {
            const s7 = n4[o4];
            for (let n5 = 0; n5 < t3.length; n5++) {
              const o5 = e4.getTile(t3[n5]);
              if (!o5 || !o5.hasData())
                continue;
              if (c3(s7, o5.tileID))
                continue;
              const a4 = this._createProxiedId(s7, o5, i3[s7.key] && i3[s7.key][e4.id]), l4 = this.proxyToSource[s7.key][e4.id];
              l4 ? l4.push(a4) : this.proxyToSource[s7.key][e4.id] = [a4], r3.push(a4);
            }
          }
        }
        _createProxiedId(e4, t3, i3) {
          let r3 = this.orthoMatrix;
          if (i3) {
            const e5 = i3.find((e6) => e6.key === t3.tileID.key);
            if (e5)
              return e5;
          }
          if (t3.tileID.key !== e4.key) {
            const i4 = e4.canonical.z - t3.tileID.canonical.z;
            let n4, o3, s6;
            r3 = Au.create();
            const a3 = t3.tileID.wrap - e4.wrap << e4.overscaledZ;
            i4 > 0 ? (n4 = cr >> i4, o3 = n4 * ((t3.tileID.canonical.x << i4) - e4.canonical.x + a3), s6 = n4 * ((t3.tileID.canonical.y << i4) - e4.canonical.y)) : (n4 = cr << -i4, o3 = cr * (t3.tileID.canonical.x - (e4.canonical.x + a3 << -i4)), s6 = cr * (t3.tileID.canonical.y - (e4.canonical.y << -i4))), Au.ortho(r3, 0, n4, 0, n4, 0, 1), Au.translate(r3, r3, [o3, s6, 0]);
          }
          return new hM(t3.tileID, e4.key, r3);
        }
        _findTileCoveringTileID(e4, t3) {
          let i3 = t3.getTile(e4);
          if (i3 && i3.hasData())
            return i3;
          const r3 = this._findCoveringTileCache[t3.id], n4 = r3[e4.key];
          if (i3 = n4 ? t3.getTileByID(n4) : null, i3 && i3.hasData() || null === n4)
            return i3;
          let o3 = i3 ? i3.tileID : e4, s6 = o3.overscaledZ;
          const a3 = t3.getSource().minzoom, l3 = [];
          if (!n4) {
            const r4 = t3.getSource().maxzoom;
            if (e4.canonical.z >= r4) {
              const i4 = e4.canonical.z - r4;
              t3.getSource().reparseOverscaled ? (s6 = Math.max(e4.canonical.z + 2, t3.transform.tileZoom), o3 = new qu(s6, e4.wrap, r4, e4.canonical.x >> i4, e4.canonical.y >> i4)) : 0 !== i4 && (s6 = r4, o3 = new qu(s6, e4.wrap, r4, e4.canonical.x >> i4, e4.canonical.y >> i4));
            }
            o3.key !== e4.key && (l3.push(o3.key), i3 = t3.getTile(o3));
          }
          const c3 = (e5) => {
            l3.forEach((t4) => {
              r3[t4] = e5;
            }), l3.length = 0;
          };
          for (s6 -= 1; s6 >= a3 && (!i3 || !i3.hasData()); s6--) {
            i3 && c3(i3.tileID.key);
            const e5 = o3.calculateScaledKey(s6);
            if (i3 = t3.getTileByID(e5), i3 && i3.hasData())
              break;
            const n5 = r3[e5];
            if (null === n5)
              break;
            void 0 === n5 ? l3.push(e5) : i3 = t3.getTileByID(n5);
          }
          return c3(i3 ? i3.tileID.key : null), i3 && i3.hasData() ? i3 : null;
        }
        findDEMTileFor(e4) {
          return this.enabled ? this._findTileCoveringTileID(e4, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = true;
        }
        _clearRenderCacheForTile(e4, t3) {
          let i3 = this._tilesDirty[e4];
          i3 || (i3 = this._tilesDirty[e4] = {}), i3[t3.key] = true;
        }
      }
      function dM(e4, t3, i3) {
        const r3 = function(e5, t4, i4) {
          const r4 = Du.dot(t4, e5), n5 = Du.dot(i4, [0.2126, 0.7152, 0.0722]), o4 = (e6, t5, i5) => (1 - i5) * e6 + i5 * t5, s7 = o4(1 - 0.3 * Math.min(n5, 1), 1, Math.min(r4 + 1, 1));
          return o4(0.92, 1, Math.asin(z(t4[2], -1, 1)) / Math.PI + 0.5) * s7;
        }(e4, [0, 0, 1], t3), n4 = [0, 0, 0];
        Du.scale(n4, i3.slice(0, 3), r3);
        const o3 = [0, 0, 0];
        Du.scale(o3, t3.slice(0, 3), e4[2]);
        const s6 = [0, 0, 0];
        return Du.add(s6, n4, o3), ae(s6);
      }
      const pM = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], fM = ["stars", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbolSDF", "symbolIcon", "symbolTextAndIcon"];
      class mM {
        static cacheKey(e4, t3, i3, r3) {
          let n4 = `${t3}${r3 ? r3.cacheKey : ""}`;
          for (const t4 of i3)
            e4.usedDefines.includes(t4) && (n4 += `/${t4}`);
          return n4;
        }
        constructor(e4, t3, i3, r3, n4, o3) {
          const s6 = e4.gl;
          this.program = s6.createProgram(), this.configuration = r3, this.name = t3, this.fixedDefines = [...o3];
          const a3 = r3 ? r3.getBinderAttributes() : [], l3 = (i3.staticAttributes || []).concat(a3);
          let c3 = r3 ? r3.defines() : [];
          c3 = c3.concat(o3.map((e5) => `#define ${e5}`));
          const h3 = "#version 300 es\n";
          let u3 = h3 + c3.concat("precision mediump float;", jE, VE.fragmentSource).join("\n");
          for (const e5 of i3.fragmentIncludes)
            u3 += `
${NE[e5]}`;
          u3 += `
${i3.fragmentSource}`;
          let d3 = h3 + c3.concat("precision highp float;", jE, VE.vertexSource).join("\n");
          for (const e5 of i3.vertexIncludes)
            d3 += `
${NE[e5]}`;
          d3 += `
${i3.vertexSource}`;
          const p3 = s6.createShader(s6.FRAGMENT_SHADER);
          if (s6.isContextLost())
            return void (this.failedToCreate = true);
          s6.shaderSource(p3, u3), s6.compileShader(p3), s6.attachShader(this.program, p3);
          const f3 = s6.createShader(s6.VERTEX_SHADER);
          if (s6.isContextLost())
            this.failedToCreate = true;
          else {
            s6.shaderSource(f3, d3), s6.compileShader(f3), s6.attachShader(this.program, f3), this.attributes = {}, this.numAttributes = l3.length;
            for (let e5 = 0; e5 < this.numAttributes; e5++)
              if (l3[e5]) {
                const t4 = l3[e5].startsWith("a_") ? l3[e5] : `a_${l3[e5]}`;
                s6.bindAttribLocation(this.program, e5, t4), this.attributes[t4] = e5;
              }
            s6.linkProgram(this.program), s6.deleteShader(f3), s6.deleteShader(p3), this.fixedUniforms = n4(e4), this.binderUniforms = r3 ? r3.getUniforms(e4) : [], o3.includes("TERRAIN") && (this.terrainUniforms = ((e5) => ({ u_dem: new kl(e5), u_dem_prev: new kl(e5), u_dem_tl: new Bl(e5), u_dem_scale: new Ol(e5), u_dem_tl_prev: new Bl(e5), u_dem_scale_prev: new Ol(e5), u_dem_size: new Ol(e5), u_dem_lerp: new Ol(e5), u_exaggeration: new Ol(e5), u_depth: new kl(e5), u_depth_size_inv: new Bl(e5), u_meter_to_dem: new Ol(e5), u_label_plane_matrix_inv: new jl(e5) }))(e4)), o3.includes("GLOBE") && (this.globeUniforms = ((e5) => ({ u_tile_tl_up: new Fl(e5), u_tile_tr_up: new Fl(e5), u_tile_br_up: new Fl(e5), u_tile_bl_up: new Fl(e5), u_tile_up_scale: new Ol(e5) }))(e4)), o3.includes("FOG") && (this.fogUniforms = ((e5) => ({ u_fog_matrix: new jl(e5), u_fog_range: new Bl(e5), u_fog_color: new Nl(e5), u_fog_horizon_blend: new Ol(e5), u_fog_vertical_limit: new Bl(e5), u_fog_temporal_offset: new Ol(e5), u_frustum_tl: new Fl(e5), u_frustum_tr: new Fl(e5), u_frustum_br: new Fl(e5), u_frustum_bl: new Fl(e5), u_globe_pos: new Fl(e5), u_globe_radius: new Ol(e5), u_globe_transition: new Ol(e5), u_is_globe: new kl(e5), u_viewport: new Bl(e5) }))(e4)), o3.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((e5) => ({ u_cutoff_params: new Nl(e5) }))(e4)), o3.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((e5) => ({ u_lighting_ambient_color: new Fl(e5), u_lighting_directional_dir: new Fl(e5), u_lighting_directional_color: new Fl(e5), u_ground_radiance: new Fl(e5) }))(e4)), o3.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((e5) => ({ u_light_matrix_0: new jl(e5), u_light_matrix_1: new jl(e5), u_fade_range: new Bl(e5), u_shadow_normal_offset: new Fl(e5), u_shadow_intensity: new Ol(e5), u_shadow_texel_size: new Ol(e5), u_shadow_map_resolution: new Ol(e5), u_shadow_direction: new Fl(e5), u_shadow_bias: new Fl(e5), u_shadowmap_0: new kl(e5), u_shadowmap_1: new kl(e5) }))(e4));
          }
        }
        setTerrainUniformValues(e4, t3) {
          if (!this.terrainUniforms)
            return;
          const i3 = this.terrainUniforms;
          if (!this.failedToCreate) {
            e4.program.set(this.program);
            for (const e5 in t3)
              i3[e5] && i3[e5].set(this.program, e5, t3[e5]);
          }
        }
        setGlobeUniformValues(e4, t3) {
          if (!this.globeUniforms)
            return;
          const i3 = this.globeUniforms;
          if (!this.failedToCreate) {
            e4.program.set(this.program);
            for (const e5 in t3)
              i3[e5] && i3[e5].set(this.program, e5, t3[e5]);
          }
        }
        setFogUniformValues(e4, t3) {
          if (!this.fogUniforms)
            return;
          const i3 = this.fogUniforms;
          if (!this.failedToCreate) {
            e4.program.set(this.program);
            for (const e5 in t3)
              i3[e5].set(this.program, e5, t3[e5]);
          }
        }
        setCutoffUniformValues(e4, t3) {
          if (!this.cutoffUniforms)
            return;
          const i3 = this.cutoffUniforms;
          if (!this.failedToCreate) {
            e4.program.set(this.program);
            for (const e5 in t3)
              i3[e5].set(this.program, e5, t3[e5]);
          }
        }
        setLightsUniformValues(e4, t3) {
          if (!this.lightsUniforms)
            return;
          const i3 = this.lightsUniforms;
          if (!this.failedToCreate) {
            e4.program.set(this.program);
            for (const e5 in t3)
              i3[e5].set(this.program, e5, t3[e5]);
          }
        }
        setShadowUniformValues(e4, t3) {
          if (this.failedToCreate || !this.shadowUniforms)
            return;
          const i3 = this.shadowUniforms;
          e4.program.set(this.program);
          for (const e5 in t3)
            i3[e5].set(this.program, e5, t3[e5]);
        }
        _drawDebugWireframe(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3) {
          const h3 = e4.options.wireframe;
          if (false === h3.terrain && false === h3.layers2D && false === h3.layers3D)
            return;
          const u3 = e4.context;
          if (!(() => !(!h3.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!h3.layers2D || e4._terrain && e4._terrain.renderingToTexture || !pM.includes(this.name)) || !(!h3.layers3D || !fM.includes(this.name)))())
            return;
          const d3 = u3.gl, p3 = e4.wireframeDebugCache.getLinesFromTrianglesBuffer(e4.frameCounter, n4, u3);
          if (!p3)
            return;
          const f3 = [...this.fixedDefines];
          f3.push("DEBUG_WIREFRAME");
          const m3 = e4.getOrCreateProgram(this.name, { config: this.configuration, defines: f3 });
          u3.program.set(m3.program);
          const _3 = (e5, t4, i4) => {
            if (t4[e5] && i4[e5])
              for (const r4 in t4[e5])
                i4[e5][r4] && i4[e5][r4].set(i4.program, r4, t4[e5][r4].current);
          };
          l3 && l3.setUniforms(m3.program, u3, m3.binderUniforms, s6, { zoom: a3 }), _3("fixedUniforms", this, m3), _3("terrainUniforms", this, m3), _3("globeUniforms", this, m3), _3("fogUniforms", this, m3), _3("lightsUniforms", this, m3), _3("shadowUniforms", this, m3), p3.bind(), u3.setColorMode(new Cx([d3.ONE, d3.ONE_MINUS_SRC_ALPHA, d3.ZERO, d3.ONE], hi.transparent, [true, true, true, false])), u3.setDepthMode(new Mx(t3.func === d3.LESS ? d3.LEQUAL : t3.func, Mx.ReadOnly, t3.range)), u3.setStencilMode(Sx.disabled);
          const g3 = 3 * o3.primitiveLength * 2, y3 = 3 * o3.primitiveOffset * 2 * 2;
          c3 && c3 > 1 ? d3.drawElementsInstanced(d3.LINES, g3, d3.UNSIGNED_SHORT, y3, c3) : d3.drawElements(d3.LINES, g3, d3.UNSIGNED_SHORT, y3), n4.bind(), u3.program.set(this.program), u3.setDepthMode(t3), u3.setStencilMode(i3), u3.setColorMode(r3);
        }
        draw(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3) {
          const _3 = e4.context, g3 = _3.gl;
          if (this.failedToCreate)
            return;
          _3.program.set(this.program), _3.setDepthMode(i3), _3.setStencilMode(r3), _3.setColorMode(n4), _3.setCullFace(o3);
          for (const e5 of Object.keys(this.fixedUniforms))
            this.fixedUniforms[e5].set(this.program, e5, s6[e5]);
          p3 && p3.setUniforms(this.program, _3, this.binderUniforms, u3, { zoom: d3 });
          const y3 = { [g3.LINES]: 2, [g3.TRIANGLES]: 3, [g3.LINE_STRIP]: 1 }[t3], x3 = m3 && m3 > 0 ? 1 : void 0;
          for (const o4 of h3.get()) {
            const s7 = o4.vaos || (o4.vaos = {});
            (s7[a3] || (s7[a3] = new $E())).bind(_3, this, l3, p3 ? p3.getPaintVertexBuffers() : [], c3, o4.vertexOffset, f3 || [], x3), m3 && m3 > 1 ? g3.drawElementsInstanced(t3, o4.primitiveLength * y3, g3.UNSIGNED_SHORT, o4.primitiveOffset * y3 * 2, m3) : g3.drawElements(t3, o4.primitiveLength * y3, g3.UNSIGNED_SHORT, o4.primitiveOffset * y3 * 2), t3 === g3.TRIANGLES && this._drawDebugWireframe(e4, i3, r3, n4, c3, o4, u3, d3, p3, m3);
          }
        }
      }
      function _M(e4, t3) {
        const i3 = Math.pow(2, t3.tileID.overscaledZ), r3 = t3.tileSize * Math.pow(2, e4.transform.tileZoom) / i3, n4 = r3 * (t3.tileID.canonical.x + t3.tileID.wrap * i3), o3 = r3 * t3.tileID.canonical.y;
        return { u_image: 0, u_texsize: t3.imageAtlasTexture ? t3.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / rv(t3, 1, e4.transform.tileZoom), u_pixel_coord_upper: [n4 >> 16, o3 >> 16], u_pixel_coord_lower: [65535 & n4, 65535 & o3] };
      }
      const gM = Au.create(), yM = (e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3) => {
        const _3 = t3.style.light, g3 = _3.properties.get("position"), y3 = [g3.x, g3.y, g3.z], x3 = Eu.create();
        "viewport" === _3.properties.get("anchor") && (Eu.fromRotation(x3, -t3.transform.angle), Du.transformMat3(y3, y3, x3));
        const v3 = _3.properties.get("color"), b3 = t3.transform, w3 = { u_matrix: e4, u_lightpos: y3, u_lightintensity: _3.properties.get("intensity"), u_lightcolor: [v3.r, v3.g, v3.b], u_vertical_gradient: +i3, u_opacity: r3, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: gM, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n4, u_edge_radius: o3, u_flood_light_color: u3, u_vertical_scale: d3, u_flood_light_intensity: p3, u_ground_shadow_factor: f3, u_emissive_strength: m3 };
        return "globe" === b3.projection.name && (w3.u_tile_id = [s6.canonical.x, s6.canonical.y, 1 << s6.canonical.z], w3.u_zoom_transition = l3, w3.u_inv_rot_matrix = h3, w3.u_merc_center = c3, w3.u_up_dir = b3.projection.upVector(new ju(0, 0, 0), c3[0] * cr, c3[1] * cr), w3.u_height_lift = a3), w3;
      }, xM = (e4, t3, i3) => ({ u_matrix: e4, u_edge_radius: t3, u_vertical_scale: i3 }), vM = (e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3) => {
        const f3 = yM(e4, t3, i3, r3, n4, o3, s6, l3, c3, h3, u3, d3, p3, 1, [0, 0, 0], 0), m3 = { u_height_factor: -Math.pow(2, s6.overscaledZ) / a3.tileSize / 8 };
        return k2(f3, _M(t3, a3), m3);
      }, bM = (e4, t3) => ({ u_matrix: e4, u_emissive_strength: t3 }), wM = (e4, t3, i3, r3) => k2(bM(e4, t3), _M(i3, r3)), TM = (e4, t3, i3) => ({ u_matrix: e4, u_world: i3, u_emissive_strength: t3 }), EM = (e4, t3, i3, r3, n4) => k2(wM(e4, t3, i3, r3), { u_world: n4 }), MM = (e4, t3, i3, r3) => {
        const n4 = cr / i3.tileSize;
        return { u_matrix: e4, u_camera_to_center_distance: t3.getCameraToCenterDistance(r3), u_extrude_scale: [t3.pixelsToGLUnits[0] / n4, t3.pixelsToGLUnits[1] / n4] };
      }, AM = (e4, t3, i3 = 1) => ({ u_matrix: e4, u_color: t3, u_overlay: 0, u_overlay_scale: i3 }), SM = Au.create(), IM = (e4, t3, i3, r3, n4, o3, s6) => {
        const a3 = e4.transform, l3 = "globe" === a3.projection.name, c3 = l3 ? Cd(a3.zoom, t3.canonical) * a3._pixelsPerMercatorPixel : rv(i3, 1, o3), h3 = { u_matrix: t3.projMatrix, u_extrude_scale: c3, u_intensity: s6, u_inv_rot_matrix: SM, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (l3) {
          h3.u_inv_rot_matrix = r3, h3.u_merc_center = n4, h3.u_tile_id = [t3.canonical.x, t3.canonical.y, 1 << t3.canonical.z], h3.u_zoom_transition = Dd(a3.zoom);
          const e5 = n4[0] * cr, i4 = n4[1] * cr;
          h3.u_up_dir = a3.projection.upVector(new ju(0, 0, 0), e5, i4);
        }
        return h3;
      }, CM = (e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3, x3, v3, b3) => {
        return { u_matrix: e4, u_normalize_matrix: t3, u_globe_matrix: i3, u_merc_matrix: r3, u_grid_matrix: n4, u_tl_parent: o3, u_scale_parent: h3, u_fade_t: u3.mix, u_opacity: u3.opacity * d3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d3.paint.get("raster-brightness-min"), u_brightness_high: d3.paint.get("raster-brightness-max"), u_saturation_factor: (T3 = d3.paint.get("raster-saturation"), T3 > 0 ? 1 - 1 / (1.001 - T3) : -T3), u_contrast_factor: (w3 = d3.paint.get("raster-contrast"), w3 > 0 ? 1 / (1 - w3) : 1 + w3), u_spin_weights: zM(d3.paint.get("raster-hue-rotate")), u_perspective_transform: p3, u_raster_elevation: f3, u_tl_br: s6, u_zoom_transition: a3, u_merc_center: l3, u_cutoff_params: c3, u_colorization_mix: PM(_3, y3), u_colorization_offset: DM(g3, y3), u_color_ramp: m3, u_texture_offset: [v3 / (x3 + 2 * v3), x3 / (x3 + 2 * v3)], u_texture_res: [x3 + 2 * v3, x3 + 2 * v3], u_emissive_strength: b3 };
        var w3, T3;
      };
      function zM(e4) {
        e4 *= Math.PI / 180;
        const t3 = Math.sin(e4), i3 = Math.cos(e4);
        return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * t3 - i3 + 1) / 3, (Math.sqrt(3) * t3 - i3 + 1) / 3];
      }
      function PM([e4, t3, i3, r3], [n4, o3]) {
        if (n4 === o3)
          return [0, 0, 0, 0];
        const s6 = 259 / 257 / (o3 - n4);
        return [e4 * s6, t3 * s6, i3 * s6, r3 * s6];
      }
      function DM(e4, [t3, i3]) {
        return t3 === i3 ? 0 : ((e4 - t3) / (i3 - t3) * 259 - 1) / 257;
      }
      const RM = Au.create(), LM = (e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3) => {
        const y3 = n4.transform, x3 = { u_is_size_zoom_constant: +("constant" === e4 || "source" === e4), u_is_size_feature_constant: +("constant" === e4 || "camera" === e4), u_size_t: t3 ? t3.uSizeT : 0, u_size: t3 ? t3.uSize : 0, u_camera_to_center_distance: y3.getCameraToCenterDistance(m3), u_rotate_symbol: +i3, u_aspect_ratio: y3.width / y3.height, u_fade_change: n4.options.fadeDuration ? n4.symbolFadeChange : 1, u_matrix: o3, u_label_plane_matrix: s6, u_coord_matrix: a3, u_is_text: +l3, u_pitch_with_map: +r3, u_texsize: c3, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: RM, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: RM, u_up_vector: [0, -1, 0], u_icon_transition: g3 || 0, u_icon_saturation: _3 };
        return "globe" === m3.name && (x3.u_tile_id = [h3.canonical.x, h3.canonical.y, 1 << h3.canonical.z], x3.u_zoom_transition = u3, x3.u_inv_rot_matrix = p3, x3.u_merc_center = d3, x3.u_camera_forward = y3._camera.forward(), x3.u_ecef_origin = function(e5, t4) {
          const i4 = [0, 0, 0], r4 = Ad(fd(t4.canonical));
          return Du.transformMat4(i4, i4, r4), Du.transformMat4(i4, i4, e5), i4;
        }(y3.globeMatrix, h3.toUnwrapped()), x3.u_tile_matrix = Float32Array.from(y3.globeMatrix), x3.u_up_vector = f3), x3;
      }, kM = (e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3) => k2(LM(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, u3, d3, p3, f3, m3, _3, 1), { u_gamma_scale: r3 ? n4.transform.getCameraToCenterDistance(_3) * Math.cos(n4.terrain ? 0 : n4.transform._pitch) : 1, u_device_pixel_ratio: dt.devicePixelRatio, u_is_halo: +h3, undefined: void 0 }), OM = (e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3) => k2(kM(e4, t3, i3, r3, n4, o3, s6, a3, true, l3, true, h3, u3, d3, p3, f3, m3), { u_texsize_icon: c3, u_texture_icon: 1 }), BM = (e4, t3, i3, r3) => ({ u_matrix: e4, u_emissive_strength: t3, u_opacity: i3, u_color: r3 }), FM = (e4, t3, i3, r3, n4, o3, s6) => k2(function(e5, t4, i4, r4) {
        const n5 = i4.imageManager.getPattern(e5.toString(), t4), { width: o4, height: s7 } = i4.imageManager.getPixelSize(t4), a3 = Math.pow(2, r4.tileID.overscaledZ), l3 = r4.tileSize * Math.pow(2, i4.transform.tileZoom) / a3, c3 = l3 * (r4.tileID.canonical.x + r4.tileID.wrap * a3), h3 = l3 * r4.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: n5.tl, u_pattern_br: n5.br, u_texsize: [o4, s7], u_pattern_size: n5.displaySize, u_tile_units_to_pixels: 1 / rv(r4, 1, i4.transform.tileZoom), u_pixel_coord_upper: [c3 >> 16, h3 >> 16], u_pixel_coord_lower: [65535 & c3, 65535 & h3] };
      }(n4, o3, r3, s6), { u_matrix: e4, u_emissive_strength: t3, u_opacity: i3 }), NM = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, ShadowMap0: 10 }, UM = (e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3 = [0, 0, 0]) => {
        const p3 = r3.style.light, f3 = p3.properties.get("position"), m3 = [-f3.x, -f3.y, f3.z], _3 = Eu.create();
        "viewport" === p3.properties.get("anchor") && (Eu.fromRotation(_3, -r3.transform.angle), Du.transformMat3(m3, m3, _3));
        const g3 = "MASK" === c3.alphaMode, y3 = p3.properties.get("color"), x3 = u3.paint.get("model-ambient-occlusion-intensity"), v3 = u3.paint.get("model-color").constantOr(hi.white), b3 = u3.paint.get("model-color-mix-intensity").constantOr(0);
        return { u_matrix: e4, u_lighting_matrix: t3, u_normal_matrix: i3, u_lightpos: m3, u_lightintensity: p3.properties.get("intensity"), u_lightcolor: [y3.r, y3.g, y3.b], u_camera_pos: d3, u_opacity: n4, u_baseTextureIsAlpha: 0, u_alphaMask: +g3, u_alphaCutoff: c3.alphaCutoff, u_baseColorFactor: [o3.r, o3.g, o3.b, o3.a], u_emissiveFactor: [s6[0], s6[1], s6[2], 1], u_metallicFactor: a3, u_roughnessFactor: l3, u_baseColorTexture: NM.BaseColor, u_metallicRoughnessTexture: NM.MetallicRoughness, u_normalTexture: NM.Normal, u_occlusionTexture: NM.Occlusion, u_emissionTexture: NM.Emission, u_color_mix: [v3.r, v3.g, v3.b, b3], u_aoIntensity: x3, u_emissive_strength: h3 };
      }, VM = new Float32Array(16), jM = (e4, t3 = VM, i3 = VM) => ({ u_matrix: e4, u_instance: t3, u_node_matrix: i3 }), GM = { fillExtrusion: (e4) => ({ u_matrix: new jl(e4), u_lightpos: new Fl(e4), u_lightintensity: new Ol(e4), u_lightcolor: new Fl(e4), u_vertical_gradient: new Ol(e4), u_opacity: new Ol(e4), u_edge_radius: new Ol(e4), u_ao: new Bl(e4), u_tile_id: new Fl(e4), u_zoom_transition: new Ol(e4), u_inv_rot_matrix: new jl(e4), u_merc_center: new Bl(e4), u_up_dir: new Fl(e4), u_height_lift: new Ol(e4), u_flood_light_color: new Fl(e4), u_vertical_scale: new Ol(e4), u_flood_light_intensity: new Ol(e4), u_ground_shadow_factor: new Fl(e4), u_emissive_strength: new Ol(e4) }), fillExtrusionDepth: (e4) => ({ u_matrix: new jl(e4), u_edge_radius: new Ol(e4), u_vertical_scale: new Ol(e4) }), fillExtrusionPattern: (e4) => ({ u_matrix: new jl(e4), u_lightpos: new Fl(e4), u_lightintensity: new Ol(e4), u_lightcolor: new Fl(e4), u_vertical_gradient: new Ol(e4), u_height_factor: new Ol(e4), u_edge_radius: new Ol(e4), u_ao: new Bl(e4), u_tile_id: new Fl(e4), u_zoom_transition: new Ol(e4), u_inv_rot_matrix: new jl(e4), u_merc_center: new Bl(e4), u_up_dir: new Fl(e4), u_height_lift: new Ol(e4), u_image: new kl(e4), u_texsize: new Bl(e4), u_pixel_coord_upper: new Bl(e4), u_pixel_coord_lower: new Bl(e4), u_tile_units_to_pixels: new Ol(e4), u_opacity: new Ol(e4) }), fillExtrusionGroundEffect: (e4) => ({ u_matrix: new jl(e4), u_opacity: new Ol(e4), u_ao_pass: new Ol(e4), u_meter_to_tile: new Ol(e4), u_ao: new Bl(e4), u_flood_light_intensity: new Ol(e4), u_flood_light_color: new Fl(e4), u_attenuation: new Ol(e4), u_edge_radius: new Ol(e4), u_fb: new kl(e4), u_fb_size: new Ol(e4) }), fill: (e4) => ({ u_matrix: new jl(e4), u_emissive_strength: new Ol(e4) }), fillPattern: (e4) => ({ u_matrix: new jl(e4), u_emissive_strength: new Ol(e4), u_image: new kl(e4), u_texsize: new Bl(e4), u_pixel_coord_upper: new Bl(e4), u_pixel_coord_lower: new Bl(e4), u_tile_units_to_pixels: new Ol(e4) }), fillOutline: (e4) => ({ u_matrix: new jl(e4), u_emissive_strength: new Ol(e4), u_world: new Bl(e4) }), fillOutlinePattern: (e4) => ({ u_matrix: new jl(e4), u_emissive_strength: new Ol(e4), u_world: new Bl(e4), u_image: new kl(e4), u_texsize: new Bl(e4), u_pixel_coord_upper: new Bl(e4), u_pixel_coord_lower: new Bl(e4), u_tile_units_to_pixels: new Ol(e4) }), circle: (e4) => ({ u_camera_to_center_distance: new Ol(e4), u_extrude_scale: new $l(e4), u_device_pixel_ratio: new Ol(e4), u_matrix: new jl(e4), u_inv_rot_matrix: new jl(e4), u_merc_center: new Bl(e4), u_tile_id: new Fl(e4), u_zoom_transition: new Ol(e4), u_up_dir: new Fl(e4), u_emissive_strength: new Ol(e4) }), collisionBox: (e4) => ({ u_matrix: new jl(e4), u_camera_to_center_distance: new Ol(e4), u_extrude_scale: new Bl(e4) }), collisionCircle: (e4) => ({ u_matrix: new jl(e4), u_inv_matrix: new jl(e4), u_camera_to_center_distance: new Ol(e4), u_viewport_size: new Bl(e4) }), debug: (e4) => ({ u_color: new Ul(e4), u_matrix: new jl(e4), u_overlay: new kl(e4), u_overlay_scale: new Ol(e4) }), clippingMask: (e4) => ({ u_matrix: new jl(e4) }), heatmap: (e4) => ({ u_extrude_scale: new Ol(e4), u_intensity: new Ol(e4), u_matrix: new jl(e4), u_inv_rot_matrix: new jl(e4), u_merc_center: new Bl(e4), u_tile_id: new Fl(e4), u_zoom_transition: new Ol(e4), u_up_dir: new Fl(e4) }), heatmapTexture: (e4) => ({ u_image: new kl(e4), u_color_ramp: new kl(e4), u_opacity: new Ol(e4) }), hillshade: (e4) => ({ u_matrix: new jl(e4), u_image: new kl(e4), u_latrange: new Bl(e4), u_light: new Bl(e4), u_shadow: new Ul(e4), u_highlight: new Ul(e4), u_emissive_strength: new Ol(e4), u_accent: new Ul(e4) }), hillshadePrepare: (e4) => ({ u_matrix: new jl(e4), u_image: new kl(e4), u_dimension: new Bl(e4), u_zoom: new Ol(e4) }), line: (e4) => ({ u_matrix: new jl(e4), u_pixels_to_tile_units: new $l(e4), u_device_pixel_ratio: new Ol(e4), u_units_to_pixels: new Bl(e4), u_dash_image: new kl(e4), u_gradient_image: new kl(e4), u_image_height: new Ol(e4), u_texsize: new Bl(e4), u_tile_units_to_pixels: new Ol(e4), u_alpha_discard_threshold: new Ol(e4), u_trim_offset: new Bl(e4), u_emissive_strength: new Ol(e4) }), linePattern: (e4) => ({ u_matrix: new jl(e4), u_texsize: new Bl(e4), u_pixels_to_tile_units: new $l(e4), u_device_pixel_ratio: new Ol(e4), u_image: new kl(e4), u_units_to_pixels: new Bl(e4), u_tile_units_to_pixels: new Ol(e4), u_alpha_discard_threshold: new Ol(e4) }), raster: (e4) => ({ u_matrix: new jl(e4), u_normalize_matrix: new jl(e4), u_globe_matrix: new jl(e4), u_merc_matrix: new jl(e4), u_grid_matrix: new ql(e4), u_tl_parent: new Bl(e4), u_scale_parent: new Ol(e4), u_fade_t: new Ol(e4), u_opacity: new Ol(e4), u_image0: new kl(e4), u_image1: new kl(e4), u_brightness_low: new Ol(e4), u_brightness_high: new Ol(e4), u_saturation_factor: new Ol(e4), u_contrast_factor: new Ol(e4), u_spin_weights: new Fl(e4), u_perspective_transform: new Bl(e4), u_raster_elevation: new Ol(e4), u_tl_br: new Nl(e4), u_zoom_transition: new Ol(e4), u_merc_center: new Bl(e4), u_cutoff_params: new Nl(e4), u_colorization_mix: new Nl(e4), u_colorization_offset: new Ol(e4), u_color_ramp: new kl(e4), u_texture_offset: new Bl(e4), u_texture_res: new Bl(e4), u_emissive_strength: new Ol(e4) }), symbolIcon: (e4) => ({ u_is_size_zoom_constant: new kl(e4), u_is_size_feature_constant: new kl(e4), u_size_t: new Ol(e4), u_size: new Ol(e4), u_camera_to_center_distance: new Ol(e4), u_rotate_symbol: new kl(e4), u_aspect_ratio: new Ol(e4), u_fade_change: new Ol(e4), u_matrix: new jl(e4), u_label_plane_matrix: new jl(e4), u_coord_matrix: new jl(e4), u_is_text: new kl(e4), u_pitch_with_map: new kl(e4), u_texsize: new Bl(e4), u_tile_id: new Fl(e4), u_zoom_transition: new Ol(e4), u_inv_rot_matrix: new jl(e4), u_merc_center: new Bl(e4), u_camera_forward: new Fl(e4), u_tile_matrix: new jl(e4), u_up_vector: new Fl(e4), u_ecef_origin: new Fl(e4), u_texture: new kl(e4), u_icon_transition: new Ol(e4), u_icon_saturation: new Ol(e4) }), symbolSDF: (e4) => ({ u_is_size_zoom_constant: new kl(e4), u_is_size_feature_constant: new kl(e4), u_size_t: new Ol(e4), u_size: new Ol(e4), u_camera_to_center_distance: new Ol(e4), u_rotate_symbol: new kl(e4), u_aspect_ratio: new Ol(e4), u_fade_change: new Ol(e4), u_matrix: new jl(e4), u_label_plane_matrix: new jl(e4), u_coord_matrix: new jl(e4), u_is_text: new kl(e4), u_pitch_with_map: new kl(e4), u_texsize: new Bl(e4), u_texture: new kl(e4), u_gamma_scale: new Ol(e4), u_device_pixel_ratio: new Ol(e4), u_tile_id: new Fl(e4), u_zoom_transition: new Ol(e4), u_inv_rot_matrix: new jl(e4), u_merc_center: new Bl(e4), u_camera_forward: new Fl(e4), u_tile_matrix: new jl(e4), u_up_vector: new Fl(e4), u_ecef_origin: new Fl(e4), u_is_halo: new kl(e4) }), symbolTextAndIcon: (e4) => ({ u_is_size_zoom_constant: new kl(e4), u_is_size_feature_constant: new kl(e4), u_size_t: new Ol(e4), u_size: new Ol(e4), u_camera_to_center_distance: new Ol(e4), u_rotate_symbol: new kl(e4), u_aspect_ratio: new Ol(e4), u_fade_change: new Ol(e4), u_matrix: new jl(e4), u_label_plane_matrix: new jl(e4), u_coord_matrix: new jl(e4), u_is_text: new kl(e4), u_pitch_with_map: new kl(e4), u_texsize: new Bl(e4), u_texsize_icon: new Bl(e4), u_texture: new kl(e4), u_texture_icon: new kl(e4), u_gamma_scale: new Ol(e4), u_device_pixel_ratio: new Ol(e4), u_is_halo: new kl(e4) }), background: (e4) => ({ u_matrix: new jl(e4), u_emissive_strength: new Ol(e4), u_opacity: new Ol(e4), u_color: new Ul(e4) }), backgroundPattern: (e4) => ({ u_matrix: new jl(e4), u_emissive_strength: new Ol(e4), u_opacity: new Ol(e4), u_image: new kl(e4), u_pattern_tl: new Bl(e4), u_pattern_br: new Bl(e4), u_texsize: new Bl(e4), u_pattern_size: new Bl(e4), u_pixel_coord_upper: new Bl(e4), u_pixel_coord_lower: new Bl(e4), u_tile_units_to_pixels: new Ol(e4) }), terrainRaster: KE, terrainDepth: KE, skybox: (e4) => ({ u_matrix: new jl(e4), u_sun_direction: new Fl(e4), u_cubemap: new kl(e4), u_opacity: new Ol(e4), u_temporal_offset: new Ol(e4) }), skyboxGradient: (e4) => ({ u_matrix: new jl(e4), u_color_ramp: new kl(e4), u_center_direction: new Fl(e4), u_radius: new Ol(e4), u_opacity: new Ol(e4), u_temporal_offset: new Ol(e4) }), skyboxCapture: (e4) => ({ u_matrix_3f: new ql(e4), u_sun_direction: new Fl(e4), u_sun_intensity: new Ol(e4), u_color_tint_r: new Nl(e4), u_color_tint_m: new Nl(e4), u_luminance: new Ol(e4) }), globeRaster: (e4) => ({ u_proj_matrix: new jl(e4), u_globe_matrix: new jl(e4), u_normalize_matrix: new jl(e4), u_merc_matrix: new jl(e4), u_zoom_transition: new Ol(e4), u_merc_center: new Bl(e4), u_image0: new kl(e4), u_grid_matrix: new ql(e4), u_skirt_height: new Ol(e4), u_frustum_tl: new Fl(e4), u_frustum_tr: new Fl(e4), u_frustum_br: new Fl(e4), u_frustum_bl: new Fl(e4), u_globe_pos: new Fl(e4), u_globe_radius: new Ol(e4), u_viewport: new Bl(e4) }), globeAtmosphere: (e4) => ({ u_frustum_tl: new Fl(e4), u_frustum_tr: new Fl(e4), u_frustum_br: new Fl(e4), u_frustum_bl: new Fl(e4), u_horizon: new Ol(e4), u_transition: new Ol(e4), u_fadeout_range: new Ol(e4), u_color: new Nl(e4), u_high_color: new Nl(e4), u_space_color: new Nl(e4), u_temporal_offset: new Ol(e4), u_horizon_angle: new Ol(e4) }), model: (e4) => ({ u_matrix: new jl(e4), u_lighting_matrix: new jl(e4), u_normal_matrix: new jl(e4), u_lightpos: new Fl(e4), u_lightintensity: new Ol(e4), u_lightcolor: new Fl(e4), u_camera_pos: new Fl(e4), u_opacity: new Ol(e4), u_baseColorFactor: new Nl(e4), u_emissiveFactor: new Nl(e4), u_metallicFactor: new Ol(e4), u_roughnessFactor: new Ol(e4), u_baseTextureIsAlpha: new kl(e4), u_alphaMask: new kl(e4), u_alphaCutoff: new Ol(e4), u_baseColorTexture: new kl(e4), u_metallicRoughnessTexture: new kl(e4), u_normalTexture: new kl(e4), u_occlusionTexture: new kl(e4), u_emissionTexture: new kl(e4), u_color_mix: new Nl(e4), u_aoIntensity: new Ol(e4), u_emissive_strength: new Ol(e4) }), modelDepth: (e4) => ({ u_matrix: new jl(e4), u_instance: new jl(e4), u_node_matrix: new jl(e4) }), groundShadow: (e4) => ({ u_matrix: new jl(e4), u_ground_shadow_factor: new Fl(e4) }), stars: (e4) => ({ u_matrix: new jl(e4), u_up: new Fl(e4), u_right: new Fl(e4), u_intensity_multiplier: new Ol(e4) }) };
      let qM;
      function ZM(e4, t3, i3, r3, n4, o3, s6) {
        const a3 = e4.context, l3 = a3.gl, c3 = e4.transform, h3 = e4.getOrCreateProgram("collisionBox"), u3 = [];
        let d3 = 0, p3 = 0;
        for (let a4 = 0; a4 < r3.length; a4++) {
          const f4 = r3[a4], m4 = t3.getTile(f4), _4 = m4.getBucket(i3);
          if (!_4)
            continue;
          const g4 = XT(f4, _4, c3);
          let y4 = g4;
          0 === n4[0] && 0 === n4[1] || (y4 = e4.translatePosMatrix(g4, m4, n4, o3));
          const x4 = s6 ? _4.textCollisionBox : _4.iconCollisionBox, v3 = _4.collisionCircleArray;
          if (v3.length > 0) {
            const e5 = Au.create(), t4 = y4;
            Au.mul(e5, _4.placementInvProjMatrix, c3.glCoordMatrix), Au.mul(e5, e5, _4.placementViewportMatrix), u3.push({ circleArray: v3, circleOffset: p3, transform: t4, invTransform: e5, projection: _4.getProjection() }), d3 += v3.length / 4, p3 = d3;
          }
          x4 && (e4.terrain && e4.terrain.setupElevationDraw(m4, h3), h3.draw(e4, l3.LINES, Mx.disabled, Sx.disabled, e4.colorModeForRenderPass(), Dx.disabled, MM(y4, c3, m4, _4.getProjection()), i3.id, x4.layoutVertexBuffer, x4.indexBuffer, x4.segments, null, c3.zoom, null, [x4.collisionVertexBuffer, x4.collisionVertexBufferExt]));
        }
        if (!s6 || !u3.length)
          return;
        const f3 = e4.getOrCreateProgram("collisionCircle"), m3 = new Za();
        m3.resize(4 * d3), m3._trim();
        let _3 = 0;
        for (const e5 of u3)
          for (let t4 = 0; t4 < e5.circleArray.length / 4; t4++) {
            const i4 = 4 * t4, r4 = e5.circleArray[i4 + 0], n5 = e5.circleArray[i4 + 1], o4 = e5.circleArray[i4 + 2], s7 = e5.circleArray[i4 + 3];
            m3.emplace(_3++, r4, n5, o4, s7, 0), m3.emplace(_3++, r4, n5, o4, s7, 1), m3.emplace(_3++, r4, n5, o4, s7, 2), m3.emplace(_3++, r4, n5, o4, s7, 3);
          }
        (!qM || qM.length < 2 * d3) && (qM = function(e5) {
          const t4 = 2 * e5, i4 = new Wa();
          i4.resize(t4), i4._trim();
          for (let e6 = 0; e6 < t4; e6++) {
            const t5 = 6 * e6;
            i4.uint16[t5 + 0] = 4 * e6 + 0, i4.uint16[t5 + 1] = 4 * e6 + 1, i4.uint16[t5 + 2] = 4 * e6 + 2, i4.uint16[t5 + 3] = 4 * e6 + 2, i4.uint16[t5 + 4] = 4 * e6 + 3, i4.uint16[t5 + 5] = 4 * e6 + 0;
          }
          return i4;
        }(d3));
        const g3 = a3.createIndexBuffer(qM, true), y3 = a3.createVertexBuffer(m3, h_.members, true);
        for (const t4 of u3) {
          const r4 = { u_matrix: t4.transform, u_inv_matrix: t4.invTransform, u_camera_to_center_distance: (x3 = c3).getCameraToCenterDistance(t4.projection), u_viewport_size: [x3.width, x3.height] };
          f3.draw(e4, l3.TRIANGLES, Mx.disabled, Sx.disabled, e4.colorModeForRenderPass(), Dx.disabled, r4, i3.id, y3, g3, xl.simpleSegment(0, 2 * t4.circleOffset, t4.circleArray.length, t4.circleArray.length / 2), null, c3.zoom);
        }
        var x3;
        y3.destroy(), g3.destroy();
      }
      const $M = Au.create();
      function WM({ width: e4, height: t3, anchor: i3, textOffset: r3, textScale: n4 }, o3) {
        const { horizontalAlign: s6, verticalAlign: a3 } = F_(i3), l3 = -(s6 - 0.5) * e4, c3 = -(a3 - 0.5) * t3, h3 = xg(i3, r3);
        return new y2((l3 / n4 + h3[0]) * o3, (c3 / n4 + h3[1]) * o3);
      }
      function HM(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3) {
        const u3 = e4.text.placedSymbolArray, d3 = e4.text.dynamicLayoutVertexArray, p3 = e4.icon.dynamicLayoutVertexArray, f3 = {}, m3 = e4.getProjection(), _3 = YT(a3, m3, o3), g3 = o3.elevation, y3 = m3.upVectorScale(a3.canonical, o3.center.lat, o3.worldSize).metersToTile;
        d3.clear();
        for (let p4 = 0; p4 < u3.length; p4++) {
          const x3 = u3.get(p4), { tileAnchorX: v3, tileAnchorY: b3, numGlyphs: w3 } = x3, T3 = x3.hidden || !x3.crossTileID || e4.allowVerticalPlacement && !x3.placedOrientation ? null : r3[x3.crossTileID];
          if (T3) {
            let r4 = 0, u4 = 0, p5 = 0;
            if (g3) {
              const e5 = g3 ? g3.getAtTileOffset(a3, v3, b3) : 0, [t4, i4, n5] = m3.upVector(a3.canonical, v3, b3);
              r4 = e5 * t4 * y3, u4 = e5 * i4 * y3, p5 = e5 * n5 * y3;
            }
            let [E3, M3, A3, S3] = cv(x3.projectedAnchorX + r4, x3.projectedAnchorY + u4, x3.projectedAnchorZ + p5, i3 ? _3 : s6);
            const I3 = hv(o3.getCameraToCenterDistance(m3), S3);
            let C3 = n4.evaluateSizeForFeature(e4.textSizeData, c3, x3) * I3 / u_;
            i3 && (C3 *= e4.tilePixelRatio / l3);
            const z2 = WM(T3, C3);
            i3 ? ({ x: E3, y: M3, z: A3 } = m3.projectTilePoint(v3 + z2.x, b3 + z2.y, a3.canonical), [E3, M3, A3] = cv(E3 + r4, M3 + u4, A3 + p5, s6)) : (t3 && z2._rotate(-o3.angle), E3 += z2.x, M3 += z2.y, A3 = 0);
            const P3 = e4.allowVerticalPlacement && x3.placedOrientation === A_.vertical ? Math.PI / 2 : 0;
            for (let e5 = 0; e5 < w3; e5++)
              dy(d3, E3, M3, A3, P3);
            h3 && x3.associatedIconIndex >= 0 && (f3[x3.associatedIconIndex] = { x: E3, y: M3, z: A3, angle: P3 });
          } else
            xv(w3, d3);
        }
        if (h3) {
          p3.clear();
          const t4 = e4.icon.placedSymbolArray;
          for (let e5 = 0; e5 < t4.length; e5++) {
            const i4 = t4.get(e5), { numGlyphs: r4 } = i4, n5 = f3[e5];
            if (i4.hidden || !n5)
              xv(r4, p3);
            else {
              const { x: e6, y: t5, z: i5, angle: o4 } = n5;
              for (let n6 = 0; n6 < r4; n6++)
                dy(p3, e6, t5, i5, o4);
            }
          }
          e4.icon.dynamicLayoutVertexBuffer.updateData(p3);
        }
        e4.text.dynamicLayoutVertexBuffer.updateData(d3);
      }
      function XM(e4, t3, i3) {
        return i3.iconsInText && t3 ? "symbolTextAndIcon" : e4 ? "symbolSDF" : "symbolIcon";
      }
      function YM(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3) {
        const p3 = e4.context, f3 = p3.gl, m3 = e4.transform, _3 = "map" === a3, g3 = "map" === l3, y3 = _3 && "point" !== i3.layout.get("symbol-placement"), x3 = _3 && !g3 && !y3, v3 = void 0 !== i3.layout.get("symbol-sort-key").constantOr(1);
        let b3 = false;
        const w3 = e4.depthModeForSublayer(0, Mx.ReadOnly), T3 = [Kd(m3.center.lng), Jd(m3.center.lat)], E3 = i3.layout.get("text-variable-anchor"), M3 = "globe" === m3.projection.name, A3 = [], S3 = [0, -1, 0];
        let I3 = S3;
        !M3 && !m3.mercatorFromTransition || _3 || (I3 = function(e5) {
          const t4 = e5._camera.getWorldToCamera(e5.worldSize, 1), i4 = Au.multiply([], t4, e5.globeMatrix);
          Au.invert(i4, i4);
          const r4 = [0, 0, 0], n5 = [0, 1, 0, 0];
          return yu.transformMat4(n5, n5, i4), r4[0] = n5[0], r4[1] = n5[1], r4[2] = n5[2], Du.normalize(r4, r4), r4;
        }(m3));
        for (const a4 of r3) {
          const r4 = t3.getTile(a4), l4 = r4.getBucket(i3);
          if (!l4)
            continue;
          if ("mercator" === l4.projection.name && M3)
            continue;
          const u4 = n4 ? l4.text : l4.icon;
          if (!u4 || l4.fullyClipped || !u4.segments.get().length)
            continue;
          const d4 = u4.programConfigurations.get(i3.id), p4 = n4 || l4.sdfIcons, w4 = n4 ? l4.textSizeData : l4.iconSizeData, C3 = g3 || 0 !== m3.pitch, z2 = m_(w4, m3.zoom);
          let P3, D2, R3, L3, k3 = [0, 0], O2 = null;
          if (n4)
            D2 = r4.glyphAtlasTexture ? r4.glyphAtlasTexture : null, R3 = f3.LINEAR, P3 = r4.glyphAtlasTexture ? r4.glyphAtlasTexture.size : [0, 0], l4.iconsInText && (k3 = r4.imageAtlasTexture ? r4.imageAtlasTexture.size : [0, 0], O2 = r4.imageAtlasTexture ? r4.imageAtlasTexture : null, L3 = C3 || e4.options.rotating || e4.options.zooming || "composite" === w4.kind || "camera" === w4.kind ? f3.LINEAR : f3.NEAREST);
          else {
            const t4 = 1 !== i3.layout.get("icon-size").constantOr(0) || l4.iconsNeedLinear;
            D2 = r4.imageAtlasTexture ? r4.imageAtlasTexture : null, R3 = p4 || e4.options.rotating || e4.options.zooming || t4 || C3 ? f3.LINEAR : f3.NEAREST, P3 = r4.imageAtlasTexture ? r4.imageAtlasTexture.size : [0, 0];
          }
          const B2 = "globe" === l4.projection.name, F2 = B2 ? I3 : S3, N3 = B2 ? Dd(m3.zoom) : 0, U2 = YT(a4, l4.getProjection(), m3), V3 = m3.calculatePixelsToTileUnitsMatrix(r4), j3 = sv(U2, r4.tileID.canonical, g3, _3, m3, l4.getProjection(), V3), G2 = e4.terrain && g3 && y3 ? Au.invert(Au.create(), j3) : $M, q2 = lv(U2, r4.tileID.canonical, g3, _3, m3, l4.getProjection(), V3), Z3 = E3 && l4.hasTextData(), $3 = l4.hasIconTextFit() && Z3 && l4.hasIconData();
          if (y3) {
            const t4 = m3.elevation, i4 = t4 ? t4.getAtTileOffsetFunc(a4, m3.center.lat, m3.worldSize, l4.getProjection()) : null, o4 = av(U2, r4.tileID.canonical, g3, _3, m3, l4.getProjection(), V3);
            dv(l4, U2, e4, n4, o4, q2, g3, c3, i4, a4);
          }
          const W2 = y3 || n4 && E3 || $3, H3 = e4.translatePosMatrix(U2, r4, o3, s6), X2 = W2 ? $M : j3, Y2 = e4.translatePosMatrix(q2, r4, o3, s6, true), K2 = l4.getProjection().createInversionMatrix(m3, a4.canonical), J2 = i3.paint.get("icon-image-cross-fade").constantOr(0), Q2 = [];
          e4.terrainRenderModeElevated() && g3 && Q2.push("PITCH_WITH_MAP_TERRAIN"), B2 && (Q2.push("PROJECTION_GLOBE_VIEW"), W2 && Q2.push("PROJECTED_POS_ON_VIEWPORT")), J2 > 0 && Q2.push("ICON_TRANSITION"), u4.zOffsetVertexBuffer && Q2.push("Z_OFFSET");
          const ee2 = p4 && 0 !== i3.paint.get(n4 ? "text-halo-width" : "icon-halo-width").constantOr(1);
          let te2;
          p4 ? te2 = l4.iconsInText ? OM(w4.kind, z2, x3, g3, e4, H3, X2, Y2, P3, k3, a4, N3, T3, K2, F2, l4.getProjection()) : kM(w4.kind, z2, x3, g3, e4, H3, X2, Y2, n4, P3, true, a4, N3, T3, K2, F2, l4.getProjection()) : (h3 < 1 && Q2.push("SATURATION"), te2 = LM(w4.kind, z2, x3, g3, e4, H3, X2, Y2, n4, P3, a4, N3, T3, K2, F2, l4.getProjection(), h3, J2));
          const ie2 = { program: e4.getOrCreateProgram(XM(p4, n4, l4), { config: d4, defines: Q2 }), buffers: u4, uniformValues: te2, atlasTexture: D2, atlasTextureIcon: O2, atlasInterpolation: R3, atlasInterpolationIcon: L3, isSDF: p4, hasHalo: ee2, tile: r4, labelPlaneMatrixInv: G2 };
          if (v3 && l4.canOverlap) {
            b3 = true;
            const e5 = u4.segments.get();
            for (const t4 of e5)
              A3.push({ segments: new xl([t4]), sortKey: t4.sortKey, state: ie2 });
          } else
            A3.push({ segments: u4.segments, sortKey: 0, state: ie2 });
        }
        b3 && A3.sort((e5, t4) => e5.sortKey - t4.sortKey);
        for (const t4 of A3) {
          const r4 = t4.state;
          if (e4.terrain && e4.terrain.setupElevationDraw(r4.tile, r4.program, { useDepthForOcclusion: m3.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: r4.labelPlaneMatrixInv }), p3.activeTexture.set(f3.TEXTURE0), r4.atlasTexture && r4.atlasTexture.bind(r4.atlasInterpolation, f3.CLAMP_TO_EDGE), r4.atlasTextureIcon && (p3.activeTexture.set(f3.TEXTURE1), r4.atlasTextureIcon && r4.atlasTextureIcon.bind(r4.atlasInterpolationIcon, f3.CLAMP_TO_EDGE)), e4.uploadCommonLightUniforms(e4.context, r4.program), r4.hasHalo) {
            const n5 = r4.uniformValues;
            n5.u_is_halo = 1, KM(r4.buffers, t4.segments, i3, e4, r4.program, w3, u3, d3, n5, 2), n5.u_is_halo = 0;
          } else {
            if (r4.isSDF) {
              const n5 = r4.uniformValues;
              r4.hasHalo && (n5.u_is_halo = 1, KM(r4.buffers, t4.segments, i3, e4, r4.program, w3, u3, d3, n5, 1)), n5.u_is_halo = 0;
            }
            KM(r4.buffers, t4.segments, i3, e4, r4.program, w3, u3, d3, r4.uniformValues, 1);
          }
        }
      }
      function KM(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3) {
        const h3 = [e4.dynamicLayoutVertexBuffer, e4.opacityVertexBuffer, e4.iconTransitioningVertexBuffer, e4.globeExtVertexBuffer, e4.zOffsetVertexBuffer];
        n4.draw(r3, r3.context.gl.TRIANGLES, o3, s6, a3, Dx.disabled, l3, i3.id, e4.layoutVertexBuffer, e4.indexBuffer, t3, i3.paint, r3.transform.zoom, e4.programConfigurations.get(i3.id), h3, c3);
      }
      function JM(e4, t3, i3, r3, n4, o3, s6) {
        const a3 = e4.context.gl, l3 = i3.paint.get("fill-pattern"), c3 = l3 && l3.constantOr(1);
        let h3, u3, d3, p3, f3;
        s6 ? (u3 = c3 && !i3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", h3 = a3.LINES) : (u3 = c3 ? "fillPattern" : "fill", h3 = a3.TRIANGLES);
        for (const m3 of r3) {
          const r4 = t3.getTile(m3);
          if (c3 && !r4.patternsLoaded())
            continue;
          const _3 = r4.getBucket(i3);
          if (!_3)
            continue;
          e4.prepareDrawTile();
          const g3 = _3.programConfigurations.get(i3.id), y3 = e4.isTileAffectedByFog(m3), x3 = e4.getOrCreateProgram(u3, { config: g3, overrideFog: y3 });
          c3 && (e4.context.activeTexture.set(a3.TEXTURE0), r4.imageAtlasTexture && r4.imageAtlasTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), g3.updatePaintBuffers());
          const v3 = l3.constantOr(null);
          if (v3 && r4.imageAtlas) {
            const e5 = r4.imageAtlas.patternPositions[v3.toString()];
            e5 && g3.setConstantPatternPositions(e5);
          }
          const b3 = e4.translatePosMatrix(m3.projMatrix, r4, i3.paint.get("fill-translate"), i3.paint.get("fill-translate-anchor")), w3 = i3.paint.get("fill-emissive-strength");
          if (s6) {
            p3 = _3.indexBuffer2, f3 = _3.segments2;
            const t4 = e4.terrain && e4.terrain.renderingToTexture ? e4.terrain.drapeBufferSize : [a3.drawingBufferWidth, a3.drawingBufferHeight];
            d3 = "fillOutlinePattern" === u3 && c3 ? EM(b3, w3, e4, r4, t4) : TM(b3, w3, t4);
          } else
            p3 = _3.indexBuffer, f3 = _3.segments, d3 = c3 ? wM(b3, w3, e4, r4) : bM(b3, w3);
          e4.uploadCommonUniforms(e4.context, x3, m3.toUnwrapped()), x3.draw(e4, h3, n4, e4.stencilModeForClipping(m3), o3, Dx.disabled, d3, i3.id, _3.layoutVertexBuffer, p3, f3, i3.paint, e4.transform.zoom, g3, void 0);
        }
      }
      function QM(e4, t3, i3, r3, n4, o3, s6, a3) {
        i3.resetLayerRenderingStats();
        const l3 = e4.context, c3 = l3.gl, h3 = e4.transform, u3 = i3.paint.get("fill-extrusion-pattern"), d3 = u3.constantOr(1), p3 = i3.paint.get("fill-extrusion-opacity"), f3 = e4.style.enable3dLights(), m3 = i3.paint.get(f3 && !d3 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), _3 = [i3.paint.get("fill-extrusion-ambient-occlusion-intensity"), m3], g3 = i3.layout.get("fill-extrusion-edge-radius"), y3 = g3 > 0 && !i3.paint.get("fill-extrusion-rounded-roof"), x3 = y3 ? 0 : g3, v3 = "globe" === h3.projection.name ? Ib() : 0, b3 = "globe" === h3.projection.name, w3 = b3 ? Dd(h3.zoom) : 0, T3 = [Kd(h3.center.lng), Jd(h3.center.lat)], E3 = i3.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0, 3), M3 = i3.paint.get("fill-extrusion-flood-light-intensity"), A3 = i3.paint.get("fill-extrusion-vertical-scale"), S3 = eM(e4, i3.paint.get("fill-extrusion-cutoff-fade-range")), I3 = i3.paint.get("fill-extrusion-emissive-strength"), C3 = [];
        let z2;
        b3 && C3.push("PROJECTION_GLOBE_VIEW"), _3[0] > 0 && C3.push("FAUX_AO"), y3 && C3.push("ZERO_ROOF_RADIUS"), a3 && C3.push("HAS_CENTROID"), M3 > 0 && C3.push("FLOOD_LIGHT"), S3.shouldRenderCutoff && C3.push("RENDER_CUTOFF");
        const P3 = "shadow" === e4.renderPass, D2 = e4.shadowRenderer, R3 = P3 && !!D2;
        e4.shadowRenderer && (e4.shadowRenderer.useNormalOffset = true);
        let L3 = [0, 0, 0];
        if (D2) {
          const t4 = e4.style.directionalLight, i4 = e4.style.ambientLight;
          t4 && i4 && (L3 = WA(t4, i4)), z2 = C3.concat(["SHADOWS_SINGLE_CASCADE"]);
        }
        const k3 = R3 ? "fillExtrusionDepth" : d3 ? "fillExtrusionPattern" : "fillExtrusion", O2 = i3.getLayerRenderingStats();
        for (const f4 of r3) {
          const r4 = t3.getTile(f4), m4 = r4.getBucket(i3);
          if (!m4 || m4.projection.name !== h3.projection.name)
            continue;
          let g4 = false;
          D2 && (g4 = 0 === D2.getMaxCascadeForTile(f4.toUnwrapped()));
          const y4 = e4.isTileAffectedByFog(f4), R4 = m4.programConfigurations.get(i3.id), B2 = e4.getOrCreateProgram(k3, { config: R4, defines: g4 ? z2 : C3, overrideFog: y4 });
          if (e4.terrain && e4.terrain.setupElevationDraw(r4, B2, { useMeterToDem: true }), !m4.centroidVertexBuffer) {
            const e5 = B2.attributes.a_centroid_pos;
            void 0 !== e5 && c3.vertexAttrib2f(e5, 0, 0);
          }
          !P3 && D2 && D2.setupShadows(r4.tileID.toUnwrapped(), B2, "vector-tile", r4.tileID.overscaledZ), d3 && (e4.context.activeTexture.set(c3.TEXTURE0), r4.imageAtlasTexture && r4.imageAtlasTexture.bind(c3.LINEAR, c3.CLAMP_TO_EDGE), R4.updatePaintBuffers());
          const F2 = u3.constantOr(null);
          if (F2 && r4.imageAtlas) {
            const e5 = r4.imageAtlas.patternPositions[F2.toString()];
            e5 && R4.setConstantPatternPositions(e5);
          }
          const N3 = i3.paint.get("fill-extrusion-vertical-gradient");
          let U2;
          if (P3 && D2) {
            if (oA(r4.tileID, m4, e4))
              continue;
            const t4 = D2.calculateShadowPassMatrixFromTile(r4.tileID.toUnwrapped());
            U2 = xM(t4, x3, A3);
          } else {
            const t4 = e4.translatePosMatrix(f4.expandedProjMatrix, r4, i3.paint.get("fill-extrusion-translate"), i3.paint.get("fill-extrusion-translate-anchor")), n5 = h3.projection.createInversionMatrix(h3, f4.canonical);
            U2 = d3 ? vM(t4, e4, N3, p3, _3, x3, f4, r4, v3, w3, T3, n5, E3, A3) : yM(t4, e4, N3, p3, _3, x3, f4, v3, w3, T3, n5, E3, A3, M3, L3, I3);
          }
          e4.uploadCommonUniforms(l3, B2, f4.toUnwrapped(), null, S3);
          let V3 = m4.segments;
          if ("mercator" === h3.projection.name && !P3 && (V3 = m4.getVisibleSegments(r4.tileID, e4.terrain, e4.transform.getFrustum(0)), !V3.get().length))
            continue;
          if (O2)
            if (P3)
              for (const e5 of V3.get())
                O2.numRenderedVerticesInShadowPass += e5.primitiveLength;
            else
              for (const e5 of V3.get())
                O2.numRenderedVerticesInTransparentPass += e5.primitiveLength;
          const j3 = [];
          (e4.terrain || a3) && j3.push(m4.centroidVertexBuffer), b3 && j3.push(m4.layoutVertexExtBuffer), B2.draw(e4, l3.gl.TRIANGLES, n4, o3, s6, Dx.backCCW, U2, i3.id, m4.layoutVertexBuffer, m4.indexBuffer, V3, i3.paint, e4.transform.zoom, R4, j3);
        }
        e4.shadowRenderer && (e4.shadowRenderer.useNormalOffset = false);
      }
      function eA(e4, t3, i3, r3, n4, o3, s6, a3, l3, c3, h3, u3, d3, p3, f3, m3, _3, g3, y3) {
        const x3 = e4.context, v3 = x3.gl, b3 = e4.transform, w3 = e4.transform.zoom, T3 = [], E3 = eM(e4, i3.paint.get("fill-extrusion-cutoff-fade-range"));
        "clear" === c3 ? (T3.push("CLEAR_SUBPASS"), y3 && (T3.push("CLEAR_FROM_TEXTURE"), x3.activeTexture.set(v3.TEXTURE0), y3.bind(v3.LINEAR, v3.CLAMP_TO_EDGE))) : "sdf" === c3 && T3.push("SDF_SUBPASS"), _3 && T3.push("HAS_CENTROID"), E3.shouldRenderCutoff && T3.push("RENDER_CUTOFF");
        const M3 = i3.layout.get("fill-extrusion-edge-radius"), A3 = (t4, r4, c4, g4, v4) => {
          const b4 = r4.programConfigurations.get(i3.id), A4 = e4.isTileAffectedByFog(t4), S3 = e4.getOrCreateProgram("fillExtrusionGroundEffect", { config: b4, defines: T3, overrideFog: A4 }), I3 = ((e5, t5, i4, r5, n5, o4, s7, a4, l4, c5, h4) => ({ u_matrix: t5, u_opacity: i4, u_ao_pass: r5 ? 1 : 0, u_meter_to_tile: n5, u_ao: o4, u_flood_light_intensity: s7, u_flood_light_color: a4, u_attenuation: l4, u_edge_radius: c5, u_fb: 0, u_fb_size: h4 }))(0, g4, h3, l3, v4, [u3, d3 * v4], p3, f3, m3, w3 >= 17 ? 0 : M3 * v4, y3 ? y3.size[0] : 0), C3 = [];
          _3 && C3.push(r4.hiddenByLandmarkVertexBuffer), e4.uploadCommonUniforms(x3, S3, t4.toUnwrapped(), null, E3), S3.draw(e4, x3.gl.TRIANGLES, n4, o3, s6, a3, I3, i3.id, r4.vertexBuffer, r4.indexBuffer, c4, i3.paint, w3, b4, C3);
        };
        for (const n5 of r3) {
          const r4 = t3.getTile(n5), o4 = r4.getBucket(i3);
          if (!o4 || o4.projection.name !== b3.projection.name || !o4.groundEffect || o4.groundEffect && !o4.groundEffect.hasData())
            continue;
          const s7 = o4.groundEffect, a4 = 1 / o4.tileToMeter;
          {
            const t4 = e4.translatePosMatrix(n5.projMatrix, r4, i3.paint.get("fill-extrusion-translate"), i3.paint.get("fill-extrusion-translate-anchor")), o5 = s7.getDefaultSegment();
            A3(n5, s7, o5, t4, a4);
          }
          if (g3)
            for (let o5 = 0; o5 < 4; o5++) {
              const s8 = $u[o5](n5), l4 = t3.getTile(s8);
              if (!l4)
                continue;
              const c4 = l4.getBucket(i3);
              if (!c4 || c4.projection.name !== b3.projection.name || !c4.groundEffect || c4.groundEffect && !c4.groundEffect.hasData())
                continue;
              const h4 = c4.groundEffect;
              let u4, d4;
              0 === o5 ? (u4 = [-cr, 0, 0], d4 = 1) : 1 === o5 ? (u4 = [cr, 0, 0], d4 = 0) : 2 === o5 ? (u4 = [0, -cr, 0], d4 = 3) : (u4 = [0, cr, 0], d4 = 2);
              const p4 = h4.regionSegments[d4];
              if (!p4)
                continue;
              const f4 = new Float32Array(16);
              Au.translate(f4, n5.projMatrix, u4), A3(n5, h4, p4, e4.translatePosMatrix(f4, r4, i3.paint.get("fill-extrusion-translate"), i3.paint.get("fill-extrusion-translate-anchor")), a4);
            }
        }
      }
      function tA(e4, t3, i3, r3, n4, o3, s6) {
        0 === r3.centroidVertexArray.length && r3.createCentroidsBuffer();
        const a3 = o3 ? o3.findDEMTileFor(i3) : null;
        if (!(a3 && a3.dem || s6))
          return;
        const l3 = (e5) => {
          const i4 = t3.getSource().minzoom, r4 = (e6) => {
            const i5 = t3.getTileByID(e6);
            if (i5 && i5.hasData())
              return i5.getBucket(n4);
          }, o4 = [0, -1, 1];
          for (const t4 of o4) {
            if (e5.overscaledZ + t4 < i4)
              continue;
            const n5 = r4(e5.calculateScaledKey(e5.overscaledZ + t4));
            if (n5)
              return n5;
          }
        }, c3 = [0, 0, 0], h3 = (e5, t4) => (c3[0] = Math.min(e5.min.y, t4.min.y), c3[1] = Math.max(e5.max.y, t4.max.y), c3[2] = cr - t4.min.x > e5.max.x ? t4.min.x - cr : e5.max.x, c3), u3 = (e5, t4) => (c3[0] = Math.min(e5.min.x, t4.min.x), c3[1] = Math.max(e5.max.x, t4.max.x), c3[2] = cr - t4.min.y > e5.max.y ? t4.min.y - cr : e5.max.y, c3), d3 = [(e5, t4) => h3(e5, t4), (e5, t4) => h3(t4, e5), (e5, t4) => u3(e5, t4), (e5, t4) => u3(t4, e5)], p3 = (e5, t4, r4, n5, s7, l4, c4) => {
          if (!o3)
            return 0;
          const h4 = [[l4 ? r4 : e5, l4 ? e5 : r4, 0], [l4 ? r4 : t4, l4 ? t4 : r4, 0]], u4 = c4 < 0 ? cr + c4 : c4, d4 = [l4 ? u4 : (e5 + t4) / 2, l4 ? (e5 + t4) / 2 : u4, 0];
          return 0 === r4 && c4 < 0 || 0 !== r4 && c4 > 0 ? o3.getForTilePoints(s7, [d4], true, n5) : h4.push(d4), o3.getForTilePoints(i3, h4, true, a3), Math.max(h4[0][2], h4[1][2], d4[2]) / o3.exaggeration();
        };
        for (let e5 = 0; e5 < 4; e5++) {
          const t4 = r3.borderFeatureIndices[e5];
          if (0 === t4.length)
            continue;
          const n5 = $u[e5](i3), a4 = l3(n5);
          if (!(a4 && a4 instanceof vb))
            continue;
          if (r3.borderDoneWithNeighborZ[e5] === a4.canonical.z)
            continue;
          0 === a4.centroidVertexArray.length && a4.createCentroidsBuffer();
          const c4 = o3 ? o3.findDEMTileFor(n5) : null;
          if (!(c4 && c4.dem || s6))
            continue;
          const h4 = (e5 < 2 ? 1 : 5) - e5, u4 = a4.borderDoneWithNeighborZ[h4] !== r3.canonical.z, g3 = a4.borderFeatureIndices[h4];
          let x3 = 0;
          if (r3.canonical.z !== a4.canonical.z) {
            for (const e6 of t4)
              r3.showCentroid(r3.featuresOnBorder[e6]);
            if (u4)
              for (const e6 of g3)
                a4.showCentroid(a4.featuresOnBorder[e6]);
            r3.borderDoneWithNeighborZ[e5] = a4.canonical.z, a4.borderDoneWithNeighborZ[h4] = r3.canonical.z;
          }
          for (const i4 of t4) {
            const t5 = r3.featuresOnBorder[i4], o4 = r3.centroidData[t5.centroidDataIndex], l4 = t5.borders[e5];
            let u5;
            for (; x3 < g3.length; ) {
              u5 = a4.featuresOnBorder[g3[x3]];
              const e6 = u5.borders[h4];
              if (e6[1] > l4[0] + 3 || e6[0] > l4[0] - 3)
                break;
              a4.showCentroid(u5), x3++;
            }
            if (u5 && x3 < g3.length) {
              const i5 = x3;
              let v3 = 0;
              for (; !(u5.borders[h4][0] > l4[1] - 3) && (v3++, ++x3 !== g3.length); )
                u5 = a4.featuresOnBorder[g3[x3]];
              if (u5 = a4.featuresOnBorder[g3[i5]], v3 > 1) {
                const e6 = u5.borders[h4];
                Math.abs(l4[0] - e6[0]) < 3 && Math.abs(l4[1] - e6[1]) < 3 && (v3 = 1, x3 = i5 + 1);
              } else if (0 === v3) {
                r3.showCentroid(t5);
                continue;
              }
              const b3 = a4.centroidData[u5.centroidDataIndex];
              s6 && 1 === v3 && (((m3 = o4).flags | (_3 = b3).flags) & cb ? (m3.flags |= cb, _3.flags |= cb) : (m3.flags &= 2147483647, _3.flags &= 2147483647));
              let w3 = new y2(0, 0);
              if (v3 > 1)
                x3 = i5;
              else if (c4 && c4.dem && !(t5.intersectsCount() > 1 || u5.intersectsCount() > 1)) {
                const t6 = d3[e5](o4, b3), i6 = e5 % 2 ? cr - 1 : 0;
                f3 = p3(t6[0], Math.min(cr - 1, t6[1]), i6, c4, n5, e5 < 2, t6[2]), w3 = new y2(Math.ceil(7 * (f3 + 450)), 0);
              }
              o4.centroidXY = b3.centroidXY = w3, r3.writeCentroidToBuffer(o4), a4.writeCentroidToBuffer(b3);
            } else
              r3.showCentroid(t5);
          }
          r3.borderDoneWithNeighborZ[e5] = a4.canonical.z, a4.borderDoneWithNeighborZ[h4] = r3.canonical.z;
        }
        var f3, m3, _3;
        (r3.needsCentroidUpdate || !r3.centroidVertexBuffer && 0 !== r3.centroidVertexArray.length) && r3.uploadCentroid(e4);
      }
      const iA = [1, 0, 0], rA = [0, 1, 0], nA = [0, 0, 1];
      function oA(e4, t3, i3) {
        const r3 = i3.transform, n4 = i3.shadowRenderer;
        if (!n4)
          return true;
        const o3 = e4.toUnwrapped(), s6 = r3.tileSize * n4._cascades[i3.currentShadowCascade].scale;
        let a3 = t3.maxHeight;
        if (r3.elevation) {
          const t4 = r3.elevation.getMinMaxForTile(e4);
          t4 && (a3 += t4.max);
        }
        const l3 = [...n4.shadowDirection];
        l3[2] = -l3[2];
        const c3 = n4.computeSimplifiedTileShadowVolume(o3, a3, s6, l3);
        if (!c3)
          return false;
        const h3 = [iA, rA, nA, l3, [l3[0], 0, l3[2]], [0, l3[1], l3[2]]], u3 = "globe" === r3.projection.name, d3 = r3.scaleZoom(s6), p3 = Qu.fromInvProjectionMatrix(r3.invProjMatrix, r3.worldSize, d3, !u3), f3 = n4.getCurrentCascadeFrustum();
        return 0 === p3.intersectsPrecise(c3.vertices, c3.planes, h3) || 0 === f3.intersectsPrecise(c3.vertices, c3.planes, h3);
      }
      function sA(e4) {
        const t3 = e4._nearZ, i3 = e4.projection.farthestPixelDistance(e4), r3 = i3 - t3, n4 = 0.2 * e4.height, o3 = t3 + n4;
        return [t3, i3, (o3 - n4 - t3) / r3, (o3 - t3) / r3];
      }
      const aA = new hi(1, 0, 0, 1), lA = new hi(0, 1, 0, 1), cA = new hi(0, 0, 1, 1), hA = new hi(1, 0, 1, 1), uA = new hi(0, 1, 1, 1);
      function dA(e4, t3, i3) {
        const r3 = e4.context, n4 = e4.transform, o3 = r3.gl, s6 = "globe" === n4.projection.name, a3 = s6 ? ["PROJECTION_GLOBE_VIEW"] : [];
        let l3 = i3.projMatrix;
        if (s6 && Dd(n4.zoom) > 0) {
          const e5 = Sd(_d(i3.canonical, n4));
          l3 = Au.multiply(new Float32Array(16), n4.globeMatrix, e5), Au.multiply(l3, n4.projMatrix, l3);
        }
        const c3 = e4.getOrCreateProgram("debug", { defines: a3 }), h3 = t3.getTileByID(i3.key);
        e4.terrain && e4.terrain.setupElevationDraw(h3, c3);
        const u3 = Mx.disabled, d3 = Sx.disabled, p3 = e4.colorModeForRenderPass(), f3 = "$debug";
        r3.activeTexture.set(o3.TEXTURE0), e4.emptyTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE), s6 ? h3._makeGlobeTileDebugBuffers(e4.context, n4) : h3._makeDebugTileBoundsBuffers(e4.context, n4.projection);
        const m3 = h3._tileDebugBuffer || e4.debugBuffer, _3 = h3._tileDebugIndexBuffer || e4.debugIndexBuffer, g3 = h3._tileDebugSegments || e4.debugSegments;
        c3.draw(e4, o3.LINE_STRIP, u3, d3, p3, Dx.disabled, AM(l3, hi.red), f3, m3, _3, g3, null, null, null, [h3._globeTileDebugBorderBuffer]);
        const y3 = h3.latestRawTileData, x3 = Math.floor((y3 && y3.byteLength || 0) / 1024), v3 = t3.getTile(i3).tileSize, b3 = 512 / Math.min(v3, 512) * (i3.overscaledZ / n4.zoom) * 0.5;
        let w3 = i3.canonical.toString();
        i3.overscaledZ !== i3.canonical.z && (w3 += ` => ${i3.overscaledZ}`), w3 += ` ${x3}kb`, function(e5, t4) {
          e5.initDebugOverlayCanvas();
          const i4 = e5.debugOverlayCanvas, r4 = e5.context.gl, n5 = e5.debugOverlayCanvas.getContext("2d");
          n5.clearRect(0, 0, i4.width, i4.height), n5.shadowColor = "white", n5.shadowBlur = 2, n5.lineWidth = 1.5, n5.strokeStyle = "white", n5.textBaseline = "top", n5.font = "bold 36px Open Sans, sans-serif", n5.fillText(t4, 5, 5), n5.strokeText(t4, 5, 5), e5.debugOverlayTexture.update(i4), e5.debugOverlayTexture.bind(r4.LINEAR, r4.CLAMP_TO_EDGE);
        }(e4, w3);
        const T3 = h3._tileDebugTextBuffer || e4.debugBuffer, E3 = h3._tileDebugTextIndexBuffer || e4.quadTriangleIndexBuffer, M3 = h3._tileDebugTextSegments || e4.debugSegments;
        c3.draw(e4, o3.TRIANGLES, u3, d3, Cx.alphaBlended, Dx.disabled, AM(l3, hi.transparent, b3), f3, T3, E3, M3, null, null, null, [h3._globeTileDebugTextBuffer]);
      }
      function pA(e4, t3, i3, r3) {
        mA(e4, 0, t3 + i3 / 2, e4.transform.width, i3, r3);
      }
      function fA(e4, t3, i3, r3) {
        mA(e4, t3 - i3 / 2, 0, i3, e4.transform.height, r3);
      }
      function mA(e4, t3, i3, r3, n4, o3) {
        const s6 = e4.context, a3 = s6.gl;
        a3.enable(a3.SCISSOR_TEST), a3.scissor(t3 * dt.devicePixelRatio, i3 * dt.devicePixelRatio, r3 * dt.devicePixelRatio, n4 * dt.devicePixelRatio), s6.clear({ color: o3 }), a3.disable(a3.SCISSOR_TEST);
      }
      const _A = Ia([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: gA } = _A;
      function yA(e4, t3, i3, r3) {
        e4.emplaceBack(t3, i3, r3);
      }
      class xA {
        constructor(e4) {
          this.vertexArray = new tl(), this.indices = new Wa(), yA(this.vertexArray, -1, -1, 1), yA(this.vertexArray, 1, -1, 1), yA(this.vertexArray, -1, 1, 1), yA(this.vertexArray, 1, 1, 1), yA(this.vertexArray, -1, -1, -1), yA(this.vertexArray, 1, -1, -1), yA(this.vertexArray, -1, 1, -1), yA(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = e4.createVertexBuffer(this.vertexArray, gA), this.indexBuffer = e4.createIndexBuffer(this.indices), this.segment = xl.simpleSegment(0, 0, 36, 12);
        }
      }
      function vA(e4, t3, i3, r3, n4, o3) {
        const s6 = e4.context.gl, a3 = t3.paint.get("sky-atmosphere-color"), l3 = t3.paint.get("sky-atmosphere-halo-color"), c3 = t3.paint.get("sky-atmosphere-sun-intensity"), h3 = ((e5, t4, i4, r4, n5) => ({ u_matrix_3f: e5, u_sun_direction: t4, u_sun_intensity: i4, u_color_tint_r: [r4.r, r4.g, r4.b, r4.a], u_color_tint_m: [n5.r, n5.g, n5.b, n5.a], u_luminance: 5e-5 }))(Eu.fromMat4(Eu.create(), r3), n4, c3, a3, l3);
        s6.framebufferTexture2D(s6.FRAMEBUFFER, s6.COLOR_ATTACHMENT0, s6.TEXTURE_CUBE_MAP_POSITIVE_X + o3, t3.skyboxTexture, 0), i3.draw(e4, s6.TRIANGLES, Mx.disabled, Sx.disabled, Cx.unblended, Dx.frontCW, h3, "skyboxCapture", t3.skyboxGeometry.vertexBuffer, t3.skyboxGeometry.indexBuffer, t3.skyboxGeometry.segment);
      }
      const bA = Ia([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class wA {
        constructor(e4) {
          const t3 = new Ka();
          t3.emplaceBack(-1, 1, 1, 0, 0), t3.emplaceBack(1, 1, 1, 1, 0), t3.emplaceBack(1, -1, 1, 1, 1), t3.emplaceBack(-1, -1, 1, 0, 1);
          const i3 = new Wa();
          i3.emplaceBack(0, 1, 2), i3.emplaceBack(2, 3, 0), this.vertexBuffer = e4.createVertexBuffer(t3, bA.members), this.indexBuffer = e4.createIndexBuffer(i3), this.segments = xl.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const TA = Ia([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
      class EA {
        constructor() {
          this.colorModeAlphaBlendedWriteRGB = new Cx([1, Ix, 1, Ix], hi.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new Cx([1, 0, 1, 0], hi.transparent, [false, false, false, true]);
        }
        update(e4) {
          const t3 = e4.context;
          if (!this.atmosphereBuffer) {
            this.atmosphereBuffer = new wA(t3);
            const e5 = 100, i3 = 200, r3 = function(e6) {
              const t4 = Xn(30), i4 = [];
              for (let e7 = 0; e7 < 16e3; ++e7) {
                const e8 = 2 * Math.PI * t4(), r4 = Math.acos(1 - 2 * t4()) - 0.5 * Math.PI;
                i4.push(Du.fromValues(Math.cos(r4) * Math.cos(e8), Math.cos(r4) * Math.sin(e8), Math.sin(r4)));
              }
              return i4;
            }(), n4 = Xn(300), o3 = new Ja(), s6 = new Wa();
            let a3 = 0;
            for (let t4 = 0; t4 < r3.length; ++t4) {
              const l3 = Du.scale([], r3[t4], 200), c3 = Math.max(0, 1 + 0.01 * e5 * (1 * n4() - 0.5)), h3 = Math.max(0, 1 + 0.01 * i3 * (1 * n4() - 0.5));
              o3.emplaceBack(l3[0], l3[1], l3[2], -1, -1, c3, h3), o3.emplaceBack(l3[0], l3[1], l3[2], 1, -1, c3, h3), o3.emplaceBack(l3[0], l3[1], l3[2], 1, 1, c3, h3), o3.emplaceBack(l3[0], l3[1], l3[2], -1, 1, c3, h3), s6.emplaceBack(a3 + 0, a3 + 1, a3 + 2), s6.emplaceBack(a3 + 0, a3 + 2, a3 + 3), a3 += 4;
            }
            this.starsVx = t3.createVertexBuffer(o3, TA.members), this.starsIdx = t3.createIndexBuffer(s6), this.starsSegments = xl.simpleSegment(0, 0, o3.length, s6.length);
          }
        }
        destroy() {
          this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
        }
        drawAtmosphereGlow(e4, t3) {
          const i3 = e4.context, r3 = i3.gl, n4 = e4.transform, o3 = new Mx(r3.LEQUAL, Mx.ReadOnly, [0, 1]), s6 = Dd(n4.zoom), a3 = t3.properties.get("color").toArray01(), l3 = t3.properties.get("high-color").toArray01(), c3 = t3.properties.get("space-color").toArray01PremultipliedAlpha(), h3 = 5e-4, u3 = z((t3.properties.get("horizon-blend") - 0) / 1 * 0.2495 + h3, 5e-4, 0.25), d3 = Ld(e4, i3, n4) && u3 === h3 ? n4.worldSize / (2 * Math.PI * 1.025) - 1 : n4.globeRadius, p3 = e4.frameCounter / 1e3 % 1, f3 = Du.length(n4.globeCenterInViewSpace), m3 = Math.sqrt(Math.pow(f3, 2) - Math.pow(d3, 2)), _3 = Math.acos(m3 / f3), g3 = (t4) => {
            const h4 = "globe" === n4.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
            t4 && h4.push("ALPHA_PASS");
            const d4 = e4.getOrCreateProgram("globeAtmosphere", { defines: h4 }), f4 = ((e5, t5, i4, r4, n5, o4, s7, a4, l4, c4, h5, u4) => ({ u_frustum_tl: e5, u_frustum_tr: t5, u_frustum_br: i4, u_frustum_bl: r4, u_horizon: n5, u_transition: o4, u_fadeout_range: s7, u_color: a4, u_high_color: l4, u_space_color: c4, u_temporal_offset: h5, u_horizon_angle: u4 }))(n4.frustumCorners.TL, n4.frustumCorners.TR, n4.frustumCorners.BR, n4.frustumCorners.BL, n4.frustumCorners.horizon, s6, u3, a3, l3, c3, p3, _3);
            e4.uploadCommonUniforms(i3, d4);
            const m4 = this.atmosphereBuffer;
            m4 && d4.draw(e4, r3.TRIANGLES, o3, Sx.disabled, t4 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Dx.backCW, f4, t4 ? "atmosphere_glow_alpha" : "atmosphere_glow", m4.vertexBuffer, m4.indexBuffer, m4.segments);
          };
          g3(false), g3(true);
        }
        drawStars(e4, t3) {
          const i3 = z(t3.properties.get("star-intensity"), 0, 1);
          if (0 === i3)
            return;
          const r3 = e4.context, n4 = r3.gl, o3 = e4.transform, s6 = e4.getOrCreateProgram("stars"), a3 = Iu.identity([]);
          Iu.rotateX(a3, a3, -o3._pitch), Iu.rotateZ(a3, a3, -o3.angle), Iu.rotateX(a3, a3, w2(o3._center.lat)), Iu.rotateY(a3, a3, -w2(o3._center.lng));
          const l3 = Au.fromQuat(new Float32Array(16), a3), c3 = Au.multiply([], o3.starsProjMatrix, l3), h3 = Eu.fromMat4([], l3), u3 = Eu.invert([], h3), d3 = [0, 1, 0];
          Du.transformMat3(d3, d3, u3), Du.scale(d3, d3, 0.15);
          const p3 = [1, 0, 0];
          Du.transformMat3(p3, p3, u3), Du.scale(p3, p3, 0.15);
          const f3 = ((e5, t4, i4, r4) => ({ u_matrix: Float32Array.from(e5), u_up: t4, u_right: i4, u_intensity_multiplier: r4 }))(c3, d3, p3, i3);
          e4.uploadCommonUniforms(r3, s6), this.starsVx && this.starsIdx && s6.draw(e4, n4.TRIANGLES, Mx.disabled, Sx.disabled, this.colorModeAlphaBlendedWriteRGB, Dx.disabled, f3, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
        }
      }
      function MA(e4, t3) {
        const i3 = [...e4], r3 = t3.cameraWorldSizeForFog / t3.worldSize, n4 = Au.identity([]);
        return Au.scale(n4, n4, [r3, r3, 1]), Au.multiply(i3, n4, i3), Au.multiply(i3, t3.worldToFogMatrix, i3), i3;
      }
      function AA(e4, t3, i3, r3) {
        const n4 = i3.material, o3 = r3.context, { baseColorTexture: s6, metallicRoughnessTexture: a3 } = n4.pbrMetallicRoughness, { normalTexture: l3, occlusionTexture: c3, emissionTexture: h3 } = n4;
        function u3(t4, i4, r4) {
          if (t4 && (e4.push(i4), o3.activeTexture.set(o3.gl.TEXTURE0 + r4), t4.gfxTexture)) {
            const { minFilter: e5, magFilter: i5, wrapS: r5, wrapT: n5 } = t4.sampler;
            t4.gfxTexture.bindExtraParam(e5, i5, r5, n5);
          }
        }
        u3(s6, "HAS_TEXTURE_u_baseColorTexture", NM.BaseColor), u3(a3, "HAS_TEXTURE_u_metallicRoughnessTexture", NM.MetallicRoughness), u3(l3, "HAS_TEXTURE_u_normalTexture", NM.Normal), u3(c3, "HAS_TEXTURE_u_occlusionTexture", NM.Occlusion), u3(h3, "HAS_TEXTURE_u_emissionTexture", NM.Emission), i3.texcoordBuffer && (e4.push("HAS_ATTRIBUTE_a_uv_2f"), t3.push(i3.texcoordBuffer)), i3.colorBuffer && (e4.push(12 === i3.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t3.push(i3.colorBuffer)), i3.normalBuffer && (e4.push("HAS_ATTRIBUTE_a_normal_3f"), t3.push(i3.normalBuffer)), i3.pbrBuffer && (e4.push("HAS_ATTRIBUTE_a_pbr"), e4.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t3.push(i3.pbrBuffer)), "OPAQUE" !== n4.alphaMode && "MASK" !== n4.alphaMode || e4.push("UNPREMULT_TEXTURE_IN_SHADER"), n4.defined || e4.push("DIFFUSE_SHADED"), e4.push("USE_STANDARD_DERIVATIVES");
      }
      function SA(e4, t3, i3, r3, n4, o3) {
        const s6 = i3.paint.get("model-opacity"), a3 = t3.context, l3 = new Mx(t3.context.gl.LEQUAL, Mx.ReadWrite, t3.depthRangeFor3D), c3 = t3.transform, h3 = e4.mesh, u3 = h3.material, d3 = u3.pbrMetallicRoughness, p3 = t3.style.fog;
        let f3;
        f3 = "pixels" === t3.transform.projection.zAxisUnit ? [...e4.nodeModelMatrix] : Au.multiply([], r3.zScaleMatrix, e4.nodeModelMatrix), Au.multiply(f3, r3.negCameraPosMatrix, f3);
        const m3 = Au.invert([], f3);
        Au.transpose(m3, m3);
        const _3 = i3.paint.get("model-emissive-strength").constantOr(0), g3 = UM(new Float32Array(e4.worldViewProjection), new Float32Array(f3), new Float32Array(m3), t3, s6, d3.baseColorFactor, u3.emissiveFactor, d3.metallicFactor, d3.roughnessFactor, u3, _3, i3), y3 = { defines: [] }, x3 = [];
        AA(y3.defines, x3, h3, t3);
        const v3 = t3.shadowRenderer;
        v3 && (v3.useNormalOffset = false);
        let b3 = null;
        if (p3) {
          const i4 = MA(e4.nodeModelMatrix, t3.transform);
          if (b3 = new Float32Array(i4), "globe" !== c3.projection.name) {
            const e5 = h3.aabb.min, t4 = h3.aabb.max, [r4, n5] = p3.getOpacityForBounds(i4, e5[0], e5[1], t4[0], t4[1]);
            y3.overrideFog = r4 >= fw || n5 >= fw;
          }
        }
        const w3 = eM(t3, i3.paint.get("model-cutoff-fade-range"));
        w3.shouldRenderCutoff && y3.defines.push("RENDER_CUTOFF");
        const T3 = t3.getOrCreateProgram("model", y3);
        t3.uploadCommonUniforms(a3, T3, null, b3, w3), "shadow" !== t3.renderPass && v3 && v3.setupShadowsFromMatrix(e4.nodeModelMatrix, T3), T3.draw(t3, a3.gl.TRIANGLES, l3, n4, o3, h3.material.doubleSided ? Dx.disabled : Dx.backCCW, g3, i3.id, h3.vertexBuffer, h3.indexBuffer, h3.segments, i3.paint, t3.transform.zoom, void 0, x3);
      }
      function IA(e4, t3, i3, r3, n4, o3, s6) {
        let a3;
        a3 = "globe" === e4.projection.name ? Av(i3, e4) : [...i3], Au.multiply(a3, a3, t3.matrix);
        const l3 = Au.multiply([], r3, a3);
        if (t3.meshes)
          for (const e5 of t3.meshes) {
            if ("BLEND" !== e5.material.alphaMode) {
              s6.push({ mesh: e5, depth: 0, modelIndex: n4, worldViewProjection: l3, nodeModelMatrix: a3 });
              continue;
            }
            const t4 = Du.transformMat4([], e5.centroid, l3);
            t4[2] > 0 && o3.push({ mesh: e5, depth: t4[2], modelIndex: n4, worldViewProjection: l3, nodeModelMatrix: a3 });
          }
        if (t3.children)
          for (const a4 of t3.children)
            IA(e4, a4, i3, r3, n4, o3, s6);
      }
      function CA(e4, t3, i3, r3) {
        const n4 = i3.shadowRenderer;
        if (!n4)
          return;
        const o3 = n4.getShadowPassDepthMode(), s6 = n4.getShadowPassColorMode(), a3 = n4.calculateShadowPassMatrixFromMatrix(t3), l3 = jM(a3);
        i3.getOrCreateProgram("modelDepth", { defines: ["DEPTH_TEXTURE"] }).draw(i3, i3.context.gl.TRIANGLES, o3, Sx.disabled, s6, Dx.backCCW, l3, r3.id, e4.vertexBuffer, e4.indexBuffer, e4.segments, r3.paint, i3.transform.zoom, void 0, void 0);
      }
      function zA(e4, t3, i3) {
        const r3 = t3.updateZoomBasedPaintProperties(), n4 = function(e5, t4, i4) {
          let r4, n5, o3, s6 = e5.terrain ? e5.terrain.exaggeration() : 0;
          if (e5.terrain && s6 > 0) {
            const t5 = e5.terrain, n6 = t5.findDEMTileFor(i4);
            n6 && n6.dem ? r4 = Jm.create(t5, i4, n6) : s6 = 0;
          }
          if (0 === s6 && (t4.terrainElevationMin = 0, t4.terrainElevationMax = 0), s6 === t4.validForExaggeration && (0 === s6 || r4 && r4._demTile && r4._demTile.tileID === t4.validForDEMTile.id && r4._dem._timestamp === t4.validForDEMTile.timestamp))
            return false;
          for (const e6 in t4.instancesPerModel) {
            const i5 = t4.instancesPerModel[e6];
            for (let e7 = 0; e7 < i5.instancedDataArray.length; ++e7) {
              const a3 = (r4 ? s6 * r4.getElevationAt(0 | i5.instancedDataArray.float32[16 * e7], 0 | i5.instancedDataArray.float32[16 * e7 + 1], true, true) : 0) + i5.instancesEvaluatedElevation[e7];
              i5.instancedDataArray.float32[16 * e7 + 6] = a3, n5 = n5 ? Math.min(t4.terrainElevationMin, a3) : a3, o3 = o3 ? Math.max(t4.terrainElevationMax, a3) : a3;
            }
          }
          return t4.terrainElevationMin = n5 || 0, t4.terrainElevationMax = o3 || 0, t4.validForExaggeration = s6, t4.validForDEMTile = r4 && r4._demTile ? { id: r4._demTile.tileID, timestamp: r4._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
        }(e4, t3, i3);
        (r3 || n4) && (t3.uploaded = false, t3.upload(e4.context));
      }
      const PA = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new ed([0, 0, 0], [cr, cr, 0]) };
      function DA(e4, t3) {
        const i3 = 1 << e4.canonical.z, r3 = t3.getFreeCameraOptions().position, n4 = t3.elevation, o3 = e4.canonical.x / i3, s6 = (e4.canonical.x + 1) / i3, a3 = e4.canonical.y / i3, l3 = (e4.canonical.y + 1) / i3;
        let c3 = t3._centerAltitude;
        if (n4) {
          const t4 = n4.getMinMaxForTile(e4);
          t4 && t4.max > c3 && (c3 = t4.max);
        }
        const h3 = z(r3.x, o3, s6) - r3.x, u3 = z(r3.y, a3, l3) - r3.y, d3 = Qd(c3, t3.center.lat) - r3.z;
        return t3._zoomFromMercatorZ(Math.sqrt(h3 * h3 + u3 * u3 + d3 * d3));
      }
      function RA(e4, t3, i3, r3, n4, o3, s6) {
        const a3 = e4.context, l3 = "shadow" === e4.renderPass, c3 = e4.shadowRenderer, h3 = l3 && c3 ? c3.getShadowPassDepthMode() : new Mx(a3.gl.LEQUAL, Mx.ReadWrite, e4.depthRangeFor3D), u3 = e4.isTileAffectedByFog(o3);
        if (i3.meshes)
          for (const d3 of i3.meshes) {
            const p3 = ["MODEL_POSITION_ON_GPU"], f3 = [];
            let m3, _3, g3;
            r3.instancedDataArray.length > 20 && p3.push("INSTANCED_ARRAYS");
            const y3 = eM(e4, t3.paint.get("model-cutoff-fade-range"));
            if (y3.shouldRenderCutoff && p3.push("RENDER_CUTOFF"), l3 && c3)
              m3 = e4.getOrCreateProgram("modelDepth", { defines: p3 }), _3 = jM(s6.shadowTileMatrix, s6.shadowTileMatrix, Float32Array.from(i3.matrix)), g3 = c3.getShadowPassColorMode();
            else {
              AA(p3, f3, d3, e4), m3 = e4.getOrCreateProgram("model", { defines: p3, overrideFog: u3 });
              const r4 = d3.material, l4 = r4.pbrMetallicRoughness, h4 = t3.paint.get("model-opacity"), x4 = t3.paint.get("model-emissive-strength").constantOr(0);
              _3 = UM(o3.expandedProjMatrix, Float32Array.from(i3.matrix), new Float32Array(16), e4, h4, l4.baseColorFactor, r4.emissiveFactor, l4.metallicFactor, l4.roughnessFactor, r4, x4, t3, n4), c3 && (s6.shadowUniformsInitialized ? m3.setShadowUniformValues(a3, c3.getShadowUniformValues()) : (c3.setupShadows(o3.toUnwrapped(), m3, "model-tile", o3.overscaledZ), s6.shadowUniformsInitialized = true)), g3 = y3.shouldRenderCutoff || h4 < 1 || "OPAQUE" !== r4.alphaMode ? Cx.alphaBlended : Cx.unblended;
            }
            e4.uploadCommonUniforms(a3, m3, o3.toUnwrapped(), null, y3);
            const x3 = d3.material.doubleSided ? Dx.disabled : Dx.backCCW;
            if (r3.instancedDataArray.length > 20)
              f3.push(r3.instancedDataBuffer), m3.draw(e4, a3.gl.TRIANGLES, h3, Sx.disabled, g3, x3, _3, t3.id, d3.vertexBuffer, d3.indexBuffer, d3.segments, t3.paint, e4.transform.zoom, void 0, f3, r3.instancedDataArray.length);
            else {
              const i4 = l3 ? "u_instance" : "u_normal_matrix";
              for (let n5 = 0; n5 < r3.instancedDataArray.length; ++n5)
                _3[i4] = new Float32Array(r3.instancedDataArray.arrayBuffer, 64 * n5, 16), m3.draw(e4, a3.gl.TRIANGLES, h3, Sx.disabled, g3, x3, _3, t3.id, d3.vertexBuffer, d3.indexBuffer, d3.segments, t3.paint, e4.transform.zoom, void 0, f3);
            }
          }
        if (i3.children)
          for (const a4 of i3.children)
            RA(e4, t3, a4, r3, n4, o3, s6);
      }
      const LA = [1, -1, 1];
      function kA(e4, t3, i3, r3) {
        if (!i3.modelManager)
          return true;
        const n4 = i3.modelManager;
        if (!i3.shadowRenderer)
          return true;
        const o3 = i3.shadowRenderer, s6 = t3.aabb;
        let a3 = true, l3 = e4.maxHeight;
        if (0 === l3) {
          let t4 = 0;
          for (const i4 in e4.instancesPerModel) {
            const e5 = n4.getModel(i4, r3);
            e5 ? t4 = Math.max(t4, Math.max(Math.max(e5.aabb.max[0], e5.aabb.max[1]), e5.aabb.max[2])) : a3 = false;
          }
          l3 = e4.maxScale * t4 * 1.41 + e4.maxVerticalOffset, a3 && (e4.maxHeight = l3);
        }
        s6.max[2] = l3, s6.min[2] += e4.terrainElevationMin, s6.max[2] += e4.terrainElevationMax, Du.transformMat4(s6.min, s6.min, t3.tileMatrix), Du.transformMat4(s6.max, s6.max, t3.tileMatrix);
        const c3 = s6.intersects(o3.getCurrentCascadeFrustum());
        return 0 === i3.currentShadowCascade && (e4.isInsideFirstShadowMapFrustum = 2 === c3), 0 === c3;
      }
      class OA {
      }
      class BA {
        constructor() {
          this._storage = /* @__PURE__ */ new Map();
        }
        getLinesFromTrianglesBuffer(e4, t3, i3) {
          {
            const i4 = this._storage.get(t3.id);
            if (i4)
              return i4.lastUsedFrameIdx = e4, i4.buf;
          }
          const r3 = i3.gl, n4 = r3.getBufferParameter(r3.ELEMENT_ARRAY_BUFFER, r3.BUFFER_SIZE), o3 = new ArrayBuffer(n4), s6 = new Int16Array(o3);
          r3.getBufferSubData(r3.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(o3));
          const a3 = new ja();
          for (let e5 = 0; e5 < n4 / 2; e5 += 3) {
            const t4 = s6[e5], i4 = s6[e5 + 1], r4 = s6[e5 + 2];
            a3.emplaceBack(t4, i4), a3.emplaceBack(i4, r4), a3.emplaceBack(r4, t4);
          }
          const l3 = i3.bindVertexArrayOES.current, c3 = new OA();
          return c3.buf = new Fy(i3, a3), c3.lastUsedFrameIdx = e4, this._storage.set(t3.id, c3), i3.bindVertexArrayOES.set(l3), c3.buf;
        }
        update(e4) {
          for (const [t3, i3] of this._storage)
            e4 - i3.lastUsedFrameIdx > 30 && (i3.buf.destroy(), this._storage.delete(t3));
        }
        destroy() {
          for (const [e4, t3] of this._storage)
            t3.buf.destroy(), this._storage.delete(e4);
        }
      }
      const FA = { symbol: function(e4, t3, i3, r3, n4) {
        if ("translucent" !== e4.renderPass)
          return;
        const o3 = Sx.disabled, s6 = e4.colorModeForRenderPass();
        i3.layout.get("text-variable-anchor") && function(e5, t4, i4, r4, n5, o4, s7) {
          const a3 = t4.transform, l3 = "map" === n5, c3 = "map" === o4;
          for (const t5 of e5) {
            const e6 = r4.getTile(t5), n6 = e6.getBucket(i4);
            if (!n6 || !n6.text || !n6.text.segments.get().length)
              continue;
            const o5 = m_(n6.textSizeData, a3.zoom), h3 = YT(t5, n6.getProjection(), a3), u3 = a3.calculatePixelsToTileUnitsMatrix(e6), d3 = sv(h3, e6.tileID.canonical, c3, l3, a3, n6.getProjection(), u3), p3 = n6.hasIconTextFit() && n6.hasIconData();
            if (o5) {
              const i5 = Math.pow(2, a3.zoom - e6.tileID.overscaledZ);
              HM(n6, l3, c3, s7, __, a3, d3, t5, i5, o5, p3);
            }
          }
        }(r3, e4, i3, t3, i3.layout.get("text-rotation-alignment"), i3.layout.get("text-pitch-alignment"), n4), 0 !== i3.paint.get("icon-opacity").constantOr(1) && YM(e4, t3, i3, r3, false, i3.paint.get("icon-translate"), i3.paint.get("icon-translate-anchor"), i3.layout.get("icon-rotation-alignment"), i3.layout.get("icon-pitch-alignment"), i3.layout.get("icon-keep-upright"), i3.paint.get("icon-color-saturation"), o3, s6), 0 !== i3.paint.get("text-opacity").constantOr(1) && YM(e4, t3, i3, r3, true, i3.paint.get("text-translate"), i3.paint.get("text-translate-anchor"), i3.layout.get("text-rotation-alignment"), i3.layout.get("text-pitch-alignment"), i3.layout.get("text-keep-upright"), i3.paint.get("icon-color-saturation"), o3, s6), t3.map.showCollisionBoxes && (ZM(e4, t3, i3, r3, i3.paint.get("text-translate"), i3.paint.get("text-translate-anchor"), true), ZM(e4, t3, i3, r3, i3.paint.get("icon-translate"), i3.paint.get("icon-translate-anchor"), false));
      }, circle: function(e4, t3, i3, r3) {
        if ("translucent" !== e4.renderPass)
          return;
        const n4 = i3.paint.get("circle-opacity"), o3 = i3.paint.get("circle-stroke-width"), s6 = i3.paint.get("circle-stroke-opacity"), a3 = void 0 !== i3.layout.get("circle-sort-key").constantOr(1), l3 = i3.paint.get("circle-emissive-strength");
        if (0 === n4.constantOr(1) && (0 === o3.constantOr(1) || 0 === s6.constantOr(1)))
          return;
        const c3 = e4.context, h3 = c3.gl, u3 = e4.transform, d3 = e4.depthModeForSublayer(0, Mx.ReadOnly), p3 = Sx.disabled, f3 = e4.colorModeForDrapableLayerRenderPass(l3), m3 = "globe" === u3.projection.name, _3 = [Kd(u3.center.lng), Jd(u3.center.lat)], g3 = [];
        for (let n5 = 0; n5 < r3.length; n5++) {
          const o4 = r3[n5], s7 = t3.getTile(o4), l4 = s7.getBucket(i3);
          if (!l4 || l4.projection.name !== u3.projection.name)
            continue;
          const c4 = l4.programConfigurations.get(i3.id), h4 = Gp(i3), d4 = e4.isTileAffectedByFog(o4);
          m3 && h4.push("PROJECTION_GLOBE_VIEW");
          const p4 = e4.getOrCreateProgram("circle", { config: c4, defines: h4, overrideFog: d4 }), f4 = l4.layoutVertexBuffer, y4 = l4.globeExtVertexBuffer, x3 = l4.indexBuffer, v3 = u3.projection.createInversionMatrix(u3, o4.canonical), b3 = { programConfiguration: c4, program: p4, layoutVertexBuffer: f4, globeExtVertexBuffer: y4, indexBuffer: x3, uniformValues: jp(e4, o4, s7, v3, _3, i3), tile: s7 };
          if (a3) {
            const e5 = l4.segments.get();
            for (const t4 of e5)
              g3.push({ segments: new xl([t4]), sortKey: t4.sortKey, state: b3 });
          } else
            g3.push({ segments: l4.segments, sortKey: 0, state: b3 });
        }
        a3 && g3.sort((e5, t4) => e5.sortKey - t4.sortKey);
        const y3 = { useDepthForOcclusion: u3.depthOcclusionForSymbolsAndCircles };
        for (const t4 of g3) {
          const { programConfiguration: r4, program: n5, layoutVertexBuffer: o4, globeExtVertexBuffer: s7, indexBuffer: a4, uniformValues: l4, tile: m4 } = t4.state, _4 = t4.segments;
          e4.terrain && e4.terrain.setupElevationDraw(m4, n5, y3), e4.uploadCommonUniforms(c3, n5, m4.tileID.toUnwrapped()), n5.draw(e4, h3.TRIANGLES, d3, p3, f3, Dx.disabled, l4, i3.id, o4, a4, _4, i3.paint, u3.zoom, r4, [s7]);
        }
      }, heatmap: function(e4, t3, i3, r3) {
        if (0 !== i3.paint.get("heatmap-opacity"))
          if ("offscreen" === e4.renderPass) {
            const n4 = e4.context, o3 = n4.gl, s6 = Sx.disabled, a3 = new Cx([o3.ONE, o3.ONE, o3.ONE, o3.ONE], hi.transparent, [true, true, true, true]);
            !function(e5, t4, i4, r4) {
              const n5 = e5.gl, o4 = t4.width * r4, s7 = t4.height * r4;
              e5.activeTexture.set(n5.TEXTURE1), e5.viewport.set([0, 0, o4, s7]);
              let a4 = i4.heatmapFbo;
              if (!a4 || a4 && (a4.width !== o4 || a4.height !== s7)) {
                a4 && a4.destroy();
                const t5 = n5.createTexture();
                n5.bindTexture(n5.TEXTURE_2D, t5), n5.texParameteri(n5.TEXTURE_2D, n5.TEXTURE_WRAP_S, n5.CLAMP_TO_EDGE), n5.texParameteri(n5.TEXTURE_2D, n5.TEXTURE_WRAP_T, n5.CLAMP_TO_EDGE), n5.texParameteri(n5.TEXTURE_2D, n5.TEXTURE_MIN_FILTER, n5.LINEAR), n5.texParameteri(n5.TEXTURE_2D, n5.TEXTURE_MAG_FILTER, n5.LINEAR), a4 = i4.heatmapFbo = e5.createFramebuffer(o4, s7, true, null), function(e6, t6, i5, r5, n6, o5) {
                  const s8 = e6.gl;
                  s8.texImage2D(s8.TEXTURE_2D, 0, e6.extRenderToTextureHalfFloat ? s8.RGBA16F : s8.RGBA, n6, o5, 0, s8.RGBA, e6.extRenderToTextureHalfFloat ? s8.HALF_FLOAT : s8.UNSIGNED_BYTE, null), r5.colorAttachment.set(i5);
                }(e5, 0, t5, a4, o4, s7);
              } else
                n5.bindTexture(n5.TEXTURE_2D, a4.colorAttachment.get()), e5.bindFramebuffer.set(a4.framebuffer);
            }(n4, e4, i3, "globe" === e4.transform.projection.name ? 0.5 : 0.25), n4.clear({ color: hi.transparent });
            const l3 = e4.transform, c3 = "globe" === l3.projection.name, h3 = c3 ? ["PROJECTION_GLOBE_VIEW"] : [], u3 = c3 ? Dx.frontCCW : Dx.disabled, d3 = [Kd(l3.center.lng), Jd(l3.center.lat)];
            for (let p3 = 0; p3 < r3.length; p3++) {
              const f3 = r3[p3];
              if (t3.hasRenderableParent(f3))
                continue;
              const m3 = t3.getTile(f3), _3 = m3.getBucket(i3);
              if (!_3 || _3.projection.name !== l3.projection.name)
                continue;
              const g3 = e4.isTileAffectedByFog(f3), y3 = _3.programConfigurations.get(i3.id), x3 = e4.getOrCreateProgram("heatmap", { config: y3, defines: h3, overrideFog: g3 }), { zoom: v3 } = e4.transform;
              e4.terrain && e4.terrain.setupElevationDraw(m3, x3), e4.uploadCommonUniforms(n4, x3, f3.toUnwrapped());
              const b3 = l3.projection.createInversionMatrix(l3, f3.canonical);
              x3.draw(e4, o3.TRIANGLES, Mx.disabled, s6, a3, u3, IM(e4, f3, m3, b3, d3, v3, i3.paint.get("heatmap-intensity")), i3.id, _3.layoutVertexBuffer, _3.indexBuffer, _3.segments, i3.paint, e4.transform.zoom, y3, c3 ? [_3.globeExtVertexBuffer] : null);
            }
            n4.viewport.set([0, 0, e4.width, e4.height]);
          } else
            "translucent" === e4.renderPass && (e4.context.setColorMode(e4.colorModeForRenderPass()), function(e5, t4) {
              const i4 = e5.context, r4 = i4.gl, n4 = t4.heatmapFbo;
              if (!n4)
                return;
              i4.activeTexture.set(r4.TEXTURE0), r4.bindTexture(r4.TEXTURE_2D, n4.colorAttachment.get()), i4.activeTexture.set(r4.TEXTURE1);
              let o3 = t4.colorRampTexture;
              o3 || (o3 = t4.colorRampTexture = new My(i4, t4.colorRamp, r4.RGBA)), o3.bind(r4.LINEAR, r4.CLAMP_TO_EDGE), e5.getOrCreateProgram("heatmapTexture").draw(e5, r4.TRIANGLES, Mx.disabled, Sx.disabled, e5.colorModeForRenderPass(), Dx.disabled, ((e6, t5, i5, r5) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t5.paint.get("heatmap-opacity") }))(0, t4), t4.id, e5.viewportBuffer, e5.quadTriangleIndexBuffer, e5.viewportSegments, t4.paint, e5.transform.zoom);
            }(e4, i3));
      }, line: function(e4, t3, i3, r3) {
        if ("translucent" !== e4.renderPass)
          return;
        const n4 = i3.paint.get("line-opacity"), o3 = i3.paint.get("line-width");
        if (0 === n4.constantOr(1) || 0 === o3.constantOr(1))
          return;
        const s6 = i3.paint.get("line-emissive-strength"), a3 = e4.depthModeForSublayer(0, Mx.ReadOnly), l3 = e4.colorModeForDrapableLayerRenderPass(s6), c3 = e4.terrain && e4.terrain.renderingToTexture ? 1 : dt.devicePixelRatio, h3 = i3.paint.get("line-dasharray"), u3 = h3.constantOr(1), d3 = i3.layout.get("line-cap"), p3 = i3.paint.get("line-pattern"), f3 = p3.constantOr(1), m3 = i3.paint.get("line-pattern").constantOr(1), _3 = 1 !== i3.paint.get("line-opacity").constantOr(1);
        let g3 = !m3 && _3;
        const y3 = i3.paint.get("line-gradient"), x3 = f3 ? "linePattern" : "line", v3 = e4.context, b3 = v3.gl, w3 = Gb(i3);
        e4.terrain && e4.terrain.clipOrMaskOverlapStencilType() && (g3 = false);
        for (const n5 of r3) {
          const r4 = t3.getTile(n5);
          if (f3 && !r4.patternsLoaded())
            continue;
          const o4 = r4.getBucket(i3);
          if (!o4)
            continue;
          e4.prepareDrawTile();
          const s7 = o4.programConfigurations.get(i3.id), m4 = e4.isTileAffectedByFog(n5), _4 = e4.getOrCreateProgram(x3, { config: s7, defines: w3, overrideFog: m4 }), T3 = p3.constantOr(null);
          if (T3 && r4.imageAtlas) {
            const e5 = r4.imageAtlas.patternPositions[T3.toString()];
            e5 && s7.setConstantPatternPositions(e5);
          }
          const E3 = h3.constantOr(null), M3 = d3.constantOr(null);
          if (!f3 && E3 && M3 && r4.lineAtlas) {
            const e5 = r4.lineAtlas.getDash(E3, M3);
            e5 && s7.setConstantPatternPositions(e5);
          }
          let [A3, S3] = i3.paint.get("line-trim-offset");
          if ("round" === M3 || "square" === M3) {
            const e5 = 1;
            A3 !== S3 && (0 === A3 && (A3 -= e5), 1 === S3 && (S3 += e5));
          }
          const I3 = e4.terrain ? n5.projMatrix : null, C3 = f3 ? Ub(e4, r4, i3, I3, c3) : Nb(e4, r4, i3, I3, o4.lineClipsArray.length, c3, [A3, S3]);
          if (y3) {
            const r5 = o4.gradients[i3.id];
            let s8 = r5.texture;
            if (i3.gradientVersion !== r5.version) {
              let a4 = 256;
              if (i3.stepInterpolant) {
                const i4 = t3.getSource().maxzoom, r6 = n5.canonical.z === i4 ? Math.ceil(1 << e4.transform.maxZoom - n5.canonical.z) : 1;
                a4 = z(U(o4.maxLineLength / cr * 1024 * r6), 256, v3.maxTextureSize);
              }
              r5.gradient = of({ expression: i3.gradientExpression(), evaluationKey: "lineProgress", resolution: a4, image: r5.gradient || void 0, clips: o4.lineClipsArray }), r5.texture ? r5.texture.update(r5.gradient) : r5.texture = new My(v3, r5.gradient, b3.RGBA), r5.version = i3.gradientVersion, s8 = r5.texture;
            }
            v3.activeTexture.set(b3.TEXTURE1), s8.bind(i3.stepInterpolant ? b3.NEAREST : b3.LINEAR, b3.CLAMP_TO_EDGE);
          }
          u3 && (v3.activeTexture.set(b3.TEXTURE0), r4.lineAtlasTexture && r4.lineAtlasTexture.bind(b3.LINEAR, b3.REPEAT), s7.updatePaintBuffers()), f3 && (v3.activeTexture.set(b3.TEXTURE0), r4.imageAtlasTexture && r4.imageAtlasTexture.bind(b3.LINEAR, b3.CLAMP_TO_EDGE), s7.updatePaintBuffers()), e4.uploadCommonUniforms(v3, _4, n5.toUnwrapped());
          const P3 = (t4) => {
            _4.draw(e4, b3.TRIANGLES, a3, t4, l3, Dx.disabled, C3, i3.id, o4.layoutVertexBuffer, o4.indexBuffer, o4.segments, i3.paint, e4.transform.zoom, s7, [o4.layoutVertexBuffer2]);
          };
          if (g3) {
            const t4 = e4.stencilModeForClipping(n5).ref;
            0 === t4 && e4.terrain && v3.clear({ stencil: 0 });
            const i4 = { func: b3.EQUAL, mask: 255 };
            C3.u_alpha_discard_threshold = 0.8, P3(new Sx(i4, t4, 255, b3.KEEP, b3.KEEP, b3.INVERT)), C3.u_alpha_discard_threshold = 0, P3(new Sx(i4, t4, 255, b3.KEEP, b3.KEEP, b3.KEEP));
          } else
            P3(e4.stencilModeForClipping(n5));
        }
        g3 && (e4.resetStencilClippingMasks(), e4.terrain && v3.clear({ stencil: 0 }));
      }, fill: function(e4, t3, i3, r3) {
        const n4 = i3.paint.get("fill-color"), o3 = i3.paint.get("fill-opacity");
        if (0 === o3.constantOr(1))
          return;
        const s6 = i3.paint.get("fill-emissive-strength"), a3 = e4.colorModeForDrapableLayerRenderPass(s6), l3 = i3.paint.get("fill-pattern"), c3 = e4.opaquePassEnabledForLayer() && !l3.constantOr(1) && 1 === n4.constantOr(hi.transparent).a && 1 === o3.constantOr(0) ? "opaque" : "translucent";
        if (e4.renderPass === c3) {
          const n5 = e4.depthModeForSublayer(1, "opaque" === e4.renderPass ? Mx.ReadWrite : Mx.ReadOnly);
          JM(e4, t3, i3, r3, n5, a3, false);
        }
        if ("translucent" === e4.renderPass && i3.paint.get("fill-antialias")) {
          const n5 = e4.depthModeForSublayer(i3.getPaintProperty("fill-outline-color") ? 2 : 0, Mx.ReadOnly);
          JM(e4, t3, i3, r3, n5, a3, true);
        }
      }, "fill-extrusion": function(e4, t3, i3, r3) {
        const n4 = i3.paint.get("fill-extrusion-opacity"), o3 = e4.context, s6 = o3.gl, a3 = e4.terrain, l3 = a3 && a3.renderingToTexture, c3 = i3.paint.get("fill-extrusion-cutoff-fade-range");
        if (0 === n4)
          return;
        const h3 = e4.conflationActive && e4.layerUsedInConflation(i3, t3.getSource());
        if (h3 && function(e5, t4, i4, r4) {
          for (const n5 of r4) {
            const r5 = t4.getTile(n5).getBucket(i4);
            r5 && (r5.updateReplacement(n5, e5.replacementSource), r5.uploadCentroid(e5.context));
          }
        }(e4, t3, i3, r3), a3 || h3)
          for (const n5 of r3) {
            const r4 = t3.getTile(n5).getBucket(i3);
            r4 && tA(e4.context, t3, n5, r4, i3, a3, h3);
          }
        if ("shadow" === e4.renderPass && e4.shadowRenderer) {
          const o4 = e4.shadowRenderer;
          if (a3 && n4 < 0.65 && i3._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof Ao)
            return;
          const s7 = o4.getShadowPassDepthMode(), l4 = o4.getShadowPassColorMode();
          QM(e4, t3, i3, r3, s7, Sx.disabled, l4, h3);
        } else if ("translucent" === e4.renderPass) {
          const u3 = !i3.paint.get("fill-extrusion-pattern").constantOr(1);
          if (!l3) {
            const o4 = new Mx(e4.context.gl.LEQUAL, Mx.ReadWrite, e4.depthRangeFor3D);
            0 === c3 && 1 === n4 && u3 ? QM(e4, t3, i3, r3, o4, Sx.disabled, Cx.unblended, h3) : (QM(e4, t3, i3, r3, o4, Sx.disabled, Cx.disabled, h3), QM(e4, t3, i3, r3, o4, e4.stencilModeFor3D(), e4.colorModeForRenderPass(), h3), e4.resetStencilClippingMasks());
          }
          if (e4.style.enable3dLights() && u3 && (!a3 && "globe" !== e4.transform.projection.name || l3)) {
            const n5 = i3.paint.get("fill-extrusion-opacity"), c4 = i3.paint.get("fill-extrusion-ambient-occlusion-intensity"), u4 = i3.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), d3 = i3.paint.get("fill-extrusion-flood-light-intensity"), p3 = i3.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0, 3), f3 = c4 > 0 && u4 > 0, m3 = d3 > 0, _3 = (e5, t4, i4) => (1 - i4) * e5 + i4 * t4, g3 = (o4) => {
              const a4 = e4.depthModeForSublayer(1, Mx.ReadOnly, s6.LEQUAL, true), l4 = i3.paint.get(o4 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), f4 = _3(0.1, 3, l4), m4 = e4._showOverdrawInspector;
              if (!m4) {
                const l5 = new Sx({ func: s6.ALWAYS, mask: 255 }, 255, 255, s6.KEEP, s6.KEEP, s6.REPLACE), m5 = new Cx([s6.ONE, s6.ONE, s6.ONE, s6.ONE], hi.transparent, [false, false, false, true], s6.MIN);
                eA(e4, t3, i3, r3, a4, l5, m5, Dx.disabled, o4, "sdf", n5, c4, u4, d3, p3, f4, h3, false);
              }
              {
                const l5 = m4 ? Sx.disabled : new Sx({ func: s6.EQUAL, mask: 255 }, 255, 255, s6.KEEP, s6.DECR, s6.DECR), _4 = m4 ? e4.colorModeForRenderPass() : new Cx([s6.ONE_MINUS_DST_ALPHA, s6.DST_ALPHA, s6.ONE, s6.ONE], hi.transparent, [true, true, true, true]);
                eA(e4, t3, i3, r3, a4, l5, _4, Dx.disabled, o4, "color", n5, c4, u4, d3, p3, f4, h3, false);
              }
            };
            if (l3) {
              const l4 = (o4, a4, l5) => {
                const f4 = e4.depthModeForSublayer(1, Mx.ReadOnly, s6.LEQUAL, false), m4 = i3.paint.get(o4 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), g4 = _3(0.1, 3, m4);
                {
                  const l6 = new Cx([s6.ONE, s6.ONE, s6.ONE, s6.ONE], hi.transparent, [false, false, false, true]);
                  eA(e4, t3, i3, r3, f4, Sx.disabled, l6, Dx.disabled, o4, "clear", n5, c4, u4, d3, p3, g4, h3, a4);
                }
                {
                  const l6 = new Sx({ func: s6.ALWAYS, mask: 255 }, 255, 255, s6.KEEP, s6.KEEP, s6.REPLACE), m5 = new Cx([s6.ONE, s6.ONE, s6.ONE, s6.ONE], hi.transparent, [false, false, false, true], s6.MIN);
                  eA(e4, t3, i3, r3, f4, l6, m5, Dx.disabled, o4, "sdf", n5, c4, u4, d3, p3, g4, h3, a4);
                }
                {
                  const l6 = o4 ? s6.ZERO : s6.ONE_MINUS_DST_ALPHA, m5 = new Sx({ func: s6.EQUAL, mask: 255 }, 255, 255, s6.KEEP, s6.DECR, s6.DECR), _4 = new Cx([l6, s6.DST_ALPHA, s6.ONE_MINUS_DST_ALPHA, s6.ZERO], hi.transparent, [true, true, true, true]);
                  eA(e4, t3, i3, r3, f4, m5, _4, Dx.disabled, o4, "color", n5, c4, u4, d3, p3, g4, h3, a4);
                }
                {
                  const m5 = new Cx([s6.ONE, s6.ONE, s6.ONE, o4 ? s6.ZERO : s6.ONE], hi.transparent, [false, false, false, true], o4 ? s6.FUNC_ADD : s6.MAX);
                  eA(e4, t3, i3, r3, f4, Sx.disabled, m5, Dx.disabled, o4, "clear", n5, c4, u4, d3, p3, g4, h3, a4, l5);
                }
              };
              if (f3 || m3) {
                let t4;
                if (e4.prepareDrawTile(), a3) {
                  const e5 = a3.drapeBufferSize[0], i4 = a3.drapeBufferSize[1];
                  t4 = a3.framebufferCopyTexture, t4 && (!t4 || t4.size[0] === e5 && t4.size[1] === i4) || (t4 && t4.destroy(), t4 = a3.framebufferCopyTexture = new My(o3, new ef({ width: e5, height: i4 }), s6.RGBA)), t4.bind(s6.LINEAR, s6.CLAMP_TO_EDGE), s6.copyTexImage2D(s6.TEXTURE_2D, 0, s6.RGBA, 0, 0, e5, i4, 0);
                }
                f3 && l4(true, false, t4), m3 && l4(false, true, t4);
              }
            } else
              f3 && g3(true), m3 && g3(false);
          }
        }
      }, hillshade: function(e4, t3, i3, r3) {
        if ("offscreen" !== e4.renderPass && "translucent" !== e4.renderPass)
          return;
        if (e4.style.disableElevatedTerrain)
          return;
        const n4 = e4.context, o3 = e4.terrain && e4.terrain.renderingToTexture, [s6, a3] = "translucent" !== e4.renderPass || o3 ? [{}, r3] : e4.stencilConfigForOverlap(r3);
        for (const r4 of a3) {
          const n5 = t3.getTile(r4);
          if (n5.needsHillshadePrepare && "offscreen" === e4.renderPass)
            YE(e4, n5, i3);
          else if ("translucent" === e4.renderPass) {
            const t4 = e4.depthModeForSublayer(0, Mx.ReadOnly), a4 = i3.paint.get("hillshade-emissive-strength"), l3 = e4.colorModeForDrapableLayerRenderPass(a4), c3 = o3 && e4.terrain ? e4.terrain.stencilModeForRTTOverlap(r4) : s6[r4.overscaledZ];
            HE(e4, r4, n5, i3, t4, c3, l3);
          }
        }
        n4.viewport.set([0, 0, e4.width, e4.height]), e4.resetStencilClippingMasks();
      }, raster: function(e4, t3, i3, r3, n4, o3) {
        if ("translucent" !== e4.renderPass)
          return;
        if (0 === i3.paint.get("raster-opacity"))
          return;
        const s6 = e4.context, a3 = s6.gl, l3 = t3.getSource(), c3 = function(e5, t4, i4) {
          const r4 = e5.paint.get("raster-color"), n5 = [], o4 = e5.paint.get("raster-resampling"), s7 = e5.paint.get("raster-color-mix"), a4 = e5.paint.get("raster-color-range"), l4 = [s7[0], s7[1], s7[2], 0], c4 = s7[3], h4 = "nearest" === o4 ? i4.NEAREST : i4.LINEAR;
          if (r4 && n5.push("RASTER_COLOR"), r4) {
            t4.activeTexture.set(i4.TEXTURE2);
            let r5 = e5.colorRampTexture;
            r5 || (r5 = e5.colorRampTexture = new My(t4, e5.colorRamp, i4.RGBA)), r5.bind(i4.LINEAR, i4.CLAMP_TO_EDGE);
          }
          return { mix: l4, range: a4, offset: c4, defines: n5, resampling: h4 };
        }(i3, s6, a3), h3 = c3.defines, u3 = "globe" === e4.transform.projection.name;
        let d3 = false;
        if (l3 instanceof Jb && !r3.length) {
          if (!u3)
            return;
          if (l3.onNorthPole)
            d3 = true, h3.push("GLOBE_POLES");
          else {
            if (!l3.onSouthPole)
              return;
            d3 = true, h3.push("GLOBE_POLES");
          }
        }
        const p3 = i3.paint.get("raster-emissive-strength"), f3 = e4.colorModeForDrapableLayerRenderPass(p3), m3 = e4.terrain && e4.terrain.renderingToTexture, _3 = l3 instanceof Jb && 0 !== i3.paint.get("raster-elevation"), g3 = !e4.options.moving, y3 = "nearest" === i3.paint.get("raster-resampling") ? a3.NEAREST : a3.LINEAR;
        if (d3) {
          const r4 = t3.getSource();
          if (!(r4 instanceof Jb))
            return;
          const n5 = r4.texture;
          if (!n5)
            return;
          const o4 = e4.globeSharedBuffers;
          if (!o4)
            return;
          const l4 = new Mx(a3.LEQUAL, Mx.ReadWrite, e4.depthRangeFor3D), h4 = Float32Array.from(e4.transform.expandedFarZProjMatrix);
          let u4 = Rd(0, 0, e4.transform);
          const d4 = Float32Array.from(Ad(fd(new ju(0, 0, 0)))), m4 = { opacity: 1, mix: 0 };
          e4.terrain && e4.terrain.prepareDrawTile(), s6.activeTexture.set(a3.TEXTURE0), n5.bind(y3, a3.CLAMP_TO_EDGE), s6.activeTexture.set(a3.TEXTURE1), n5.bind(y3, a3.CLAMP_TO_EDGE), n5.useMipmap && s6.extTextureFilterAnisotropic && e4.transform.pitch > 20 && a3.texParameterf(a3.TEXTURE_2D, s6.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s6.extTextureFilterAnisotropicMax);
          const [_4, g4, x4, v4] = o4.getPoleBuffers(0, true);
          let b4;
          r4.onNorthPole ? (b4 = _4, e4.renderDefaultNorthPole = false) : (u4 = Au.scale(Au.create(), u4, [1, -1, 1]), b4 = g4, e4.renderDefaultSouthPole = false);
          const w4 = ((e5, t4, i4, r5, n6, o5, s7, a4, l5, c4, h5, u5) => CM(e5, t4, i4, new Float32Array(16), new Float32Array(9), [0, 0], [0, 0, 0, 0], 0, [0, 0], [0, 0, 0, 0], 1, r5, n6, o5 || [0, 0], s7, 2, l5, c4, h5, 1, 0, u5))(h4, d4, u4, m4, i3, r4.perspectiveTransform || [0, 0], i3.paint.get("raster-elevation"), 0, c3.mix, c3.offset, c3.range, p3), T3 = e4.getOrCreateProgram("raster", { defines: c3.defines });
          return e4.uploadCommonUniforms(s6, T3, null), void T3.draw(e4, a3.TRIANGLES, l4, Sx.disabled, f3, Dx.disabled, w4, i3.id, b4, x4, v4);
        }
        if (!r3.length)
          return;
        const [x3, v3] = l3 instanceof Jb || m3 ? [{}, r3] : e4.stencilConfigForOverlap(r3), b3 = v3[v3.length - 1].overscaledZ, w3 = _3 && u3;
        w3 && c3.defines.push("PROJECTION_GLOBE_VIEW"), _3 && c3.defines.push("RENDER_CUTOFF");
        for (const r4 of v3) {
          const n5 = r4.toUnwrapped(), h4 = t3.getTile(r4);
          if (m3 && (!h4 || !h4.hasData()))
            continue;
          if (!h4.texture)
            continue;
          let d4, v4;
          m3 ? (d4 = Mx.disabled, v4 = r4.projMatrix) : _3 ? (d4 = new Mx(a3.LEQUAL, Mx.ReadWrite, e4.depthRangeFor3D), v4 = u3 ? Float32Array.from(e4.transform.expandedFarZProjMatrix) : e4.transform.calculateProjMatrix(n5, g3)) : (d4 = e4.depthModeForSublayer(r4.overscaledZ - b3, 1 === i3.paint.get("raster-opacity") ? Mx.ReadWrite : Mx.ReadOnly, a3.LESS), v4 = e4.transform.calculateProjMatrix(n5, g3));
          const T3 = e4.terrain && m3 ? e4.terrain.stencilModeForRTTOverlap(r4) : x3[r4.overscaledZ], E3 = o3 ? 0 : i3.paint.get("raster-fade-duration");
          h4.registerFadeDuration(E3);
          const M3 = t3.findLoadedParent(r4, 0), A3 = aM(h4, M3, t3, e4.transform, E3);
          let S3, I3;
          e4.terrain && e4.terrain.prepareDrawTile(), s6.activeTexture.set(a3.TEXTURE0), h4.texture && h4.texture.bind(y3, a3.CLAMP_TO_EDGE), s6.activeTexture.set(a3.TEXTURE1), M3 ? (M3.texture && M3.texture.bind(y3, a3.CLAMP_TO_EDGE), S3 = Math.pow(2, M3.tileID.overscaledZ - h4.tileID.overscaledZ), I3 = [h4.tileID.canonical.x * S3 % 1, h4.tileID.canonical.y * S3 % 1]) : h4.texture && h4.texture.bind(y3, a3.CLAMP_TO_EDGE), h4.texture && h4.texture.useMipmap && s6.extTextureFilterAnisotropic && e4.transform.pitch > 20 && a3.texParameterf(a3.TEXTURE_2D, s6.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s6.extTextureFilterAnisotropicMax);
          const C3 = e4.transform, z2 = l3 instanceof Jb ? l3.perspectiveTransform : [0, 0], P3 = _3 ? sA(C3) : [0, 0, 0, 0];
          let D2, R3, L3, k3, O2, B2;
          if (w3 && l3 instanceof Jb && l3.coordinates.length > 3) {
            D2 = Float32Array.from(Ad(fd(new ju(0, 0, 0)))), R3 = Float32Array.from(C3.globeMatrix), L3 = Float32Array.from(Pd(C3)), k3 = [Kd(C3.center.lng), Jd(C3.center.lat)], B2 = [Kd(l3.coordinates[1][0]), Jd(l3.coordinates[1][1]), Kd(l3.coordinates[3][0]), Jd(l3.coordinates[3][1])];
            const t4 = new sc(l3.coordinates[1], l3.coordinates[3]);
            O2 = Float32Array.from(kd(new ju(0, 0, 0), t4, 0, C3.worldSize / e4.transform._pixelsPerMercatorPixel));
          } else
            D2 = new Float32Array(16), R3 = new Float32Array(9), L3 = new Float32Array(16), k3 = [0, 0], O2 = new Float32Array(16), B2 = [0, 0, 0, 0];
          const F2 = CM(v4, D2, R3, L3, O2, I3 || [0, 0], B2, Dd(e4.transform.zoom), k3, P3, S3 || 1, A3, i3, z2, _3 ? i3.paint.get("raster-elevation") : 0, 2, c3.mix, c3.offset, c3.range, 1, 0, p3), N3 = e4.isTileAffectedByFog(r4), U2 = e4.getOrCreateProgram("raster", { defines: c3.defines, overrideFog: N3 });
          if (e4.uploadCommonUniforms(s6, U2, n5), l3 instanceof Jb) {
            if (m3 || !u3)
              l3.boundsBuffer && l3.boundsSegments && U2.draw(e4, a3.TRIANGLES, d4, Sx.disabled, f3, Dx.disabled, F2, i3.id, l3.boundsBuffer, e4.quadTriangleIndexBuffer, l3.boundsSegments);
            else if (e4.globeSharedBuffers) {
              const [t4, r5, n6] = e4.globeSharedBuffers.getGridBuffers(0, false);
              U2.draw(e4, a3.TRIANGLES, d4, Sx.disabled, f3, Dx.frontCCW, F2, i3.id, t4, r5, n6), U2.draw(e4, a3.TRIANGLES, d4, Sx.disabled, f3, Dx.backCCW, F2, i3.id, t4, r5, n6);
            }
          } else {
            const { tileBoundsBuffer: t4, tileBoundsIndexBuffer: r5, tileBoundsSegments: n6 } = e4.getTileBoundsBuffers(h4);
            U2.draw(e4, a3.TRIANGLES, d4, T3, f3, Dx.disabled, F2, i3.id, t4, r5, n6);
          }
        }
        e4.resetStencilClippingMasks();
      }, background: function(e4, t3, i3, r3) {
        const n4 = i3.paint.get("background-color"), o3 = i3.paint.get("background-opacity"), s6 = i3.paint.get("background-emissive-strength");
        if (0 === o3)
          return;
        const a3 = e4.context, l3 = a3.gl, c3 = e4.transform, h3 = c3.tileSize, u3 = i3.paint.get("background-pattern");
        if (e4.isPatternMissing(u3, i3.scope))
          return;
        const d3 = !u3 && 1 === n4.a && 1 === o3 && e4.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (e4.renderPass !== d3)
          return;
        const p3 = Sx.disabled, f3 = e4.depthModeForSublayer(0, "opaque" === d3 ? Mx.ReadWrite : Mx.ReadOnly), m3 = e4.colorModeForDrapableLayerRenderPass(s6), _3 = u3 ? "backgroundPattern" : "background";
        let g3, y3 = r3;
        y3 || (g3 = e4.getBackgroundTiles(), y3 = Object.values(g3).map((e5) => e5.tileID)), u3 && (a3.activeTexture.set(l3.TEXTURE0), e4.imageManager.bind(e4.context, i3.scope));
        for (const d4 of y3) {
          const y4 = e4.isTileAffectedByFog(d4), x3 = e4.getOrCreateProgram(_3, { overrideFog: y4 }), v3 = d4.toUnwrapped(), b3 = r3 ? d4.projMatrix : e4.transform.calculateProjMatrix(v3);
          e4.prepareDrawTile();
          const w3 = t3 ? t3.getTile(d4) : g3 ? g3[d4.key] : new Oy(d4, h3, c3.zoom, e4), T3 = u3 ? FM(b3, s6, o3, e4, u3, i3.scope, { tileID: d4, tileSize: h3 }) : BM(b3, s6, o3, n4);
          e4.uploadCommonUniforms(a3, x3, v3);
          const { tileBoundsBuffer: E3, tileBoundsIndexBuffer: M3, tileBoundsSegments: A3 } = e4.getTileBoundsBuffers(w3);
          x3.draw(e4, l3.TRIANGLES, f3, p3, m3, Dx.disabled, T3, i3.id, E3, M3, A3);
        }
      }, sky: function(e4, t3, i3) {
        const r3 = e4._atmosphere ? Dd(e4.transform.zoom) : 1, n4 = i3.paint.get("sky-opacity") * r3;
        if (0 === n4)
          return;
        const o3 = e4.context, s6 = i3.paint.get("sky-type"), a3 = new Mx(o3.gl.LEQUAL, Mx.ReadOnly, [0, 1]), l3 = e4.frameCounter / 1e3 % 1;
        "atmosphere" === s6 ? "offscreen" === e4.renderPass ? i3.needsSkyboxCapture(e4) && (function(e5, t4, i4, r4) {
          const n5 = e5.context, o4 = n5.gl;
          let s7 = t4.skyboxFbo;
          if (!s7) {
            s7 = t4.skyboxFbo = n5.createFramebuffer(32, 32, true, null), t4.skyboxGeometry = new xA(n5), t4.skyboxTexture = n5.gl.createTexture(), o4.bindTexture(o4.TEXTURE_CUBE_MAP, t4.skyboxTexture), o4.texParameteri(o4.TEXTURE_CUBE_MAP, o4.TEXTURE_WRAP_S, o4.CLAMP_TO_EDGE), o4.texParameteri(o4.TEXTURE_CUBE_MAP, o4.TEXTURE_WRAP_T, o4.CLAMP_TO_EDGE), o4.texParameteri(o4.TEXTURE_CUBE_MAP, o4.TEXTURE_MIN_FILTER, o4.LINEAR), o4.texParameteri(o4.TEXTURE_CUBE_MAP, o4.TEXTURE_MAG_FILTER, o4.LINEAR);
            for (let e6 = 0; e6 < 6; ++e6)
              o4.texImage2D(o4.TEXTURE_CUBE_MAP_POSITIVE_X + e6, 0, o4.RGBA, 32, 32, 0, o4.RGBA, o4.UNSIGNED_BYTE, null);
          }
          n5.bindFramebuffer.set(s7.framebuffer), n5.viewport.set([0, 0, 32, 32]);
          const a4 = t4.getCenter(e5, true), l4 = e5.getOrCreateProgram("skyboxCapture"), c3 = new Float64Array(16);
          Au.identity(c3), Au.rotateY(c3, c3, 0.5 * -Math.PI), vA(e5, t4, l4, c3, a4, 0), Au.identity(c3), Au.rotateY(c3, c3, 0.5 * Math.PI), vA(e5, t4, l4, c3, a4, 1), Au.identity(c3), Au.rotateX(c3, c3, 0.5 * -Math.PI), vA(e5, t4, l4, c3, a4, 2), Au.identity(c3), Au.rotateX(c3, c3, 0.5 * Math.PI), vA(e5, t4, l4, c3, a4, 3), Au.identity(c3), vA(e5, t4, l4, c3, a4, 4), Au.identity(c3), Au.rotateY(c3, c3, Math.PI), vA(e5, t4, l4, c3, a4, 5), n5.viewport.set([0, 0, e5.width, e5.height]);
        }(e4, i3), i3.markSkyboxValid(e4)) : "sky" === e4.renderPass && function(e5, t4, i4, r4, n5) {
          const o4 = e5.context, s7 = o4.gl, a4 = e5.transform, l4 = e5.getOrCreateProgram("skybox");
          o4.activeTexture.set(s7.TEXTURE0), s7.bindTexture(s7.TEXTURE_CUBE_MAP, t4.skyboxTexture);
          const c3 = ((e6, t5, i5, r5, n6) => ({ u_matrix: e6, u_sun_direction: t5, u_cubemap: 0, u_opacity: r5, u_temporal_offset: n6 }))(a4.skyboxMatrix, t4.getCenter(e5, false), 0, r4, n5);
          e5.uploadCommonUniforms(o4, l4), l4.draw(e5, s7.TRIANGLES, i4, Sx.disabled, e5.colorModeForRenderPass(), Dx.backCW, c3, "skybox", t4.skyboxGeometry.vertexBuffer, t4.skyboxGeometry.indexBuffer, t4.skyboxGeometry.segment);
        }(e4, i3, a3, n4, l3) : "gradient" === s6 && "sky" === e4.renderPass && function(e5, t4, i4, r4, n5) {
          const o4 = e5.context, s7 = o4.gl, a4 = e5.transform, l4 = e5.getOrCreateProgram("skyboxGradient");
          t4.skyboxGeometry || (t4.skyboxGeometry = new xA(o4)), o4.activeTexture.set(s7.TEXTURE0);
          let c3 = t4.colorRampTexture;
          c3 || (c3 = t4.colorRampTexture = new My(o4, t4.colorRamp, s7.RGBA)), c3.bind(s7.LINEAR, s7.CLAMP_TO_EDGE);
          const h3 = ((e6, t5, i5, r5, n6) => ({ u_matrix: e6, u_color_ramp: 0, u_center_direction: t5, u_radius: w2(i5), u_opacity: r5, u_temporal_offset: n6 }))(a4.skyboxMatrix, t4.getCenter(e5, false), t4.paint.get("sky-gradient-radius"), r4, n5);
          e5.uploadCommonUniforms(o4, l4), l4.draw(e5, s7.TRIANGLES, i4, Sx.disabled, e5.colorModeForRenderPass(), Dx.backCW, h3, "skyboxGradient", t4.skyboxGeometry.vertexBuffer, t4.skyboxGeometry.indexBuffer, t4.skyboxGeometry.segment);
        }(e4, i3, a3, n4, l3);
      }, debug: function(e4, t3, i3) {
        for (let r3 = 0; r3 < i3.length; r3++)
          dA(e4, t3, i3[r3]);
      }, custom: function(e4, t3, i3, r3) {
        const n4 = e4.context, o3 = i3.implementation;
        if (!e4.transform.projection.unsupportedLayers || !e4.transform.projection.unsupportedLayers.includes("custom") || e4.terrain && (e4.terrain.renderingToTexture || "offscreen" === e4.renderPass) && i3.isLayerDraped(t3)) {
          if ("offscreen" === e4.renderPass) {
            const t4 = o3.prerender;
            if (t4) {
              if (e4.setCustomLayerDefaults(), n4.setColorMode(e4.colorModeForRenderPass()), "globe" === e4.transform.projection.name) {
                const i4 = e4.transform.pointMerc;
                t4.call(o3, n4.gl, e4.transform.customLayerMatrix(), e4.transform.getProjection(), e4.transform.globeToMercatorMatrix(), Dd(e4.transform.zoom), [i4.x, i4.y], e4.transform.pixelsPerMeterRatio);
              } else
                t4.call(o3, n4.gl, e4.transform.customLayerMatrix());
              n4.setDirty(), e4.setBaseState();
            }
          } else if ("translucent" === e4.renderPass) {
            if (e4.terrain && e4.terrain.renderingToTexture) {
              const t5 = o3.renderToTile;
              if (t5) {
                const i4 = r3[0].canonical, s6 = new lp(i4.x + r3[0].wrap * (1 << i4.z), i4.y, i4.z);
                n4.setDepthMode(Mx.disabled), n4.setStencilMode(Sx.disabled), n4.setColorMode(e4.colorModeForRenderPass()), e4.setCustomLayerDefaults(), t5.call(o3, n4.gl, s6), n4.setDirty(), e4.setBaseState();
              }
              return;
            }
            e4.setCustomLayerDefaults(), n4.setColorMode(e4.colorModeForRenderPass()), n4.setStencilMode(Sx.disabled);
            const t4 = "3d" === o3.renderingMode ? new Mx(e4.context.gl.LEQUAL, Mx.ReadWrite, e4.depthRangeFor3D) : e4.depthModeForSublayer(0, Mx.ReadOnly);
            if (n4.setDepthMode(t4), "globe" === e4.transform.projection.name) {
              const t5 = e4.transform.pointMerc;
              o3.render(n4.gl, e4.transform.customLayerMatrix(), e4.transform.getProjection(), e4.transform.globeToMercatorMatrix(), Dd(e4.transform.zoom), [t5.x, t5.y], e4.transform.pixelsPerMeterRatio);
            } else
              o3.render(n4.gl, e4.transform.customLayerMatrix());
            n4.setDirty(), e4.setBaseState(), n4.bindFramebuffer.set(null);
          }
        } else
          H2("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      }, model: function(e4, t3, i3, r3) {
        if ("opaque" === e4.renderPass)
          return;
        const n4 = i3.paint.get("model-opacity");
        if (0 === n4)
          return;
        const o3 = i3.paint.get("model-cast-shadows");
        if ("shadow" === e4.renderPass) {
          if (!o3)
            return;
          if (e4.terrain && n4 < 0.65 && i3._transitionablePaint._values["model-opacity"].value.expression instanceof Ao)
            return;
        }
        const s6 = e4.shadowRenderer, a3 = i3.paint.get("model-receive-shadows");
        s6 && (s6.useNormalOffset = true, a3 || (s6.enabled = false));
        const l3 = () => {
          s6 && (s6.useNormalOffset = true, a3 || (s6.enabled = true));
        }, c3 = t3.getSource();
        if ("light-beam" === e4.renderPass && "batched-model" !== c3.type)
          return;
        if ("vector" === c3.type || "geojson" === c3.type)
          return function(e5, t4, i4, r4) {
            const n5 = e5.transform;
            if ("mercator" !== n5.projection.name)
              return void H2(`Drawing 3D models for ${n5.projection.name} projection is not yet implemented`);
            const o4 = n5.getFreeCameraOptions().position;
            if (!e5.modelManager)
              return;
            const s7 = e5.modelManager, a4 = e5.shadowRenderer;
            if (!i4._unevaluatedLayout._values.hasOwnProperty("model-id"))
              return;
            const l4 = i4._unevaluatedLayout._values["model-id"], c4 = { ...i4.layout.get("model-id").parameters };
            for (const h4 of r4) {
              const r5 = t4.getTile(h4).getBucket(i4);
              if (!r5 || r5.projection.name !== n5.projection.name)
                continue;
              const u4 = DA(h4, n5);
              c4.zoom = u4;
              const d4 = l4.possiblyEvaluate(c4);
              if (zA(e5, r5, h4), PA.shadowUniformsInitialized = false, PA.useSingleShadowCascade = !!a4 && 0 === a4.getMaxCascadeForTile(h4.toUnwrapped()), "shadow" === e5.renderPass && a4) {
                if (1 === e5.currentShadowCascade && r5.isInsideFirstShadowMapFrustum)
                  continue;
                const t5 = n5.calculatePosMatrix(h4.toUnwrapped(), n5.worldSize);
                if (PA.tileMatrix.set(t5), PA.shadowTileMatrix = Float32Array.from(a4.calculateShadowPassMatrixFromMatrix(t5)), PA.aabb.min.fill(0), PA.aabb.max[0] = PA.aabb.max[1] = cr, PA.aabb.max[2] = 0, kA(r5, PA, e5, i4.scope))
                  continue;
              }
              const p4 = 1 << h4.canonical.z, f4 = [((o4.x - h4.wrap) * p4 - h4.canonical.x) * cr, (o4.y * p4 - h4.canonical.y) * cr, o4.z * p4 * cr];
              for (let t5 in r5.instancesPerModel) {
                const n6 = r5.instancesPerModel[t5];
                n6.features.length > 0 && (t5 = d4.evaluate(n6.features[0].feature, {}));
                const o5 = s7.getModel(t5, i4.scope);
                if (o5 && o5.uploaded)
                  for (const t6 of o5.nodes)
                    RA(e5, i4, t6, n6, f4, h4, PA);
              }
            }
          }(e4, t3, i3, r3), void l3();
        if (!c3.loaded())
          return;
        if ("batched-model" === c3.type)
          return function(e5, t4, i4, r4) {
            const n5 = e5.context, o4 = e5.transform, s7 = e5.style.fog, a4 = e5.shadowRenderer;
            if ("mercator" !== o4.projection.name)
              return void H2(`Drawing 3D landmark models for ${o4.projection.name} projection is not yet implemented`);
            const l4 = e5.transform.getFreeCameraOptions().position, c4 = Du.scale([], [l4.x, l4.y, l4.z], e5.transform.worldSize);
            Du.negate(c4, c4);
            const h4 = Au.identity([]), u4 = op(o4.center.lat, o4.zoom), d4 = Au.fromScaling([], [1, 1, 1 / u4]);
            Au.translate(h4, h4, c4);
            const p4 = i4.paint.get("model-opacity"), f4 = new Mx(n5.gl.LEQUAL, Mx.ReadWrite, e5.depthRangeFor3D), m4 = new Mx(n5.gl.LEQUAL, Mx.ReadOnly, e5.depthRangeFor3D), _4 = function(l5, c5) {
              for (const u5 of r4) {
                const r5 = t4.getTile(u5).getBucket(i4);
                if (!r5 || !r5.uploaded)
                  continue;
                let _5 = false;
                a4 && (_5 = 0 === a4.getMaxCascadeForTile(u5.toUnwrapped()));
                const g3 = o4.calculatePosMatrix(u5.toUnwrapped(), o4.worldSize), y3 = r5.modelTraits;
                for (const t5 of r5.getNodesInfo()) {
                  if (t5.hiddenByReplacement)
                    continue;
                  if (!t5.node.meshes)
                    continue;
                  const r6 = t5.node, x3 = "light-beam" === e5.renderPass, v3 = [...g3], b3 = t5.evaluatedScale;
                  let w3 = 0;
                  e5.terrain && r6.elevation && (w3 = r6.elevation * e5.terrain.exaggeration()), Au.translate(v3, v3, [(r6.anchor ? r6.anchor[0] : 0) * (b3[0] - 1), (r6.anchor ? r6.anchor[1] : 0) * (b3[1] - 1), w3]), b3 !== Iv && Au.scale(v3, v3, b3), Au.multiply(v3, v3, r6.matrix);
                  const T3 = Au.multiply([], d4, v3);
                  Au.multiply(T3, h4, T3);
                  const E3 = Au.invert([], T3);
                  Au.transpose(E3, E3), Au.scale(E3, E3, LA);
                  const M3 = Au.multiply([], o4.expandedFarZProjMatrix, v3);
                  for (let h5 = 0; h5 < r6.meshes.length; ++h5) {
                    const d5 = r6.meshes[h5], g4 = h5 === r6.lightMeshIndex;
                    if (g4) {
                      if (!x3 && !e5.terrain && e5.shadowRenderer) {
                        e5.currentLayer < e5.firstLightBeamLayer && (e5.firstLightBeamLayer = e5.currentLayer);
                        continue;
                      }
                    } else if (x3)
                      continue;
                    const b4 = { defines: [] }, w4 = [];
                    AA(b4.defines, w4, d5, e5), 4 & y3 || b4.defines.push("DIFFUSE_SHADED"), _5 && b4.defines.push("SHADOWS_SINGLE_CASCADE");
                    const A3 = "shadow" === e5.renderPass;
                    if (A3) {
                      CA(d5, v3, e5, i4);
                      continue;
                    }
                    let S3 = null;
                    if (s7) {
                      const t6 = MA(v3, e5.transform);
                      if (S3 = new Float32Array(t6), "globe" !== o4.projection.name) {
                        const e6 = d5.aabb.min, i5 = d5.aabb.max, [r7, n6] = s7.getOpacityForBounds(t6, e6[0], e6[1], i5[0], i5[1]);
                        b4.overrideFog = r7 >= fw || n6 >= fw;
                      }
                    }
                    const I3 = e5.getOrCreateProgram("model", b4);
                    !A3 && a4 && (a4.useNormalOffset = !!d5.normalBuffer, a4.setupShadowsFromMatrix(v3, I3, a4.useNormalOffset)), e5.uploadCommonUniforms(n5, I3, u5.toUnwrapped(), S3);
                    const C3 = d5.material, z2 = C3.pbrMetallicRoughness;
                    z2.metallicFactor = 0.9, z2.roughnessFactor = 0.5;
                    const P3 = 0, D2 = UM(new Float32Array(M3), new Float32Array(T3), new Float32Array(E3), e5, p4, z2.baseColorFactor, C3.emissiveFactor, z2.metallicFactor, z2.roughnessFactor, C3, P3, i4);
                    I3.draw(e5, n5.gl.TRIANGLES, c5 && !g4 ? f4 : m4, Sx.disabled, l5 ? g4 || p4 < 1 || t5.hasTranslucentParts ? Cx.alphaBlended : Cx.unblended : Cx.disabled, Dx.backCCW, D2, i4.id, d5.vertexBuffer, d5.indexBuffer, d5.segments, i4.paint, e5.transform.zoom, void 0, w4);
                  }
                }
              }
            };
            (function(e6, t5, i5, r5) {
              const n6 = e6.terrain ? e6.terrain.exaggeration() : 0, o5 = e6.transform.zoom;
              for (const s8 of r5) {
                const r6 = t5.getTile(s8).getBucket(i5);
                r6 && (e6.conflationActive && r6.updateReplacement(s8, e6.replacementSource), r6.evaluateScale(e6, i5), e6.terrain && n6 > 0 && r6.elevationUpdate(e6.terrain, n6, s8, i5.source), r6.needsReEvaluation(e6, o5, i5) && r6.evaluate(i5));
              }
            })(e5, t4, i4, r4), 1 === p4 ? _4(true, true) : (_4(false, true), _4(true, false));
          }(e4, t3, i3, r3), void l3();
        const h3 = c3.getModels(), u3 = [], d3 = e4.transform.getFreeCameraOptions().position, p3 = Du.scale([], [d3.x, d3.y, d3.z], e4.transform.worldSize);
        Du.negate(p3, p3);
        const f3 = [], m3 = [];
        let _3 = 0;
        for (const t4 of h3) {
          const r4 = i3.paint.get("model-rotation").constantOr(null), n5 = i3.paint.get("model-scale").constantOr(null), o4 = i3.paint.get("model-translation").constantOr(null);
          t4.computeModelMatrix(e4, r4, n5, o4, true, true, false);
          const s7 = Au.identity([]), a4 = op(t4.position.lat, e4.transform.zoom), l4 = Au.fromScaling([], [1, 1, 1 / a4]);
          Au.translate(s7, s7, p3), u3.push({ zScaleMatrix: l4, negCameraPosMatrix: s7 });
          for (const i4 of t4.nodes)
            IA(e4.transform, i4, t4.matrix, e4.transform.expandedFarZProjMatrix, _3, f3, m3);
          _3++;
        }
        if (f3.sort((e5, t4) => t4.depth - e5.depth), "shadow" !== e4.renderPass) {
          if (1 === n4)
            for (const t4 of m3)
              SA(t4, e4, i3, u3[t4.modelIndex], Sx.disabled, e4.colorModeForRenderPass());
          else {
            for (const t4 of m3)
              SA(t4, e4, i3, u3[t4.modelIndex], Sx.disabled, Cx.disabled);
            for (const t4 of m3)
              SA(t4, e4, i3, u3[t4.modelIndex], e4.stencilModeFor3D(), e4.colorModeForRenderPass());
            e4.resetStencilClippingMasks();
          }
          for (const t4 of f3)
            SA(t4, e4, i3, u3[t4.modelIndex], Sx.disabled, e4.colorModeForRenderPass());
          l3();
        } else {
          for (const t4 of m3)
            CA(t4.mesh, t4.nodeModelMatrix, e4, i3);
          for (const t4 of f3)
            CA(t4.mesh, t4.nodeModelMatrix, e4, i3);
          l3();
        }
      } }, NA = { modelUpload: function(e4, t3, i3) {
        const r3 = t3.getSource();
        if (!r3.loaded())
          return;
        if ("vector" === r3.type || "geojson" === r3.type)
          return void (e4.modelManager && e4.modelManager.upload(e4, i3));
        if ("batched-model" === r3.type)
          return;
        const n4 = r3.getModels();
        for (const t4 of n4)
          t4.upload(e4.context);
      } };
      class UA {
        constructor(e4, t3, i3) {
          this.context = new Rx(e4, t3), this.transform = i3, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = Lx.maxUnderzooming + Lx.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new Xv(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new qA(this), this._wireframeDebugCache = new BA(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true;
        }
        updateTerrain(e4, t3) {
          const i3 = !!e4 && !!e4.terrain && this.transform.projection.supportsTerrain;
          if (!(i3 || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new uM(this, e4));
          const r3 = this._terrain;
          this.transform.elevation = i3 ? r3 : null, r3.update(e4, this.transform, t3), this.transform.elevation && !r3.enabled && (this.transform.elevation = null);
        }
        _updateFog(e4) {
          const t3 = e4.fog;
          if (!t3 || "globe" === this.transform.projection.name || t3.getOpacity(this.transform.pitch) < 1 || t3.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [i3, r3] = t3.getFovAdjustedRange(this.transform._fov);
          if (i3 > r3)
            return void (this.transform.fogCullDistSq = null);
          const n4 = i3 + 0.78 * (r3 - i3);
          this.transform.fogCullDistSq = n4 * n4;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
        }
        get shadowRenderer() {
          return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
        }
        get wireframeDebugCache() {
          return this._wireframeDebugCache;
        }
        resize(e4, t3) {
          if (this.width = e4 * dt.devicePixelRatio, this.height = t3 * dt.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const e5 of this.style.order)
              this.style._mergedLayers[e5].resize();
        }
        setup() {
          const e4 = this.context, i3 = new za();
          i3.emplaceBack(0, 0), i3.emplaceBack(cr, 0), i3.emplaceBack(0, cr), i3.emplaceBack(cr, cr), this.tileExtentBuffer = e4.createVertexBuffer(i3, Nu.members), this.tileExtentSegments = xl.simpleSegment(0, 0, 4, 2);
          const r3 = new za();
          r3.emplaceBack(0, 0), r3.emplaceBack(cr, 0), r3.emplaceBack(0, cr), r3.emplaceBack(cr, cr), this.debugBuffer = e4.createVertexBuffer(r3, Nu.members), this.debugSegments = xl.simpleSegment(0, 0, 4, 5);
          const n4 = new za();
          n4.emplaceBack(-1, -1), n4.emplaceBack(1, -1), n4.emplaceBack(-1, 1), n4.emplaceBack(1, 1), this.viewportBuffer = e4.createVertexBuffer(n4, Nu.members), this.viewportSegments = xl.simpleSegment(0, 0, 4, 2);
          const o3 = new Da();
          o3.emplaceBack(0, 0, 0, 0), o3.emplaceBack(cr, 0, cr, 0), o3.emplaceBack(0, cr, 0, cr), o3.emplaceBack(cr, cr, cr, cr), this.mercatorBoundsBuffer = e4.createVertexBuffer(o3, Ly.members), this.mercatorBoundsSegments = xl.simpleSegment(0, 0, 4, 2);
          const s6 = new Wa();
          s6.emplaceBack(0, 1, 2), s6.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e4.createIndexBuffer(s6);
          const a3 = new el();
          for (const e5 of [0, 1, 3, 2, 0])
            a3.emplaceBack(e5);
          this.debugIndexBuffer = e4.createIndexBuffer(a3), this.emptyTexture = new My(e4, new ef({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), e4.gl.RGBA), this.identityMat = Au.create();
          const l3 = this.context.gl;
          this.stencilClearMode = new Sx({ func: l3.ALWAYS, mask: 0 }, 0, 255, l3.ZERO, l3.ZERO, l3.ZERO), this.loadTimeStamps.push(t2.performance.now());
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(e4) {
          return e4._makeTileBoundsBuffers(this.context, this.transform.projection), e4._tileBoundsBuffer ? { tileBoundsBuffer: e4._tileBoundsBuffer, tileBoundsIndexBuffer: e4._tileBoundsIndexBuffer, tileBoundsSegments: e4._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const e4 = this.context.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e4.TRIANGLES, Mx.disabled, this.stencilClearMode, Cx.disabled, Dx.disabled, sM(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(e4, t3, i3) {
          if (!t3 || this.currentStencilSource === t3.id || !e4.isTileClipped() || !i3 || 0 === i3.length)
            return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let e5 = false;
            for (const t4 of i3)
              if (void 0 === this._tileClippingMaskIDs[t4.key]) {
                e5 = true;
                break;
              }
            if (!e5)
              return;
          }
          this.currentStencilSource = t3.id;
          const r3 = this.context, n4 = r3.gl;
          this.nextStencilID + i3.length > 256 && this.clearStencil(), r3.setColorMode(Cx.disabled), r3.setDepthMode(Mx.disabled);
          const o3 = this.getOrCreateProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const e5 of i3) {
            const i4 = t3.getTile(e5), r4 = this._tileClippingMaskIDs[e5.key] = this.nextStencilID++, { tileBoundsBuffer: s6, tileBoundsIndexBuffer: a3, tileBoundsSegments: l3 } = this.getTileBoundsBuffers(i4);
            o3.draw(this, n4.TRIANGLES, Mx.disabled, new Sx({ func: n4.ALWAYS, mask: 0 }, r4, 255, n4.KEEP, n4.KEEP, n4.REPLACE), Cx.disabled, Dx.disabled, sM(e5.projMatrix), "$clipping", s6, a3, l3);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const e4 = this.nextStencilID++, t3 = this.context.gl;
          return new Sx({ func: t3.NOTEQUAL, mask: 255 }, e4, 255, t3.KEEP, t3.KEEP, t3.REPLACE);
        }
        stencilModeForClipping(e4) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(e4);
          const t3 = this.context.gl;
          return new Sx({ func: t3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e4.key], 0, t3.KEEP, t3.KEEP, t3.REPLACE);
        }
        stencilConfigForOverlap(e4) {
          const t3 = this.context.gl, i3 = e4.sort((e5, t4) => t4.overscaledZ - e5.overscaledZ), r3 = i3[i3.length - 1].overscaledZ, n4 = i3[0].overscaledZ - r3 + 1;
          if (n4 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + n4 > 256 && this.clearStencil();
            const e5 = {};
            for (let i4 = 0; i4 < n4; i4++)
              e5[i4 + r3] = new Sx({ func: t3.GEQUAL, mask: 255 }, i4 + this.nextStencilID, 255, t3.KEEP, t3.KEEP, t3.REPLACE);
            return this.nextStencilID += n4, [e5, i3];
          }
          return [{ [r3]: Sx.disabled }, i3];
        }
        colorModeForRenderPass() {
          const e4 = this.context.gl;
          if (this._showOverdrawInspector) {
            const t3 = 1 / 8;
            return new Cx([e4.CONSTANT_COLOR, e4.ONE, e4.CONSTANT_COLOR, e4.ONE], new hi(t3, t3, t3, 0), [true, true, true, true]);
          }
          return "opaque" === this.renderPass ? Cx.unblended : Cx.alphaBlended;
        }
        colorModeForDrapableLayerRenderPass(e4) {
          const t3 = this.context.gl;
          return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new Cx([t3.ONE, t3.ONE_MINUS_SRC_ALPHA, t3.CONSTANT_ALPHA, t3.ONE_MINUS_SRC_ALPHA], new hi(0, 0, 0, void 0 === e4 ? 0 : e4), [true, true, true, true]) : this.colorModeForRenderPass();
        }
        depthModeForSublayer(e4, t3, i3, r3 = false) {
          if (!this.opaquePassEnabledForLayer() && !r3)
            return Mx.disabled;
          const n4 = 1 - ((1 + this.currentLayer) * this.numSublayers + e4) * this.depthEpsilon;
          return new Mx(i3 || this.context.gl.LEQUAL, t3, [n4, n4]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(e4, i3) {
          this._wireframeDebugCache.update(this.frameCounter), this.style = e4, this.options = i3;
          const r3 = this.style._mergedLayers, n4 = this.style.order, o3 = n4.map((e5) => r3[e5]), s6 = this.style._mergedSourceCaches;
          this.imageManager = e4.imageManager, this.modelManager = e4.modelManager, this.symbolFadeChange = e4.placement.symbolFadeChange(dt.now()), this.imageManager.beginFrame();
          let a3 = 0, l3 = false;
          for (const e5 in s6) {
            const t3 = s6[e5];
            t3.used && (t3.prepare(this.context), t3.getSource().usedInConflation && ++a3);
          }
          const c3 = {}, h3 = {}, u3 = {}, d3 = {}, p3 = {};
          for (const e5 in s6) {
            const t3 = s6[e5];
            c3[e5] = t3.getVisibleCoordinates(), h3[e5] = c3[e5].slice().reverse(), u3[e5] = t3.getVisibleCoordinates(true).reverse(), d3[e5] = t3.getShadowCasterCoordinates(), p3[e5] = t3.sortCoordinatesByDistance(c3[e5]);
          }
          const f3 = (e5) => {
            const t3 = this.style.getLayerSourceCache(e5);
            return t3 && t3.used ? t3.getSource() : null;
          };
          if (a3) {
            const e5 = [];
            for (const t3 of o3)
              this.layerUsedInConflation(t3, f3(t3)) && e5.push(t3);
            if (e5 && e5.length > 1) {
              const t3 = [];
              for (const i4 of e5) {
                const e6 = this.style.getLayerSourceCache(i4);
                e6 && e6.used && e6.getSource().usedInConflation && t3.push({ layer: i4.fqid, cache: e6 });
              }
              this.replacementSource.setSources(t3), l3 = true;
            }
          }
          l3 || this.replacementSource.clear(), this.conflationActive = l3, this.minCutoffZoom = 0, this.longestCutoffRange = 0;
          for (const e5 of o3) {
            const t3 = e5.cutoffRange();
            if (this.longestCutoffRange = Math.max(t3, this.longestCutoffRange), t3 > 0) {
              const t4 = f3(e5);
              t4 && (this.minCutoffZoom = Math.max(t4.minzoom, this.minCutoffZoom)), e5.minzoom && (this.minCutoffZoom = Math.max(e5.minzoom, this.minCutoffZoom));
            }
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e5 = 0; e5 < o3.length; e5++)
            if (o3[e5].is3D()) {
              this.opaquePassCutoff = e5;
              break;
            }
          const m3 = this.style && this.style.fog;
          m3 ? (this._fogVisible = 0 !== m3.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = m3.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(u3), this.opaquePassCutoff = 0);
          const _3 = this._shadowRenderer;
          if (_3) {
            _3.updateShadowParameters(this.transform, this.style.directionalLight);
            for (const e5 in s6)
              for (const t3 of c3[e5]) {
                let e6 = { min: 0, max: 0 };
                this.terrain && (e6 = this.terrain.getMinMaxForTile(t3) || e6), _3.addShadowReceiver(t3.toUnwrapped(), e6.min, e6.max);
              }
          }
          "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new Gd(this.context));
          for (const t3 of o3) {
            if (t3.isHidden(this.transform.zoom))
              continue;
            const i4 = e4.getLayerSourceCache(t3);
            this.uploadLayer(this, t3, i4);
          }
          if (this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new EA()), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), !Ye.has(this.context.gl))
            return;
          this.renderPass = "offscreen";
          for (const t3 of o3) {
            const i4 = e4.getLayerSourceCache(t3);
            if (!t3.hasOffscreenPass() || t3.isHidden(this.transform.zoom))
              continue;
            const r4 = i4 ? h3[i4.id] : void 0;
            ("custom" === t3.type || "raster" === t3.type || t3.isSky() || r4 && r4.length) && this.renderLayer(this, i4, t3, r4);
          }
          this.depthRangeFor3D = [0, 1 - (o3.length + 2) * this.numSublayers * this.depthEpsilon];
          const g3 = this.terrain;
          g3 && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && !this.transform.isOrthographic && g3.drawDepth(), this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, d3)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
          const y3 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), x3 = (() => {
            if (i3.showOverdrawInspector)
              return hi.black;
            if (this.style.fog && this.transform.projection.supportsFog && !y3) {
              const e5 = this.style.fog.properties.get("color").toArray01();
              return new hi(...e5);
            }
            if (this.style.fog && this.transform.projection.supportsFog && y3) {
              const e5 = this.style.fog.properties.get("space-color").toArray01();
              return new hi(...e5);
            }
            return hi.transparent;
          })();
          if (this.context.clear({ color: x3, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && y3 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain)
            for (this.currentLayer = n4.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const t3 = o3[this.currentLayer], i4 = e4.getLayerSourceCache(t3);
              if (t3.isSky())
                continue;
              const r4 = i4 ? (t3.is3D() ? p3 : h3)[i4.id] : void 0;
              this._renderTileClippingMasks(t3, i4, r4), this.renderLayer(this, i4, t3, r4);
            }
          if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && y3 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || Dd(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible()))
            for (this.currentLayer = 0; this.currentLayer < n4.length; this.currentLayer++) {
              const t3 = o3[this.currentLayer], i4 = e4.getLayerSourceCache(t3);
              t3.isSky() && this.renderLayer(this, i4, t3, i4 ? h3[i4.id] : void 0);
            }
          this.renderPass = "translucent", this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
          let v3 = 0;
          for (_3 && (v3 = _3.getShadowCastingLayerCount()); this.currentLayer < n4.length; ) {
            const t3 = o3[this.currentLayer], i4 = e4.getLayerSourceCache(t3);
            if (t3.isSky()) {
              ++this.currentLayer;
              continue;
            }
            if (g3 && this.style.isLayerDraped(t3)) {
              if (t3.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = g3.renderBatch(this.currentLayer);
              continue;
            }
            let r4;
            if (i4 && (r4 = ("symbol" === t3.type ? u3 : t3.is3D() ? p3 : h3)[i4.id]), this._renderTileClippingMasks(t3, i4, i4 ? c3[i4.id] : void 0), this.renderLayer(this, i4, t3, r4), !g3 && _3 && v3 > 0 && t3.hasShadowPass() && 0 == --v3 && (_3.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
              const t4 = this.currentLayer;
              for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= t4; this.currentLayer++) {
                const t5 = o3[this.currentLayer];
                if (!t5.hasLightBeamPass())
                  continue;
                const i5 = e4.getLayerSourceCache(t5);
                this.renderLayer(this, i5, t5, i5 ? h3[i5.id] : void 0);
              }
              this.currentLayer = t4, this.renderPass = "translucent";
            }
            ++this.currentLayer;
          }
          if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
            let t3 = null;
            o3.forEach((i4) => {
              const r4 = e4.getLayerSourceCache(i4);
              r4 && !i4.isHidden(this.transform.zoom) && r4.getVisibleCoordinates().length && (!t3 || t3.getSource().maxzoom < r4.getSource().maxzoom) && (t3 = r4);
            }), t3 && this.options.showTileBoundaries && FA.debug(this, t3, t3.getVisibleCoordinates());
          }
          this.options.showPadding && function(e5) {
            const t3 = e5.transform.padding;
            pA(e5, e5.transform.height - (t3.top || 0), 3, aA), pA(e5, t3.bottom || 0, 3, lA), fA(e5, t3.left || 0, 3, cA), fA(e5, e5.transform.width - (t3.right || 0), 3, hA);
            const i4 = e5.transform.centerPoint;
            !function(e6, t4, i5, r4) {
              mA(e6, t4 - 1, i5 - 10, 2, 20, r4), mA(e6, t4 - 10, i5 - 1, 20, 2, r4);
            }(e5, i4.x, e5.transform.height - i4.y, uA);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(t2.performance.now()), this.saveCanvasCopy()), l3 || (this.conflationActive = false);
        }
        uploadLayer(e4, t3, i3) {
          this.gpuTimingStart(t3), (!e4.transform.projection.unsupportedLayers || !e4.transform.projection.unsupportedLayers.includes(t3.type) || e4.terrain && "custom" === t3.type) && NA[`${t3.type}Upload`] && NA[`${t3.type}Upload`](e4, i3, t3.scope), this.gpuTimingEnd();
        }
        renderLayer(e4, t3, i3, r3) {
          i3.isHidden(this.transform.zoom) || ("background" === i3.type || "sky" === i3.type || "custom" === i3.type || "model" === i3.type || "raster" === i3.type || r3 && r3.length) && (this.id = i3.id, this.gpuTimingStart(i3), (!e4.transform.projection.unsupportedLayers || !e4.transform.projection.unsupportedLayers.includes(i3.type) || e4.terrain && "custom" === i3.type) && FA[i3.type](e4, t3, i3, r3, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(e4) {
          if (!this.options.gpuTiming)
            return;
          const t3 = this.context.extTimerQuery, i3 = this.context.gl;
          let r3 = this.gpuTimers[e4.id];
          r3 || (r3 = this.gpuTimers[e4.id] = { calls: 0, cpuTime: 0, query: i3.createQuery() }), r3.calls++, i3.beginQuery(t3.TIME_ELAPSED_EXT, r3.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const e4 = this.context.extTimerQuery, t3 = this.context.gl, i3 = t3.createQuery();
            this.deferredRenderGpuTimeQueries.push(i3), t3.beginQuery(e4.TIME_ELAPSED_EXT, i3);
          }
        }
        gpuTimingDeferredRenderEnd() {
          this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const e4 = this.gpuTimers;
          return this.gpuTimers = {}, e4;
        }
        collectDeferredRenderGpuQueries() {
          const e4 = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], e4;
        }
        queryGpuTimers(e4) {
          const t3 = {};
          for (const i3 in e4) {
            const r3 = e4[i3], n4 = this.context.extTimerQuery, o3 = n4.getQueryParameter(r3.query, this.context.gl.QUERY_RESULT) / 1e6;
            n4.deleteQueryEXT(r3.query), t3[i3] = o3;
          }
          return t3;
        }
        queryGpuTimeDeferredRender(e4) {
          if (!this.options.gpuTimingDeferredRender)
            return 0;
          const t3 = this.context.extTimerQuery, i3 = this.context.gl;
          let r3 = 0;
          for (const n4 of e4)
            r3 += t3.getQueryParameter(n4, i3.QUERY_RESULT) / 1e6, t3.deleteQueryEXT(n4);
          return r3;
        }
        translatePosMatrix(e4, t3, i3, r3, n4) {
          if (!i3[0] && !i3[1])
            return e4;
          const o3 = n4 ? "map" === r3 ? this.transform.angle : 0 : "viewport" === r3 ? -this.transform.angle : 0;
          if (o3) {
            const e5 = Math.sin(o3), t4 = Math.cos(o3);
            i3 = [i3[0] * t4 - i3[1] * e5, i3[0] * e5 + i3[1] * t4];
          }
          const s6 = [n4 ? i3[0] : rv(t3, i3[0], this.transform.zoom), n4 ? i3[1] : rv(t3, i3[1], this.transform.zoom), 0], a3 = new Float32Array(16);
          return Au.translate(a3, e4, s6), a3;
        }
        saveTileTexture(e4) {
          const t3 = e4.size[0], i3 = this._tileTextures[t3];
          i3 ? i3.push(e4) : this._tileTextures[t3] = [e4];
        }
        getTileTexture(e4) {
          const t3 = this._tileTextures[e4];
          return t3 && t3.length > 0 ? t3.pop() : null;
        }
        isPatternMissing(e4, t3) {
          return null === e4 || void 0 !== e4 && !this.imageManager.getPattern(e4.toString(), t3);
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
        }
        linearFloatFilteringSupported() {
          return null != this.context.extTextureFloatLinear;
        }
        currentGlobalDefines(e4, t3, i3) {
          const r3 = void 0 === i3 ? this.terrain && this.terrain.renderingToTexture : i3, n4 = this.terrain && 0 === this.terrain.exaggeration(), o3 = [];
          return this.style && this.style.enable3dLights() && ("globeRaster" === e4 || "terrainRaster" === e4 ? (o3.push("LIGHTING_3D_MODE"), o3.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : r3 || o3.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass ? this._shadowMapDebug || o3.push("DEPTH_TEXTURE") : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? o3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET") : o3.push("RENDER_SHADOWS", "DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (o3.push("TERRAIN"), this.linearFloatFilteringSupported() && o3.push("TERRAIN_DEM_FLOAT_FORMAT"), n4 && o3.push("ZERO_EXAGGERATION")), "globe" === this.transform.projection.name && o3.push("GLOBE"), !this._fogVisible || r3 || void 0 !== t3 && !t3 || o3.push("FOG", "FOG_DITHERING"), r3 && o3.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o3.push("OVERDRAW_INSPECTOR"), o3;
        }
        getOrCreateProgram(e4, t3) {
          this.cache = this.cache || {};
          const i3 = t3 && t3.defines || [], r3 = t3 && t3.config, n4 = this.currentGlobalDefines(e4, t3 && t3.overrideFog, t3 && t3.overrideRtt).concat(i3), o3 = mM.cacheKey(GE[e4], e4, n4, r3);
          return this.cache[o3] || (this.cache[o3] = new mM(this.context, e4, GE[e4], r3, GM[e4], n4)), this.cache[o3];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e4 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e4.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t2.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new My(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        uploadCommonLightUniforms(e4, t3) {
          if (this.style.enable3dLights()) {
            const i3 = this.style.directionalLight, r3 = this.style.ambientLight;
            if (i3 && r3) {
              const n4 = ((e5, t4) => {
                const i4 = e5.properties.get("direction"), r4 = e5.properties.get("color").toArray01(), n5 = e5.properties.get("intensity"), o3 = t4.properties.get("color").toArray01(), s6 = t4.properties.get("intensity"), a3 = [i4.x, i4.y, i4.z], l3 = se(o3, s6), c3 = se(r4, n5);
                return { u_lighting_ambient_color: l3, u_lighting_directional_dir: a3, u_lighting_directional_color: c3, u_ground_radiance: dM(a3, c3, l3) };
              })(i3, r3);
              t3.setLightsUniformValues(e4, n4);
            }
          }
        }
        uploadCommonUniforms(e4, t3, i3, r3, n4) {
          if (this.uploadCommonLightUniforms(e4, t3), this.terrain && this.terrain.renderingToTexture)
            return;
          const o3 = this.style.fog;
          if (o3) {
            const n5 = o3.getOpacity(this.transform.pitch), s6 = ((e5, t4, i4, r4, n6, o4, s7, a3, l3, c3, h3, u3) => {
              const d3 = e5.transform, p3 = t4.properties.get("color").toArray01();
              p3[3] = r4;
              const f3 = e5.frameCounter / 1e3 % 1, [m3, _3] = t4.properties.get("vertical-range");
              return { u_fog_matrix: i4 ? d3.calculateFogTileMatrix(i4) : u3 || e5.identityMat, u_fog_range: t4.getFovAdjustedRange(d3._fov), u_fog_color: p3, u_fog_horizon_blend: t4.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(m3, _3), _3], u_fog_temporal_offset: f3, u_frustum_tl: n6, u_frustum_tr: o4, u_frustum_br: s7, u_frustum_bl: a3, u_globe_pos: l3, u_globe_radius: c3, u_viewport: h3, u_globe_transition: Dd(d3.zoom), u_is_globe: +("globe" === d3.projection.name) };
            })(this, o3, i3, n5, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * dt.devicePixelRatio, this.transform.height * dt.devicePixelRatio], r3);
            t3.setFogUniformValues(e4, s6);
          }
          n4 && t3.setCutoffUniformValues(e4, n4.uniformValues);
        }
        setTileLoadedFlag(e4) {
          this.tileLoaded = e4;
        }
        saveCanvasCopy() {
          const e4 = this.canvasCopy();
          e4 && (this.frameCopies.push(e4), this.tileLoaded = false);
        }
        canvasCopy() {
          const e4 = this.context.gl, t3 = e4.createTexture();
          return e4.bindTexture(e4.TEXTURE_2D, t3), e4.copyTexImage2D(e4.TEXTURE_2D, 0, e4.RGBA, 0, 0, e4.drawingBufferWidth, e4.drawingBufferHeight, 0), t3;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return false;
          const e4 = this.style && this.style.fog;
          return !!e4 && 0 !== e4.getOpacity(this.transform.pitch);
        }
        getBackgroundTiles() {
          const e4 = this._backgroundTiles, t3 = this._backgroundTiles = {}, i3 = this.transform.coveringTiles({ tileSize: 512 });
          for (const r3 of i3)
            t3[r3.key] = e4[r3.key] || new Oy(r3, 512, this.transform.tileZoom, this);
          return t3;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
        layerUsedInConflation(e4, t3) {
          return !(!e4.is3D() || e4.minzoom && e4.minzoom > this.transform.zoom || "building" !== e4.sourceLayer && (!t3 || "batched-model" !== t3.type));
        }
        isTileAffectedByFog(e4) {
          if (!this.style || !this.style.fog)
            return false;
          if ("globe" === this.transform.projection.name)
            return true;
          let t3 = this._cachedTileFogOpacities[e4.key];
          return t3 || (this._cachedTileFogOpacities[e4.key] = t3 = this.style.fog.getOpacityForTile(e4)), t3[0] >= fw || t3[1] >= fw;
        }
      }
      const VA = 2048;
      class jA {
        constructor(e4, t3) {
          this.aabb = e4, this.lastCascade = t3;
        }
      }
      class GA {
        add(e4, t3) {
          const i3 = this.receivers[e4.key];
          void 0 !== i3 ? (i3.aabb.min[0] = Math.min(i3.aabb.min[0], t3.min[0]), i3.aabb.min[1] = Math.min(i3.aabb.min[1], t3.min[1]), i3.aabb.min[2] = Math.min(i3.aabb.min[2], t3.min[2]), i3.aabb.max[0] = Math.max(i3.aabb.max[0], t3.max[0]), i3.aabb.max[1] = Math.max(i3.aabb.max[1], t3.max[1]), i3.aabb.max[2] = Math.max(i3.aabb.max[2], t3.max[2])) : this.receivers[e4.key] = new jA(t3, null);
        }
        clear() {
          this.receivers = {};
        }
        get(e4) {
          return this.receivers[e4.key];
        }
        computeRequiredCascades(e4, t3, i3) {
          const r3 = ed.fromPoints(e4.points);
          let n4 = 0;
          for (const e5 in this.receivers) {
            const o3 = this.receivers[e5];
            if (!o3)
              continue;
            if (!r3.intersectsAabb(o3.aabb))
              continue;
            o3.aabb.min = r3.closestPoint(o3.aabb.min), o3.aabb.max = r3.closestPoint(o3.aabb.max);
            const s6 = o3.aabb.getCorners();
            for (let e6 = 0; e6 < i3.length; e6++) {
              let r4 = true;
              for (const n5 of s6) {
                const o4 = [n5[0] * t3, n5[1] * t3, n5[2]];
                if (Du.transformMat4(o4, o4, i3[e6].matrix), o4[0] < -1 || o4[0] > 1 || o4[1] < -1 || o4[1] > 1) {
                  r4 = false;
                  break;
                }
              }
              if (o3.lastCascade = e6, n4 = Math.max(n4, e6), r4)
                break;
            }
          }
          return n4 + 1;
        }
      }
      class qA {
        constructor(e4) {
          this.painter = e4, this._enabled = false, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new GA(), this._depthMode = new Mx(e4.context.gl.LEQUAL, Mx.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this.useNormalOffset = false;
        }
        destroy() {
          for (const e4 of this._cascades)
            e4.texture.destroy(), e4.framebuffer.destroy();
          this._cascades = [];
        }
        updateShadowParameters(e4, t3) {
          const i3 = this.painter;
          if (this._enabled = false, this._shadowLayerCount = 0, this._receivers.clear(), !t3 || !t3.properties)
            return;
          const r3 = t3.properties.get("shadow-intensity");
          if (!t3.shadowsEnabled() || r3 <= 0)
            return;
          if (this._shadowLayerCount = i3.style.order.reduce((t4, r4) => {
            const n5 = i3.style._mergedLayers[r4];
            return t4 + (n5.hasShadowPass() && !n5.isHidden(e4.zoom) ? 1 : 0);
          }, 0), this._enabled = this._shadowLayerCount > 0, !this._enabled)
            return;
          const n4 = i3.context, o3 = VA, s6 = VA;
          if (0 === this._cascades.length)
            for (let e5 = 0; e5 < 2; ++e5) {
              const e6 = i3._shadowMapDebug, t4 = n4.gl, r4 = n4.createFramebuffer(o3, s6, e6, "texture"), a4 = new My(n4, { width: o3, height: s6, data: null }, t4.DEPTH_COMPONENT);
              if (r4.depthAttachment.set(a4.texture), e6) {
                const e7 = new My(n4, { width: o3, height: s6, data: null }, t4.RGBA);
                r4.colorAttachment.set(e7.texture);
              }
              this._cascades.push({ framebuffer: r4, texture: a4, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new Qu(), scale: 0 });
            }
          this.shadowDirection = $A(t3);
          let a3 = 0;
          if (e4.elevation) {
            const t4 = e4.elevation, i4 = [1e4, -1e4];
            t4.visibleDemTiles.filter((e5) => e5.dem).forEach((e5) => {
              const t5 = e5.dem.tree;
              i4[0] = Math.min(i4[0], t5.minimums[0]), i4[1] = Math.max(i4[1], t5.maximums[0]);
            }), 1e4 !== i4[0] && (a3 = (i4[1] - i4[0]) * t4.exaggeration());
          }
          const l3 = 1.5 * e4.cameraToCenterDistance, c3 = 3 * l3, h3 = new Float64Array(16);
          for (let t4 = 0; t4 < 2; ++t4) {
            const i4 = this._cascades[t4];
            let r4 = e4.height / 50, n5 = 1;
            0 === t4 ? n5 = l3 : (r4 = l3, n5 = c3);
            const [o4, s7] = HA(e4, this.shadowDirection, r4, n5, VA, a3);
            i4.scale = e4.scale, i4.matrix = o4, i4.boundingSphereRadius = s7, Au.invert(h3, i4.matrix), i4.frustum = Qu.fromInvProjectionMatrix(h3, 1, 0, true), i4.far = n5;
          }
          this._uniformValues.u_fade_range = [0.75 * this._cascades[1].far, this._cascades[1].far], this._uniformValues.u_shadow_intensity = r3, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 48828125e-11, this._uniformValues.u_shadow_map_resolution = VA, this._uniformValues.u_shadowmap_0 = NM.ShadowMap0, this._uniformValues.u_shadowmap_1 = NM.ShadowMap0 + 1, this._groundShadowTiles = i3.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
          const u3 = i3.transform.elevation;
          for (const e5 of this._groundShadowTiles) {
            let t4 = { min: 0, max: 0 };
            if (u3) {
              const i4 = u3.getMinMaxForTile(e5);
              i4 && (t4 = i4);
            }
            this.addShadowReceiver(e5.toUnwrapped(), t4.min, t4.max);
          }
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e4) {
          this._enabled = e4;
        }
        drawShadowPass(e4, t3) {
          if (!this._enabled)
            return;
          const i3 = this.painter, r3 = i3.context;
          this._numCascadesToRender = this._receivers.computeRequiredCascades(i3.transform.getFrustum(0), i3.transform.worldSize, this._cascades), r3.viewport.set([0, 0, VA, VA]);
          for (let n4 = 0; n4 < this._numCascadesToRender; ++n4) {
            i3.currentShadowCascade = n4, r3.bindFramebuffer.set(this._cascades[n4].framebuffer.framebuffer), r3.clear({ color: hi.white, depth: 1 });
            for (const r4 of e4.order) {
              const n5 = e4._mergedLayers[r4];
              if (!n5.hasShadowPass() || n5.isHidden(i3.transform.zoom))
                continue;
              const o3 = e4.getLayerSourceCache(n5), s6 = o3 ? t3[o3.id] : void 0;
              ("model" === n5.type || s6 && s6.length) && i3.renderLayer(i3, o3, n5, s6);
            }
          }
          i3.currentShadowCascade = 0;
        }
        drawGroundShadows() {
          if (!this._enabled)
            return;
          const e4 = this.painter, t3 = e4.style, i3 = e4.context, r3 = t3.directionalLight, n4 = t3.ambientLight;
          if (!r3 || !n4)
            return;
          const o3 = [], s6 = eM(e4, e4.longestCutoffRange);
          s6.shouldRenderCutoff && o3.push("RENDER_CUTOFF");
          const a3 = WA(r3, n4), l3 = new Mx(i3.gl.LEQUAL, Mx.ReadOnly, e4.depthRangeFor3D);
          for (const t4 of this._groundShadowTiles) {
            const r4 = t4.toUnwrapped(), n5 = e4.isTileAffectedByFog(t4), c3 = e4.getOrCreateProgram("groundShadow", { defines: o3, overrideFog: n5 });
            this.setupShadows(r4, c3), e4.uploadCommonUniforms(i3, c3, r4, null, s6);
            const h3 = { u_matrix: e4.transform.calculateProjMatrix(r4), u_ground_shadow_factor: a3 };
            c3.draw(e4, i3.gl.TRIANGLES, l3, Sx.disabled, Cx.multiply, Dx.disabled, h3, "ground_shadow", e4.tileExtentBuffer, e4.quadTriangleIndexBuffer, e4.tileExtentSegments, {}, e4.transform.zoom, null, null);
          }
        }
        getShadowPassColorMode() {
          return this.painter._shadowMapDebug ? Cx.unblended : Cx.disabled;
        }
        getShadowPassDepthMode() {
          return this._depthMode;
        }
        getShadowCastingLayerCount() {
          return this._shadowLayerCount;
        }
        calculateShadowPassMatrixFromTile(e4) {
          const t3 = this.painter.transform, i3 = t3.calculatePosMatrix(e4, t3.worldSize);
          return Au.multiply(i3, this._cascades[this.painter.currentShadowCascade].matrix, i3), Float32Array.from(i3);
        }
        calculateShadowPassMatrixFromMatrix(e4) {
          return Au.multiply(e4, this._cascades[this.painter.currentShadowCascade].matrix, e4), Float32Array.from(e4);
        }
        setupShadows(e4, t3, i3, r3 = 0) {
          if (!this._enabled)
            return;
          const n4 = this.painter.transform, o3 = this.painter.context, s6 = o3.gl, a3 = this._uniformValues, l3 = new Float64Array(16), c3 = n4.calculatePosMatrix(e4, n4.worldSize);
          for (let e5 = 0; e5 < 2; e5++)
            Au.multiply(l3, this._cascades[e5].matrix, c3), a3[0 === e5 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(l3), o3.activeTexture.set(s6.TEXTURE0 + NM.ShadowMap0 + e5), this._cascades[e5].texture.bind(s6.NEAREST, s6.CLAMP_TO_EDGE);
          if (this.useNormalOffset = !!i3, this.useNormalOffset) {
            const t4 = ap(e4.canonical), o4 = 2 / n4.tileSize * cr / VA, s7 = o4 * this._cascades[0].boundingSphereRadius, l4 = o4 * this._cascades[1].boundingSphereRadius, c4 = ("vector-tile" === i3 ? 1 : 3) / Math.pow(2, r3 - e4.canonical.z - (1 - n4.zoom + Math.floor(n4.zoom)));
            a3.u_shadow_normal_offset = [t4, s7 * c4, l4 * c4], a3.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            a3.u_shadow_bias = [36e-5, 12e-4, 0.012];
          t3.setShadowUniformValues(o3, a3);
        }
        setupShadowsFromMatrix(e4, t3, i3 = false) {
          if (!this._enabled)
            return;
          const r3 = this.painter.context, n4 = r3.gl, o3 = this._uniformValues, s6 = new Float64Array(16);
          for (let t4 = 0; t4 < 2; t4++)
            Au.multiply(s6, this._cascades[t4].matrix, e4), o3[0 === t4 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(s6), r3.activeTexture.set(n4.TEXTURE0 + NM.ShadowMap0 + t4), this._cascades[t4].texture.bind(n4.NEAREST, n4.CLAMP_TO_EDGE);
          if (this.useNormalOffset = i3, i3) {
            const e5 = 5;
            o3.u_shadow_normal_offset = [1, e5, e5], o3.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            o3.u_shadow_bias = [36e-5, 12e-4, 0.012];
          t3.setShadowUniformValues(r3, o3);
        }
        getShadowUniformValues() {
          return this._uniformValues;
        }
        getCurrentCascadeFrustum() {
          return this._cascades[this.painter.currentShadowCascade].frustum;
        }
        computeSimplifiedTileShadowVolume(e4, t3, i3, r3) {
          if (r3[2] >= 0)
            return {};
          const n4 = function(e5, t4, i4) {
            const r4 = i4 / (1 << e5.canonical.z);
            return new ed([e5.canonical.x * r4 + e5.wrap * i4, e5.canonical.y * r4 + e5.wrap * i4, 0], [(e5.canonical.x + 1) * r4 + e5.wrap * i4, (e5.canonical.y + 1) * r4 + e5.wrap * i4, t4]);
          }(e4, t3, i3).getCorners(), o3 = t3 / -r3[2];
          r3[0] < 0 ? (Du.add(n4[0], n4[0], [r3[0] * o3, 0, 0]), Du.add(n4[3], n4[3], [r3[0] * o3, 0, 0])) : r3[0] > 0 && (Du.add(n4[1], n4[1], [r3[0] * o3, 0, 0]), Du.add(n4[2], n4[2], [r3[0] * o3, 0, 0])), r3[1] < 0 ? (Du.add(n4[0], n4[0], [0, r3[1] * o3, 0]), Du.add(n4[1], n4[1], [0, r3[1] * o3, 0])) : r3[1] > 0 && (Du.add(n4[2], n4[2], [0, r3[1] * o3, 0]), Du.add(n4[3], n4[3], [0, r3[1] * o3, 0]));
          const s6 = {};
          return s6.vertices = n4, s6.planes = [ZA(n4[1], n4[0], n4[4]), ZA(n4[2], n4[1], n4[5]), ZA(n4[3], n4[2], n4[6]), ZA(n4[0], n4[3], n4[7])], s6;
        }
        addShadowReceiver(e4, t3, i3) {
          this._receivers.add(e4, ed.fromTileIdAndHeight(e4, t3, i3));
        }
        getMaxCascadeForTile(e4) {
          const t3 = this._receivers.get(e4);
          return t3 && t3.lastCascade ? t3.lastCascade : 0;
        }
      }
      function ZA(e4, t3, i3) {
        const r3 = Du.sub([], i3, t3), n4 = Du.sub([], e4, t3), o3 = Du.cross([], r3, n4), s6 = Du.length(o3);
        return 0 === s6 ? [0, 0, 1, 0] : (Du.scale(o3, o3, 1 / s6), [o3[0], o3[1], o3[2], -Du.dot(o3, t3)]);
      }
      function $A(e4) {
        const t3 = e4.properties.get("direction"), i3 = J(t3.x, t3.y, t3.z);
        i3[2] = z(i3[2], 0, 75);
        const r3 = K([i3[0], i3[1], i3[2]]);
        return Du.fromValues(r3.x, r3.y, r3.z);
      }
      function WA(e4, t3) {
        const i3 = e4.properties.get("color"), r3 = e4.properties.get("intensity"), n4 = e4.properties.get("direction"), o3 = [n4.x, n4.y, n4.z], s6 = t3.properties.get("color"), a3 = t3.properties.get("intensity"), l3 = Math.max(Du.dot([0, 0, 1], o3), 0), c3 = [0, 0, 0];
        Du.scale(c3, s6.toArray01Linear().slice(0, 3), a3);
        const h3 = [0, 0, 0];
        return Du.scale(h3, i3.toArray01Linear().slice(0, 3), l3 * r3), ae([c3[0] > 0 ? c3[0] / (c3[0] + h3[0]) : 0, c3[1] > 0 ? c3[1] / (c3[1] + h3[1]) : 0, c3[2] > 0 ? c3[2] / (c3[2] + h3[2]) : 0]);
      }
      function HA(e4, t3, i3, r3, n4, o3) {
        const s6 = e4.zoom, a3 = e4.scale, l3 = e4.worldSize, c3 = 1 / l3, h3 = e4.aspect, u3 = Math.sqrt(1 + h3 * h3) * Math.tan(0.5 * e4.fovX), d3 = u3 * u3, p3 = r3 - i3, f3 = r3 + i3;
        let m3, _3;
        d3 > p3 / f3 ? (m3 = r3, _3 = r3 * u3) : (m3 = 0.5 * f3 * (1 + d3), _3 = 0.5 * Math.sqrt(p3 * p3 + 2 * (r3 * r3 + i3 * i3) * d3 + f3 * f3 * d3 * d3));
        const g3 = e4.projection.pixelsPerMeter(e4.center.lat, l3), y3 = e4._camera.getCameraToWorldMercator(), x3 = [0, 0, -m3 * c3];
        Du.transformMat4(x3, x3, y3);
        let v3 = _3 * c3;
        const b3 = e4._edgeInsets;
        if (!(0 === b3.left && 0 === b3.top && 0 === b3.right && 0 === b3.bottom || b3.left === b3.right && b3.top === b3.bottom)) {
          const t4 = e4._camera.getWorldToCamera(e4.worldSize, "meters" === e4.projection.zAxisUnit ? g3 : 1), n5 = e4._camera.getCameraToClipPerspective(e4._fov, e4.width / e4.height, i3, r3);
          n5[8] = 2 * -e4.centerOffset.x / e4.width, n5[9] = 2 * e4.centerOffset.y / e4.height;
          const o4 = new Float64Array(16);
          Au.mul(o4, n5, t4);
          const c4 = new Float64Array(16);
          Au.invert(c4, o4);
          const h4 = Qu.fromInvProjectionMatrix(c4, l3, s6, true);
          for (const t5 of h4.points) {
            const i4 = ((w3 = t5)[0] /= a3, w3[1] /= a3, w3[2] = Qd(w3[2], e4._center.lat), w3);
            v3 = Math.max(v3, Du.len(Du.subtract([], x3, i4)));
          }
        }
        var w3;
        v3 *= n4 / (n4 - 1);
        const T3 = Math.acos(t3[2]), E3 = Math.atan2(-t3[0], -t3[1]), M3 = new Yx();
        M3.position = x3, M3.setPitchBearing(T3, E3);
        const A3 = M3.getWorldToCamera(l3, g3), S3 = v3 * l3, I3 = Math.min(e4._mercatorZfromZoom(17) * l3 * -2, -2 * S3), C3 = M3.getCameraToClipOrthographic(-S3, S3, -S3, S3, I3, (S3 + o3 * g3) / t3[2]), z2 = new Float64Array(16);
        Au.multiply(z2, C3, A3);
        const P3 = Du.fromValues(Math.floor(1e6 * x3[0]) / 1e6 * l3, Math.floor(1e6 * x3[1]) / 1e6 * l3, 0), D2 = 0.5 * n4, R3 = [0, 0, 0];
        Du.transformMat4(R3, P3, z2), Du.scale(R3, R3, D2);
        const L3 = [Math.floor(R3[0]), Math.floor(R3[1]), Math.floor(R3[2])], k3 = [0, 0, 0];
        Du.sub(k3, R3, L3), Du.scale(k3, k3, -1 / D2);
        const O2 = new Float64Array(16);
        return Au.identity(O2), Au.translate(O2, O2, k3), Au.multiply(z2, O2, z2), [z2, S3];
      }
      class XA extends zt {
        constructor(e4) {
          super(), this.requestManager = e4, this.models = { "": {} }, this.numModelsLoading = {};
        }
        loadModel(e4, t3) {
          return fT(this.requestManager.transformRequest(t3, ye.Model).url).then((t4) => {
            if (!t4)
              return;
            const i3 = TT(t4), r3 = new Cv(e4, void 0, void 0, i3);
            return r3.computeBoundsAndApplyParent(), r3;
          }).catch((i3) => {
            this.fire(new Ct(new Error(`Could not load model ${e4} from ${t3}: ${i3.message}`)));
          });
        }
        load(e4, t3) {
          this.models[t3] || (this.models[t3] = {});
          const i3 = Object.keys(e4);
          this.numModelsLoading[t3] = (this.numModelsLoading[t3] || 0) + i3.length;
          const r3 = [];
          for (const t4 of i3)
            r3.push(this.loadModel(t4, e4[t4]));
          Promise.allSettled(r3).then((e5) => {
            for (let r4 = 0; r4 < e5.length; r4++) {
              const { status: n4, value: o3 } = e5[r4];
              "fulfilled" === n4 && o3 && (this.models[t3][i3[r4]] = o3);
            }
            this.numModelsLoading[t3] -= i3.length, this.fire(new It("data", { dataType: "style" }));
          }).catch((e5) => {
            this.fire(new Ct(new Error(`Could not load models: ${e5.message}`)));
          });
        }
        isLoaded() {
          for (const e4 in this.numModelsLoading)
            if (this.numModelsLoading[e4] > 0)
              return false;
          return true;
        }
        hasModel(e4, t3) {
          return !!this.getModel(e4, t3);
        }
        getModel(e4, t3) {
          return this.models[t3] || (this.models[t3] = {}), this.models[t3][e4];
        }
        addModel(e4, t3, i3) {
          this.models[i3] || (this.models[i3] = {}), this.hasModel(e4, i3) && this.removeModel(e4, i3), this.load({ [e4]: this.requestManager.normalizeModelURL(t3) }, i3);
        }
        addModels(e4, t3) {
          const i3 = {};
          for (const t4 in e4)
            i3[t4] = this.requestManager.normalizeModelURL(e4[t4]);
          this.load(i3, t3);
        }
        removeModel(e4, t3) {
          this.models[t3] || (this.models[t3] = {});
          const i3 = this.models[t3][e4];
          delete this.models[t3][e4], i3.destroy();
        }
        listModels(e4) {
          return this.models[e4] || (this.models[e4] = {}), Object.keys(this.models[e4]);
        }
        upload(e4, t3) {
          this.models[t3] || (this.models[t3] = {});
          for (const i3 in this.models[t3])
            this.models[t3][i3].upload(e4.context);
        }
      }
      const YA = (e4, t3) => Ss(e4, t3 && t3.filter((e5) => "source.canvas" !== e5.identifier)), KA = O(OT, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection", "setCamera", "addImport", "removeImport", "setImportUrl", "setImportData", "setImportConfig"]), JA = O(OT, ["setCenter", "setZoom", "setBearing", "setPitch"]), QA = { version: 8, layers: [], sources: {} }, eS = { duration: 300, delay: 0 }, tS = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
      class iS extends zt {
        constructor(e4, t3 = {}) {
          super(), this.map = e4, this.scope = t3.scope || "", this.fragments = [], this.importDepth = t3.importDepth || 0, this.importsCache = t3.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = t3.resolvedImports || /* @__PURE__ */ new Set(), this.transition = k2({}, eS), this._buildingIndex = new DT(this), this.crossTileSymbolIndex = new CE(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._changes = t3.styleChanges || new Ea(), this.dispatcher = t3.dispatcher ? t3.dispatcher : new Ew(Ww(), this), t3.imageManager ? this.imageManager = t3.imageManager : (this.imageManager = new aw(), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = t3.glyphManager ? t3.glyphManager : new og(e4._requestManager, t3.localFontFamily ? 2 : t3.localIdeographFontFamily ? 1 : 0, t3.localFontFamily || t3.localIdeographFontFamily), t3.modelManager ? this.modelManager = t3.modelManager : (this.modelManager = new XA(e4._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._order = [], this._markersNeedUpdate = false, this.options = /* @__PURE__ */ new Map(), this._configDependentLayers = /* @__PURE__ */ new Set(), this._config = t3.config, this.dispatcher.broadcast("setReferrer", ve());
          const i3 = this;
          this._rtlTextPluginCallback = iS.registerForPluginStateChange((e5) => {
            i3.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e5.pluginStatus, pluginURL: e5.pluginURL }, (e6, t4) => {
              if (Qs(e6), t4 && t4.every((e7) => e7))
                for (const e7 in i3._sourceCaches) {
                  const t5 = i3._sourceCaches[e7], r3 = t5.getSource().type;
                  "vector" !== r3 && "geojson" !== r3 || t5.reload();
                }
            });
          }), this.on("data", (e5) => {
            if ("source" !== e5.dataType || "metadata" !== e5.sourceDataType)
              return;
            const t4 = this.getOwnSource(e5.sourceId);
            if (t4 && t4.vectorLayerIds)
              for (const e6 in this._layers) {
                const i4 = this._layers[e6];
                i4.source === t4.id && this._validateLayer(i4);
              }
          });
        }
        loadURL(e4, t3 = {}) {
          this.fire(new It("dataloading", { dataType: "style" }));
          const i3 = "boolean" == typeof t3.validate ? t3.validate : !Pe(e4);
          e4 = this.map._requestManager.normalizeStyleURL(e4, t3.accessToken), this.resolvedImports.add(e4);
          const r3 = this.importsCache.get(e4);
          if (r3)
            return this._load(r3, i3);
          const n4 = this.map._requestManager.transformRequest(e4, ye.Style);
          this._request = we(n4, (t4, r4) => {
            if (this._request = null, t4)
              this.fire(new Ct(t4));
            else if (r4)
              return this.importsCache.set(e4, r4), this._load(r4, i3);
          });
        }
        loadJSON(e4, t3 = {}) {
          this.fire(new It("dataloading", { dataType: "style" })), this._request = dt.frame(() => {
            this._request = null, this._load(e4, false !== t3.validate);
          });
        }
        loadEmpty() {
          this.fire(new It("dataloading", { dataType: "style" })), this._load(QA, false);
        }
        _loadImports(e4, t3) {
          if (this.importDepth >= 4)
            return H2("Style doesn't support nesting deeper than 5"), Promise.resolve();
          const i3 = [];
          for (const r3 of e4) {
            const e5 = this._createFragmentStyle(r3), n4 = new Promise((t4) => {
              e5.once("style.import.load", t4), e5.once("error", t4);
            }).then(() => this.mergeAll());
            if (i3.push(n4), this.resolvedImports.has(r3.url)) {
              e5.loadEmpty();
              continue;
            }
            const o3 = r3.data || this.importsCache.get(r3.url);
            o3 ? e5.loadJSON(o3, { validate: t3 }) : r3.url ? e5.loadURL(r3.url, { validate: t3 }) : e5.loadEmpty(), this.fragments.push({ style: e5, id: r3.id, config: r3.config });
          }
          return Promise.allSettled(i3);
        }
        _createFragmentStyle(e4) {
          const t3 = this.scope ? va(e4.id, this.scope) : e4.id, i3 = new iS(this.map, { scope: t3, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: e4.config });
          return i3.setEventedParent(this.map, { style: i3 }), i3;
        }
        _reloadImports() {
          this.mergeAll(), this._updateMapProjection(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options });
          const e4 = this.isRootStyle();
          this._shouldPrecompile = e4, this.fire(new It(e4 ? "style.load" : "style.import.load"));
        }
        _load(e4, t3) {
          const i3 = e4.schema;
          if (this.isRootStyle() && (e4.fragment || i3 && false !== e4.fragment)) {
            const i4 = k2({}, QA, { imports: [{ id: "basemap", data: e4, url: "" }] });
            return void this._load(i4, t3);
          }
          if (this.setConfig(this._config, i3), t3 && YA(this, ms(e4)))
            return;
          this._loaded = true, this.stylesheet = $2(e4);
          for (const t4 in e4.sources)
            this.addSource(t4, e4.sources[t4], { validate: false, isInitialLoad: true });
          e4.sprite ? this._loadSprite(e4.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), this.glyphManager.setURL(e4.glyphs, this.scope);
          const r3 = kT(this.stylesheet.layers);
          if (this._order = r3.map((e5) => e5.id), this.stylesheet.light && H2("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights)
            if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
              const e5 = this.stylesheet.lights[0];
              this.light = new cw(e5.properties, e5.id);
            } else
              this.setLights(this.stylesheet.lights);
          this.light || (this.light = new cw(this.stylesheet.light)), this._layers = {}, this._serializedLayers = {};
          for (const e5 of r3) {
            const t4 = ow(e5, this.options);
            t4.setScope(this.scope), t4.isConfigDependent && this._configDependentLayers.add(t4.fqid), t4.setEventedParent(this, { layer: { id: t4.id } }), this._layers[t4.id] = t4, this._serializedLayers[t4.id] = t4.serialize();
            const i4 = this.getOwnLayerSourceCache(t4), r4 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
            i4 && t4.canCastShadows() && r4 && (i4.castsShadows = true);
          }
          this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
          const n4 = this.stylesheet.terrain;
          n4 && (void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = dt.hasCanvasFingerprintNoise()), this.disableElevatedTerrain ? H2("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).") : this.terrainSetForDrapingOnly() || this._createTerrain(n4, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new It("data", { dataType: "style" })), e4.imports ? this._loadImports(e4.imports, t3).then(() => this._reloadImports()) : this._reloadImports();
        }
        isRootStyle() {
          return 0 === this.importDepth;
        }
        mergeAll() {
          let e4, t3, i3, r3, n4, o3, s6, a3;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((l3) => {
            if (l3.stylesheet) {
              if (null != l3.light && (e4 = l3.light), l3.stylesheet.lights)
                for (const e5 of l3.stylesheet.lights)
                  "ambient" === e5.type && null != l3.ambientLight && (t3 = l3.ambientLight), "directional" === e5.type && null != l3.directionalLight && (i3 = l3.directionalLight);
              r3 = this._prioritizeTerrain(r3, l3.terrain, l3.stylesheet.terrain), l3.stylesheet.fog && null != l3.fog && (n4 = l3.fog), null != l3.stylesheet.camera && (a3 = l3.stylesheet.camera), null != l3.stylesheet.projection && (o3 = l3.stylesheet.projection), null != l3.stylesheet.transition && (s6 = l3.stylesheet.transition);
            }
          }), this.light = e4, this.ambientLight = t3, this.directionalLight = i3, this.fog = n4, null === r3 ? delete this.terrain : this.terrain = r3, this.camera = a3 || { "camera-projection": "perspective" }, this.projection = o3 || { name: "mercator" }, this.transition = k2({}, eS, s6), this.mergeSources(), this.mergeLayers();
        }
        forEachFragmentStyle(e4) {
          const t3 = (i3) => {
            for (const e5 of i3.fragments)
              t3(e5.style);
            e4(i3);
          };
          t3(this);
        }
        _prioritizeTerrain(e4, t3, i3) {
          const r3 = e4 && 0 === e4.drapeRenderMode;
          return null === i3 ? t3 && 0 === t3.drapeRenderMode ? t3 : r3 ? e4 : null : null != t3 && (!e4 || r3 || t3 && 1 === t3.drapeRenderMode) ? t3 : e4;
        }
        mergeTerrain() {
          let e4;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t3) => {
            e4 = this._prioritizeTerrain(e4, t3.terrain, t3.stylesheet.terrain);
          }), null === e4 ? delete this.terrain : this.terrain = e4;
        }
        mergeProjection() {
          let e4;
          this.forEachFragmentStyle((t3) => {
            null != t3.stylesheet.projection && (e4 = t3.stylesheet.projection);
          }), this.projection = e4 || { name: "mercator" };
        }
        mergeSources() {
          const e4 = {}, t3 = {}, i3 = {};
          this.forEachFragmentStyle((r3) => {
            for (const t4 in r3._sourceCaches) {
              const i4 = va(t4, r3.scope);
              e4[i4] = r3._sourceCaches[t4];
            }
            for (const e5 in r3._otherSourceCaches) {
              const i4 = va(e5, r3.scope);
              t3[i4] = r3._otherSourceCaches[e5];
            }
            for (const e5 in r3._symbolSourceCaches) {
              const t4 = va(e5, r3.scope);
              i3[t4] = r3._symbolSourceCaches[e5];
            }
          }), this._mergedSourceCaches = e4, this._mergedOtherSourceCaches = t3, this._mergedSymbolSourceCaches = i3;
        }
        mergeLayers() {
          const e4 = {}, t3 = [], i3 = {};
          this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((i4) => {
            for (const r4 of i4._order) {
              const n4 = i4._layers[r4];
              if ("slot" === n4.type) {
                const t4 = ba(r4);
                if (e4[t4])
                  continue;
                e4[t4] = [];
              }
              n4.slot && e4[n4.slot] ? e4[n4.slot].push(n4) : t3.push(n4);
            }
          }), this._mergedOrder = [];
          const r3 = (t4 = []) => {
            for (const n4 of t4)
              if ("slot" === n4.type) {
                const t5 = ba(n4.id);
                e4[t5] && r3(e4[t5]);
              } else {
                const e5 = va(n4.id, n4.scope);
                this._mergedOrder.push(e5), i3[e5] = n4, n4.is3D() && (this._has3DLayers = true), "circle" === n4.type && (this._hasCircleLayers = true), "symbol" === n4.type && (this._hasSymbolLayers = true);
              }
          };
          r3(t3), this._mergedLayers = i3, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && 0 === this.terrain.drapeRenderMode;
        }
        getCamera() {
          return this.stylesheet.camera;
        }
        setCamera(e4) {
          return this.stylesheet.camera = k2({}, this.stylesheet.camera, e4), this.camera = this.stylesheet.camera, this;
        }
        setProjection(e4) {
          e4 ? this.stylesheet.projection = e4 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
        }
        _updateMapProjection() {
          this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
        }
        _loadSprite(e4) {
          this._spriteRequest = function(e5, t3, i3) {
            let r3, n4, o3;
            const s6 = dt.devicePixelRatio > 1 ? "@2x" : "";
            let a3 = we(t3.transformRequest(t3.normalizeSpriteURL(e5, s6, ".json"), ye.SpriteJSON), (e6, t4) => {
              a3 = null, o3 || (o3 = e6, r3 = t4, c3());
            }), l3 = Ie(t3.transformRequest(t3.normalizeSpriteURL(e5, s6, ".png"), ye.SpriteImage), (e6, t4) => {
              l3 = null, o3 || (o3 = e6, n4 = t4, c3());
            });
            function c3() {
              if (o3)
                i3(o3);
              else if (r3 && n4) {
                const e6 = dt.getImageData(n4), t4 = {};
                for (const i4 in r3) {
                  const { width: n5, height: o4, x: s7, y: a4, sdf: l4, pixelRatio: c4, stretchX: h3, stretchY: u3, content: d3 } = r3[i4], p3 = new ef({ width: n5, height: o4 });
                  ef.copy(e6, p3, { x: s7, y: a4 }, { x: 0, y: 0 }, { width: n5, height: o4 }), t4[i4] = { data: p3, pixelRatio: c4, sdf: l4, stretchX: h3, stretchY: u3, content: d3 };
                }
                i3(null, t4);
              }
            }
            return { cancel() {
              a3 && (a3.cancel(), a3 = null), l3 && (l3.cancel(), l3 = null);
            } };
          }(e4, this.map._requestManager, (e5, t3) => {
            if (this._spriteRequest = null, e5)
              this.fire(new Ct(e5));
            else if (t3)
              for (const e6 in t3)
                this.imageManager.addImage(e6, this.scope, t3[e6]);
            this.imageManager.setLoaded(true, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new It("data", { dataType: "style" }));
          });
        }
        _validateLayer(e4) {
          const t3 = this.getOwnSource(e4.source);
          if (!t3)
            return;
          const i3 = e4.sourceLayer;
          i3 && ("geojson" === t3.type || t3.vectorLayerIds && -1 === t3.vectorLayerIds.indexOf(i3)) && this.fire(new Ct(new Error(`Source layer "${i3}" does not exist on source "${t3.id}" as specified by style layer "${e4.id}"`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._changes.getUpdatedSourceCaches()).length)
            return false;
          for (const e4 in this._sourceCaches)
            if (!this._sourceCaches[e4].loaded())
              return false;
          if (!this.imageManager.isLoaded())
            return false;
          if (!this.modelManager.isLoaded())
            return false;
          for (const { style: e4 } of this.fragments)
            if (!e4.loaded())
              return false;
          return true;
        }
        _serializeImports() {
          if (this.stylesheet.imports)
            return this.stylesheet.imports.map((e4, t3) => {
              const i3 = this.fragments[t3];
              return i3 && i3.style && (e4.data = i3.style.serialize()), e4;
            });
        }
        _serializeSources() {
          const e4 = {};
          for (const t3 in this._sourceCaches) {
            const i3 = this._sourceCaches[t3].getSource();
            e4[i3.id] || (e4[i3.id] = i3.serialize());
          }
          return e4;
        }
        _serializeLayers(e4) {
          const t3 = [];
          for (const i3 of e4) {
            const e5 = this._layers[i3];
            e5 && "custom" !== e5.type && t3.push(e5.serialize());
          }
          return t3;
        }
        hasLightTransitions() {
          return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
        }
        hasFogTransition() {
          return !!this.fog && this.fog.hasTransition();
        }
        hasTransitions() {
          if (this.hasLightTransitions())
            return true;
          if (this.hasFogTransition())
            return true;
          for (const e4 in this._sourceCaches)
            if (this._sourceCaches[e4].hasTransition())
              return true;
          for (const e4 in this._layers)
            if (this._layers[e4].hasTransition())
              return true;
          return false;
        }
        get order() {
          return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
        }
        isLayerDraped(e4) {
          return !!this.terrain && ("function" == typeof e4.isLayerDraped ? e4.isLayerDraped(this.getLayerSourceCache(e4)) : tS.has(e4.type));
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        _checkLayer(e4) {
          const t3 = this.getOwnLayer(e4);
          if (t3)
            return t3;
          this.fire(new Ct(new Error(`The layer '${e4}' does not exist in the map's style.`)));
        }
        _checkSource(e4) {
          const t3 = this.getOwnSource(e4);
          if (t3)
            return t3;
          this.fire(new Ct(new Error(`The source '${e4}' does not exist in the map's style.`)));
        }
        update(e4) {
          if (!this._loaded)
            return;
          this.ambientLight && this.ambientLight.recalculate(e4), this.directionalLight && this.directionalLight.recalculate(e4);
          const t3 = this.calculateLightsBrightness();
          e4.brightness = t3 || 0, t3 !== this._brightness && (this._brightness = t3, this.dispatcher.broadcast("setBrightness", t3));
          const i3 = this._changes.isDirty();
          if (this._changes.isDirty()) {
            const t4 = this._changes.getLayerUpdatesByScope();
            for (const e5 in t4) {
              const { updatedIds: i4, removedIds: r4 } = t4[e5];
              (i4 || r4) && this._updateWorkerLayers(e5, i4, r4);
            }
            this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(e4), this.light && this.light.updateTransitions(e4), this.ambientLight && this.ambientLight.updateTransitions(e4), this.directionalLight && this.directionalLight.updateTransitions(e4), this.fog && this.fog.updateTransitions(e4), this._changes.reset();
          }
          const r3 = {};
          for (const e5 in this._mergedSourceCaches) {
            const t4 = this._mergedSourceCaches[e5];
            r3[e5] = t4.used, t4.used = false;
          }
          for (const t4 of this._mergedOrder) {
            const i4 = this._mergedLayers[t4];
            if (i4.recalculate(e4, this._availableImages), !i4.isHidden(e4.zoom)) {
              const e5 = this.getLayerSourceCache(i4);
              e5 && (e5.used = true);
            }
            if (!this._precompileDone && this._shouldPrecompile)
              for (let t5 = i4.minzoom || 0; t5 < (i4.maxzoom || 25.5); t5++) {
                const t6 = this.map.painter;
                if (t6) {
                  const r4 = i4.getProgramIds();
                  if (!r4)
                    continue;
                  for (const n4 of r4) {
                    const r5 = i4.getDefaultProgramParams(n4, e4.zoom);
                    r5 && (t6.style = this, this.fog && (t6._fogVisible = true, r5.overrideFog = true, t6.getOrCreateProgram(n4, r5)), t6._fogVisible = false, r5.overrideFog = false, t6.getOrCreateProgram(n4, r5), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (r5.overrideRtt = true, t6.getOrCreateProgram(n4, r5)));
                  }
                }
              }
          }
          this._shouldPrecompile && (this._precompileDone = true);
          for (const e5 in r3) {
            const t4 = this._mergedSourceCaches[e5];
            r3[e5] !== t4.used && t4.getSource().fire(new It("data", { sourceDataType: "visibility", dataType: "source", sourceId: t4.getSource().id }));
          }
          this.light && this.light.recalculate(e4), this.terrain && this.terrain.recalculate(e4), this.fog && this.fog.recalculate(e4), this.z = e4.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i3 && this.fire(new It("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e4 = this._changes.getUpdatedImages();
          if (e4.length) {
            for (const t3 in this._sourceCaches)
              this._sourceCaches[t3].reloadTilesForDependencies(["icons", "patterns"], e4);
            this._changes.resetUpdatedImages();
          }
        }
        _updateWorkerLayers(e4, t3, i3) {
          const r3 = this.getFragmentStyle(e4);
          r3 && this.dispatcher.broadcast("updateLayers", { layers: t3 ? r3._serializeLayers(t3) : [], scope: e4, removedIds: i3 || [], options: r3.options });
        }
        setState(e4) {
          if (this._checkLoaded(), YA(this, ms(e4)))
            return false;
          (e4 = $2(e4)).layers = kT(e4.layers);
          const t3 = function(e5, t4) {
            if (!e5)
              return [{ command: OT.setStyle, args: [t4] }];
            let i4 = [];
            try {
              if (!x2(e5.version, t4.version))
                return [{ command: OT.setStyle, args: [t4] }];
              x2(e5.center, t4.center) || i4.push({ command: OT.setCenter, args: [t4.center] }), x2(e5.zoom, t4.zoom) || i4.push({ command: OT.setZoom, args: [t4.zoom] }), x2(e5.bearing, t4.bearing) || i4.push({ command: OT.setBearing, args: [t4.bearing] }), x2(e5.pitch, t4.pitch) || i4.push({ command: OT.setPitch, args: [t4.pitch] }), x2(e5.sprite, t4.sprite) || i4.push({ command: OT.setSprite, args: [t4.sprite] }), x2(e5.glyphs, t4.glyphs) || i4.push({ command: OT.setGlyphs, args: [t4.glyphs] }), x2(e5.imports, t4.imports) || function(e6 = [], t5 = [], i5) {
                t5 = t5 || [];
                const r4 = (e6 = e6 || []).map(jT), n5 = t5.map(jT), o4 = e6.reduce(GT, {}), s7 = t5.reduce(GT, {}), a3 = r4.slice();
                let l3, c3, h3, u3;
                for (l3 = 0, c3 = 0; l3 < r4.length; l3++)
                  h3 = r4[l3], s7.hasOwnProperty(h3) ? c3++ : (i5.push({ command: OT.removeImport, args: [h3] }), a3.splice(a3.indexOf(h3, c3), 1));
                for (l3 = 0, c3 = 0; l3 < n5.length; l3++)
                  h3 = n5[n5.length - 1 - l3], a3[a3.length - 1 - l3] !== h3 && (o4.hasOwnProperty(h3) ? (i5.push({ command: OT.removeImport, args: [h3] }), a3.splice(a3.lastIndexOf(h3, a3.length - c3), 1)) : c3++, u3 = a3[a3.length - l3], i5.push({ command: OT.addImport, args: [s7[h3], u3] }), a3.splice(a3.length - l3, 0, h3));
                for (const e7 of t5) {
                  const t6 = o4[e7.id];
                  if (!t6 || x2(t6, e7))
                    continue;
                  x2(t6.config, e7.config) || i5.push({ command: OT.setImportConfig, args: [e7.id, e7.config] }), x2(t6.url, e7.url) || i5.push({ command: OT.setImportUrl, args: [e7.id, e7.url] });
                  const r5 = e7.data;
                  x2(t6 && t6.data, r5) || i5.push({ command: OT.setImportData, args: [e7.id, r5] });
                }
              }(e5.imports, t4.imports, i4), x2(e5.transition, t4.transition) || i4.push({ command: OT.setTransition, args: [t4.transition] }), x2(e5.light, t4.light) || i4.push({ command: OT.setLight, args: [t4.light] }), x2(e5.fog, t4.fog) || i4.push({ command: OT.setFog, args: [t4.fog] }), x2(e5.projection, t4.projection) || i4.push({ command: OT.setProjection, args: [t4.projection] }), x2(e5.lights, t4.lights) || i4.push({ command: OT.setLights, args: [t4.lights] }), x2(e5.camera, t4.camera) || i4.push({ command: OT.setCamera, args: [t4.camera] });
              const r3 = {}, n4 = [];
              !function(e6, t5, i5, r4) {
                let n5;
                for (n5 in t5 = t5 || {}, e6 = e6 || {})
                  e6.hasOwnProperty(n5) && (t5.hasOwnProperty(n5) || FT(n5, i5, r4));
                for (n5 in t5) {
                  if (!t5.hasOwnProperty(n5))
                    continue;
                  const o4 = t5[n5];
                  e6.hasOwnProperty(n5) ? x2(e6[n5], o4) || ("geojson" === e6[n5].type && "geojson" === o4.type && UT(e6, t5, n5) ? i5.push({ command: OT.setGeoJSONSourceData, args: [n5, o4.data] }) : NT(n5, t5, i5, r4)) : BT(n5, t5, i5);
                }
              }(e5.sources, t4.sources, n4, r3);
              const o3 = [];
              e5.layers && e5.layers.forEach((e6) => {
                e6.source && r3[e6.source] ? i4.push({ command: OT.removeLayer, args: [e6.id] }) : o3.push(e6);
              });
              let s6 = e5.terrain;
              s6 && r3[s6.source] && (i4.push({ command: OT.setTerrain, args: [void 0] }), s6 = void 0), i4 = i4.concat(n4), x2(s6, t4.terrain) || i4.push({ command: OT.setTerrain, args: [t4.terrain] }), function(e6, t5, i5) {
                t5 = t5 || [];
                const r4 = (e6 = e6 || []).map(jT), n5 = t5.map(jT), o4 = e6.reduce(GT, {}), s7 = t5.reduce(GT, {}), a3 = r4.slice(), l3 = /* @__PURE__ */ Object.create(null);
                let c3, h3, u3, d3, p3, f3, m3;
                for (c3 = 0, h3 = 0; c3 < r4.length; c3++)
                  u3 = r4[c3], s7.hasOwnProperty(u3) ? h3++ : (i5.push({ command: OT.removeLayer, args: [u3] }), a3.splice(a3.indexOf(u3, h3), 1));
                for (c3 = 0, h3 = 0; c3 < n5.length; c3++)
                  u3 = n5[n5.length - 1 - c3], a3[a3.length - 1 - c3] !== u3 && (o4.hasOwnProperty(u3) ? (i5.push({ command: OT.removeLayer, args: [u3] }), a3.splice(a3.lastIndexOf(u3, a3.length - h3), 1)) : h3++, f3 = a3[a3.length - c3], i5.push({ command: OT.addLayer, args: [s7[u3], f3] }), a3.splice(a3.length - c3, 0, u3), l3[u3] = true);
                for (c3 = 0; c3 < n5.length; c3++)
                  if (u3 = n5[c3], d3 = o4[u3], p3 = s7[u3], !l3[u3] && !x2(d3, p3))
                    if (x2(d3.source, p3.source) && x2(d3["source-layer"], p3["source-layer"]) && x2(d3.type, p3.type)) {
                      for (m3 in VT(d3.layout, p3.layout, i5, u3, null, OT.setLayoutProperty), VT(d3.paint, p3.paint, i5, u3, null, OT.setPaintProperty), x2(d3.slot, p3.slot) || i5.push({ command: OT.setSlot, args: [u3, p3.slot] }), x2(d3.filter, p3.filter) || i5.push({ command: OT.setFilter, args: [u3, p3.filter] }), x2(d3.minzoom, p3.minzoom) && x2(d3.maxzoom, p3.maxzoom) || i5.push({ command: OT.setLayerZoomRange, args: [u3, p3.minzoom, p3.maxzoom] }), d3)
                        d3.hasOwnProperty(m3) && "layout" !== m3 && "paint" !== m3 && "filter" !== m3 && "metadata" !== m3 && "minzoom" !== m3 && "maxzoom" !== m3 && "slot" !== m3 && (0 === m3.indexOf("paint.") ? VT(d3[m3], p3[m3], i5, u3, m3.slice(6), OT.setPaintProperty) : x2(d3[m3], p3[m3]) || i5.push({ command: OT.setLayerProperty, args: [u3, m3, p3[m3]] }));
                      for (m3 in p3)
                        p3.hasOwnProperty(m3) && !d3.hasOwnProperty(m3) && "layout" !== m3 && "paint" !== m3 && "filter" !== m3 && "metadata" !== m3 && "minzoom" !== m3 && "maxzoom" !== m3 && "slot" !== m3 && (0 === m3.indexOf("paint.") ? VT(d3[m3], p3[m3], i5, u3, m3.slice(6), OT.setPaintProperty) : x2(d3[m3], p3[m3]) || i5.push({ command: OT.setLayerProperty, args: [u3, m3, p3[m3]] }));
                    } else
                      i5.push({ command: OT.removeLayer, args: [u3] }), f3 = a3[a3.lastIndexOf(u3) + 1], i5.push({ command: OT.addLayer, args: [p3, f3] });
              }(o3, t4.layers, i4);
            } catch (e6) {
              console.warn("Unable to compute style diff:", e6), i4 = [{ command: OT.setStyle, args: [t4] }];
            }
            return i4;
          }(this.serialize(), e4).filter((e5) => !(e5.command in JA));
          if (0 === t3.length)
            return false;
          const i3 = t3.filter((e5) => !(e5.command in KA));
          if (i3.length > 0)
            throw new Error(`Unimplemented: ${i3.map((e5) => e5.command).join(", ")}.`);
          return t3.forEach((e5) => {
            this[e5.command].apply(this, e5.args);
          }), this.stylesheet = e4, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
        }
        addImage(e4, t3) {
          return this.getImage(e4) ? this.fire(new Ct(new Error("An image with this name already exists."))) : (this.imageManager.addImage(e4, this.scope, t3), this._afterImageUpdated(e4), this);
        }
        updateImage(e4, t3) {
          this.imageManager.updateImage(e4, this.scope, t3);
        }
        getImage(e4) {
          return this.imageManager.getImage(e4, this.scope);
        }
        removeImage(e4) {
          return this.getImage(e4) ? (this.imageManager.removeImage(e4, this.scope), this._afterImageUpdated(e4), this) : this.fire(new Ct(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(e4) {
          this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(e4), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new It("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addModel(e4, t3, i3 = {}) {
          return this._checkLoaded(), this._validate(Ms, `models.${e4}`, t3, null, i3) || (this.modelManager.addModel(e4, t3, this.scope), this._changes.setDirty()), this;
        }
        hasModel(e4) {
          return this.modelManager.hasModel(e4, this.scope);
        }
        removeModel(e4) {
          return this.hasModel(e4) ? (this.modelManager.removeModel(e4, this.scope), this) : this.fire(new Ct(new Error("No model with this ID exists.")));
        }
        listModels() {
          return this._checkLoaded(), this.modelManager.listModels(this.scope);
        }
        addSource(e4, t3, i3 = {}) {
          if (this._checkLoaded(), void 0 !== this.getOwnSource(e4))
            throw new Error(`There is already a source with ID "${e4}".`);
          if (!t3.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(t3).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(t3.type) >= 0 && this._validate(_s, `sources.${e4}`, t3, null, i3))
            return;
          this.map && this.map._collectResourceTiming && (t3.collectResourceTiming = true);
          const r3 = ST(e4, t3, this.dispatcher, this);
          r3.scope = this.scope, r3.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(r3.id), source: r3.serialize(), sourceId: r3.id }));
          const n4 = (e5) => {
            const t4 = (e5 ? "symbol:" : "other:") + r3.id, i4 = va(t4, this.scope), n5 = this._sourceCaches[t4] = new Lx(i4, r3, e5);
            (e5 ? this._symbolSourceCaches : this._otherSourceCaches)[r3.id] = n5, n5.onAdd(this.map);
          };
          n4(false), "vector" !== t3.type && "geojson" !== t3.type || n4(true), r3.onAdd && r3.onAdd(this.map), i3.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
        }
        removeSource(e4) {
          this._checkLoaded();
          const t3 = this.getOwnSource(e4);
          if (!t3)
            throw new Error("There is no source with this ID");
          for (const t4 in this._layers)
            if (this._layers[t4].source === e4)
              return this.fire(new Ct(new Error(`Source "${e4}" cannot be removed while layer "${t4}" is using it.`)));
          if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === e4)
            return this.fire(new Ct(new Error(`Source "${e4}" cannot be removed while terrain is using it.`)));
          const i3 = this.getOwnSourceCaches(e4);
          for (const e5 of i3) {
            const t4 = ba(e5.id);
            delete this._sourceCaches[t4], this._changes.discardSourceCacheUpdate(e5.id), e5.fire(new It("data", { sourceDataType: "metadata", dataType: "source", sourceId: e5.getSource().id })), e5.setEventedParent(null), e5.clearTiles();
          }
          return delete this._otherSourceCaches[e4], delete this._symbolSourceCaches[e4], this.mergeSources(), t3.setEventedParent(null), t3.onRemove && t3.onRemove(this.map), this._changes.setDirty(), this;
        }
        setGeoJSONSourceData(e4, t3) {
          this._checkLoaded(), this.getOwnSource(e4).setData(t3), this._changes.setDirty();
        }
        getOwnSource(e4) {
          const t3 = this.getOwnSourceCache(e4);
          return t3 && t3.getSource();
        }
        getOwnSources() {
          const e4 = [];
          for (const t3 in this._otherSourceCaches) {
            const i3 = this.getOwnSourceCache(t3);
            i3 && e4.push(i3.getSource());
          }
          return e4;
        }
        setLights(e4) {
          if (this._checkLoaded(), !e4)
            return delete this.ambientLight, void delete this.directionalLight;
          const t3 = this._getTransitionParameters();
          for (const i4 of e4) {
            if (this._validate(ys, "lights", i4))
              return;
            switch (i4.type) {
              case "ambient":
                if (this.ambientLight) {
                  const e5 = this.ambientLight;
                  e5.set(i4), e5.updateTransitions(t3);
                } else
                  this.ambientLight = new Mw(i4, Aw, this.scope, this.options);
                break;
              case "directional":
                if (this.directionalLight) {
                  const e5 = this.directionalLight;
                  e5.set(i4), e5.updateTransitions(t3);
                } else
                  this.directionalLight = new Mw(i4, Sw, this.scope, this.options);
            }
          }
          const i3 = new oa(this.z || 0, t3);
          this.ambientLight && this.ambientLight.recalculate(i3), this.directionalLight && this.directionalLight.recalculate(i3), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
        }
        calculateLightsBrightness() {
          const e4 = this.directionalLight, t3 = this.ambientLight;
          if (!e4 || !t3)
            return;
          const i3 = (e5) => 0.2126 * (e5[0] <= 0.03928 ? e5[0] / 12.92 : Math.pow((e5[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e5[1] <= 0.03928 ? e5[1] / 12.92 : Math.pow((e5[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e5[2] <= 0.03928 ? e5[2] / 12.92 : Math.pow((e5[2] + 0.055) / 1.055, 2.4)), r3 = e4.properties.get("color").toArray01(), n4 = e4.properties.get("intensity"), o3 = e4.properties.get("direction"), s6 = 1 - J(o3.x, o3.y, o3.z)[2] / 90, a3 = i3(r3) * n4 * s6, l3 = t3.properties.get("color").toArray01(), c3 = t3.properties.get("intensity");
          return (a3 + i3(l3) * c3) / 2;
        }
        getBrightness() {
          return this._brightness;
        }
        getLights() {
          if (!this.enable3dLights())
            return null;
          const e4 = [];
          return this.directionalLight && e4.push(this.directionalLight.get()), this.ambientLight && e4.push(this.ambientLight.get()), e4;
        }
        enable3dLights() {
          return !!this.ambientLight && !!this.directionalLight;
        }
        getFragmentStyle(e4) {
          if (!e4)
            return this;
          if (xa(e4)) {
            const t3 = function(e5) {
              const t4 = e5.indexOf(ya);
              return t4 >= 0 ? e5.slice(t4 + 1) : "";
            }(e4), i3 = this.fragments.find(({ id: e5 }) => e5 === t3);
            if (!i3)
              throw new Error(`Style import not found: ${e4}`);
            const r3 = ba(e4);
            return i3.style.getFragmentStyle(r3);
          }
          {
            const t3 = this.fragments.find(({ id: t4 }) => t4 === e4);
            if (!t3)
              throw new Error(`Style import not found: ${e4}`);
            return t3.style;
          }
        }
        getConfigProperty(e4, t3) {
          const i3 = this.getFragmentStyle(e4);
          if (!i3)
            return null;
          const r3 = i3.options.get(t3), n4 = r3 ? r3.value || r3.default : null;
          return n4 ? n4.serialize() : null;
        }
        setConfigProperty(e4, t3, i3) {
          const r3 = Eo(i3);
          if ("success" !== r3.result)
            return void YA(this, r3.value);
          const n4 = r3.value.expression, o3 = this.getFragmentStyle(e4);
          if (!o3)
            return;
          const s6 = o3.options.get(t3);
          s6 && (o3.options.set(t3, { ...s6, value: n4 }), o3.updateConfigDependencies());
        }
        setConfig(e4, t3) {
          if (this._config = e4, e4 || t3)
            if (t3) {
              this.options.clear();
              for (const i3 in t3) {
                let r3, n4;
                const o3 = Eo(t3[i3].default);
                if ("success" === o3.result && (r3 = o3.value.expression), e4 && void 0 !== e4[i3]) {
                  const t4 = Eo(e4[i3]);
                  "success" === t4.result && (n4 = t4.value.expression);
                }
                const { minValue: s6, maxValue: a3, stepValue: l3, type: c3, values: h3 } = t3[i3];
                r3 ? this.options.set(i3, { default: r3, value: n4, minValue: s6, maxValue: a3, stepValue: l3, type: c3, values: h3 }) : this.fire(new Ct(new Error(`No schema defined for config option "${i3}".`)));
              }
            } else
              this.fire(new Ct(new Error("Attempting to set config for a style without schema.")));
        }
        updateConfigDependencies() {
          for (const e4 of this._configDependentLayers) {
            const t3 = this.getLayer(e4);
            t3 && (t3.possiblyEvaluateVisibility(), this._updateLayer(t3));
          }
          this.ambientLight && this.ambientLight.scope === this.scope && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.scope === this.scope && this.directionalLight.updateConfig(this.options), this._changes.setDirty();
        }
        addLayer(e4, t3, i3 = {}) {
          this._checkLoaded();
          const r3 = e4.id;
          if (this._layers[r3])
            return void this.fire(new Ct(new Error(`Layer with id "${r3}" already exists on this map`)));
          let n4;
          if ("custom" === e4.type) {
            if (YA(this, function(e5) {
              const t4 = [], i4 = e5.id;
              return void 0 === i4 && t4.push({ message: `layers.${i4}: missing required property "id"` }), void 0 === e5.render && t4.push({ message: `layers.${i4}: missing required method "render"` }), e5.renderingMode && "2d" !== e5.renderingMode && "3d" !== e5.renderingMode && t4.push({ message: `layers.${i4}: property "renderingMode" must be either "2d" or "3d"` }), t4;
            }(e4)))
              return;
            n4 = ow(e4, this.options);
          } else {
            if ("object" == typeof e4.source && (this.addSource(r3, e4.source), e4 = k2(e4 = $2(e4), { source: r3 })), this._validate(bs, `layers.${r3}`, e4, { arrayIndex: -1 }, i3))
              return;
            n4 = ow(e4, this.options), this._validateLayer(n4), n4.setEventedParent(this, { layer: { id: r3 } }), this._serializedLayers[n4.id] = n4.serialize();
          }
          n4.isConfigDependent && this._configDependentLayers.add(n4.fqid), n4.setScope(this.scope);
          let o3 = this._order.length;
          if (t3) {
            const e5 = this._order.indexOf(t3);
            if (-1 === e5)
              return void this.fire(new Ct(new Error(`Layer with id "${t3}" does not exist on this map.`)));
            n4.slot === this._layers[t3].slot ? o3 = e5 : H2(`Layer with id "${t3}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(o3, 0, r3), this._layerOrderChanged = true, this._layers[r3] = n4;
          const s6 = this.getOwnLayerSourceCache(n4), a3 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
          s6 && n4.canCastShadows() && a3 && (s6.castsShadows = true);
          const l3 = this._changes.getRemovedLayer(n4);
          if (l3 && n4.source && s6 && "custom" !== n4.type) {
            this._changes.discardLayerRemoval(n4);
            const e5 = va(n4.source, n4.scope);
            l3.type !== n4.type ? this._changes.updateSourceCache(e5, "clear") : (this._changes.updateSourceCache(e5, "reload"), s6.pause());
          }
          this._updateLayer(n4), n4.onAdd && n4.onAdd(this.map), n4.scope = this.scope, this.mergeLayers();
        }
        moveLayer(e4, t3) {
          this._checkLoaded();
          const i3 = this._checkLayer(e4);
          if (!i3)
            return;
          if (e4 === t3)
            return;
          const r3 = this._order.indexOf(e4);
          this._order.splice(r3, 1);
          let n4 = this._order.length;
          if (t3) {
            const e5 = this._order.indexOf(t3);
            if (-1 === e5)
              return void this.fire(new Ct(new Error(`Layer with id "${t3}" does not exist on this map.`)));
            i3.slot === this._layers[t3].slot ? n4 = e5 : H2(`Layer with id "${t3}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(n4, 0, e4), this._changes.setDirty(), this._layerOrderChanged = true, this.mergeLayers();
        }
        removeLayer(e4) {
          this._checkLoaded();
          const t3 = this._checkLayer(e4);
          if (!t3)
            return;
          t3.setEventedParent(null);
          const i3 = this._order.indexOf(e4);
          this._order.splice(i3, 1), delete this._layers[e4], delete this._serializedLayers[e4], this._changes.setDirty(), this._layerOrderChanged = true, this._configDependentLayers.delete(t3.fqid), this._changes.removeLayer(t3);
          const r3 = this.getOwnLayerSourceCache(t3);
          if (r3 && r3.castsShadows) {
            let e5 = false;
            for (const i4 in this._layers)
              if (this._layers[i4].source === t3.source && this._layers[i4].canCastShadows()) {
                e5 = true;
                break;
              }
            r3.castsShadows = e5;
          }
          t3.onRemove && t3.onRemove(this.map), this.mergeLayers();
        }
        getOwnLayer(e4) {
          return this._layers[e4];
        }
        hasLayer(e4) {
          return e4 in this._mergedLayers;
        }
        hasLayerType(e4) {
          for (const t3 in this._layers)
            if (this._layers[t3].type === e4)
              return true;
          return false;
        }
        setLayerZoomRange(e4, t3, i3) {
          this._checkLoaded();
          const r3 = this._checkLayer(e4);
          r3 && (r3.minzoom === t3 && r3.maxzoom === i3 || (null != t3 && (r3.minzoom = t3), null != i3 && (r3.maxzoom = i3), this._updateLayer(r3)));
        }
        setSlot(e4, t3) {
          this._checkLoaded();
          const i3 = this._checkLayer(e4);
          i3 && i3.slot !== t3 && (i3.slot = t3, this._updateLayer(i3));
        }
        setFilter(e4, t3, i3 = {}) {
          this._checkLoaded();
          const r3 = this._checkLayer(e4);
          if (r3 && !x2(r3.filter, t3))
            return null == t3 ? (r3.filter = void 0, void this._updateLayer(r3)) : void (this._validate(ws, `layers.${r3.id}.filter`, t3, { layerType: r3.type }, i3) || (r3.filter = $2(t3), this._updateLayer(r3)));
        }
        getFilter(e4) {
          const t3 = this._checkLayer(e4);
          if (t3)
            return $2(t3.filter);
        }
        setLayoutProperty(e4, t3, i3, r3 = {}) {
          this._checkLoaded();
          const n4 = this._checkLayer(e4);
          n4 && (x2(n4.getLayoutProperty(t3), i3) || (n4.setLayoutProperty(t3, i3, r3), n4.isConfigDependent && this._configDependentLayers.add(n4.fqid), this._updateLayer(n4)));
        }
        getLayoutProperty(e4, t3) {
          const i3 = this._checkLayer(e4);
          if (i3)
            return i3.getLayoutProperty(t3);
        }
        setPaintProperty(e4, t3, i3, r3 = {}) {
          this._checkLoaded();
          const n4 = this._checkLayer(e4);
          if (!n4)
            return;
          if (x2(n4.getPaintProperty(t3), i3))
            return;
          const o3 = n4.setPaintProperty(t3, i3, r3);
          n4.isConfigDependent && this._configDependentLayers.add(n4.fqid), o3 && this._updateLayer(n4), this._changes.updatePaintProperties(n4);
        }
        getPaintProperty(e4, t3) {
          const i3 = this._checkLayer(e4);
          if (i3)
            return i3.getPaintProperty(t3);
        }
        setFeatureState(e4, t3) {
          this._checkLoaded();
          const i3 = e4.source, r3 = e4.sourceLayer, n4 = this._checkSource(i3);
          if (!n4)
            return;
          const o3 = n4.type;
          if ("geojson" === o3 && r3)
            return void this.fire(new Ct(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if ("vector" === o3 && !r3)
            return void this.fire(new Ct(new Error("The sourceLayer parameter must be provided for vector source types.")));
          void 0 === e4.id && this.fire(new Ct(new Error("The feature id parameter must be provided.")));
          const s6 = this.getOwnSourceCaches(i3);
          for (const i4 of s6)
            i4.setFeatureState(r3, e4.id, t3);
        }
        removeFeatureState(e4, t3) {
          this._checkLoaded();
          const i3 = e4.source, r3 = this._checkSource(i3);
          if (!r3)
            return;
          const n4 = r3.type, o3 = "vector" === n4 ? e4.sourceLayer : void 0;
          if ("vector" === n4 && !o3)
            return void this.fire(new Ct(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (t3 && "string" != typeof e4.id && "number" != typeof e4.id)
            return void this.fire(new Ct(new Error("A feature id is required to remove its specific state property.")));
          const s6 = this.getOwnSourceCaches(i3);
          for (const i4 of s6)
            i4.removeFeatureState(o3, e4.id, t3);
        }
        getFeatureState(e4) {
          this._checkLoaded();
          const t3 = e4.source, i3 = e4.sourceLayer, r3 = this._checkSource(t3);
          if (r3) {
            if ("vector" !== r3.type || i3)
              return void 0 === e4.id && this.fire(new Ct(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(t3)[0].getFeatureState(i3, e4.id);
            this.fire(new Ct(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
        }
        setTransition(e4) {
          return this.stylesheet.transition = k2({}, this.stylesheet.transition, e4), this.transition = this.stylesheet.transition, this;
        }
        getTransition() {
          return k2({}, this.stylesheet.transition);
        }
        serialize() {
          this._checkLoaded();
          const e4 = this.getTerrain(), t3 = e4 && this.terrain && this.terrain.scope === this.scope ? e4 : this.stylesheet.terrain;
          return Z2({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: t3, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e5) => void 0 !== e5);
        }
        _updateLayer(e4) {
          this._changes.updateLayer(e4);
          const t3 = this.getLayerSourceCache(e4), i3 = va(e4.source, e4.scope), r3 = this._changes.getUpdatedSourceCaches();
          e4.source && !r3[i3] && t3 && "raster" !== t3.getSource().type && (this._changes.updateSourceCache(i3, "reload"), t3.pause()), e4.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(e4) {
          const t3 = (e5) => "fill-extrusion" === this._mergedLayers[e5].type, i3 = this.order, r3 = {}, n4 = [];
          for (let o4 = i3.length - 1; o4 >= 0; o4--) {
            const s6 = i3[o4];
            if (t3(s6)) {
              r3[s6] = o4;
              for (const t4 of e4) {
                const e5 = t4[s6];
                if (e5)
                  for (const t5 of e5)
                    n4.push(t5);
              }
            }
          }
          n4.sort((e5, t4) => t4.intersectionZ - e5.intersectionZ);
          const o3 = [];
          for (let s6 = i3.length - 1; s6 >= 0; s6--) {
            const a3 = i3[s6];
            if (t3(a3))
              for (let e5 = n4.length - 1; e5 >= 0; e5--) {
                const t4 = n4[e5].feature;
                if (r3[t4.layer.id] < s6)
                  break;
                o3.push(t4), n4.pop();
              }
            else
              for (const t4 of e4) {
                const e5 = t4[a3];
                if (e5)
                  for (const t5 of e5)
                    o3.push(t5.feature);
              }
          }
          return o3;
        }
        queryRenderedFeatures(e4, t3, i3) {
          t3 && t3.filter && this._validate(ws, "queryRenderedFeatures.filter", t3.filter, null, t3), t3.scope = this.scope, t3.availableImages = this._availableImages, t3.serializedLayers = this._serializedLayers;
          const r3 = {};
          if (t3 && t3.layers) {
            if (!Array.isArray(t3.layers))
              return this.fire(new Ct(new Error("parameters.layers must be an Array."))), [];
            for (const e5 of t3.layers) {
              const t4 = this._mergedLayers[e5];
              if (!t4)
                return this.fire(new Ct(new Error(`The layer '${e5}' does not exist in the map's style and cannot be queried for features.`))), [];
              r3[t4.source] = true;
            }
          }
          const n4 = [], o3 = t3.serializedLayers || {}, s6 = t3 && t3.layers ? t3.layers.some((e5) => {
            const t4 = this.getLayer(e5);
            return t4 && t4.is3D();
          }) : this.has3DLayers(), a3 = Iw.createFromScreenPoints(e4, i3);
          for (const e5 in this._mergedSourceCaches) {
            const l3 = this._mergedSourceCaches[e5].getSource();
            if (!l3 || l3.scope !== t3.scope)
              continue;
            const c3 = this._mergedSourceCaches[e5].getSource().id;
            t3.layers && !r3[c3] || n4.push(CT(this._mergedSourceCaches[e5], this._mergedLayers, o3, a3, t3, i3, s6, !!this.map._showQueryGeometry));
          }
          return this.placement && n4.push(function(e5, t4, i4, r4, n5, o4, s7) {
            const a4 = {}, l3 = o4.queryRenderedSymbols(r4), c3 = [];
            for (const e6 of Object.keys(l3).map(Number))
              c3.push(s7[e6]);
            c3.sort(PT);
            for (const i5 of c3) {
              const r5 = i5.featureIndex.lookupSymbolFeatures(l3[i5.bucketInstanceId], t4, i5.bucketIndex, i5.sourceLayerIndex, n5.filter, n5.layers, n5.availableImages, e5);
              for (const e6 in r5) {
                const t5 = a4[e6] = a4[e6] || [], n6 = r5[e6];
                n6.sort((e7, t6) => {
                  const r6 = i5.featureSortOrder;
                  if (r6) {
                    const i6 = r6.indexOf(e7.featureIndex);
                    return r6.indexOf(t6.featureIndex) - i6;
                  }
                  return t6.featureIndex - e7.featureIndex;
                });
                for (const e7 of n6)
                  t5.push(e7);
              }
            }
            for (const t5 in a4)
              a4[t5].forEach((r5) => {
                const n6 = r5.feature, o5 = i4(e5[t5]);
                if (!o5)
                  return;
                const s8 = o5.getFeatureState(n6.layer["source-layer"], n6.id);
                n6.source = n6.layer.source, n6.layer["source-layer"] && (n6.sourceLayer = n6.layer["source-layer"]), n6.state = s8;
              });
            return a4;
          }(this._mergedLayers, o3, this.getLayerSourceCache.bind(this), a3.screenGeometry, t3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n4);
        }
        querySourceFeatures(e4, t3) {
          t3 && t3.filter && this._validate(ws, "querySourceFeatures.filter", t3.filter, null, t3);
          const i3 = this.getOwnSourceCaches(e4);
          let r3 = [];
          for (const e5 of i3)
            r3 = r3.concat(zT(e5, t3));
          return r3;
        }
        addSourceType(e4, t3, i3) {
          return iS.getSourceType(e4) ? i3(new Error(`A source type called "${e4}" already exists.`)) : (iS.setSourceType(e4, t3), t3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e4, url: t3.workerSourceURL }, i3) : i3(null, null));
        }
        getFlatLight() {
          return this.light.getLight();
        }
        setFlatLight(e4, t3, i3 = {}) {
          this._checkLoaded();
          const r3 = this.light.getLight();
          let n4 = false;
          for (const t4 in e4)
            if (!x2(e4[t4], r3[t4])) {
              n4 = true;
              break;
            }
          if (!n4)
            return;
          const o3 = this._getTransitionParameters();
          this.light.setLight(e4, t3, i3), this.light.updateTransitions(o3);
        }
        getTerrain() {
          return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        setTerrain(e4, t3 = 1) {
          if (this._checkLoaded(), !e4)
            return delete this.terrain, null === e4 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
          let i3 = e4;
          const r3 = null == e4.source;
          if (1 === t3) {
            if ("object" == typeof i3.source) {
              const e6 = "terrain-dem-src";
              this.addSource(e6, i3.source), i3 = $2(i3), i3 = k2(i3, { source: e6 });
            }
            const e5 = k2({}, i3), t4 = {};
            if (this.terrain && r3) {
              e5.source = this.terrain.get().source;
              const i4 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
              i4 && (t4.style = i4.serialize());
            }
            if (this._validate(xs, "terrain", e5, t4))
              return;
          }
          if (!this.terrain || this.terrain.scope !== this.scope && !r3 || this.terrain && t3 !== this.terrain.drapeRenderMode) {
            if (!i3)
              return;
            this._createTerrain(i3, t3), this.fire(new It("data", { dataType: "style" }));
          } else {
            const t4 = this.terrain, r4 = t4.get();
            for (const e5 of Object.keys(Pt.terrain))
              !i3.hasOwnProperty(e5) && Pt.terrain[e5].default && (i3[e5] = Pt.terrain[e5].default);
            for (const i4 in e4)
              if (!x2(e4[i4], r4[i4])) {
                t4.set(e4, this.options), this.stylesheet.terrain = e4;
                const i5 = this._getTransitionParameters({ duration: 0 });
                t4.updateTransitions(i5), this.fire(new It("data", { dataType: "style" }));
                break;
              }
          }
          this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
        }
        _createFog(e4) {
          const t3 = this.fog = new vw(e4, this.map.transform);
          this.stylesheet.fog = t3.get();
          const i3 = this._getTransitionParameters({ duration: 0 });
          t3.updateTransitions(i3);
        }
        _updateMarkersOpacity() {
          0 !== this.map._markers.length && this.map._requestDomTask(() => {
            for (const e4 of this.map._markers)
              e4._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(e4) {
          if (this._checkLoaded(), !e4)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
          if (this.fog) {
            const t3 = this.fog;
            if (!x2(t3.get(), e4)) {
              t3.set(e4), this.stylesheet.fog = t3.get();
              const i3 = this._getTransitionParameters({ duration: 0 });
              t3.updateTransitions(i3);
            }
          } else
            this._createFog(e4);
          this._markersNeedUpdate = true;
        }
        _getTransitionParameters(e4) {
          return { now: dt.now(), transition: k2(this.transition, e4) };
        }
        updateDrapeFirstLayers() {
          if (!this.terrain)
            return;
          const e4 = [], t3 = [];
          for (const i3 in this._mergedLayers)
            this.isLayerDraped(this._mergedLayers[i3]) ? e4.push(i3) : t3.push(i3);
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e4), this._drapedFirstOrder.push(...t3);
        }
        _createTerrain(e4, t3) {
          const i3 = this.terrain = new uw(e4, t3, this.scope, this.options);
          1 === t3 && (this.stylesheet.terrain = e4), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
          const r3 = this._getTransitionParameters({ duration: 0 });
          i3.updateTransitions(r3);
        }
        _force3DLayerUpdate() {
          for (const e4 in this._layers) {
            const t3 = this._layers[e4];
            "fill-extrusion" === t3.type && this._updateLayer(t3);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const e4 in this._layers) {
            const t3 = this._layers[e4];
            "symbol" === t3.type && this._updateLayer(t3);
          }
        }
        _validate(e4, t3, i3, r3, n4 = {}) {
          if (n4 && false === n4.validate)
            return false;
          const o3 = k2({}, this.serialize());
          return YA(this, e4.call(ms, k2({ key: t3, style: o3, value: i3, styleSpec: Pt }, r3)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), ta.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const e4 in this._mergedLayers)
            this._mergedLayers[e4].setEventedParent(null);
          for (const e4 in this._mergedSourceCaches)
            this._mergedSourceCaches[e4].clearTiles(), this._mergedSourceCaches[e4].setEventedParent(null);
          this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
        }
        clearSource(e4) {
          const t3 = this.getSourceCaches(e4);
          for (const e5 of t3)
            e5.clearTiles();
        }
        clearSources() {
          for (const e4 in this._mergedSourceCaches)
            this._mergedSourceCaches[e4].clearTiles();
        }
        reloadSource(e4) {
          const t3 = this.getSourceCaches(e4);
          for (const e5 of t3)
            e5.resume(), e5.reload();
        }
        reloadSources() {
          for (const e4 of this.getSources())
            e4.reload && e4.reload();
        }
        updateSources(e4) {
          let t3;
          this.directionalLight && (t3 = $A(this.directionalLight));
          for (const i3 in this._mergedSourceCaches)
            this._mergedSourceCaches[i3].update(e4, void 0, void 0, t3);
        }
        _generateCollisionBoxes() {
          for (const e4 in this._sourceCaches) {
            const t3 = this._sourceCaches[e4];
            t3.resume(), t3.reload();
          }
        }
        _updatePlacement(e4, t3, i3, r3, n4 = false) {
          let o3 = false, s6 = false;
          const a3 = {}, l3 = {};
          for (const t4 of this._mergedOrder) {
            const i4 = this._mergedLayers[t4];
            if ("symbol" !== i4.type)
              continue;
            const r4 = va(i4.source, i4.scope);
            let n5 = a3[r4];
            if (!n5) {
              const e5 = this.getLayerSourceCache(i4);
              if (!e5)
                continue;
              const t5 = e5.getRenderableIds(true).map((t6) => e5.getTileByID(t6));
              l3[r4] = t5.slice(), n5 = a3[r4] = t5.sort((e6, t6) => t6.tileID.overscaledZ - e6.tileID.overscaledZ || (e6.tileID.isLessThan(t6.tileID) ? -1 : 1));
            }
            const s7 = this.crossTileSymbolIndex.addLayer(i4, n5, e4.center.lng, e4.projection);
            o3 = o3 || s7;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), n4 = n4 || this._layerOrderChanged || 0 === i3, this._layerOrderChanged && this.fire(new It("neworder")), (n4 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(dt.now(), e4.zoom)) && (this.pauseablePlacement = new gE(e4, this._mergedOrder, n4, t3, i3, r3, this.placement, this.fog && e4.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, a3, l3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(dt.now()), s6 = true), o3 && this.pauseablePlacement.placement.setStale()), s6 || o3)
            for (const e5 of this._mergedOrder) {
              const t4 = this._mergedLayers[e5];
              "symbol" === t4.type && this.placement.updateLayerOpacities(t4, a3[va(t4.source, t4.scope)]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(dt.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e4 in this._sourceCaches)
            this._sourceCaches[e4].releaseSymbolFadeTiles();
        }
        addImport(e4) {
          this._checkLoaded();
          const t3 = this.stylesheet.imports = this.stylesheet.imports || [], i3 = t3.findIndex(({ id: t4 }) => t4 === e4.id);
          return -1 !== i3 ? this.fire(new Ct(new Error(`Import with id '${e4.id}' already exists in the map's style.`))) : (t3.push(e4), this._loadImports([e4], true), this);
        }
        setImportUrl(e4, t3) {
          this._checkLoaded();
          const i3 = this.stylesheet.imports || [], r3 = this.getImportIndex(e4);
          if (-1 === r3)
            return this;
          i3[r3].url = t3;
          const n4 = this.fragments[r3];
          return n4.style = this._createFragmentStyle(i3[r3]), n4.style.on("style.import.load", () => this.mergeAll()), n4.style.loadURL(t3), this;
        }
        setImportData(e4, t3) {
          this._checkLoaded();
          const i3 = this.getImportIndex(e4), r3 = this.stylesheet.imports || [];
          return -1 === i3 ? this : t3 ? (this.fragments[i3].style.setState(t3), this._reloadImports(), this) : (delete r3[i3].data, this.setImportUrl(e4, r3[i3].url));
        }
        setImportConfig(e4, t3) {
          this._checkLoaded();
          const i3 = this.getImportIndex(e4), r3 = this.stylesheet.imports || [];
          if (-1 === i3)
            return this;
          t3 ? r3[i3].config = t3 : delete r3[i3].config;
          const n4 = this.fragments[i3], o3 = n4.style.stylesheet && n4.style.stylesheet.schema;
          return n4.config = t3, n4.style.setConfig(t3, o3), n4.style.updateConfigDependencies(), this;
        }
        removeImport(e4) {
          this._checkLoaded();
          const t3 = this.stylesheet.imports || [], i3 = this.getImportIndex(e4);
          return -1 === i3 || (t3.splice(i3, 1), this.fragments[i3].style._remove(), this.fragments.splice(i3, 1), this._reloadImports()), this;
        }
        getImportIndex(e4) {
          const t3 = (this.stylesheet.imports || []).findIndex((t4) => t4.id === e4);
          return -1 === t3 && this.fire(new Ct(new Error(`Import '${e4}' does not exist in the map's style and cannot be updated.`))), t3;
        }
        getLayer(e4) {
          return this._mergedLayers[e4];
        }
        getSources() {
          const e4 = [];
          for (const t3 in this._mergedOtherSourceCaches) {
            const i3 = this._mergedOtherSourceCaches[t3];
            i3 && e4.push(i3.getSource());
          }
          return e4;
        }
        getSource(e4, t3) {
          const i3 = this.getSourceCache(e4, t3);
          return i3 && i3.getSource();
        }
        getLayerSource(e4) {
          const t3 = this.getLayerSourceCache(e4);
          return t3 && t3.getSource();
        }
        getSourceCache(e4, t3) {
          const i3 = va(e4, t3);
          return this._mergedOtherSourceCaches[i3];
        }
        getLayerSourceCache(e4) {
          const t3 = va(e4.source, e4.scope);
          return "symbol" === e4.type ? this._mergedSymbolSourceCaches[t3] : this._mergedOtherSourceCaches[t3];
        }
        getSourceCaches(e4) {
          const t3 = [];
          return this._mergedOtherSourceCaches[e4] && t3.push(this._mergedOtherSourceCaches[e4]), this._mergedSymbolSourceCaches[e4] && t3.push(this._mergedSymbolSourceCaches[e4]), t3;
        }
        updateSourceCaches() {
          const e4 = this._changes.getUpdatedSourceCaches();
          for (const t3 in e4) {
            const i3 = e4[t3];
            "reload" === i3 ? this.reloadSource(t3) : "clear" === i3 && this.clearSource(t3);
          }
        }
        updateLayers(e4) {
          const t3 = this._changes.getUpdatedPaintProperties();
          for (const i3 of t3) {
            const t4 = this.getLayer(i3);
            t4 && t4.updateTransitions(e4);
          }
        }
        getImages(e4, t3, i3) {
          this.imageManager.getImages(t3.icons, t3.scope, i3), this._updateTilesForChangedImages();
          const r3 = (e5) => {
            e5 && e5.setDependencies(t3.tileID.key, t3.type, t3.icons);
          };
          r3(this._otherSourceCaches[t3.source]), r3(this._symbolSourceCaches[t3.source]);
        }
        getGlyphs(e4, t3, i3) {
          this.glyphManager.getGlyphs(t3.stacks, t3.scope, i3);
        }
        getResource(e4, t3, i3) {
          return be(t3, i3);
        }
        getOwnSourceCache(e4) {
          return this._otherSourceCaches[e4];
        }
        getOwnLayerSourceCache(e4) {
          return "symbol" === e4.type ? this._symbolSourceCaches[e4.source] : this._otherSourceCaches[e4.source];
        }
        getOwnSourceCaches(e4) {
          const t3 = [];
          return this._otherSourceCaches[e4] && t3.push(this._otherSourceCaches[e4]), this._symbolSourceCaches[e4] && t3.push(this._symbolSourceCaches[e4]), t3;
        }
        _isSourceCacheLoaded(e4) {
          const t3 = this.getOwnSourceCaches(e4);
          return 0 === t3.length ? (this.fire(new Ct(new Error(`There is no source with ID '${e4}'`))), false) : t3.every((e5) => e5.loaded());
        }
        has3DLayers() {
          return this._has3DLayers;
        }
        hasSymbolLayers() {
          return this._hasSymbolLayers;
        }
        hasCircleLayers() {
          return this._hasCircleLayers;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      function rS(e4, t3) {
        let i3 = false, r3 = null;
        const n4 = () => {
          r3 = null, i3 && (e4(), r3 = setTimeout(n4, t3), i3 = false);
        };
        return () => (i3 = true, r3 || n4(), r3);
      }
      iS.getSourceType = function(e4) {
        return AT[e4];
      }, iS.setSourceType = function(e4, t3) {
        AT[e4] = t3;
      }, iS.registerForPluginStateChange = function(e4) {
        return e4({ pluginStatus: Ks, pluginURL: Js }), ta.on("pluginStateChange", e4), e4;
      };
      class nS {
        constructor(e4) {
          this._hashName = e4 && encodeURIComponent(e4), j2(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = rS(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(e4) {
          return this._map = e4, t2.addEventListener("hashchange", this._onHashChange, false), e4.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), t2.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const e4 = this._map;
          if (!e4)
            return "";
          const i3 = oS(e4);
          if (this._hashName) {
            const e5 = this._hashName;
            let r3 = false;
            const n4 = t2.location.hash.slice(1).split("&").map((t3) => {
              const n5 = t3.split("=")[0];
              return n5 === e5 ? (r3 = true, `${n5}=${i3}`) : t3;
            }).filter((e6) => e6);
            return r3 || n4.push(`${e5}=${i3}`), `#${n4.join("&")}`;
          }
          return `#${i3}`;
        }
        _getCurrentHash() {
          const e4 = t2.location.hash.replace("#", "");
          if (this._hashName) {
            let t3;
            return e4.split("&").map((e5) => e5.split("=")).forEach((e5) => {
              e5[0] === this._hashName && (t3 = e5);
            }), (t3 && t3[1] || "").split("/");
          }
          return e4.split("/");
        }
        _onHashChange() {
          const e4 = this._map;
          if (!e4)
            return false;
          const t3 = this._getCurrentHash();
          if (t3.length >= 3 && !t3.some((e5) => isNaN(e5))) {
            const i3 = e4.dragRotate.isEnabled() && e4.touchZoomRotate.isEnabled() ? +(t3[3] || 0) : e4.getBearing();
            return e4.jumpTo({ center: [+t3[2], +t3[1]], zoom: +t3[0], bearing: i3, pitch: +(t3[4] || 0) }), true;
          }
          return false;
        }
        _updateHashUnthrottled() {
          const e4 = t2.location.href.replace(/(#.+)?$/, this.getHashString());
          t2.history.replaceState(t2.history.state, null, e4);
        }
      }
      function oS(e4, t3) {
        const i3 = e4.getCenter(), r3 = Math.round(100 * e4.getZoom()) / 100, n4 = Math.ceil((r3 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o3 = Math.pow(10, n4), s6 = Math.round(i3.lng * o3) / o3, a3 = Math.round(i3.lat * o3) / o3, l3 = e4.getBearing(), c3 = e4.getPitch();
        let h3 = t3 ? `/${s6}/${a3}/${r3}` : `${r3}/${a3}/${s6}`;
        return (l3 || c3) && (h3 += "/" + Math.round(10 * l3) / 10), c3 && (h3 += `/${Math.round(c3)}`), h3;
      }
      const sS = { linearity: 0.3, easing: I2(0, 0, 0.3, 1) }, aS = k2({ deceleration: 2500, maxSpeed: 1400 }, sS), lS = k2({ deceleration: 20, maxSpeed: 1400 }, sS), cS = k2({ deceleration: 1e3, maxSpeed: 360 }, sS), hS = k2({ deceleration: 1e3, maxSpeed: 90 }, sS);
      class uS {
        constructor(e4) {
          this._map = e4, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(e4) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: dt.now(), settings: e4 });
        }
        _drainInertiaBuffer() {
          const e4 = this._inertiaBuffer, t3 = dt.now();
          for (; e4.length > 0 && t3 - e4[0].time > 160; )
            e4.shift();
        }
        _onMoveEnd(e4) {
          if (this._map._prefersReducedMotion())
            return;
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const t3 = { zoom: 0, bearing: 0, pitch: 0, pan: new y2(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: e5 } of this._inertiaBuffer)
            t3.zoom += e5.zoomDelta || 0, t3.bearing += e5.bearingDelta || 0, t3.pitch += e5.pitchDelta || 0, e5.panDelta && t3.pan._add(e5.panDelta), e5.around && (t3.around = e5.around), e5.pinchAround && (t3.pinchAround = e5.pinchAround);
          const i3 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r3 = {};
          if (t3.pan.mag()) {
            const n4 = pS(t3.pan.mag(), i3, k2({}, aS, e4 || {}));
            r3.offset = t3.pan.mult(n4.amount / t3.pan.mag()), r3.center = this._map.transform.center, dS(r3, n4);
          }
          if (t3.zoom) {
            const e5 = pS(t3.zoom, i3, lS);
            r3.zoom = this._map.transform.zoom + e5.amount, dS(r3, e5);
          }
          if (t3.bearing) {
            const e5 = pS(t3.bearing, i3, cS);
            r3.bearing = this._map.transform.bearing + z(e5.amount, -179, 179), dS(r3, e5);
          }
          if (t3.pitch) {
            const e5 = pS(t3.pitch, i3, hS);
            r3.pitch = this._map.transform.pitch + e5.amount, dS(r3, e5);
          }
          if (r3.zoom || r3.bearing) {
            const e5 = void 0 === t3.pinchAround ? t3.around : t3.pinchAround;
            r3.around = e5 ? this._map.unproject(e5) : this._map.getCenter();
          }
          return this.clear(), r3.noMoveStart = true, r3;
        }
      }
      function dS(e4, t3) {
        (!e4.duration || e4.duration < t3.duration) && (e4.duration = t3.duration, e4.easing = t3.easing);
      }
      function pS(e4, t3, i3) {
        const { maxSpeed: r3, linearity: n4, deceleration: o3 } = i3, s6 = z(e4 * n4 / (t3 / 1e3), -r3, r3), a3 = Math.abs(s6) / (o3 * n4);
        return { easing: i3.easing, duration: 1e3 * a3, amount: s6 * (a3 / 2) };
      }
      class fS extends It {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e4, t3, i3, r3 = {}) {
          const n4 = wt(t3.getCanvasContainer(), i3);
          super(e4, k2({ point: n4, lngLat: t3.unproject(n4), originalEvent: i3 }, r3)), this._defaultPrevented = false, this.target = t3;
        }
      }
      class mS extends It {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e4, t3, i3) {
          const r3 = "touchend" === e4 ? i3.changedTouches : i3.touches, n4 = Tt(t3.getCanvasContainer(), r3), o3 = n4.map((e5) => t3.unproject(e5)), s6 = n4.reduce((e5, t4, i4, r4) => e5.add(t4.div(r4.length)), new y2(0, 0));
          super(e4, { points: n4, point: s6, lngLats: o3, lngLat: t3.unproject(s6), originalEvent: i3 }), this._defaultPrevented = false;
        }
      }
      class _S extends It {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e4, t3, i3) {
          super(e4, { originalEvent: i3 }), this._defaultPrevented = false;
        }
      }
      class gS {
        constructor(e4, t3) {
          this._map = e4, this._clickTolerance = t3.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(e4) {
          return this._firePreventable(new _S(e4.type, this._map, e4));
        }
        mousedown(e4, t3) {
          return this._mousedownPos = t3, this._firePreventable(new fS(e4.type, this._map, e4));
        }
        mouseup(e4) {
          this._map.fire(new fS(e4.type, this._map, e4));
        }
        preclick(e4) {
          const t3 = k2({}, e4);
          t3.type = "preclick", this._map.fire(new fS(t3.type, this._map, t3));
        }
        click(e4, t3) {
          this._mousedownPos && this._mousedownPos.dist(t3) >= this._clickTolerance || (this.preclick(e4), this._map.fire(new fS(e4.type, this._map, e4)));
        }
        dblclick(e4) {
          return this._firePreventable(new fS(e4.type, this._map, e4));
        }
        mouseover(e4) {
          this._map.fire(new fS(e4.type, this._map, e4));
        }
        mouseout(e4) {
          this._map.fire(new fS(e4.type, this._map, e4));
        }
        touchstart(e4) {
          return this._firePreventable(new mS(e4.type, this._map, e4));
        }
        touchmove(e4) {
          this._map.fire(new mS(e4.type, this._map, e4));
        }
        touchend(e4) {
          this._map.fire(new mS(e4.type, this._map, e4));
        }
        touchcancel(e4) {
          this._map.fire(new mS(e4.type, this._map, e4));
        }
        _firePreventable(e4) {
          if (this._map.fire(e4), e4.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class yS {
        constructor(e4) {
          this._map = e4;
        }
        reset() {
          this._delayContextMenu = false, this._contextMenuEvent = void 0;
        }
        mousemove(e4) {
          this._map.fire(new fS(e4.type, this._map, e4));
        }
        mousedown() {
          this._delayContextMenu = true;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new fS("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e4) {
          this._delayContextMenu ? this._contextMenuEvent = e4 : this._map.fire(new fS(e4.type, this._map, e4)), this._map.listens("contextmenu") && e4.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class xS {
        constructor(e4, t3) {
          this._map = e4, this._el = e4.getCanvasContainer(), this._container = e4.getContainer(), this._clickTolerance = t3.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e4, t3) {
          this.isEnabled() && e4.shiftKey && 0 === e4.button && (yt(), this._startPos = this._lastPos = t3, this._active = true);
        }
        mousemoveWindow(e4, t3) {
          if (!this._active)
            return;
          const i3 = t3, r3 = this._startPos, n4 = this._lastPos;
          if (!r3 || !n4 || n4.equals(i3) || !this._box && i3.dist(r3) < this._clickTolerance)
            return;
          this._lastPos = i3, this._box || (this._box = pt("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e4));
          const o3 = Math.min(r3.x, i3.x), s6 = Math.max(r3.x, i3.x), a3 = Math.min(r3.y, i3.y), l3 = Math.max(r3.y, i3.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${o3}px,${a3}px)`, this._box.style.width = s6 - o3 + "px", this._box.style.height = l3 - a3 + "px");
          });
        }
        mouseupWindow(e4, t3) {
          if (!this._active)
            return;
          const i3 = this._startPos, r3 = t3;
          if (i3 && 0 === e4.button) {
            if (this.reset(), bt(), i3.x !== r3.x || i3.y !== r3.y)
              return this._map.fire(new It("boxzoomend", { originalEvent: e4 })), { cameraAnimation: (e5) => e5.fitScreenCoordinates(i3, r3, this._map.getBearing(), { linear: false }) };
            this._fireEvent("boxzoomcancel", e4);
          }
        }
        keydown(e4) {
          this._active && 27 === e4.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e4));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), xt(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(e4, t3) {
          return this._map.fire(new It(e4, { originalEvent: t3 }));
        }
      }
      function vS(e4, t3) {
        const i3 = {};
        for (let r3 = 0; r3 < e4.length; r3++)
          i3[e4[r3].identifier] = t3[r3];
        return i3;
      }
      class bS {
        constructor(e4) {
          this.reset(), this.numTouches = e4.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
        }
        touchstart(e4, t3, i3) {
          (this.centroid || i3.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = e4.timeStamp), i3.length === this.numTouches && (this.centroid = function(e5) {
            const t4 = new y2(0, 0);
            for (const i4 of e5)
              t4._add(i4);
            return t4.div(e5.length);
          }(t3), this.touches = vS(i3, t3)));
        }
        touchmove(e4, t3, i3) {
          if (this.aborted || !this.centroid)
            return;
          const r3 = vS(i3, t3);
          for (const e5 in this.touches) {
            const t4 = r3[e5];
            (!t4 || t4.dist(this.touches[e5]) > 30) && (this.aborted = true);
          }
        }
        touchend(e4, t3, i3) {
          if ((!this.centroid || e4.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i3.length) {
            const e5 = !this.aborted && this.centroid;
            if (this.reset(), e5)
              return e5;
          }
        }
      }
      class wS {
        constructor(e4) {
          this.singleTap = new bS(e4), this.numTaps = e4.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(e4, t3, i3) {
          this.singleTap.touchstart(e4, t3, i3);
        }
        touchmove(e4, t3, i3) {
          this.singleTap.touchmove(e4, t3, i3);
        }
        touchend(e4, t3, i3) {
          const r3 = this.singleTap.touchend(e4, t3, i3);
          if (r3) {
            const t4 = e4.timeStamp - this.lastTime < 500, i4 = !this.lastTap || this.lastTap.dist(r3) < 30;
            if (t4 && i4 || this.reset(), this.count++, this.lastTime = e4.timeStamp, this.lastTap = r3, this.count === this.numTaps)
              return this.reset(), r3;
          }
        }
      }
      class TS {
        constructor() {
          this._zoomIn = new wS({ numTouches: 1, numTaps: 2 }), this._zoomOut = new wS({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e4, t3, i3) {
          this._zoomIn.touchstart(e4, t3, i3), this._zoomOut.touchstart(e4, t3, i3);
        }
        touchmove(e4, t3, i3) {
          this._zoomIn.touchmove(e4, t3, i3), this._zoomOut.touchmove(e4, t3, i3);
        }
        touchend(e4, t3, i3) {
          const r3 = this._zoomIn.touchend(e4, t3, i3), n4 = this._zoomOut.touchend(e4, t3, i3);
          return r3 ? (this._active = true, e4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() + 1, around: t4.unproject(r3) }, { originalEvent: e4 }) }) : n4 ? (this._active = true, e4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() - 1, around: t4.unproject(n4) }, { originalEvent: e4 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const ES = { 0: 1, 2: 2 };
      class MS {
        constructor(e4) {
          this.reset(), this._clickTolerance = e4.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(e4, t3) {
          return false;
        }
        _move(e4, t3) {
          return {};
        }
        mousedown(e4, t3) {
          if (this._lastPoint)
            return;
          const i3 = Et(e4);
          this._correctButton(e4, i3) && (this._lastPoint = t3, this._eventButton = i3);
        }
        mousemoveWindow(e4, t3) {
          const i3 = this._lastPoint;
          if (i3) {
            if (e4.preventDefault(), null != this._eventButton && function(e5, t4) {
              const i4 = ES[t4];
              return void 0 === e5.buttons || (e5.buttons & i4) !== i4;
            }(e4, this._eventButton))
              this.reset();
            else if (this._moved || !(t3.dist(i3) < this._clickTolerance))
              return this._moved = true, this._lastPoint = t3, this._move(i3, t3);
          }
        }
        mouseupWindow(e4) {
          this._lastPoint && Et(e4) === this._eventButton && (this._moved && bt(), this.reset());
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class AS extends MS {
        mousedown(e4, t3) {
          super.mousedown(e4, t3), this._lastPoint && (this._active = true);
        }
        _correctButton(e4, t3) {
          return 0 === t3 && !e4.ctrlKey;
        }
        _move(e4, t3) {
          return { around: t3, panDelta: t3.sub(e4) };
        }
      }
      class SS extends MS {
        _correctButton(e4, t3) {
          return 0 === t3 && e4.ctrlKey || 2 === t3;
        }
        _move(e4, t3) {
          const i3 = 0.8 * (t3.x - e4.x);
          if (i3)
            return this._active = true, { bearingDelta: i3 };
        }
        contextmenu(e4) {
          e4.preventDefault();
        }
      }
      class IS extends MS {
        _correctButton(e4, t3) {
          return 0 === t3 && e4.ctrlKey || 2 === t3;
        }
        _move(e4, t3) {
          const i3 = -0.5 * (t3.y - e4.y);
          if (i3)
            return this._active = true, { pitchDelta: i3 };
        }
        contextmenu(e4) {
          e4.preventDefault();
        }
      }
      class CS {
        constructor(e4, t3) {
          this._map = e4, this._el = e4.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = t3.clickTolerance || 1, this.reset(), j2(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new y2(0, 0);
        }
        touchstart(e4, t3, i3) {
          return this._calculateTransform(e4, t3, i3);
        }
        touchmove(e4, t3, i3) {
          if (this._active && !(i3.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (1 === i3.length && !ie())
                return void this._showTouchPanBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return e4.cancelable && e4.preventDefault(), this._calculateTransform(e4, t3, i3);
          }
        }
        touchend(e4, t3, i3) {
          this._calculateTransform(e4, t3, i3), this._active && i3.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(e4, t3, i3) {
          i3.length > 0 && (this._active = true);
          const r3 = vS(i3, t3), n4 = new y2(0, 0), o3 = new y2(0, 0);
          let s6 = 0;
          for (const e5 in r3) {
            const t4 = r3[e5], i4 = this._touches[e5];
            i4 && (n4._add(t4), o3._add(t4.sub(i4)), s6++, r3[e5] = t4);
          }
          if (this._touches = r3, s6 < this._minTouches || !o3.mag())
            return;
          const a3 = o3.div(s6);
          return this._sum._add(a3), this._sum.mag() < this._clickTolerance ? void 0 : { around: n4.div(s6), panDelta: a3 };
        }
        enable() {
          this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = pt("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 500);
        }
      }
      class zS {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, this._firstTwoTouches = void 0;
        }
        _start(e4) {
        }
        _move(e4, t3, i3) {
          return {};
        }
        touchstart(e4, t3, i3) {
          this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([t3[0], t3[1]]));
        }
        touchmove(e4, t3, i3) {
          const r3 = this._firstTwoTouches;
          if (!r3)
            return;
          e4.preventDefault();
          const [n4, o3] = r3, s6 = PS(i3, t3, n4), a3 = PS(i3, t3, o3);
          if (!s6 || !a3)
            return;
          const l3 = this._aroundCenter ? null : s6.add(a3).div(2);
          return this._move([s6, a3], l3, e4);
        }
        touchend(e4, t3, i3) {
          if (!this._firstTwoTouches)
            return;
          const [r3, n4] = this._firstTwoTouches, o3 = PS(i3, t3, r3), s6 = PS(i3, t3, n4);
          o3 && s6 || (this._active && bt(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e4) {
          this._enabled = true, this._aroundCenter = !!e4 && "center" === e4.around;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function PS(e4, t3, i3) {
        for (let r3 = 0; r3 < e4.length; r3++)
          if (e4[r3].identifier === i3)
            return t3[r3];
      }
      function DS(e4, t3) {
        return Math.log(e4 / t3) / Math.LN2;
      }
      class RS extends zS {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(e4) {
          this._startDistance = this._distance = e4[0].dist(e4[1]);
        }
        _move(e4, t3) {
          const i3 = this._distance;
          if (this._distance = e4[0].dist(e4[1]), this._active || !(Math.abs(DS(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: DS(this._distance, i3), pinchAround: t3 };
        }
      }
      function LS(e4, t3) {
        return 180 * e4.angleWith(t3) / Math.PI;
      }
      class kS extends zS {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(e4) {
          this._startVector = this._vector = e4[0].sub(e4[1]), this._minDiameter = e4[0].dist(e4[1]);
        }
        _move(e4, t3) {
          const i3 = this._vector;
          if (this._vector = e4[0].sub(e4[1]), i3 && (this._active || !this._isBelowThreshold(this._vector)))
            return this._active = true, { bearingDelta: LS(this._vector, i3), pinchAround: t3 };
        }
        _isBelowThreshold(e4) {
          this._minDiameter = Math.min(this._minDiameter, e4.mag());
          const t3 = 25 / (Math.PI * this._minDiameter) * 360, i3 = this._startVector;
          if (!i3)
            return false;
          const r3 = LS(e4, i3);
          return Math.abs(r3) < t3;
        }
      }
      function OS(e4) {
        return Math.abs(e4.y) > Math.abs(e4.x);
      }
      class BS extends zS {
        constructor(e4) {
          super(), this._map = e4;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(e4) {
          this._lastPoints = e4, OS(e4[0].sub(e4[1])) && (this._valid = false);
        }
        _move(e4, t3, i3) {
          const r3 = this._lastPoints;
          if (!r3)
            return;
          const n4 = e4[0].sub(r3[0]), o3 = e4[1].sub(r3[1]);
          return this._map._cooperativeGestures && !ie() && i3.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n4, o3, i3.timeStamp), !this._valid) ? void 0 : (this._lastPoints = e4, this._active = true, { pitchDelta: (n4.y + o3.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(e4, t3, i3) {
          if (void 0 !== this._valid)
            return this._valid;
          const r3 = e4.mag() >= 2, n4 = t3.mag() >= 2;
          if (!r3 && !n4)
            return;
          if (!r3 || !n4)
            return null == this._firstMove && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
          const o3 = e4.y > 0 == t3.y > 0;
          return OS(e4) && OS(t3) && o3;
        }
      }
      const FS = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class NS {
        constructor() {
          const e4 = FS;
          this._panStep = e4.panStep, this._bearingStep = e4.bearingStep, this._pitchStep = e4.pitchStep, this._rotationDisabled = false;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        keydown(e4) {
          if (e4.altKey || e4.ctrlKey || e4.metaKey)
            return;
          let t3 = 0, i3 = 0, r3 = 0, n4 = 0, o3 = 0;
          switch (e4.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t3 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t3 = -1;
              break;
            case 37:
              e4.shiftKey ? i3 = -1 : (e4.preventDefault(), n4 = -1);
              break;
            case 39:
              e4.shiftKey ? i3 = 1 : (e4.preventDefault(), n4 = 1);
              break;
            case 38:
              e4.shiftKey ? r3 = 1 : (e4.preventDefault(), o3 = -1);
              break;
            case 40:
              e4.shiftKey ? r3 = -1 : (e4.preventDefault(), o3 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i3 = 0, r3 = 0), { cameraAnimation: (s6) => {
            const a3 = s6.getZoom();
            s6.easeTo({ duration: 300, easeId: "keyboardHandler", easing: US, zoom: t3 ? Math.round(a3) + t3 * (e4.shiftKey ? 2 : 1) : a3, bearing: s6.getBearing() + i3 * this._bearingStep, pitch: s6.getPitch() + r3 * this._pitchStep, offset: [-n4 * this._panStep, -o3 * this._panStep], center: s6.getCenter() }, { originalEvent: e4 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function US(e4) {
        return e4 * (2 - e4);
      }
      const VS = 4.000244140625;
      class jS {
        constructor(e4, t3) {
          this._map = e4, this._el = e4.getCanvasContainer(), this._handler = t3, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, j2(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(e4) {
          this._defaultZoomRate = e4;
        }
        setWheelZoomRate(e4) {
          this._wheelZoomRate = e4;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || void 0 !== this._finishTimeout;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e4) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e4 && "center" === e4.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(e4) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!(e4.ctrlKey || e4.metaKey || this.isZooming() || ie()))
              return void this._showBlockerAlert();
            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let i3 = e4.deltaMode === t2.WheelEvent.DOM_DELTA_LINE ? 40 * e4.deltaY : e4.deltaY;
          const r3 = dt.now(), n4 = r3 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = r3, 0 !== i3 && i3 % VS == 0 ? this._type = "wheel" : 0 !== i3 && Math.abs(i3) < 4 ? this._type = "trackpad" : n4 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, e4)) : this._type || (this._type = Math.abs(n4 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), e4.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = e4, this._delta -= i3, this._active || this._start(e4)), e4.preventDefault();
        }
        _onTimeout(e4) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e4);
        }
        _start(e4) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const t3 = wt(this._el, e4);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t3, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const e4 = this._map.transform;
          "wheel" === this._type && e4.projection.wrap && (e4._center.lng >= 180 || e4._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const t3 = () => e4._terrainEnabled() && this._aroundCoord ? e4.computeZoomRelativeTo(this._aroundCoord) : e4.zoom;
          if (0 !== this._delta) {
            const i4 = "wheel" === this._type && Math.abs(this._delta) > VS ? this._wheelZoomRate : this._defaultZoomRate;
            let r4 = 2 / (1 + Math.exp(-Math.abs(this._delta * i4)));
            this._delta < 0 && 0 !== r4 && (r4 = 1 / r4);
            const n5 = t3(), o4 = Math.pow(2, n5), s7 = "number" == typeof this._targetZoom ? e4.zoomScale(this._targetZoom) : o4;
            this._targetZoom = Math.min(e4.maxZoom, Math.max(e4.minZoom, e4.scaleZoom(s7 * r4))), "wheel" === this._type && (this._startZoom = n5, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
          }
          const i3 = "number" == typeof this._targetZoom ? this._targetZoom : t3(), r3 = this._startZoom, n4 = this._easing;
          let o3, s6 = false;
          if ("wheel" === this._type && r3 && n4) {
            const e5 = Math.min((dt.now() - this._lastWheelEventTime) / 200, 1);
            o3 = Kr(r3, i3, n4(e5)), e5 < 1 ? this._frameId || (this._frameId = true) : s6 = true;
          } else
            o3 = i3, s6 = true;
          this._active = true, s6 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200));
          let a3 = o3 - t3();
          return a3 * this._lastDelta < 0 && (a3 = 0), { noInertia: true, needsRenderFrame: !s6, zoomDelta: a3, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(e4) {
          let t3 = C2;
          if (this._prevEase) {
            const e5 = this._prevEase, i3 = (dt.now() - e5.start) / e5.duration, r3 = e5.easing(i3 + 0.01) - e5.easing(i3), n4 = 0.27 / Math.sqrt(r3 * r3 + 1e-4) * 0.01;
            t3 = I2(n4, Math.sqrt(0.0729 - n4 * n4), 0.25, 1);
          }
          return this._prevEase = { start: dt.now(), duration: e4, easing: t3 }, t3;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = pt("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(t2.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
          }, 200);
        }
      }
      class GS {
        constructor(e4, t3) {
          this._clickZoom = e4, this._tapZoom = t3;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class qS {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        blur() {
          this.reset();
        }
        dblclick(e4, t3) {
          return e4.preventDefault(), { cameraAnimation: (i3) => {
            i3.easeTo({ duration: 300, zoom: i3.getZoom() + (e4.shiftKey ? -1 : 1), around: i3.unproject(t3) }, { originalEvent: e4 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ZS {
        constructor() {
          this._tap = new wS({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(e4, t3, i3) {
          this._swipePoint || (this._tapTime && e4.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i3.length > 0 && (this._swipePoint = t3[0], this._swipeTouch = i3[0].identifier) : this._tap.touchstart(e4, t3, i3));
        }
        touchmove(e4, t3, i3) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i3[0].identifier !== this._swipeTouch)
                return;
              const r3 = t3[0], n4 = r3.y - this._swipePoint.y;
              return this._swipePoint = r3, e4.preventDefault(), this._active = true, { zoomDelta: n4 / 128 };
            }
          } else
            this._tap.touchmove(e4, t3, i3);
        }
        touchend(e4, t3, i3) {
          this._tapTime ? this._swipePoint && 0 === i3.length && this.reset() : this._tap.touchend(e4, t3, i3) && (this._tapTime = e4.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class $S {
        constructor(e4, t3, i3) {
          this._el = e4, this._mousePan = t3, this._touchPan = i3;
        }
        enable(e4) {
          this._inertiaOptions = e4 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class WS {
        constructor(e4, t3, i3) {
          this._pitchWithRotate = e4.pitchWithRotate, this._mouseRotate = t3, this._mousePitch = i3;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class HS {
        constructor(e4, t3, i3, r3) {
          this._el = e4, this._touchZoom = t3, this._touchRotate = i3, this._tapDragZoom = r3, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e4) {
          this._touchZoom.enable(e4), this._rotationDisabled || this._touchRotate.enable(e4), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const XS = (e4) => e4.zoom || e4.drag || e4.pitch || e4.rotate;
      class YS extends It {
      }
      class KS {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(e4, t3) {
          const i3 = Du.sub([], t3, e4);
          this.radius = Du.length(i3[2] < 0 ? Du.div([], i3, this.constants) : [i3[0], i3[1], 0]);
        }
        projectRay(e4) {
          Du.div(e4, e4, this.constants), Du.normalize(e4, e4), Du.mul(e4, e4, this.constants);
          const t3 = Du.scale([], e4, this.radius);
          if (t3[2] > 0) {
            const e5 = Du.scale([], [0, 0, 1], Du.dot(t3, [0, 0, 1])), i3 = Du.scale([], Du.normalize([], [t3[0], t3[1], 0]), this.radius), r3 = Du.add([], t3, Du.scale([], Du.sub([], Du.add([], i3, e5), t3), 2));
            t3[0] = r3[0], t3[1] = r3[1];
          }
          return t3;
        }
      }
      function JS(e4) {
        return e4.panDelta && e4.panDelta.mag() || e4.zoomDelta || e4.bearingDelta || e4.pitchDelta;
      }
      class QS {
        constructor(e4, i3) {
          this._map = e4, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new uS(e4), this._bearingSnap = i3.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new KS(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i3), j2(["handleEvent", "handleWindowEvent"], this);
          const r3 = this._el;
          this._listeners = [[r3, "touchstart", { passive: true }], [r3, "touchmove", { passive: false }], [r3, "touchend", void 0], [r3, "touchcancel", void 0], [r3, "mousedown", void 0], [r3, "mousemove", void 0], [r3, "mouseup", void 0], [t2.document, "mousemove", { capture: true }], [t2.document, "mouseup", void 0], [r3, "mouseover", void 0], [r3, "mouseout", void 0], [r3, "dblclick", void 0], [r3, "click", void 0], [r3, "keydown", { capture: false }], [r3, "keyup", void 0], [r3, "wheel", { passive: false }], [r3, "contextmenu", void 0], [t2, "blur", void 0]];
          for (const [e5, i4, r4] of this._listeners)
            e5.addEventListener(i4, e5 === t2.document ? this.handleWindowEvent : this.handleEvent, r4);
        }
        destroy() {
          for (const [e4, i3, r3] of this._listeners)
            e4.removeEventListener(i3, e4 === t2.document ? this.handleWindowEvent : this.handleEvent, r3);
        }
        _addDefaultHandlers(e4) {
          const t3 = this._map, i3 = t3.getCanvasContainer();
          this._add("mapEvent", new gS(t3, e4));
          const r3 = t3.boxZoom = new xS(t3, e4);
          this._add("boxZoom", r3);
          const n4 = new TS(), o3 = new qS();
          t3.doubleClickZoom = new GS(o3, n4), this._add("tapZoom", n4), this._add("clickZoom", o3);
          const s6 = new ZS();
          this._add("tapDragZoom", s6);
          const a3 = t3.touchPitch = new BS(t3);
          this._add("touchPitch", a3);
          const l3 = new SS(e4), c3 = new IS(e4);
          t3.dragRotate = new WS(e4, l3, c3), this._add("mouseRotate", l3, ["mousePitch"]), this._add("mousePitch", c3, ["mouseRotate"]);
          const h3 = new AS(e4), u3 = new CS(t3, e4);
          t3.dragPan = new $S(i3, h3, u3), this._add("mousePan", h3), this._add("touchPan", u3, ["touchZoom", "touchRotate"]);
          const d3 = new kS(), p3 = new RS();
          t3.touchZoomRotate = new HS(i3, p3, d3, s6), this._add("touchRotate", d3, ["touchPan", "touchZoom"]), this._add("touchZoom", p3, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new yS(t3));
          const f3 = t3.scrollZoom = new jS(t3, this);
          this._add("scrollZoom", f3, ["mousePan"]);
          const m3 = t3.keyboard = new NS();
          this._add("keyboard", m3);
          for (const i4 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            e4.interactive && e4[i4] && t3[i4].enable(e4[i4]);
        }
        _add(e4, t3, i3) {
          this._handlers.push({ handlerName: e4, handler: t3, allowed: i3 }), this._handlersById[e4] = t3;
        }
        stop(e4) {
          if (!this._updatingCamera) {
            for (const { handler: e5 } of this._handlers)
              e5.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e4), this._changes = [], this._originalZoom = void 0;
          }
        }
        isActive() {
          for (const { handler: e4 } of this._handlers)
            if (e4.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!XS(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(e4, t3, i3) {
          for (const r3 in e4)
            if (r3 !== i3 && (!t3 || t3.indexOf(r3) < 0))
              return true;
          return false;
        }
        handleWindowEvent(e4) {
          this.handleEvent(e4, `${e4.type}Window`);
        }
        _getMapTouches(e4) {
          const t3 = [];
          for (const i3 of e4)
            this._el.contains(i3.target) && t3.push(i3);
          return t3;
        }
        handleEvent(e4, t3) {
          this._updatingCamera = true;
          const i3 = "renderFrame" === e4.type, r3 = i3 ? void 0 : e4, n4 = { needsRenderFrame: false }, o3 = {}, s6 = {}, a3 = e4.touches ? this._getMapTouches(e4.touches) : void 0, l3 = a3 ? Tt(this._el, a3) : i3 ? void 0 : wt(this._el, e4);
          for (const { handlerName: i4, handler: c4, allowed: h4 } of this._handlers) {
            if (!c4.isEnabled())
              continue;
            let u3;
            this._blockedByActive(s6, h4, i4) ? c4.reset() : c4[t3 || e4.type] && (u3 = c4[t3 || e4.type](e4, l3, a3), this.mergeHandlerResult(n4, o3, u3, i4, r3), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || c4.isActive()) && (s6[i4] = c4);
          }
          const c3 = {};
          for (const e5 in this._previousActiveHandlers)
            s6[e5] || (c3[e5] = r3);
          this._previousActiveHandlers = s6, (Object.keys(c3).length || JS(n4)) && (this._changes.push([n4, o3, c3]), this._triggerRenderFrame()), (Object.keys(s6).length || JS(n4)) && this._map._stop(true), this._updatingCamera = false;
          const { cameraAnimation: h3 } = n4;
          h3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h3(this._map));
        }
        mergeHandlerResult(e4, t3, i3, r3, n4) {
          if (!i3)
            return;
          k2(e4, i3);
          const o3 = { handlerName: r3, originalEvent: i3.originalEvent || n4 };
          void 0 !== i3.zoomDelta && (t3.zoom = o3), void 0 !== i3.panDelta && (t3.drag = o3), void 0 !== i3.pitchDelta && (t3.pitch = o3), void 0 !== i3.bearingDelta && (t3.rotate = o3);
        }
        _applyChanges() {
          const e4 = {}, t3 = {}, i3 = {};
          for (const [r3, n4, o3] of this._changes)
            r3.panDelta && (e4.panDelta = (e4.panDelta || new y2(0, 0))._add(r3.panDelta)), r3.zoomDelta && (e4.zoomDelta = (e4.zoomDelta || 0) + r3.zoomDelta), r3.bearingDelta && (e4.bearingDelta = (e4.bearingDelta || 0) + r3.bearingDelta), r3.pitchDelta && (e4.pitchDelta = (e4.pitchDelta || 0) + r3.pitchDelta), void 0 !== r3.around && (e4.around = r3.around), void 0 !== r3.aroundCoord && (e4.aroundCoord = r3.aroundCoord), void 0 !== r3.pinchAround && (e4.pinchAround = r3.pinchAround), r3.noInertia && (e4.noInertia = r3.noInertia), k2(t3, n4), k2(i3, o3);
          this._updateMapTransform(e4, t3, i3), this._changes = [];
        }
        _updateMapTransform(e4, t3, i3) {
          const r3 = this._map, n4 = r3.transform, o3 = (e5) => [e5.x, e5.y, e5.z];
          if (((e5) => {
            const t4 = this._eventsInProgress.drag;
            return t4 && !this._handlersById[t4.handlerName].isActive();
          })() && !JS(e4)) {
            const e5 = n4.zoom;
            n4.cameraElevationReference = "sea", null != this._originalZoom && n4._orthographicProjectionAtLowPitch && "globe" !== n4.projection.name && 0 === n4.pitch ? (n4.cameraElevationReference = "ground", n4.zoom = this._originalZoom) : (n4.recenterOnTerrain(), n4.cameraElevationReference = "ground"), e5 !== n4.zoom && this._map._update(true);
          }
          if (n4._isCameraConstrained && r3._stop(true), !JS(e4))
            return void this._fireEvents(t3, i3, true);
          let { panDelta: s6, zoomDelta: a3, bearingDelta: l3, pitchDelta: c3, around: h3, aroundCoord: u3, pinchAround: d3 } = e4;
          n4._isCameraConstrained && (a3 > 0 && (a3 = 0), n4._isCameraConstrained = false), void 0 !== d3 && (h3 = d3), (a3 || ((e5) => t3[e5] && !this._eventsInProgress[e5])("drag")) && h3 && (this._dragOrigin = o3(n4.pointCoordinate3D(h3)), this._originalZoom = n4.zoom, this._trackingEllipsoid.setup(n4._camera.position, this._dragOrigin)), n4.cameraElevationReference = "sea", r3._stop(true), h3 = h3 || r3.transform.centerPoint, l3 && (n4.bearing += l3), c3 && (n4.pitch += c3), n4._updateCameraState();
          const p3 = [0, 0, 0];
          if (s6)
            if ("mercator" === n4.projection.name) {
              const e5 = this._trackingEllipsoid.projectRay(n4.screenPointToMercatorRay(h3).dir), t4 = this._trackingEllipsoid.projectRay(n4.screenPointToMercatorRay(h3.sub(s6)).dir);
              p3[0] = t4[0] - e5[0], p3[1] = t4[1] - e5[1];
            } else {
              const e5 = n4.pointCoordinate(h3);
              if ("globe" === n4.projection.name) {
                s6 = s6.rotate(-n4.angle);
                const t4 = n4._pixelsPerMercatorPixel / n4.worldSize;
                p3[0] = -s6.x * sp(tp(e5.y)) * t4, p3[1] = -s6.y * sp(n4.center.lat) * t4;
              } else {
                const t4 = n4.pointCoordinate(h3.sub(s6));
                e5 && t4 && (p3[0] = t4.x - e5.x, p3[1] = t4.y - e5.y);
              }
            }
          const f3 = n4.zoom, m3 = [0, 0, 0];
          if (a3) {
            const e5 = o3(u3 || n4.pointCoordinate3D(h3)), t4 = { dir: Du.normalize([], Du.sub([], e5, n4._camera.position)) };
            if (t4.dir[2] < 0) {
              const i4 = n4.zoomDeltaToMovement(e5, a3);
              Du.scale(m3, t4.dir, i4);
            }
          }
          const _3 = Du.add(p3, p3, m3);
          n4._translateCameraConstrained(_3), a3 && Math.abs(n4.zoom - f3) > 1e-4 && n4.recenterOnTerrain(), n4.cameraElevationReference = "ground", this._map._update(), e4.noInertia || this._inertia.record(e4), this._fireEvents(t3, i3, true);
        }
        _fireEvents(e4, t3, i3) {
          const r3 = XS(this._eventsInProgress), n4 = XS(e4), o3 = {};
          for (const t4 in e4) {
            const { originalEvent: i4 } = e4[t4];
            this._eventsInProgress[t4] || (o3[`${t4}start`] = i4), this._eventsInProgress[t4] = e4[t4];
          }
          !r3 && n4 && this._fireEvent("movestart", n4.originalEvent);
          for (const e5 in o3)
            this._fireEvent(e5, o3[e5]);
          n4 && this._fireEvent("move", n4.originalEvent);
          for (const t4 in e4) {
            const { originalEvent: i4 } = e4[t4];
            this._fireEvent(t4, i4);
          }
          const s6 = {};
          let a3;
          for (const e5 in this._eventsInProgress) {
            const { handlerName: i4, originalEvent: r4 } = this._eventsInProgress[e5];
            this._handlersById[i4].isActive() || (delete this._eventsInProgress[e5], a3 = t3[i4] || r4, s6[`${e5}end`] = a3);
          }
          for (const e5 in s6)
            this._fireEvent(e5, s6[e5]);
          const l3 = XS(this._eventsInProgress);
          if (i3 && (r3 || n4) && !l3) {
            this._updatingCamera = true;
            const e5 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), t4 = (e6) => 0 !== e6 && -this._bearingSnap < e6 && e6 < this._bearingSnap;
            e5 ? (t4(e5.bearing || this._map.getBearing()) && (e5.bearing = 0), this._map.easeTo(e5, { originalEvent: a3 })) : (this._map.fire(new It("moveend", { originalEvent: a3 })), t4(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }
        _fireEvent(e4, t3) {
          this._map.fire(new It(e4, t3 ? { originalEvent: t3 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e4) => {
            this._frameId = void 0, this.handleEvent(new YS("renderFrame", { timeStamp: e4 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        }
      }
      const eI = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class tI extends zt {
        constructor(e4, t3) {
          super(), this._moving = false, this._zooming = false, this.transform = e4, this._bearingSnap = t3.bearingSnap, this._respectPrefersReducedMotion = false !== t3.respectPrefersReducedMotion, j2(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new Wd(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e4, t3) {
          return this.jumpTo({ center: e4 }, t3);
        }
        panBy(e4, t3, i3) {
          return e4 = y2.convert(e4).mult(-1), this.panTo(this.transform.center, k2({ offset: e4 }, t3), i3);
        }
        panTo(e4, t3, i3) {
          return this.easeTo(k2({ center: e4 }, t3), i3);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e4, t3) {
          return this.jumpTo({ zoom: e4 }, t3), this;
        }
        zoomTo(e4, t3, i3) {
          return this.easeTo(k2({ zoom: e4 }, t3), i3);
        }
        zoomIn(e4, t3) {
          return this.zoomTo(this.getZoom() + 1, e4, t3), this;
        }
        zoomOut(e4, t3) {
          return this.zoomTo(this.getZoom() - 1, e4, t3), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e4, t3) {
          return this.jumpTo({ bearing: e4 }, t3), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e4, t3) {
          return this.jumpTo({ padding: e4 }, t3), this;
        }
        rotateTo(e4, t3, i3) {
          return this.easeTo(k2({ bearing: e4 }, t3), i3);
        }
        resetNorth(e4, t3) {
          return this.rotateTo(0, k2({ duration: 1e3 }, e4), t3), this;
        }
        resetNorthPitch(e4, t3) {
          return this.easeTo(k2({ bearing: 0, pitch: 0, duration: 1e3 }, e4), t3), this;
        }
        snapToNorth(e4, t3) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e4, t3) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e4, t3) {
          return this.jumpTo({ pitch: e4 }, t3), this;
        }
        cameraForBounds(e4, t3) {
          e4 = sc.convert(e4);
          const i3 = t3 && t3.bearing || 0, r3 = t3 && t3.pitch || 0, n4 = e4.getNorthWest(), o3 = e4.getSouthEast();
          return this._cameraForBounds(this.transform, n4, o3, i3, r3, t3);
        }
        _extendCameraOptions(e4) {
          const t3 = { top: 0, bottom: 0, right: 0, left: 0 };
          if ("number" == typeof (e4 = k2({ padding: t3, offset: [0, 0], maxZoom: this.transform.maxZoom }, e4)).padding) {
            const t4 = e4.padding;
            e4.padding = { top: t4, bottom: t4, right: t4, left: t4 };
          }
          return e4.padding = k2(t3, e4.padding), e4;
        }
        _minimumAABBFrustumDistance(e4, t3) {
          const i3 = t3.max[0] - t3.min[0], r3 = t3.max[1] - t3.min[1];
          return i3 / r3 > e4.aspect ? i3 / (2 * Math.tan(0.5 * e4.fovX) * e4.aspect) : r3 / (2 * Math.tan(0.5 * e4.fovY) * e4.aspect);
        }
        _cameraForBoundsOnGlobe(e4, t3, i3, r3, n4, o3) {
          const s6 = e4.clone(), a3 = this._extendCameraOptions(o3);
          s6.bearing = r3, s6.pitch = n4;
          const l3 = Wd.convert(t3), c3 = Wd.convert(i3), h3 = 0.5 * (l3.lat + c3.lat), u3 = 0.5 * (l3.lng + c3.lng), d3 = wd(h3, u3), p3 = Du.normalize([], d3), f3 = Du.normalize([], Du.cross([], p3, [0, 1, 0])), m3 = Du.cross([], f3, p3), _3 = [f3[0], f3[1], f3[2], 0, m3[0], m3[1], m3[2], 0, p3[0], p3[1], p3[2], 0, 0, 0, 0, 1], g3 = [d3, wd(l3.lat, l3.lng), wd(c3.lat, l3.lng), wd(c3.lat, c3.lng), wd(l3.lat, c3.lng), wd(h3, l3.lng), wd(h3, c3.lng), wd(l3.lat, u3), wd(c3.lat, u3)];
          let y3 = ed.fromPoints(g3.map((e5) => [Du.dot(f3, e5), Du.dot(m3, e5), Du.dot(p3, e5)]));
          const x3 = Du.transformMat4([], y3.center, _3);
          0 === Du.squaredLength(x3) && Du.set(x3, 0, 0, 1), Du.normalize(x3, x3), Du.scale(x3, x3, rd), s6.center = function([e5, t4, i4]) {
            const r4 = Math.hypot(e5, t4, i4), n5 = Math.atan2(e5, i4), o4 = 0.5 * Math.PI - Math.acos(-t4 / r4);
            return new Wd(T2(n5), T2(o4));
          }(x3);
          const v3 = s6.getWorldToCameraMatrix(), b3 = Au.invert(new Float64Array(16), v3);
          y3 = ed.applyTransform(y3, Au.multiply([], v3, _3)), Du.transformMat4(x3, x3, v3);
          const w3 = 0.5 * (y3.max[2] - y3.min[2]), E3 = this._minimumAABBFrustumDistance(s6, y3), M3 = Du.scale([], [0, 0, 1], w3), A3 = Du.add(M3, x3, M3), S3 = E3 + (0 === s6.pitch ? 0 : Du.distance(x3, A3)), I3 = s6.globeCenterInViewSpace, C3 = Du.sub([], x3, [I3[0], I3[1], I3[2]]);
          Du.normalize(C3, C3), Du.scale(C3, C3, S3);
          const z2 = Du.add([], x3, C3);
          Du.transformMat4(z2, z2, b3);
          const P3 = qd / rd, D2 = Du.length(z2), R3 = Qd(Math.max(D2 * P3 - qd, Number.EPSILON), 0), L3 = Math.min(s6.zoomFromMercatorZAdjusted(R3), a3.maxZoom);
          return L3 > 0.5 * (td + id) ? (s6.setProjection({ name: "mercator" }), s6.zoom = L3, this._cameraForBounds(s6, t3, i3, r3, n4, o3)) : { center: s6.center, zoom: L3, bearing: r3, pitch: n4 };
        }
        queryTerrainElevation(e4, t3) {
          const i3 = this.transform.elevation;
          return i3 ? (t3 = k2({}, { exaggerated: true }, t3), i3.getAtPoint(lp.fromLngLat(e4), null, t3.exaggerated)) : null;
        }
        _cameraForBounds(e4, t3, i3, r3, n4, o3) {
          if ("globe" === e4.projection.name)
            return this._cameraForBoundsOnGlobe(e4, t3, i3, r3, n4, o3);
          const s6 = e4.clone(), a3 = this._extendCameraOptions(o3), l3 = s6.padding;
          s6.bearing = r3, s6.pitch = n4;
          const c3 = Wd.convert(t3), h3 = Wd.convert(i3), u3 = new Wd(c3.lng, h3.lat), d3 = new Wd(h3.lng, c3.lat), p3 = s6.project(c3), f3 = s6.project(h3), m3 = this.queryTerrainElevation(c3), _3 = this.queryTerrainElevation(h3), g3 = this.queryTerrainElevation(u3), x3 = this.queryTerrainElevation(d3), v3 = [[p3.x, p3.y, Math.min(m3 || 0, _3 || 0, g3 || 0, x3 || 0)], [f3.x, f3.y, Math.max(m3 || 0, _3 || 0, g3 || 0, x3 || 0)]];
          let b3 = ed.fromPoints(v3);
          const T3 = s6.getWorldToCameraMatrix(), E3 = Au.invert(new Float64Array(16), T3);
          b3 = ed.applyTransform(b3, T3);
          const M3 = Du.sub([], b3.max, b3.min), A3 = l3.left || 0, S3 = l3.right || 0, I3 = l3.bottom || 0, C3 = l3.top || 0, { left: z2, right: P3, top: D2, bottom: R3 } = a3.padding, L3 = 0.5 * (A3 + S3), k3 = 0.5 * (C3 + I3), O2 = Math.min(s6.scaleZoom(s6.scale * Math.min((s6.width - (A3 + S3 + z2 + P3)) / M3[0], (s6.height - (I3 + C3 + R3 + D2)) / M3[1])), a3.maxZoom), B2 = s6.scale / s6.zoomScale(O2);
          b3 = new ed([b3.min[0] - (z2 + L3) * B2, b3.min[1] - (R3 + k3) * B2, b3.min[2]], [b3.max[0] + (P3 + L3) * B2, b3.max[1] + (D2 + k3) * B2, b3.max[2]]);
          const F2 = 0.5 * M3[2], N3 = this._minimumAABBFrustumDistance(s6, b3), U2 = [0, 0, 1, 0];
          yu.transformMat4(U2, U2, T3), yu.normalize(U2, U2);
          const V3 = Du.scale([], U2, N3 + F2), j3 = Du.add([], b3.center, V3), G2 = ("number" == typeof a3.offset.x && "number" == typeof a3.offset.y ? new y2(a3.offset.x, a3.offset.y) : y2.convert(a3.offset)).rotate(-w2(r3));
          b3.center[0] -= G2.x * B2, b3.center[1] += G2.y * B2, Du.transformMat4(b3.center, b3.center, E3), Du.transformMat4(j3, j3, E3);
          const q2 = [b3.center[0], b3.center[1], j3[2] * s6.pixelsPerMeter];
          Du.scale(q2, q2, 1 / s6.worldSize);
          const Z3 = ep(q2[0]), $3 = tp(q2[1]), W2 = Math.min(s6._zoomFromMercatorZ(q2[2]), a3.maxZoom), H3 = new Wd(Z3, $3);
          return s6.mercatorFromTransition && W2 < 0.5 * (td + id) ? (s6.setProjection({ name: "globe" }), s6.zoom = W2, this._cameraForBounds(s6, t3, i3, r3, n4, o3)) : { center: H3, zoom: W2, bearing: r3, pitch: n4 };
        }
        fitBounds(e4, t3, i3) {
          const r3 = this.cameraForBounds(e4, t3);
          return this._fitInternal(r3, t3, i3);
        }
        fitScreenCoordinates(e4, t3, i3, r3, n4) {
          const o3 = y2.convert(e4), s6 = y2.convert(t3), a3 = new y2(Math.min(o3.x, s6.x), Math.min(o3.y, s6.y)), l3 = new y2(Math.max(o3.x, s6.x), Math.max(o3.y, s6.y));
          if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(o3, s6))
            return this;
          const c3 = this.transform.pointLocation3D(a3), h3 = this.transform.pointLocation3D(l3), u3 = this.transform.pointLocation3D(new y2(a3.x, l3.y)), d3 = this.transform.pointLocation3D(new y2(l3.x, a3.y)), p3 = [Math.min(c3.lng, h3.lng, u3.lng, d3.lng), Math.min(c3.lat, h3.lat, u3.lat, d3.lat)], f3 = [Math.max(c3.lng, h3.lng, u3.lng, d3.lng), Math.max(c3.lat, h3.lat, u3.lat, d3.lat)], m3 = r3 && r3.pitch ? r3.pitch : this.getPitch(), _3 = this._cameraForBounds(this.transform, p3, f3, i3, m3, r3);
          return this._fitInternal(_3, r3, n4);
        }
        _fitInternal(e4, t3, i3) {
          return e4 ? (delete (t3 = k2(e4, t3)).padding, t3.linear ? this.easeTo(t3, i3) : this.flyTo(t3, i3)) : this;
        }
        jumpTo(e4, t3) {
          this.stop();
          const i3 = e4.preloadOnly ? this.transform.clone() : this.transform;
          let r3 = false, n4 = false, o3 = false;
          return "zoom" in e4 && i3.zoom !== +e4.zoom && (r3 = true, i3.zoom = +e4.zoom), void 0 !== e4.center && (i3.center = Wd.convert(e4.center)), "bearing" in e4 && i3.bearing !== +e4.bearing && (n4 = true, i3.bearing = +e4.bearing), "pitch" in e4 && i3.pitch !== +e4.pitch && (o3 = true, i3.pitch = +e4.pitch), null == e4.padding || i3.isPaddingEqual(e4.padding) || (i3.padding = e4.padding), e4.preloadOnly ? (this._preloadTiles(i3), this) : (this.fire(new It("movestart", t3)).fire(new It("move", t3)), r3 && this.fire(new It("zoomstart", t3)).fire(new It("zoom", t3)).fire(new It("zoomend", t3)), n4 && this.fire(new It("rotatestart", t3)).fire(new It("rotate", t3)).fire(new It("rotateend", t3)), o3 && this.fire(new It("pitchstart", t3)).fire(new It("pitch", t3)).fire(new It("pitchend", t3)), this.fire(new It("moveend", t3)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || H2(eI), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(e4, t3) {
          const i3 = this.transform;
          if (!i3.projection.supportsFreeCamera)
            return H2(eI), this;
          this.stop();
          const r3 = i3.zoom, n4 = i3.pitch, o3 = i3.bearing;
          i3.setFreeCameraOptions(e4);
          const s6 = r3 !== i3.zoom, a3 = n4 !== i3.pitch, l3 = o3 !== i3.bearing;
          return this.fire(new It("movestart", t3)).fire(new It("move", t3)), s6 && this.fire(new It("zoomstart", t3)).fire(new It("zoom", t3)).fire(new It("zoomend", t3)), l3 && this.fire(new It("rotatestart", t3)).fire(new It("rotate", t3)).fire(new It("rotateend", t3)), a3 && this.fire(new It("pitchstart", t3)).fire(new It("pitch", t3)).fire(new It("pitchend", t3)), this.fire(new It("moveend", t3)), this;
        }
        easeTo(e4, t3) {
          this._stop(false, e4.easeId), (false === (e4 = k2({ offset: [0, 0], duration: 500, easing: C2 }, e4)).animate || this._prefersReducedMotion(e4)) && (e4.duration = 0);
          const i3 = this.transform, r3 = this.getZoom(), n4 = this.getBearing(), o3 = this.getPitch(), s6 = this.getPadding(), a3 = "zoom" in e4 ? +e4.zoom : r3, l3 = "bearing" in e4 ? this._normalizeBearing(e4.bearing, n4) : n4, c3 = "pitch" in e4 ? +e4.pitch : o3, h3 = "padding" in e4 ? e4.padding : i3.padding, u3 = y2.convert(e4.offset);
          let d3, p3, f3;
          if ("globe" === i3.projection.name) {
            const t4 = lp.fromLngLat(i3.center), r4 = u3.rotate(-i3.angle);
            t4.x += r4.x / i3.worldSize, t4.y += r4.y / i3.worldSize;
            const n5 = t4.toLngLat(), o4 = Wd.convert(e4.center || n5);
            this._normalizeCenter(o4), d3 = i3.centerPoint.add(r4), p3 = new y2(t4.x, t4.y).mult(i3.worldSize), f3 = new y2(Kd(o4.lng), Jd(o4.lat)).mult(i3.worldSize).sub(p3);
          } else {
            d3 = i3.centerPoint.add(u3);
            const t4 = i3.pointLocation(d3), r4 = Wd.convert(e4.center || t4);
            this._normalizeCenter(r4), p3 = i3.project(t4), f3 = i3.project(r4).sub(p3);
          }
          const m3 = i3.zoomScale(a3 - r3);
          let _3, g3;
          e4.around && (_3 = Wd.convert(e4.around), g3 = i3.locationPoint(_3));
          const x3 = this._zooming || a3 !== r3, v3 = this._rotating || n4 !== l3, b3 = this._pitching || c3 !== o3, w3 = !i3.isPaddingEqual(h3), T3 = (i4) => (y3) => {
            if (x3 && (i4.zoom = Kr(r3, a3, y3)), v3 && (i4.bearing = Kr(n4, l3, y3)), b3 && (i4.pitch = Kr(o3, c3, y3)), w3 && (i4.interpolatePadding(s6, h3, y3), d3 = i4.centerPoint.add(u3)), _3)
              i4.setLocationAtPoint(_3, g3);
            else {
              const e5 = i4.zoomScale(i4.zoom - r3), t4 = a3 > r3 ? Math.min(2, m3) : Math.max(0.5, m3), n5 = Math.pow(t4, 1 - y3), o4 = i4.unproject(p3.add(f3.mult(y3 * n5)).mult(e5));
              i4.setLocationAtPoint(i4.renderWorldCopies ? o4.wrap() : o4, d3);
            }
            return e4.preloadOnly || this._fireMoveEvents(t3), i4;
          };
          if (e4.preloadOnly) {
            const t4 = this._emulate(T3, e4.duration, i3);
            return this._preloadTiles(t4), this;
          }
          const E3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = x3, this._rotating = v3, this._pitching = b3, this._padding = w3, this._easeId = e4.easeId, this._prepareEase(t3, e4.noMoveStart, E3), this._ease(T3(i3), (e5) => {
            "sea" === i3.cameraElevationReference && i3.recenterOnTerrain(), this._afterEase(t3, e5);
          }, e4), this;
        }
        _prepareEase(e4, t3, i3 = {}) {
          this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), t3 || i3.moving || this.fire(new It("movestart", e4)), this._zooming && !i3.zooming && this.fire(new It("zoomstart", e4)), this._rotating && !i3.rotating && this.fire(new It("rotatestart", e4)), this._pitching && !i3.pitching && this.fire(new It("pitchstart", e4));
        }
        _fireMoveEvents(e4) {
          this.fire(new It("move", e4)), this._zooming && this.fire(new It("zoom", e4)), this._rotating && this.fire(new It("rotate", e4)), this._pitching && this.fire(new It("pitch", e4));
        }
        _afterEase(e4, t3) {
          if (this._easeId && t3 && this._easeId === t3)
            return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const i3 = this._zooming, r3 = this._rotating, n4 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, i3 && this.fire(new It("zoomend", e4)), r3 && this.fire(new It("rotateend", e4)), n4 && this.fire(new It("pitchend", e4)), this.fire(new It("moveend", e4));
        }
        flyTo(e4, t3) {
          if (this._prefersReducedMotion(e4)) {
            const i4 = O(e4, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(i4, t3);
          }
          this.stop(), e4 = k2({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: C2 }, e4);
          const i3 = this.transform, r3 = this.getZoom(), n4 = this.getBearing(), o3 = this.getPitch(), s6 = this.getPadding(), a3 = "zoom" in e4 ? z(+e4.zoom, i3.minZoom, i3.maxZoom) : r3, l3 = "bearing" in e4 ? this._normalizeBearing(e4.bearing, n4) : n4, c3 = "pitch" in e4 ? +e4.pitch : o3, h3 = "padding" in e4 ? e4.padding : i3.padding, u3 = i3.zoomScale(a3 - r3), d3 = y2.convert(e4.offset);
          let p3 = i3.centerPoint.add(d3);
          const f3 = i3.pointLocation(p3), m3 = Wd.convert(e4.center || f3);
          this._normalizeCenter(m3);
          const _3 = i3.project(f3), g3 = i3.project(m3).sub(_3);
          let x3 = e4.curve;
          const v3 = Math.max(i3.width, i3.height), b3 = v3 / u3, w3 = g3.mag();
          if ("minZoom" in e4) {
            const t4 = z(Math.min(e4.minZoom, r3, a3), i3.minZoom, i3.maxZoom), n5 = v3 / i3.zoomScale(t4 - r3);
            x3 = Math.sqrt(n5 / w3 * 2);
          }
          const T3 = x3 * x3;
          function E3(e5) {
            const t4 = (b3 * b3 - v3 * v3 + (e5 ? -1 : 1) * T3 * T3 * w3 * w3) / (2 * (e5 ? b3 : v3) * T3 * w3);
            return Math.log(Math.sqrt(t4 * t4 + 1) - t4);
          }
          function M3(e5) {
            return (Math.exp(e5) - Math.exp(-e5)) / 2;
          }
          function A3(e5) {
            return (Math.exp(e5) + Math.exp(-e5)) / 2;
          }
          const S3 = E3(0);
          let I3 = function(e5) {
            return A3(S3) / A3(S3 + x3 * e5);
          }, P3 = function(e5) {
            return v3 * ((A3(S3) * (M3(t4 = S3 + x3 * e5) / A3(t4)) - M3(S3)) / T3) / w3;
            var t4;
          }, D2 = (E3(1) - S3) / x3;
          if (Math.abs(w3) < 1e-6 || !isFinite(D2)) {
            if (Math.abs(v3 - b3) < 1e-6)
              return this.easeTo(e4, t3);
            const i4 = b3 < v3 ? -1 : 1;
            D2 = Math.abs(Math.log(b3 / v3)) / x3, P3 = function() {
              return 0;
            }, I3 = function(e5) {
              return Math.exp(i4 * x3 * e5);
            };
          }
          e4.duration = "duration" in e4 ? +e4.duration : 1e3 * D2 / ("screenSpeed" in e4 ? +e4.screenSpeed / x3 : +e4.speed), e4.maxDuration && e4.duration > e4.maxDuration && (e4.duration = 0);
          const R3 = n4 !== l3, L3 = c3 !== o3, B2 = !i3.isPaddingEqual(h3), F2 = (i4) => (u4) => {
            const f4 = u4 * D2, y3 = 1 / I3(f4);
            i4.zoom = 1 === u4 ? a3 : r3 + i4.scaleZoom(y3), R3 && (i4.bearing = Kr(n4, l3, u4)), L3 && (i4.pitch = Kr(o3, c3, u4)), B2 && (i4.interpolatePadding(s6, h3, u4), p3 = i4.centerPoint.add(d3));
            const x4 = 1 === u4 ? m3 : i4.unproject(_3.add(g3.mult(P3(f4))).mult(y3));
            return i4.setLocationAtPoint(i4.renderWorldCopies ? x4.wrap() : x4, p3), i4._updateCameraOnTerrain(), e4.preloadOnly || this._fireMoveEvents(t3), i4;
          };
          if (e4.preloadOnly) {
            const t4 = this._emulate(F2, e4.duration, i3);
            return this._preloadTiles(t4), this;
          }
          return this._zooming = true, this._rotating = R3, this._pitching = L3, this._padding = B2, this._prepareEase(t3, false), this._ease(F2(i3), () => this._afterEase(t3), e4), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e4, t3) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const e5 = this._onEaseEnd;
            this._onEaseEnd = void 0, e5.call(this, t3);
          }
          if (!e4) {
            const e5 = this.handlers;
            e5 && e5.stop(false);
          }
          return this;
        }
        _ease(e4, t3, i3) {
          false === i3.animate || 0 === i3.duration ? (e4(1), t3()) : (this._easeStart = dt.now(), this._easeOptions = i3, this._onEaseFrame = e4, this._onEaseEnd = t3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const e4 = Math.min((dt.now() - this._easeStart) / this._easeOptions.duration, 1), t3 = this._onEaseFrame;
          t3 && t3(this._easeOptions.easing(e4)), e4 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(e4, t3) {
          e4 = D(e4, -180, 180);
          const i3 = Math.abs(e4 - t3);
          return Math.abs(e4 - 360 - t3) < i3 && (e4 -= 360), Math.abs(e4 + 360 - t3) < i3 && (e4 += 360), e4;
        }
        _normalizeCenter(e4) {
          const t3 = this.transform;
          if (t3.maxBounds)
            return;
          if ("globe" !== t3.projection.name && !t3.renderWorldCopies)
            return;
          const i3 = e4.lng - t3.center.lng;
          e4.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
        }
        _prefersReducedMotion(e4) {
          return this._respectPrefersReducedMotion && dt.prefersReducedMotion && !(e4 && e4.essential);
        }
        _emulate(e4, t3, i3) {
          const r3 = Math.ceil(15 * t3 / 1e3), n4 = [], o3 = e4(i3.clone());
          for (let e5 = 0; e5 <= r3; e5++) {
            const t4 = o3(e5 / r3);
            n4.push(t4.clone());
          }
          return n4;
        }
      }
      class iI {
        constructor(e4 = {}) {
          this.options = e4, j2(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e4) {
          const t3 = this.options && this.options.compact;
          return this._map = e4, this._container = pt("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = pt("button", "mapboxgl-ctrl-attrib-button", this._container), pt("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = pt("div", "mapboxgl-ctrl-attrib-inner", this._container), t3 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t3 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e4, t3) {
          const i3 = this._map._getUIString(`AttributionControl.${t3}`);
          e4.removeAttribute("title"), e4.firstElementChild && e4.firstElementChild.setAttribute("title", i3);
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let e4 = this._editLink;
          e4 || (e4 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const t3 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || n3.ACCESS_TOKEN }];
          if (e4) {
            const i3 = t3.reduce((e5, i4, r3) => (i4.value && (e5 += `${i4.key}=${i4.value}${r3 < t3.length - 1 ? "&" : ""}`), e5), "?");
            e4.href = `${n3.FEEDBACK_URL}/${i3}#${oS(this._map, true)}`, e4.rel = "noopener nofollow", this._setElementTitle(e4, "MapFeedback");
          }
        }
        _updateData(e4) {
          !e4 || "metadata" !== e4.sourceDataType && "visibility" !== e4.sourceDataType && "style" !== e4.dataType || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let e4 = [];
          if (this._map.style.stylesheet) {
            const e5 = this._map.style.stylesheet;
            this.styleOwner = e5.owner, this.styleId = e5.id;
          }
          const t3 = this._map.style._mergedSourceCaches;
          for (const i4 in t3) {
            const r3 = t3[i4];
            if (r3.used) {
              const t4 = r3.getSource();
              t4.attribution && e4.indexOf(t4.attribution) < 0 && e4.push(t4.attribution);
            }
          }
          e4.sort((e5, t4) => e5.length - t4.length), e4 = e4.filter((t4, i4) => {
            for (let r3 = i4 + 1; r3 < e4.length; r3++)
              if (e4[r3].indexOf(t4) >= 0)
                return false;
            return true;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e4 = [...this.options.customAttribution, ...e4] : e4.unshift(this.options.customAttribution));
          const i3 = e4.join(" | ");
          i3 !== this._attribHTML && (this._attribHTML = i3, e4.length ? (this._innerContainer.innerHTML = i3, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class rI {
        constructor() {
          j2(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(e4) {
          this._map = e4, this._container = pt("div", "mapboxgl-ctrl");
          const t3 = pt("a", "mapboxgl-ctrl-logo");
          return t3.target = "_blank", t3.rel = "noopener nofollow", t3.href = "https://www.mapbox.com/", t3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t3), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(e4) {
          e4 && "metadata" !== e4.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return true;
          const e4 = this._map.style._sourceCaches;
          if (0 === Object.entries(e4).length)
            return true;
          for (const t3 in e4) {
            const i3 = e4[t3].getSource();
            if (i3.hasOwnProperty("mapbox_logo") && !i3.mapbox_logo)
              return false;
          }
          return true;
        }
        _updateCompact() {
          const e4 = this._container.children;
          if (e4.length) {
            const t3 = e4[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? t3.classList.add("mapboxgl-compact") : t3.classList.remove("mapboxgl-compact");
          }
        }
      }
      class nI {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e4) {
          const t3 = ++this._id;
          return this._queue.push({ callback: e4, id: t3, cancelled: false }), t3;
        }
        remove(e4) {
          const t3 = this._currentlyRunning, i3 = t3 ? this._queue.concat(t3) : this._queue;
          for (const t4 of i3)
            if (t4.id === e4)
              return void (t4.cancelled = true);
        }
        run(e4 = 0) {
          const t3 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i3 of t3)
            if (!i3.cancelled && (i3.callback(e4), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      function oI(e4, t3, i3) {
        if (e4 = new Wd(e4.lng, e4.lat), t3) {
          const r3 = new Wd(e4.lng - 360, e4.lat), n4 = new Wd(e4.lng + 360, e4.lat), o3 = 360 * Math.ceil(Math.abs(e4.lng - i3.center.lng) / 360), s6 = i3.locationPoint(e4).distSqr(t3), a3 = t3.x < 0 || t3.y < 0 || t3.x > i3.width || t3.y > i3.height;
          i3.locationPoint(r3).distSqr(t3) < s6 && (a3 || Math.abs(r3.lng - i3.center.lng) < o3) ? e4 = r3 : i3.locationPoint(n4).distSqr(t3) < s6 && (a3 || Math.abs(n4.lng - i3.center.lng) < o3) && (e4 = n4);
        }
        for (; Math.abs(e4.lng - i3.center.lng) > 180; ) {
          const t4 = i3.locationPoint(e4);
          if (t4.x >= 0 && t4.y >= 0 && t4.x <= i3.width && t4.y <= i3.height)
            break;
          e4.lng > i3.center.lng ? e4.lng -= 360 : e4.lng += 360;
        }
        return e4;
      }
      const sI = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class aI extends zt {
        constructor(e4, i3) {
          if (super(), (e4 instanceof t2.HTMLElement || i3) && (e4 = k2({ element: e4 }, i3)), j2(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = e4 && e4.anchor || "center", this._color = e4 && e4.color || "#3FB1CE", this._scale = e4 && e4.scale || 1, this._draggable = e4 && e4.draggable || false, this._clickTolerance = e4 && e4.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e4 && e4.rotation || 0, this._rotationAlignment = e4 && e4.rotationAlignment || "auto", this._pitchAlignment = e4 && e4.pitchAlignment && e4.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = e4 && e4.occludedOpacity || 0.2, e4 && e4.element)
            this._element = e4.element, this._offset = y2.convert(e4 && e4.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = pt("div");
            const t3 = 41, i4 = 27, r4 = ft("svg", { display: "block", height: t3 * this._scale + "px", width: i4 * this._scale + "px", viewBox: `0 0 ${i4} ${t3}` }, this._element), n5 = ft("radialGradient", { id: "shadowGradient" }, ft("defs", {}, r4));
            ft("stop", { offset: "10%", "stop-opacity": 0.4 }, n5), ft("stop", { offset: "100%", "stop-opacity": 0.05 }, n5), ft("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r4), ft("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r4), ft("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r4), ft("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r4), this._offset = y2.convert(e4 && e4.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e5) => {
            e5.preventDefault();
          }), this._element.addEventListener("mousedown", (e5) => {
            e5.preventDefault();
          });
          const r3 = this._element.classList;
          for (const e5 in sI)
            r3.remove(`mapboxgl-marker-anchor-${e5}`);
          r3.add(`mapboxgl-marker-anchor-${this._anchor}`);
          const n4 = e4 && e4.className ? e4.className.trim().split(/\s+/) : [];
          r3.add(...n4), this._popup = null;
        }
        addTo(e4) {
          return e4 === this._map || (this.remove(), this._map = e4, e4.getCanvasContainer().appendChild(this._element), e4.on("move", this._updateMoving), e4.on("moveend", this._update), e4.on("remove", this._clearFadeTimer), e4._addMarker(this), this.setDraggable(this._draggable), this._update(), e4.on("click", this._onMapClick)), this;
        }
        remove() {
          const e4 = this._map;
          return e4 && (e4.off("click", this._onMapClick), e4.off("move", this._updateMoving), e4.off("moveend", this._update), e4.off("mousedown", this._addDragHandler), e4.off("touchstart", this._addDragHandler), e4.off("mouseup", this._onUp), e4.off("touchend", this._onUp), e4.off("mousemove", this._onMove), e4.off("touchmove", this._onMove), e4.off("remove", this._clearFadeTimer), e4._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e4) {
          return this._lngLat = Wd.convert(e4), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e4) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e4) {
            if (!("offset" in e4.options)) {
              const t3 = 38.1, i3 = 13.5, r3 = Math.sqrt(Math.pow(i3, 2) / 2);
              e4.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t3], "bottom-left": [r3, -1 * (t3 - i3 + r3)], "bottom-right": [-r3, -1 * (t3 - i3 + r3)], left: [i3, -1 * (t3 - i3)], right: [-i3, -1 * (t3 - i3)] } : this._offset;
            }
            this._popup = e4, e4._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(e4) {
          const t3 = e4.code, i3 = e4.charCode || e4.keyCode;
          "Space" !== t3 && "Enter" !== t3 && 32 !== i3 && 13 !== i3 || this.togglePopup();
        }
        _onMapClick(e4) {
          const t3 = e4.originalEvent.target, i3 = this._element;
          this._popup && (t3 === i3 || i3.contains(t3)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e4 = this._popup;
          return e4 ? (e4.isOpen() ? (e4.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e4.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const e4 = this._map, t3 = this._pos;
          if (!e4 || !t3)
            return false;
          const i3 = e4.unproject(t3), r3 = e4.getFreeCameraOptions();
          if (!r3.position)
            return false;
          const n4 = r3.position.toLngLat();
          return n4.distanceTo(i3) < 0.9 * n4.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const e4 = this._map;
          if (!e4)
            return;
          const t3 = this._pos;
          if (!t3 || t3.x < 0 || t3.x > e4.transform.width || t3.y < 0 || t3.y > e4.transform.height)
            return void this._clearFadeTimer();
          const i3 = e4.unproject(t3);
          let r3;
          e4._showingGlobe() && Nd(e4.transform, this._lngLat) ? r3 = 0 : (r3 = 1 - e4._queryFogOpacity(i3), e4.transform._terrainEnabled() && e4.getTerrain() && this._behindTerrain() && (r3 *= this._occludedOpacity)), this._element.style.opacity = `${r3}`, this._element.style.pointerEvents = r3 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r3), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const e4 = this._pos;
          if (!e4 || !this._map)
            return;
          const t3 = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${e4.x}px,${e4.y}px)
            ${sI[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t3.x}px,${t3.y}px)
        `;
        }
        _calculateXYTransform() {
          const e4 = this._pos, t3 = this._map, i3 = this.getPitchAlignment();
          if (!t3 || !e4 || "map" !== i3)
            return "";
          if (!t3._showingGlobe()) {
            const e5 = t3.getPitch();
            return e5 ? `rotateX(${e5}deg)` : "";
          }
          const r3 = T2(Fd(t3.transform, this._lngLat)), n4 = e4.sub(Bd(t3.transform)), o3 = Math.abs(n4.x) + Math.abs(n4.y);
          if (0 === o3)
            return "";
          const s6 = r3 / o3;
          return `rotateX(${-n4.y * s6}deg) rotateY(${n4.x * s6}deg)`;
        }
        _calculateZTransform() {
          const e4 = this._pos, t3 = this._map;
          if (!t3 || !e4)
            return "";
          let i3 = 0;
          const r3 = this.getRotationAlignment();
          if ("map" === r3)
            if (t3._showingGlobe()) {
              const e5 = t3.project(new Wd(this._lngLat.lng, this._lngLat.lat + 1e-3)), r4 = t3.project(new Wd(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(e5);
              i3 = T2(Math.atan2(r4.y, r4.x)) - 90;
            } else
              i3 = -t3.getBearing();
          else if ("horizon" === r3) {
            const r4 = P2(4, 6, t3.getZoom()), n4 = Bd(t3.transform);
            n4.y += r4 * t3.transform.height;
            const o3 = e4.sub(n4), s6 = T2(Math.atan2(o3.y, o3.x));
            i3 = (s6 > 90 ? s6 - 270 : s6 + 90) * (1 - r4);
          }
          return i3 += this._rotation, i3 ? `rotateZ(${i3}deg)` : "";
        }
        _update(e4) {
          t2.cancelAnimationFrame(this._updateFrameId);
          const i3 = this._map;
          i3 && (i3.transform.renderWorldCopies && (this._lngLat = oI(this._lngLat, this._pos, i3.transform)), this._pos = i3.project(this._lngLat), true === e4 ? this._updateFrameId = t2.requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), i3._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i3._showingGlobe() || i3.getTerrain() || i3.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(e4) {
          return this._offset = y2.convert(e4), this._update(), this;
        }
        addClassName(e4) {
          return this._element.classList.add(e4), this;
        }
        removeClassName(e4) {
          return this._element.classList.remove(e4), this;
        }
        toggleClassName(e4) {
          return this._element.classList.toggle(e4);
        }
        _onMove(e4) {
          const t3 = this._map;
          if (!t3)
            return;
          const i3 = this._pointerdownPos, r3 = this._positionDelta;
          if (i3 && r3) {
            if (!this._isDragging) {
              const r4 = this._clickTolerance || t3._clickTolerance;
              if (e4.point.dist(i3) < r4)
                return;
              this._isDragging = true;
            }
            this._pos = e4.point.sub(r3), this._lngLat = t3.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new It("dragstart"))), this.fire(new It("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
          const e4 = this._map;
          e4 && (e4.off("mousemove", this._onMove), e4.off("touchmove", this._onMove)), "active" === this._state && this.fire(new It("dragend")), this._state = "inactive";
        }
        _addDragHandler(e4) {
          const t3 = this._map, i3 = this._pos;
          t3 && i3 && this._element.contains(e4.originalEvent.target) && (e4.preventDefault(), this._positionDelta = e4.point.sub(i3), this._pointerdownPos = e4.point, this._state = "pending", t3.on("mousemove", this._onMove), t3.on("touchmove", this._onMove), t3.once("mouseup", this._onUp), t3.once("touchend", this._onUp));
        }
        setDraggable(e4) {
          this._draggable = !!e4;
          const t3 = this._map;
          return t3 && (e4 ? (t3.on("mousedown", this._addDragHandler), t3.on("touchstart", this._addDragHandler)) : (t3.off("mousedown", this._addDragHandler), t3.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e4) {
          return this._rotation = e4 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e4) {
          return this._rotationAlignment = e4 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(e4) {
          return this._pitchAlignment = e4 || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(e4) {
          return this._occludedOpacity = e4 || 0.2, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const lI = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, cI = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function hI(e4 = new y2(0, 0), t3 = "bottom") {
        if ("number" == typeof e4) {
          const i3 = Math.round(Math.sqrt(0.5 * Math.pow(e4, 2)));
          switch (t3) {
            case "top":
              return new y2(0, e4);
            case "top-left":
              return new y2(i3, i3);
            case "top-right":
              return new y2(-i3, i3);
            case "bottom":
              return new y2(0, -e4);
            case "bottom-left":
              return new y2(i3, -i3);
            case "bottom-right":
              return new y2(-i3, -i3);
            case "left":
              return new y2(e4, 0);
            case "right":
              return new y2(-e4, 0);
          }
          return new y2(0, 0);
        }
        return e4 instanceof y2 || Array.isArray(e4) ? y2.convert(e4) : y2.convert(e4[t3] || [0, 0]);
      }
      class uI {
        constructor(e4) {
          this.jumpTo(e4);
        }
        getValue(e4) {
          if (e4 <= this._startTime)
            return this._start;
          if (e4 >= this._endTime)
            return this._end;
          const t3 = M2((e4 - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - t3) + this._end * t3;
        }
        isEasing(e4) {
          return e4 >= this._startTime && e4 <= this._endTime;
        }
        jumpTo(e4) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e4, this._end = e4;
        }
        easeTo(e4, t3, i3) {
          this._start = this.getValue(t3), this._end = e4, this._startTime = t3, this._endTime = t3 + i3;
        }
      }
      const dI = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, pI = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false }, fI = { showCompass: true, showZoom: true, visualizePitch: false };
      class mI {
        constructor(e4, t3, i3 = false) {
          this._clickTolerance = 10, this.element = t3, this.mouseRotate = new SS({ clickTolerance: e4.dragRotate._mouseRotate._clickTolerance }), this.map = e4, i3 && (this.mousePitch = new IS({ clickTolerance: e4.dragRotate._mousePitch._clickTolerance })), j2(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), t3.addEventListener("mousedown", this.mousedown), t3.addEventListener("touchstart", this.touchstart, { passive: false }), t3.addEventListener("touchmove", this.touchmove), t3.addEventListener("touchend", this.touchend), t3.addEventListener("touchcancel", this.reset);
        }
        down(e4, t3) {
          this.mouseRotate.mousedown(e4, t3), this.mousePitch && this.mousePitch.mousedown(e4, t3), yt();
        }
        move(e4, t3) {
          const i3 = this.map, r3 = this.mouseRotate.mousemoveWindow(e4, t3), n4 = r3 && r3.bearingDelta;
          if (n4 && i3.setBearing(i3.getBearing() + n4), this.mousePitch) {
            const r4 = this.mousePitch.mousemoveWindow(e4, t3), n5 = r4 && r4.pitchDelta;
            n5 && i3.setPitch(i3.getPitch() + n5);
          }
        }
        off() {
          const e4 = this.element;
          e4.removeEventListener("mousedown", this.mousedown), e4.removeEventListener("touchstart", this.touchstart, { passive: false }), e4.removeEventListener("touchmove", this.touchmove), e4.removeEventListener("touchend", this.touchend), e4.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          xt(), t2.removeEventListener("mousemove", this.mousemove), t2.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(e4) {
          this.down(k2({}, e4, { ctrlKey: true, preventDefault: () => e4.preventDefault() }), wt(this.element, e4)), t2.addEventListener("mousemove", this.mousemove), t2.addEventListener("mouseup", this.mouseup);
        }
        mousemove(e4) {
          this.move(e4, wt(this.element, e4));
        }
        mouseup(e4) {
          this.mouseRotate.mouseupWindow(e4), this.mousePitch && this.mousePitch.mouseupWindow(e4), this.offTemp();
        }
        touchstart(e4) {
          1 !== e4.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = Tt(this.element, e4.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e4.preventDefault() }, this._startPos));
        }
        touchmove(e4) {
          1 !== e4.targetTouches.length ? this.reset() : (this._lastPos = Tt(this.element, e4.targetTouches)[0], this.move({ preventDefault: () => e4.preventDefault() }, this._lastPos));
        }
        touchend(e4) {
          0 === e4.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      const _I = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, gI = { maxWidth: 100, unit: "metric" }, yI = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, xI = { version: i2, supported: rt, setRTLTextPlugin: function(e4, t3, i3 = false) {
        if (Ks === Ws || Ks === Hs || Ks === Xs)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        Js = dt.resolveURL(e4), Ks = Ws, Ys = t3, ea(), i3 || ra();
      }, getRTLTextPluginStatus: ia, Map: class extends tI {
        constructor(e4) {
          Qe.mark(Je.create);
          const i3 = e4;
          if (null != (e4 = k2({}, pI, e4)).minZoom && null != e4.maxZoom && e4.minZoom > e4.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != e4.minPitch && null != e4.maxPitch && e4.minPitch > e4.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != e4.minPitch && e4.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (null != e4.maxPitch && e4.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (e4.antialias && function(e5) {
            const t3 = e5.navigator ? e5.navigator.userAgent : null;
            return !!function(e6) {
              if (null == te) {
                const t4 = e6.navigator ? e6.navigator.userAgent : null;
                te = !!e6.safari || !(!t4 || !(/\b(iPad|iPhone|iPod)\b/.test(t4) || t4.match("Safari") && !t4.match("Chrome")));
              }
              return te;
            }(e5) && t3 && (t3.match("Version/15.4") || t3.match("Version/15.5") || t3.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
          }(t2) && (e4.antialias = false, H2("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Tv(e4.minZoom, e4.maxZoom, e4.minPitch, e4.maxPitch, e4.renderWorldCopies), e4), this._interactive = e4.interactive, this._minTileCacheSize = e4.minTileCacheSize, this._maxTileCacheSize = e4.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e4.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e4.preserveDrawingBuffer, this._antialias = e4.antialias, this._trackResize = e4.trackResize, this._bearingSnap = e4.bearingSnap, this._refreshExpiredTiles = e4.refreshExpiredTiles, this._fadeDuration = e4.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = e4.crossSourceCollisions, this._collectResourceTiming = e4.collectResourceTiming, this._language = this._parseLanguage(e4.language), this._worldview = e4.worldview, this._renderTaskQueue = new nI(), this._domRenderTaskQueue = new nI(), this._controls = [], this._markers = [], this._popups = [], this._mapId = F(), this._locale = k2({}, dI, e4.locale), this._clickTolerance = e4.clickTolerance, this._cooperativeGestures = e4.cooperativeGestures, this._performanceMetricsCollection = e4.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new uI(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new ze(e4.transformRequest, e4.accessToken, e4.testMode), this._silenceAuthErrors = !!e4.testMode, this._contextCreateOptions = e4.contextCreateOptions ? { ...e4.contextCreateOptions } : {}, "string" == typeof e4.container) {
            if (this._container = t2.document.getElementById(e4.container), !this._container)
              throw new Error(`Container '${e4.container.toString()}' not found.`);
          } else {
            if (!(e4.container instanceof t2.HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = e4.container;
          }
          if (this._container.childNodes.length > 0 && H2("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), e4.maxBounds && this.setMaxBounds(e4.maxBounds), j2(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
            throw new Error("Failed to initialize WebGL.");
          if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), void 0 !== t2 && (this._fullscreenchangeEvent = "onfullscreenchange" in t2.document ? "fullscreenchange" : "webkitfullscreenchange", t2.addEventListener("online", this._onWindowOnline, false), t2.addEventListener("resize", this._onWindowResize, false), t2.addEventListener("orientationchange", this._onWindowResize, false), t2.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), t2.addEventListener("visibilitychange", this._onVisibilityChange, false)), this.handlers = new QS(this, e4), this._localFontFamily = e4.localFontFamily, this._localIdeographFontFamily = e4.localIdeographFontFamily, (e4.style || !e4.testMode) && this.setStyle(e4.style || n3.DEFAULT_STYLE, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), e4.projection && this.setProjection(e4.projection), e4.hash && (this._hash = new nS("string" == typeof e4.hash && e4.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
            null == i3.center && null == i3.zoom || (this.transform._unmodified = false), this.jumpTo({ center: e4.center, zoom: e4.zoom, bearing: e4.bearing, pitch: e4.pitch });
            const t3 = e4.bounds;
            t3 && (this.resize(), this.fitBounds(t3, k2({}, e4.fitBoundsOptions, { duration: 0 })));
          }
          this.resize(), e4.attributionControl && this.addControl(new iI({ customAttribution: e4.customAttribution })), this._logoControl = new rI(), this.addControl(this._logoControl, e4.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (e5) => {
            this._update("style" === e5.dataType), this.fire(new It(`${e5.dataType}data`, e5));
          }), this.on("dataloading", (e5) => {
            this.fire(new It(`${e5.dataType}dataloading`, e5));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(e4, t3) {
          if (void 0 === t3 && (t3 = e4.getDefaultPosition ? e4.getDefaultPosition() : "top-right"), !e4 || !e4.onAdd)
            return this.fire(new Ct(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i3 = e4.onAdd(this);
          this._controls.push(e4);
          const r3 = this._controlPositions[t3];
          return -1 !== t3.indexOf("bottom") ? r3.insertBefore(i3, r3.firstChild) : r3.appendChild(i3), this;
        }
        removeControl(e4) {
          if (!e4 || !e4.onRemove)
            return this.fire(new Ct(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const t3 = this._controls.indexOf(e4);
          return t3 > -1 && this._controls.splice(t3, 1), e4.onRemove(this), this;
        }
        hasControl(e4) {
          return this._controls.indexOf(e4) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(e4) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
            return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const t3 = !this._moving;
          return t3 && this.fire(new It("movestart", e4)).fire(new It("move", e4)), this.fire(new It("resize", e4)), t3 && this.fire(new It("moveend", e4)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(e4) {
          return this.transform.setMaxBounds(sc.convert(e4)), this._update();
        }
        setMinZoom(e4) {
          if ((e4 = null == e4 ? -2 : e4) >= -2 && e4 <= this.transform.maxZoom)
            return this.transform.minZoom = e4, this._update(), this.getZoom() < e4 ? this.setZoom(e4) : this.fire(new It("zoomstart")).fire(new It("zoom")).fire(new It("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(e4) {
          if ((e4 = null == e4 ? 22 : e4) >= this.transform.minZoom)
            return this.transform.maxZoom = e4, this._update(), this.getZoom() > e4 ? this.setZoom(e4) : this.fire(new It("zoomstart")).fire(new It("zoom")).fire(new It("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(e4) {
          if ((e4 = null == e4 ? 0 : e4) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (e4 >= 0 && e4 <= this.transform.maxPitch)
            return this.transform.minPitch = e4, this._update(), this.getPitch() < e4 ? this.setPitch(e4) : this.fire(new It("pitchstart")).fire(new It("pitch")).fire(new It("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(e4) {
          if ((e4 = null == e4 ? 85 : e4) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (e4 >= this.transform.minPitch)
            return this.transform.maxPitch = e4, this._update(), this.getPitch() > e4 ? this.setPitch(e4) : this.fire(new It("pitchstart")).fire(new It("pitch")).fire(new It("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e4) {
          return this.transform.renderWorldCopies = e4, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(e4) {
          return "auto" === e4 ? t2.navigator.language : Array.isArray(e4) ? 0 === e4.length ? void 0 : e4.map((e5) => "auto" === e5 ? t2.navigator.language : e5) : e4;
        }
        setLanguage(e4) {
          const t3 = this._parseLanguage(e4);
          if (!this.style || t3 === this._language)
            return this;
          this._language = t3, this.style.reloadSources();
          for (const e5 of this._controls)
            e5._setLanguage && e5._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(e4) {
          return this.style && e4 !== this._worldview ? (this._worldview = e4, this.style.reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return "globe" === this.transform.projection.name;
        }
        setProjection(e4) {
          return this._lazyInitEmptyStyle(), e4 ? "string" == typeof e4 && (e4 = { name: e4 }) : e4 = null, this._useExplicitProjection = !!e4, this._prioritizeAndUpdateProjection(e4, this.style.projection);
        }
        _updateProjectionTransition() {
          if ("globe" !== this.getProjection().name)
            return;
          const e4 = this.transform, t3 = e4.projection.name;
          let i3;
          "globe" === t3 && e4.zoom >= id ? (e4.setMercatorFromTransition(), i3 = true) : "mercator" === t3 && e4.zoom < id && (e4.setProjection({ name: "globe" }), i3 = true), i3 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(e4, t3) {
          return this._updateProjection(e4 || t3 || { name: "mercator" });
        }
        _updateProjection(e4) {
          let t3;
          return t3 = "globe" === e4.name && this.transform.zoom >= id ? this.transform.setMercatorFromTransition() : this.transform.setProjection(e4), this.style.applyProjectionUpdate(), t3 && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
        }
        project(e4) {
          return this.transform.locationPoint3D(Wd.convert(e4));
        }
        unproject(e4) {
          return this.transform.pointLocation3D(y2.convert(e4));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || false;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || false;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || false;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || false;
        }
        _createDelegatedListener(e4, t3, i3) {
          if ("mouseenter" === e4 || "mouseover" === e4) {
            let r3 = false;
            const n4 = (n5) => {
              const o4 = t3.filter((e5) => this.getLayer(e5)), s6 = o4.length ? this.queryRenderedFeatures(n5.point, { layers: o4 }) : [];
              s6.length ? r3 || (r3 = true, i3.call(this, new fS(e4, this, n5.originalEvent, { features: s6 }))) : r3 = false;
            }, o3 = () => {
              r3 = false;
            };
            return { layers: new Set(t3), listener: i3, delegates: { mousemove: n4, mouseout: o3 } };
          }
          if ("mouseleave" === e4 || "mouseout" === e4) {
            let r3 = false;
            const n4 = (n5) => {
              const o4 = t3.filter((e5) => this.getLayer(e5));
              (o4.length ? this.queryRenderedFeatures(n5.point, { layers: o4 }) : []).length ? r3 = true : r3 && (r3 = false, i3.call(this, new fS(e4, this, n5.originalEvent)));
            }, o3 = (t4) => {
              r3 && (r3 = false, i3.call(this, new fS(e4, this, t4.originalEvent)));
            };
            return { layers: new Set(t3), listener: i3, delegates: { mousemove: n4, mouseout: o3 } };
          }
          {
            const r3 = (e5) => {
              const r4 = t3.filter((e6) => this.getLayer(e6)), n4 = r4.length ? this.queryRenderedFeatures(e5.point, { layers: r4 }) : [];
              n4.length && (e5.features = n4, i3.call(this, e5), delete e5.features);
            };
            return { layers: new Set(t3), listener: i3, delegates: { [e4]: r3 } };
          }
        }
        on(e4, t3, i3) {
          if (void 0 === i3)
            return super.on(e4, t3);
          if (Array.isArray(t3) || (t3 = [t3]), t3) {
            for (const e5 of t3)
              if (!this._isValidId(e5))
                return this;
          }
          const r3 = this._createDelegatedListener(e4, t3, i3);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e4] = this._delegatedListeners[e4] || [], this._delegatedListeners[e4].push(r3);
          for (const e5 in r3.delegates)
            this.on(e5, r3.delegates[e5]);
          return this;
        }
        once(e4, t3, i3) {
          if (void 0 === i3)
            return super.once(e4, t3);
          if (Array.isArray(t3) || (t3 = [t3]), t3) {
            for (const e5 of t3)
              if (!this._isValidId(e5))
                return this;
          }
          const r3 = this._createDelegatedListener(e4, t3, i3);
          for (const e5 in r3.delegates)
            this.once(e5, r3.delegates[e5]);
          return this;
        }
        off(e4, t3, i3) {
          if (void 0 === i3)
            return super.off(e4, t3);
          t3 = new Set(Array.isArray(t3) ? t3 : [t3]);
          for (const e5 of t3)
            if (!this._isValidId(e5))
              return this;
          const r3 = (e5, t4) => {
            if (e5.size !== t4.size)
              return false;
            for (const i4 of e5)
              if (!t4.has(i4))
                return false;
            return true;
          }, n4 = this._delegatedListeners ? this._delegatedListeners[e4] : void 0;
          return n4 && ((e5) => {
            for (let n5 = 0; n5 < e5.length; n5++) {
              const o3 = e5[n5];
              if (o3.listener === i3 && r3(o3.layers, t3)) {
                for (const e6 in o3.delegates)
                  this.off(e6, o3.delegates[e6]);
                return e5.splice(n5, 1), this;
              }
            }
          })(n4), this;
        }
        queryRenderedFeatures(e4, t3) {
          if (!this.style)
            return [];
          if (void 0 !== t3 || void 0 === e4 || e4 instanceof y2 || Array.isArray(e4) || (t3 = e4, e4 = void 0), e4 = e4 || [[0, 0], [this.transform.width, this.transform.height]], (t3 = t3 || {}).layers && Array.isArray(t3.layers)) {
            for (const e5 of t3.layers)
              if (!this._isValidId(e5))
                return [];
          }
          return this.style.queryRenderedFeatures(e4, t3, this.transform);
        }
        querySourceFeatures(e4, t3) {
          return this._isValidId(e4) ? this.style.querySourceFeatures(e4, t3) : [];
        }
        isPointOnSurface(e4) {
          const { name: t3 } = this.transform.projection;
          return "globe" !== t3 && "mercator" !== t3 && H2(`${t3} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(y2.convert(e4));
        }
        setStyle(e4, t3) {
          return false !== (t3 = k2({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, t3)).diff && t3.localIdeographFontFamily === this._localIdeographFontFamily && t3.localFontFamily === this._localFontFamily && this.style && e4 ? (this._diffStyle(e4, t3), this) : (this._localIdeographFontFamily = t3.localIdeographFontFamily, this._localFontFamily = t3.localFontFamily, this._updateStyle(e4, t3));
        }
        _getUIString(e4) {
          const t3 = this._locale[e4];
          if (null == t3)
            throw new Error(`Missing UI string '${e4}'`);
          return t3;
        }
        _updateStyle(e4, t3) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e4 && (this.style = new iS(this, t3 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e4 ? this.style.loadURL(e4) : this.style.loadJSON(e4)), this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new iS(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(e4, t3) {
          if ("string" == typeof e4) {
            const i3 = this._requestManager.normalizeStyleURL(e4), r3 = this._requestManager.transformRequest(i3, ye.Style);
            we(r3, (e5, i4) => {
              e5 ? this.fire(new Ct(e5)) : i4 && this._updateDiff(i4, t3);
            });
          } else
            "object" == typeof e4 && this._updateDiff(e4, t3);
        }
        _updateDiff(e4, t3) {
          try {
            this.style.setState(e4) && this._update(true);
          } catch (i3) {
            H2(`Unable to perform style diff: ${i3.message || i3.error || i3}.  Rebuilding the style from scratch.`), this._updateStyle(e4, t3);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (H2("There is no style added to the map."), false);
        }
        _isValidId(e4) {
          return null == e4 ? (this.fire(new Ct(new Error("IDs can't be empty."))), false) : !xa(e4) || (this.fire(new Ct(new Error(`IDs can't contain special symbols: "${e4}".`))), false);
        }
        addSource(e4, t3) {
          return this._isValidId(e4) ? (this._lazyInitEmptyStyle(), this.style.addSource(e4, t3), this._update(true)) : this;
        }
        isSourceLoaded(e4) {
          return !!this._isValidId(e4) && !!this.style && this.style._isSourceCacheLoaded(e4);
        }
        areTilesLoaded() {
          const e4 = this.style && this.style._sourceCaches;
          for (const t3 in e4) {
            const i3 = e4[t3]._tiles;
            for (const e5 in i3) {
              const t4 = i3[e5];
              if ("loaded" !== t4.state && "errored" !== t4.state)
                return false;
            }
          }
          return true;
        }
        addSourceType(e4, t3, i3) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e4, t3, i3);
        }
        removeSource(e4) {
          return this._isValidId(e4) ? (this.style.removeSource(e4), this._updateTerrain(), this._update(true)) : this;
        }
        getSource(e4) {
          return this._isValidId(e4) ? this.style.getOwnSource(e4) : null;
        }
        addImage(e4, i3, { pixelRatio: r3 = 1, sdf: n4 = false, stretchX: o3, stretchY: s6, content: a3 } = {}) {
          if (this._lazyInitEmptyStyle(), i3 instanceof t2.HTMLImageElement || t2.ImageBitmap && i3 instanceof t2.ImageBitmap) {
            const { width: t3, height: l3, data: c3 } = dt.getImageData(i3);
            this.style.addImage(e4, { data: new ef({ width: t3, height: l3 }, c3), pixelRatio: r3, stretchX: o3, stretchY: s6, content: a3, sdf: n4, version: 0 });
          } else if (void 0 === i3.width || void 0 === i3.height)
            this.fire(new Ct(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: t3, height: l3 } = i3, c3 = i3;
            this.style.addImage(e4, { data: new ef({ width: t3, height: l3 }, new Uint8Array(c3.data)), pixelRatio: r3, stretchX: o3, stretchY: s6, content: a3, sdf: n4, version: 0, userImage: c3 }), c3.onAdd && c3.onAdd(this, e4);
          }
        }
        updateImage(e4, i3) {
          this._lazyInitEmptyStyle();
          const r3 = this.style.getImage(e4);
          if (!r3)
            return void this.fire(new Ct(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const n4 = i3 instanceof t2.HTMLImageElement || t2.ImageBitmap && i3 instanceof t2.ImageBitmap ? dt.getImageData(i3) : i3, { width: o3, height: s6 } = n4;
          void 0 !== o3 && void 0 !== s6 ? o3 === r3.data.width && s6 === r3.data.height ? (r3.data.replace(n4.data, !(i3 instanceof t2.HTMLImageElement || t2.ImageBitmap && i3 instanceof t2.ImageBitmap)), this.style.updateImage(e4, r3)) : this.fire(new Ct(new Error(`The width and height of the updated image (${o3}, ${s6})
                must be that same as the previous version of the image
                (${r3.data.width}, ${r3.data.height})`))) : this.fire(new Ct(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
        }
        hasImage(e4) {
          return e4 ? !!this.style && !!this.style.getImage(e4) : (this.fire(new Ct(new Error("Missing required image id"))), false);
        }
        removeImage(e4) {
          this.style.removeImage(e4);
        }
        loadImage(e4, i3) {
          Ie(this._requestManager.transformRequest(e4, ye.Image), (e5, r3) => {
            i3(e5, r3 instanceof t2.HTMLImageElement ? dt.getImageData(r3) : r3);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addModel(e4, t3) {
          this._lazyInitEmptyStyle(), this.style.addModel(e4, t3);
        }
        hasModel(e4) {
          return e4 ? this.style.hasModel(e4) : (this.fire(new Ct(new Error("Missing required model id"))), false);
        }
        removeModel(e4) {
          this.style.removeModel(e4);
        }
        listModels() {
          return this.style.listModels();
        }
        addLayer(e4, t3) {
          return this._isValidId(e4.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e4, t3), this._update(true)) : this;
        }
        moveLayer(e4, t3) {
          return this._isValidId(e4) ? (this.style.moveLayer(e4, t3), this._update(true)) : this;
        }
        removeLayer(e4) {
          return this._isValidId(e4) ? (this.style.removeLayer(e4), this._update(true)) : this;
        }
        getLayer(e4) {
          return this._isValidId(e4) ? this.style.getOwnLayer(e4) : null;
        }
        setLayerZoomRange(e4, t3, i3) {
          return this._isValidId(e4) ? (this.style.setLayerZoomRange(e4, t3, i3), this._update(true)) : this;
        }
        setFilter(e4, t3, i3 = {}) {
          return this._isValidId(e4) ? (this.style.setFilter(e4, t3, i3), this._update(true)) : this;
        }
        getFilter(e4) {
          return this._isValidId(e4) ? this.style.getFilter(e4) : null;
        }
        setPaintProperty(e4, t3, i3, r3 = {}) {
          return this._isValidId(e4) ? (this.style.setPaintProperty(e4, t3, i3, r3), this._update(true)) : this;
        }
        getPaintProperty(e4, t3) {
          return this._isValidId(e4) ? this.style.getPaintProperty(e4, t3) : null;
        }
        setLayoutProperty(e4, t3, i3, r3 = {}) {
          return this._isValidId(e4) ? (this.style.setLayoutProperty(e4, t3, i3, r3), this._update(true)) : this;
        }
        getLayoutProperty(e4, t3) {
          return this._isValidId(e4) ? this.style.getLayoutProperty(e4, t3) : null;
        }
        getConfigProperty(e4, t3) {
          return this.style.getConfigProperty(e4, t3);
        }
        setConfigProperty(e4, t3, i3) {
          return this.style.setConfigProperty(e4, t3, i3), this._update(true);
        }
        setLights(e4) {
          if (this._lazyInitEmptyStyle(), e4 && 1 === e4.length && "flat" === e4[0].type) {
            const t3 = e4[0];
            t3.properties ? this.style.setFlatLight(t3.properties, t3.id, {}) : this.style.setFlatLight({}, "flat");
          } else
            this.style.setLights(e4), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
          return this._update(true);
        }
        getLights() {
          const e4 = this.style.getLights() || [];
          return 0 === e4.length && e4.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e4;
        }
        setLight(e4, t3 = {}) {
          return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e4 }]);
        }
        getLight() {
          return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
        }
        setTerrain(e4) {
          return this._lazyInitEmptyStyle(), !e4 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e4), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e4) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e4), this._update(true);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        setCamera(e4) {
          return this.style.setCamera(e4), this._triggerCameraUpdate(e4);
        }
        _triggerCameraUpdate(e4) {
          return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e4["camera-projection"]));
        }
        getCamera() {
          return this.style.camera;
        }
        _queryFogOpacity(e4) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(Wd.convert(e4), this.transform) : 0;
        }
        setFeatureState(e4, t3) {
          return this._isValidId(e4.source) ? (this.style.setFeatureState(e4, t3), this._update()) : this;
        }
        removeFeatureState(e4, t3) {
          return this._isValidId(e4.source) ? (this.style.removeFeatureState(e4, t3), this._update()) : this;
        }
        getFeatureState(e4) {
          return this._isValidId(e4.source) ? this.style.getFeatureState(e4) : null;
        }
        _updateContainerDimensions() {
          if (!this._container)
            return;
          const e4 = this._container.getBoundingClientRect().width || 400, i3 = this._container.getBoundingClientRect().height || 300;
          let r3, n4, o3, s6 = this._container;
          for (; s6 && (!n4 || !o3); ) {
            const e5 = t2.getComputedStyle(s6).transform;
            e5 && "none" !== e5 && (r3 = e5.match(/matrix.*\((.+)\)/)[1].split(", "), r3[0] && "0" !== r3[0] && "1" !== r3[0] && (n4 = r3[0]), r3[3] && "0" !== r3[3] && "1" !== r3[3] && (o3 = r3[3])), s6 = s6.parentElement;
          }
          this._containerWidth = n4 ? Math.abs(e4 / n4) : e4, this._containerHeight = o3 ? Math.abs(i3 / o3) : i3;
        }
        _detectMissingCSS() {
          "rgb(250, 128, 114)" !== t2.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && H2("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e4 = this._container;
          e4.classList.add("mapboxgl-map"), (this._missingCSSCanary = pt("div", "mapboxgl-canary", e4)).style.visibility = "hidden", this._detectMissingCSS();
          const t3 = this._canvasContainer = pt("div", "mapboxgl-canvas-container", e4);
          this._canvas = pt("canvas", "mapboxgl-canvas", t3), this._interactive && (t3.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i3 = this._controlContainer = pt("div", "mapboxgl-control-container", e4), r3 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e5) => {
            r3[e5] = pt("div", `mapboxgl-ctrl-${e5}`, i3);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(e4, t3) {
          const i3 = dt.devicePixelRatio || 1;
          this._canvas.width = i3 * Math.ceil(e4), this._canvas.height = i3 * Math.ceil(t3), this._canvas.style.width = `${e4}px`, this._canvas.style.height = `${t3}px`;
        }
        _addMarker(e4) {
          this._markers.push(e4);
        }
        _removeMarker(e4) {
          const t3 = this._markers.indexOf(e4);
          -1 !== t3 && this._markers.splice(t3, 1);
        }
        _addPopup(e4) {
          this._popups.push(e4);
        }
        _removePopup(e4) {
          const t3 = this._popups.indexOf(e4);
          -1 !== t3 && this._popups.splice(t3, 1);
        }
        _setupPainter() {
          const e4 = k2({}, rt.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), t3 = this._canvas.getContext("webgl2", e4);
          t3 ? (Ke(t3, true), this.painter = new UA(t3, this._contextCreateOptions, this.transform), this.on("data", (e5) => {
            "source" === e5.dataType && this.painter.setTileLoadedFlag(true);
          }), o2.testSupport(t3)) : this.fire(new Ct(new Error("Failed to initialize WebGL")));
        }
        _contextLost(e4) {
          e4.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new It("webglcontextlost", { originalEvent: e4 }));
        }
        _contextRestored(e4) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new It("webglcontextrestored", { originalEvent: e4 }));
        }
        _onMapScroll(e4) {
          if (e4.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e4) {
          return this.style ? (this._styleDirty = this._styleDirty || e4, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e4) {
          return this._update(), this._renderTaskQueue.add(e4);
        }
        _cancelRenderFrame(e4) {
          this._renderTaskQueue.remove(e4);
        }
        _requestDomTask(e4) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e4() : this._domRenderTaskQueue.add(e4);
        }
        _render(e4) {
          let i3;
          this.fire(new It("renderstart"));
          const r3 = this.painter.context.extTimerQuery, n4 = dt.now(), o3 = this.painter.context.gl;
          if (this.listens("gpu-timing-frame") && (i3 = o3.createQuery(), o3.beginQuery(r3.TIME_ELAPSED_EXT, i3)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], t2.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], t2.performance.now())), this._renderTaskQueue.run(e4), this._domRenderTaskQueue.run(e4), this._removed)
            return;
          this._updateProjectionTransition();
          const s6 = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const e5 = this.transform.zoom, t3 = this.transform.pitch, i4 = dt.now(), r4 = new oa(e5, { now: i4, fadeDuration: s6, pitch: t3, transition: this.style.transition });
            this.style.update(r4);
          }
          this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
          let a3 = false;
          if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), a3 = this._updateAverageElevation(n4), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : a3 = this._updateAverageElevation(n4), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, s6, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: s6, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new It("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new It("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i3) {
            const e5 = dt.now() - n4;
            o3.endQuery(r3.TIME_ELAPSED_EXT), setTimeout(() => {
              const r4 = o3.getQueryParameter(i3, o3.QUERY_RESULT) / 1e6;
              o3.deleteQuery(i3), this.fire(new It("gpu-timing-frame", { cpuTime: e5, gpuTime: r4 })), t2.performance.mark("frame-gpu", { startTime: n4, detail: { gpuTime: r4 } });
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const e5 = this.painter.collectGpuTimers();
            setTimeout(() => {
              const t3 = this.painter.queryGpuTimers(e5);
              this.fire(new It("gpu-timing-layer", { layerTimes: t3 }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const e5 = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const t3 = this.painter.queryGpuTimeDeferredRender(e5);
              this.fire(new It("gpu-timing-deferred-render", { gpuTime: t3 }));
            }, 50);
          }
          const l3 = this._sourcesDirty || this._styleDirty || this._placementDirty || a3;
          if (l3 || this._repaint)
            this.triggerRepaint();
          else {
            const e5 = !this.isMoving() && this.loaded();
            if (e5 && (a3 = this._updateAverageElevation(n4, true)), a3)
              this.triggerRepaint();
            else if (this._triggerFrame(false), e5 && (this.fire(new It("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
              const e6 = this._calculateSpeedIndex();
              this.fire(new It("speedindexcompleted", { speedIndex: e6 })), this.speedIndexTiming = false;
            }
          }
          !this._loaded || this._fullyLoaded || l3 || (this._fullyLoaded = true, Qe.mark(Je.fullLoad), this._performanceMetricsCollection && We(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(e4) {
          for (const t3 of this._markers)
            e4 && !this.getRenderWorldCopies() && (t3._lngLat = t3._lngLat.wrap()), t3._update();
          for (const t3 of this._popups)
            !e4 || this.getRenderWorldCopies() || t3._trackPointer || (t3._lngLat = t3._lngLat.wrap()), t3._update();
        }
        _updateAverageElevation(e4, t3 = false) {
          const i3 = (e5) => (this.transform.averageElevation = e5, this._update(false), true);
          if (!this.painter.averageElevationNeedsEasing())
            return 0 !== this.transform.averageElevation && i3(0);
          const r3 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
          if (r3 || (t3 || e4 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e4)) {
            const t4 = this.transform.averageElevation;
            let n4 = this.transform.sampleAverageElevation();
            this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(n4) ? n4 = 0 : this._averageElevationLastSampledAt = e4;
            const o3 = Math.abs(t4 - n4);
            if (o3 > 1) {
              if (this._isInitialLoad || r3)
                return this._averageElevation.jumpTo(n4), i3(n4);
              this._averageElevation.easeTo(n4, e4, 300);
            } else if (o3 > 1e-4)
              return this._averageElevation.jumpTo(n4), i3(n4);
          }
          return !!this._averageElevation.isEasing(e4) && i3(this._averageElevation.getValue(e4));
        }
        _authenticate() {
          Xe(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (e4) => {
            if (e4 && (e4.message === Ce || 401 === e4.status)) {
              const e5 = this.painter.context.gl;
              Ke(e5, false), this._logoControl instanceof rI && this._logoControl._updateLogo(), e5 && e5.clear(e5.DEPTH_BUFFER_BIT | e5.COLOR_BUFFER_BIT | e5.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new Ct(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), Ze(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _updateTerrain() {
          const e4 = this._isDragging();
          this.painter.updateTerrain(this.style, e4);
        }
        _calculateSpeedIndex() {
          const e4 = this.painter.canvasCopy(), t3 = this.painter.getCanvasCopiesAndTimestamps();
          t3.timeStamps.push(performance.now());
          const i3 = this.painter.context.gl, r3 = i3.createFramebuffer();
          function n4(e5) {
            i3.framebufferTexture2D(i3.FRAMEBUFFER, i3.COLOR_ATTACHMENT0, i3.TEXTURE_2D, e5, 0);
            const t4 = new Uint8Array(i3.drawingBufferWidth * i3.drawingBufferHeight * 4);
            return i3.readPixels(0, 0, i3.drawingBufferWidth, i3.drawingBufferHeight, i3.RGBA, i3.UNSIGNED_BYTE, t4), t4;
          }
          return i3.bindFramebuffer(i3.FRAMEBUFFER, r3), this._canvasPixelComparison(n4(e4), t3.canvasCopies.map(n4), t3.timeStamps);
        }
        _canvasPixelComparison(e4, t3, i3) {
          let r3 = i3[1] - i3[0];
          const n4 = e4.length / 4;
          for (let o3 = 0; o3 < t3.length; o3++) {
            const s6 = t3[o3];
            let a3 = 0;
            for (let t4 = 0; t4 < s6.length; t4 += 4)
              s6[t4] === e4[t4] && s6[t4 + 1] === e4[t4 + 1] && s6[t4 + 2] === e4[t4 + 2] && s6[t4 + 3] === e4[t4 + 3] && (a3 += 1);
            r3 += (i3[o3 + 2] - i3[o3 + 1]) * (1 - a3 / n4);
          }
          return r3;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e5 of this._controls)
            e5.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== t2 && (t2.removeEventListener("resize", this._onWindowResize, false), t2.removeEventListener("orientationchange", this._onWindowResize, false), t2.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), t2.removeEventListener("online", this._onWindowOnline, false), t2.removeEventListener("visibilitychange", this._onVisibilityChange, false));
          const e4 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          e4 && e4.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), Ye.delete(this.painter.context.gl), this._removed = true, this.fire(new It("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(true);
        }
        _triggerFrame(e4) {
          this._renderNextFrame = this._renderNextFrame || e4, this.style && !this._frame && (this._frame = dt.frame((e5) => {
            const t3 = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t3 && this._render(e5);
          }));
        }
        _preloadTiles(e4) {
          return R2(this.style ? Object.values(this.style._sourceCaches) : [], (t3, i3) => t3._preloadTiles(e4, i3), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e4) {
          this._trackResize && this.resize({ originalEvent: e4 })._update();
        }
        _onVisibilityChange() {
          "hidden" === t2.document.visibilityState && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e4) {
          this._showTileBoundaries !== e4 && (this._showTileBoundaries = e4, this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e4) {
          this._showTerrainWireframe !== e4 && (this._showTerrainWireframe = e4, this._update());
        }
        get showLayers2DWireframe() {
          return !!this._showLayers2DWireframe;
        }
        set showLayers2DWireframe(e4) {
          this._showLayers2DWireframe !== e4 && (this._showLayers2DWireframe = e4, this._update());
        }
        get showLayers3DWireframe() {
          return !!this._showLayers3DWireframe;
        }
        set showLayers3DWireframe(e4) {
          this._showLayers3DWireframe !== e4 && (this._showLayers3DWireframe = e4, this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e4) {
          this._speedIndexTiming !== e4 && (this._speedIndexTiming = e4, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e4) {
          this._showPadding !== e4 && (this._showPadding = e4, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e4) {
          this._showCollisionBoxes !== e4 && (this._showCollisionBoxes = e4, e4 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e4) {
          this._showOverdrawInspector !== e4 && (this._showOverdrawInspector = e4, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e4) {
          this._repaint !== e4 && (this._repaint = e4, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e4) {
          this._vertices = e4, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(e4) {
          this._showTileAABBs !== e4 && (this._showTileAABBs = e4, e4 && this._update());
        }
        _setCacheLimits(e4, t3) {
          !function(e5, t4) {
            ce = e5, he = t4;
          }(e4, t3);
        }
        get version() {
          return i2;
        }
      }, NavigationControl: class {
        constructor(e4) {
          this.options = k2({}, fI, e4), this._container = pt("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e5) => e5.preventDefault()), this.options.showZoom && (j2(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e5) => {
            this._map && this._map.zoomIn({}, { originalEvent: e5 });
          }), pt("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e5) => {
            this._map && this._map.zoomOut({}, { originalEvent: e5 });
          }), pt("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (j2(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e5) => {
            const t3 = this._map;
            t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e5 }) : t3.resetNorth({}, { originalEvent: e5 }));
          }), this._compassIcon = pt("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const e4 = this._map;
          if (!e4)
            return;
          const t3 = e4.getZoom(), i3 = t3 === e4.getMaxZoom(), r3 = t3 === e4.getMinZoom();
          this._zoomInButton.disabled = i3, this._zoomOutButton.disabled = r3, this._zoomInButton.setAttribute("aria-disabled", i3.toString()), this._zoomOutButton.setAttribute("aria-disabled", r3.toString());
        }
        _rotateCompassArrow() {
          const e4 = this._map;
          if (!e4)
            return;
          const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e4.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e4.transform.pitch}deg) rotateZ(${e4.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e4.transform.angle * (180 / Math.PI)}deg)`;
          e4._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t3);
          });
        }
        onAdd(e4) {
          return this._map = e4, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e4.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e4.on("pitch", this._rotateCompassArrow), e4.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new mI(e4, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const e4 = this._map;
          e4 && (this._container.remove(), this.options.showZoom && e4.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e4.off("pitch", this._rotateCompassArrow), e4.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(e4, t3) {
          const i3 = pt("button", e4, this._container);
          return i3.type = "button", i3.addEventListener("click", t3), i3;
        }
        _setButtonTitle(e4, t3) {
          if (!this._map)
            return;
          const i3 = this._map._getUIString(`NavigationControl.${t3}`);
          e4.setAttribute("aria-label", i3), e4.firstElementChild && e4.firstElementChild.setAttribute("title", i3);
        }
      }, GeolocateControl: class extends zt {
        constructor(e4) {
          super(), this.options = k2({ geolocation: t2.navigator.geolocation }, _I, e4), j2(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = rS(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(e4) {
          return this._map = e4, this._container = pt("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
        }
        _checkGeolocationSupport(e4) {
          const i3 = (t3 = !!this.options.geolocation) => {
            this._supportsGeolocation = t3, e4(t3);
          };
          void 0 !== this._supportsGeolocation ? e4(this._supportsGeolocation) : void 0 !== t2.navigator.permissions ? t2.navigator.permissions.query({ name: "geolocation" }).then((e5) => i3("denied" !== e5.state)).catch(() => i3()) : i3();
        }
        _isOutOfMapMaxBounds(e4) {
          const t3 = this._map.getMaxBounds(), i3 = e4.coords;
          return !!t3 && (i3.longitude < t3.getWest() || i3.longitude > t3.getEast() || i3.latitude < t3.getSouth() || i3.latitude > t3.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(e4) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(e4))
              return this._setErrorState(), this.fire(new It("outofmaxbounds", e4)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = e4, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e4), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e4), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new It("geolocate", e4)), this._finish();
          }
        }
        _updateCamera(e4) {
          const t3 = new Wd(e4.coords.longitude, e4.coords.latitude), i3 = e4.coords.accuracy, r3 = k2({ bearing: this._map.getBearing() }, this.options.fitBoundsOptions);
          this._map.fitBounds(t3.toBounds(i3), r3, { geolocateSource: true });
        }
        _updateMarker(e4) {
          if (e4) {
            const t3 = new Wd(e4.coords.longitude, e4.coords.latitude);
            this._accuracyCircleMarker.setLngLat(t3).addTo(this._map), this._userLocationDotMarker.setLngLat(t3).addTo(this._map), this._accuracy = e4.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const e4 = this._map.transform, t3 = Qd(1, e4._center.lat) * e4.worldSize, i3 = Math.ceil(2 * this._accuracy * t3);
          this._circleElement.style.width = `${i3}px`, this._circleElement.style.height = `${i3}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(e4) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (1 === e4.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e5 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e5), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e5), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === e4.code && this._noTimeout)
                  return;
                this._setErrorState();
              }
            "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new It("error", e4)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(e4) {
          if (void 0 !== this._map) {
            if (this._container.addEventListener("contextmenu", (e5) => e5.preventDefault()), this._geolocateButton = pt("button", "mapboxgl-ctrl-geolocate", this._container), pt("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e4) {
              H2("Geolocation support is not available so the GeolocateControl will be disabled.");
              const e5 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", e5), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e5);
            } else {
              const e5 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", e5), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e5);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = pt("div", "mapboxgl-user-location"), this._dotElement.appendChild(pt("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(pt("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new aI({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = pt("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new aI({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e5) => {
              e5.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e5.originalEvent && "resize" === e5.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new It("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(e4) {
          this._userLocationDotMarker && (e4.webkitCompassHeading ? this._heading = e4.webkitCompassHeading : true === e4.absolute && (this._heading = -1 * e4.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return H2("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new It("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new It("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new It("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
              this._clearWatch();
            else if (void 0 === this._geolocationWatchID) {
              let e4;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e4 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e4 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e4), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _addDeviceOrientationListener() {
          const e4 = () => {
            t2.addEventListener("ondeviceorientationabsolute" in t2 ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
          };
          void 0 !== t2.DeviceMotionEvent && "function" == typeof t2.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t3) => {
            "granted" === t3 && e4();
          }).catch(console.error) : e4();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), t2.removeEventListener("deviceorientation", this._onDeviceOrientation), t2.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: iI, ScaleControl: class {
        constructor(e4) {
          this.options = k2({}, gI, e4), this._isNumberFormatSupported = function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
            } catch (e5) {
              return false;
            }
          }(), j2(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const e4 = this.options.maxWidth || 100, t3 = this._map, i3 = t3._containerHeight / 2, r3 = t3._containerWidth / 2 - e4 / 2, n4 = t3.unproject([r3, i3]), o3 = t3.unproject([r3 + e4, i3]), s6 = n4.distanceTo(o3);
          if ("imperial" === this.options.unit) {
            const t4 = 3.2808 * s6;
            t4 > 5280 ? this._setScale(e4, t4 / 5280, "mile") : this._setScale(e4, t4, "foot");
          } else
            "nautical" === this.options.unit ? this._setScale(e4, s6 / 1852, "nautical-mile") : s6 >= 1e3 ? this._setScale(e4, s6 / 1e3, "kilometer") : this._setScale(e4, s6, "meter");
        }
        _setScale(e4, t3, i3) {
          this._map._requestDomTask(() => {
            const r3 = function(e5) {
              const t4 = Math.pow(10, `${Math.floor(e5)}`.length - 1);
              let i4 = e5 / t4;
              return i4 = i4 >= 10 ? 10 : i4 >= 5 ? 5 : i4 >= 3 ? 3 : i4 >= 2 ? 2 : i4 >= 1 ? 1 : function(e6) {
                const t5 = Math.pow(10, Math.ceil(-Math.log(e6) / Math.LN10));
                return Math.round(e6 * t5) / t5;
              }(i4), t4 * i4;
            }(t3), n4 = r3 / t3;
            this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i3 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i3 }).format(r3) : `${r3}&nbsp;${yI[i3]}`, this._container.style.width = e4 * n4 + "px";
          });
        }
        onAdd(e4) {
          return this._map = e4, this._language = e4.getLanguage(), this._container = pt("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e4.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(e4) {
          this._language = e4, this._update();
        }
        setUnit(e4) {
          this.options.unit = e4, this._update();
        }
      }, FullscreenControl: class {
        constructor(e4) {
          this._fullscreen = false, e4 && e4.container && (e4.container instanceof t2.HTMLElement ? this._container = e4.container : H2("Full screen control 'container' must be a DOM element.")), j2(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t2.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in t2.document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(e4) {
          return this._map = e4, this._container || (this._container = this._map.getContainer()), this._controlContainer = pt("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", H2("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, t2.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!t2.document.fullscreenEnabled && !t2.document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const e4 = this._fullscreenButton = pt("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          pt("span", "mapboxgl-ctrl-icon", e4).setAttribute("aria-hidden", "true"), e4.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t2.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e4 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e4), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e4);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (t2.document.fullscreenElement || t2.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? t2.document.exitFullscreen ? t2.document.exitFullscreen() : t2.document.webkitCancelFullScreen && t2.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends zt {
        constructor(e4) {
          super(), this.options = k2(Object.create(lI), e4), j2(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(e4 && e4.className ? e4.className.trim().split(/\s+/) : []);
        }
        addTo(e4) {
          return this._map && this.remove(), this._map = e4, this.options.closeOnClick && e4.on("preclick", this._onClose), this.options.closeOnMove && e4.on("move", this._onClose), e4.on("remove", this.remove), this._update(), e4._addPopup(this), this._focusFirstElement(), this._trackPointer ? (e4.on("mousemove", this._onMouseEvent), e4.on("mouseup", this._onMouseEvent), e4._canvasContainer.classList.add("mapboxgl-track-pointer")) : e4.on("move", this._update), this.fire(new It("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const e4 = this._map;
          return e4 && (e4.off("move", this._update), e4.off("move", this._onClose), e4.off("preclick", this._onClose), e4.off("click", this._onClose), e4.off("remove", this.remove), e4.off("mousemove", this._onMouseEvent), e4.off("mouseup", this._onMouseEvent), e4.off("drag", this._onMouseEvent), e4._canvasContainer && e4._canvasContainer.classList.remove("mapboxgl-track-pointer"), e4._removePopup(this), this._map = void 0), this.fire(new It("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e4) {
          this._lngLat = Wd.convert(e4), this._pos = null, this._trackPointer = false, this._update();
          const t3 = this._map;
          return t3 && (t3.on("move", this._update), t3.off("mousemove", this._onMouseEvent), t3._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = true, this._pos = null, this._update();
          const e4 = this._map;
          return e4 && (e4.off("move", this._update), e4.on("mousemove", this._onMouseEvent), e4.on("drag", this._onMouseEvent), e4._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(e4) {
          return this.setDOMContent(t2.document.createTextNode(e4));
        }
        setHTML(e4) {
          const i3 = t2.document.createDocumentFragment(), r3 = t2.document.createElement("body");
          let n4;
          for (r3.innerHTML = e4; n4 = r3.firstChild, n4; )
            i3.appendChild(n4);
          return this.setDOMContent(i3);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e4) {
          return this.options.maxWidth = e4, this._update(), this;
        }
        setDOMContent(e4) {
          let t3 = this._content;
          if (t3)
            for (; t3.hasChildNodes(); )
              t3.firstChild && t3.removeChild(t3.firstChild);
          else
            t3 = this._content = pt("div", "mapboxgl-popup-content", this._container || void 0);
          if (t3.appendChild(e4), this.options.closeButton) {
            const e5 = this._closeButton = pt("button", "mapboxgl-popup-close-button", t3);
            e5.type = "button", e5.setAttribute("aria-label", "Close popup"), e5.setAttribute("aria-hidden", "true"), e5.innerHTML = "&#215;", e5.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(e4) {
          return this._classList.add(e4), this._updateClassList(), this;
        }
        removeClassName(e4) {
          return this._classList.delete(e4), this._updateClassList(), this;
        }
        setOffset(e4) {
          return this.options.offset = e4, this._update(), this;
        }
        toggleClassName(e4) {
          let t3;
          return this._classList.delete(e4) ? t3 = false : (this._classList.add(e4), t3 = true), this._updateClassList(), t3;
        }
        _onMouseEvent(e4) {
          this._update(e4.point);
        }
        _getAnchor(e4) {
          if (this.options.anchor)
            return this.options.anchor;
          const t3 = this._map, i3 = this._container, r3 = this._pos;
          if (!t3 || !i3 || !r3)
            return "bottom";
          const n4 = i3.offsetWidth, o3 = i3.offsetHeight, s6 = r3.x < n4 / 2, a3 = r3.x > t3.transform.width - n4 / 2;
          if (r3.y + e4 < o3)
            return s6 ? "top-left" : a3 ? "top-right" : "top";
          if (r3.y > t3.transform.height - o3) {
            if (s6)
              return "bottom-left";
            if (a3)
              return "bottom-right";
          }
          return s6 ? "left" : a3 ? "right" : "bottom";
        }
        _updateClassList() {
          const e4 = this._container;
          if (!e4)
            return;
          const t3 = [...this._classList];
          t3.push("mapboxgl-popup"), this._anchor && t3.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t3.push("mapboxgl-popup-track-pointer"), e4.className = t3.join(" ");
        }
        _update(e4) {
          const t3 = this._map, i3 = this._content;
          if (!t3 || !this._lngLat && !this._trackPointer || !i3)
            return;
          let r3 = this._container;
          if (r3 || (r3 = this._container = pt("div", "mapboxgl-popup", t3.getContainer()), this._tip = pt("div", "mapboxgl-popup-tip", r3), r3.appendChild(i3)), this.options.maxWidth && r3.style.maxWidth !== this.options.maxWidth && (r3.style.maxWidth = this.options.maxWidth), t3.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = oI(this._lngLat, this._pos, t3.transform)), !this._trackPointer || e4) {
            const i4 = this._pos = this._trackPointer && e4 ? e4 : t3.project(this._lngLat), r4 = hI(this.options.offset), n4 = this._anchor = this._getAnchor(r4.y), o3 = hI(this.options.offset, n4), s6 = i4.add(o3).round();
            t3._requestDomTask(() => {
              this._container && n4 && (this._container.style.transform = `${sI[n4]} translate(${s6.x}px,${s6.y}px)`);
            });
          }
          if (!this._marker && t3._showingGlobe()) {
            const e5 = Nd(t3.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(e5);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const e4 = this._container.querySelector(cI);
          e4 && e4.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e4) {
          this._container && (this._container.style.opacity = `${e4}`), this._content && (this._content.style.pointerEvents = e4 ? "auto" : "none");
        }
      }, Marker: aI, Style: iS, LngLat: Wd, LngLatBounds: sc, Point: y2, MercatorCoordinate: lp, FreeCameraOptions: Xx, Evented: zt, config: n3, prewarm: function() {
        Ww().acquire(qw);
      }, clearPrewarmedResources: function() {
        const e4 = $w;
        e4 && (e4.isPreloaded() && 1 === e4.numActive() ? (e4.release(qw), $w = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return n3.ACCESS_TOKEN;
      }, set accessToken(e4) {
        n3.ACCESS_TOKEN = e4;
      }, get baseApiUrl() {
        return n3.API_URL;
      }, set baseApiUrl(e4) {
        n3.API_URL = e4;
      }, get workerCount() {
        return Zw.workerCount;
      }, set workerCount(e4) {
        Zw.workerCount = e4;
      }, get maxParallelImageRequests() {
        return n3.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(e4) {
        n3.MAX_PARALLEL_IMAGE_REQUESTS = e4;
      }, clearStorage(e4) {
        !function(e5) {
          if (!pe())
            return;
          const i3 = t2.caches.delete(le);
          e5 && i3.catch(e5).then(() => e5());
        }(e4);
      }, workerUrl: "", workerClass: null, get dracoUrl() {
        return Jw();
      }, set dracoUrl(e4) {
        !function(e5) {
          Xw = dt.resolveURL(e5), Kw || (Kw = new Ew(Ww(), new zt())), Kw.broadcast("setDracoUrl", Xw);
        }(e4);
      }, setNow: dt.setNow, restoreNow: dt.restoreNow };
      e3.A = Tw, e3.D = Ym, e3.E = cr, e3.F = Qm, e3.K = xE, e3.O = qu, e3.P = y2, e3.T = Zv, e3.V = hm, e3.a = Kf, e3.b = fm, e3.c = ow, e3.d = class extends zt {
        constructor(e4, t3, i3, r3, n4, o3) {
          super(), this.actor = e4, this.layerIndex = t3, this.availableImages = i3, this.loadVectorData = n4 || Uw, this.loading = {}, this.loaded = {}, this.deduped = new Nw(e4.scheduler), this.isSpriteLoaded = r3, this.scheduler = e4.scheduler, this.brightness = o3;
        }
        loadTile(e4, t3) {
          const i3 = e4.uid, r3 = e4 && e4.request, n4 = r3 && r3.collectResourceTiming, o3 = this.loading[i3] = new Bw(e4);
          o3.abort = this.loadVectorData(e4, (s6, a3) => {
            const l3 = !this.loading[i3];
            if (delete this.loading[i3], l3 || s6 || !a3)
              return o3.status = "done", l3 || (this.loaded[i3] = o3), t3(s6);
            const c3 = a3.rawData, h3 = {};
            a3.expires && (h3.expires = a3.expires), a3.cacheControl && (h3.cacheControl = a3.cacheControl), o3.vectorTile = a3.vectorTile || new cm(new km(c3));
            const u3 = () => {
              o3.parse(o3.vectorTile, this.layerIndex, this.availableImages, this.actor, (e5, i4) => {
                if (e5 || !i4)
                  return t3(e5);
                const o4 = {};
                if (n4) {
                  const e6 = it(r3);
                  e6.length > 0 && (o4.resourceTiming = JSON.parse(JSON.stringify(e6)));
                }
                t3(null, k2({ rawTileData: c3.slice(0) }, i4, h3, o4));
              });
            };
            this.isSpriteLoaded ? u3() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(u3, { type: "parseTile", isSymbolTile: e4.isSymbolTile, zoom: e4.tileZoom }) : u3();
            }), this.loaded = this.loaded || {}, this.loaded[i3] = o3;
          });
        }
        reloadTile(e4, t3) {
          const i3 = this.loaded, r3 = e4.uid, n4 = this;
          if (i3 && i3[r3]) {
            const o3 = i3[r3];
            o3.showCollisionBoxes = e4.showCollisionBoxes, o3.projection = e4.projection, o3.brightness = e4.brightness, o3.tileTransform = Pg(e4.tileID.canonical, e4.projection), o3.extraShadowCaster = e4.extraShadowCaster;
            const s6 = (e5, i4) => {
              const r4 = o3.reloadCallback;
              r4 && (delete o3.reloadCallback, o3.parse(o3.vectorTile, n4.layerIndex, this.availableImages, n4.actor, r4)), t3(e5, i4);
            };
            "parsing" === o3.status ? o3.reloadCallback = s6 : "done" === o3.status && (o3.vectorTile ? o3.parse(o3.vectorTile, this.layerIndex, this.availableImages, this.actor, s6) : s6());
          } else
            t3(null, void 0);
        }
        abortTile(e4, t3) {
          const i3 = e4.uid, r3 = this.loading[i3];
          r3 && (r3.abort && r3.abort(), delete this.loading[i3]), t3();
        }
        removeTile(e4, t3) {
          const i3 = this.loaded, r3 = e4.uid;
          i3 && i3[r3] && delete i3[r3], t3();
        }
      }, e3.e = Eo, e3.f = it, e3.g = d2, e3.h = we, e3.i = Te, e3.j = function(e4, t3) {
        const i3 = TT(e4);
        for (const e5 of i3) {
          for (const t4 of e5.meshes)
            ET(t4);
          e5.lights && (e5.lightMeshIndex = e5.meshes.length, e5.meshes.push(MT(e5.lights, t3)));
        }
        return i3;
      }, e3.k = oa, e3.l = function(e4) {
        let t3 = 0;
        if (new Uint32Array(e4, 0, 1)[0] !== aT) {
          const i3 = new Uint32Array(e4, 0, 7), [, , r3, n4, o3, s6] = i3;
          t3 = i3.byteLength + n4 + o3 + s6 + o3, (r3 !== e4.byteLength || t3 >= e4.byteLength) && H2("Invalid b3dm header information.");
        }
        return pT(e4, t3);
      }, e3.m = ty, e3.n = na, e3.o = It, e3.p = _2, e3.q = function(e4) {
        fe(), ue && ue.then((t3) => {
          t3.keys().then((i3) => {
            for (let r3 = 0; r3 < i3.length - e4; r3++)
              t3.delete(i3[r3]);
          });
        });
      }, e3.r = RT, e3.s = xI, e3.t = ap, e3.v = L2, e3.w = t2;
    });
    define(["./shared"], function(e3) {
      function t2(e4) {
        if ("number" == typeof e4 || "boolean" == typeof e4 || "string" == typeof e4 || null == e4)
          return JSON.stringify(e4);
        if (Array.isArray(e4)) {
          let r4 = "[";
          for (const o3 of e4)
            r4 += `${t2(o3)},`;
          return `${r4}]`;
        }
        let r3 = "{";
        for (const o3 of Object.keys(e4).sort())
          r3 += `${o3}:${t2(e4[o3])},`;
        return `${r3}}`;
      }
      function r2(r3) {
        let o3 = "";
        for (const i3 of e3.r)
          o3 += `/${t2(r3[i3])}`;
        return o3;
      }
      class o2 {
        constructor(e4) {
          this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e4 && this.replace(e4);
        }
        replace(e4, t3) {
          this._layerConfigs = {}, this._layers = {}, this.update(e4, [], t3);
        }
        update(t3, o3, i3) {
          this._options = i3;
          for (const r3 of t3) {
            this._layerConfigs[r3.id] = r3;
            const t4 = this._layers[r3.id] = e3.c(r3, this._options);
            t4.setScope(this.scope), t4.compileFilter(), this.keyCache[r3.id] && delete this.keyCache[r3.id];
          }
          for (const e4 of o3)
            delete this.keyCache[e4], delete this._layerConfigs[e4], delete this._layers[e4];
          this.familiesBySource = {};
          const s6 = function(e4, t4) {
            const o4 = {};
            for (let i5 = 0; i5 < e4.length; i5++) {
              const s7 = t4 && t4[e4[i5].id] || r2(e4[i5]);
              t4 && (t4[e4[i5].id] = s7);
              let n4 = o4[s7];
              n4 || (n4 = o4[s7] = []), n4.push(e4[i5]);
            }
            const i4 = [];
            for (const e5 in o4)
              i4.push(o4[e5]);
            return i4;
          }(e3.v(this._layerConfigs), this.keyCache);
          for (const e4 of s6) {
            const t4 = e4.map((e5) => this._layers[e5.id]), r3 = t4[0];
            if ("none" === r3.visibility)
              continue;
            const o4 = r3.source || "";
            let i4 = this.familiesBySource[o4];
            i4 || (i4 = this.familiesBySource[o4] = {});
            const s7 = r3.sourceLayer || "_geojsonTileLayer";
            let n4 = i4[s7];
            n4 || (n4 = i4[s7] = []), n4.push(t4);
          }
        }
      }
      class i2 {
        loadTile(t3, r3) {
          const { uid: o3, encoding: i3, rawImageData: s6, padding: n4 } = t3, a3 = e3.w.ImageBitmap && s6 instanceof e3.w.ImageBitmap ? this.getImageData(s6, n4) : s6;
          r3(null, new e3.D(o3, a3, i3, n4 < 1));
        }
        getImageData(e4, t3) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e4.width, e4.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e4.width, this.offscreenCanvas.height = e4.height, this.offscreenCanvasContext.drawImage(e4, 0, 0, e4.width, e4.height);
          const r3 = this.offscreenCanvasContext.getImageData(-t3, -t3, e4.width + 2 * t3, e4.height + 2 * t3);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r3;
        }
      }
      function s5(e4, t3) {
        if (0 !== e4.length) {
          n3(e4[0], t3);
          for (var r3 = 1; r3 < e4.length; r3++)
            n3(e4[r3], !t3);
        }
      }
      function n3(e4, t3) {
        for (var r3 = 0, o3 = 0, i3 = 0, s6 = e4.length, n4 = s6 - 1; i3 < s6; n4 = i3++) {
          var a3 = (e4[i3][0] - e4[n4][0]) * (e4[n4][1] + e4[i3][1]), l3 = r3 + a3;
          o3 += Math.abs(r3) >= Math.abs(a3) ? r3 - l3 + a3 : a3 - l3 + r3, r3 = l3;
        }
        r3 + o3 >= 0 != !!t3 && e4.reverse();
      }
      var a2 = e3.g(function e4(t3, r3) {
        var o3, i3 = t3 && t3.type;
        if ("FeatureCollection" === i3)
          for (o3 = 0; o3 < t3.features.length; o3++)
            e4(t3.features[o3], r3);
        else if ("GeometryCollection" === i3)
          for (o3 = 0; o3 < t3.geometries.length; o3++)
            e4(t3.geometries[o3], r3);
        else if ("Feature" === i3)
          e4(t3.geometry, r3);
        else if ("Polygon" === i3)
          s5(t3.coordinates, r3);
        else if ("MultiPolygon" === i3)
          for (o3 = 0; o3 < t3.coordinates.length; o3++)
            s5(t3.coordinates[o3], r3);
        return t3;
      });
      const l2 = e3.V.prototype.toGeoJSON;
      var h2 = { exports: {} }, u2 = e3.p, c2 = e3.a.VectorTileFeature, f2 = d2;
      function d2(e4, t3) {
        this.options = t3 || {}, this.features = e4, this.length = e4.length;
      }
      function p2(e4, t3) {
        this.id = "number" == typeof e4.id ? e4.id : void 0, this.type = e4.type, this.rawGeometry = 1 === e4.type ? [e4.geometry] : e4.geometry, this.properties = e4.tags, this.extent = t3 || 4096;
      }
      d2.prototype.feature = function(e4) {
        return new p2(this.features[e4], this.options.extent);
      }, p2.prototype.loadGeometry = function() {
        var e4 = this.rawGeometry;
        this.geometry = [];
        for (var t3 = 0; t3 < e4.length; t3++) {
          for (var r3 = e4[t3], o3 = [], i3 = 0; i3 < r3.length; i3++)
            o3.push(new u2(r3[i3][0], r3[i3][1]));
          this.geometry.push(o3);
        }
        return this.geometry;
      }, p2.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e4 = this.geometry, t3 = 1 / 0, r3 = -1 / 0, o3 = 1 / 0, i3 = -1 / 0, s6 = 0; s6 < e4.length; s6++)
          for (var n4 = e4[s6], a3 = 0; a3 < n4.length; a3++) {
            var l3 = n4[a3];
            t3 = Math.min(t3, l3.x), r3 = Math.max(r3, l3.x), o3 = Math.min(o3, l3.y), i3 = Math.max(i3, l3.y);
          }
        return [t3, o3, r3, i3];
      }, p2.prototype.toGeoJSON = c2.prototype.toGeoJSON;
      var g2 = e3.b, m2 = f2;
      function y2(e4) {
        var t3 = new g2();
        return function(e5, t4) {
          for (var r3 in e5.layers)
            t4.writeMessage(3, v2, e5.layers[r3]);
        }(e4, t3), t3.finish();
      }
      function v2(e4, t3) {
        var r3;
        t3.writeVarintField(15, e4.version || 1), t3.writeStringField(1, e4.name || ""), t3.writeVarintField(5, e4.extent || 4096);
        var o3 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (r3 = 0; r3 < e4.length; r3++)
          o3.feature = e4.feature(r3), t3.writeMessage(2, w2, o3);
        var i3 = o3.keys;
        for (r3 = 0; r3 < i3.length; r3++)
          t3.writeStringField(3, i3[r3]);
        var s6 = o3.values;
        for (r3 = 0; r3 < s6.length; r3++)
          t3.writeMessage(4, I2, s6[r3]);
      }
      function w2(e4, t3) {
        var r3 = e4.feature;
        void 0 !== r3.id && t3.writeVarintField(1, r3.id), t3.writeMessage(2, x2, e4), t3.writeVarintField(3, r3.type), t3.writeMessage(4, b2, r3);
      }
      function x2(e4, t3) {
        var r3 = e4.feature, o3 = e4.keys, i3 = e4.values, s6 = e4.keycache, n4 = e4.valuecache;
        for (var a3 in r3.properties) {
          var l3 = r3.properties[a3], h3 = s6[a3];
          if (null !== l3) {
            void 0 === h3 && (o3.push(a3), s6[a3] = h3 = o3.length - 1), t3.writeVarint(h3);
            var u3 = typeof l3;
            "string" !== u3 && "boolean" !== u3 && "number" !== u3 && (l3 = JSON.stringify(l3));
            var c3 = u3 + ":" + l3, f3 = n4[c3];
            void 0 === f3 && (i3.push(l3), n4[c3] = f3 = i3.length - 1), t3.writeVarint(f3);
          }
        }
      }
      function S2(e4, t3) {
        return (t3 << 3) + (7 & e4);
      }
      function M2(e4) {
        return e4 << 1 ^ e4 >> 31;
      }
      function b2(e4, t3) {
        for (var r3 = e4.loadGeometry(), o3 = e4.type, i3 = 0, s6 = 0, n4 = r3.length, a3 = 0; a3 < n4; a3++) {
          var l3 = r3[a3], h3 = 1;
          1 === o3 && (h3 = l3.length), t3.writeVarint(S2(1, h3));
          for (var u3 = 3 === o3 ? l3.length - 1 : l3.length, c3 = 0; c3 < u3; c3++) {
            1 === c3 && 1 !== o3 && t3.writeVarint(S2(2, u3 - 1));
            var f3 = l3[c3].x - i3, d3 = l3[c3].y - s6;
            t3.writeVarint(M2(f3)), t3.writeVarint(M2(d3)), i3 += f3, s6 += d3;
          }
          3 === o3 && t3.writeVarint(S2(7, 1));
        }
      }
      function I2(e4, t3) {
        var r3 = typeof e4;
        "string" === r3 ? t3.writeStringField(1, e4) : "boolean" === r3 ? t3.writeBooleanField(7, e4) : "number" === r3 && (e4 % 1 != 0 ? t3.writeDoubleField(3, e4) : e4 < 0 ? t3.writeSVarintField(6, e4) : t3.writeVarintField(5, e4));
      }
      h2.exports = y2, h2.exports.fromVectorTileJs = y2, h2.exports.fromGeojsonVt = function(e4, t3) {
        t3 = t3 || {};
        var r3 = {};
        for (var o3 in e4)
          r3[o3] = new m2(e4[o3].features, t3), r3[o3].name = o3, r3[o3].version = t3.version, r3[o3].extent = t3.extent;
        return y2({ layers: r3 });
      }, h2.exports.GeoJSONWrapper = m2;
      var k2 = e3.g(h2.exports);
      const P2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e4) => e4 }, _2 = Math.fround || (L2 = new Float32Array(1), (e4) => (L2[0] = +e4, L2[0]));
      var L2;
      const T2 = 3, C2 = 5, O = 6;
      class j2 {
        constructor(e4) {
          this.options = Object.assign(Object.create(P2), e4), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e4) {
          const { log: t3, minZoom: r3, maxZoom: o3 } = this.options;
          t3 && console.time("total time");
          const i3 = `prepare ${e4.length} points`;
          t3 && console.time(i3), this.points = e4;
          const s6 = [];
          for (let t4 = 0; t4 < e4.length; t4++) {
            const r4 = e4[t4];
            if (!r4.geometry)
              continue;
            const [o4, i4] = r4.geometry.coordinates, n5 = _2(z(o4)), a3 = _2(D(i4));
            s6.push(n5, a3, 1 / 0, t4, -1, 1), this.options.reduce && s6.push(0);
          }
          let n4 = this.trees[o3 + 1] = this._createTree(s6);
          t3 && console.timeEnd(i3);
          for (let e5 = o3; e5 >= r3; e5--) {
            const r4 = +Date.now();
            n4 = this.trees[e5] = this._createTree(this._cluster(n4, e5)), t3 && console.log("z%d: %d clusters in %dms", e5, n4.numItems, +Date.now() - r4);
          }
          return t3 && console.timeEnd("total time"), this;
        }
        getClusters(e4, t3) {
          let r3 = ((e4[0] + 180) % 360 + 360) % 360 - 180;
          const o3 = Math.max(-90, Math.min(90, e4[1]));
          let i3 = 180 === e4[2] ? 180 : ((e4[2] + 180) % 360 + 360) % 360 - 180;
          const s6 = Math.max(-90, Math.min(90, e4[3]));
          if (e4[2] - e4[0] >= 360)
            r3 = -180, i3 = 180;
          else if (r3 > i3) {
            const e5 = this.getClusters([r3, o3, 180, s6], t3), n5 = this.getClusters([-180, o3, i3, s6], t3);
            return e5.concat(n5);
          }
          const n4 = this.trees[this._limitZoom(t3)], a3 = n4.range(z(r3), D(s6), z(i3), D(o3)), l3 = n4.data, h3 = [];
          for (const e5 of a3) {
            const t4 = this.stride * e5;
            h3.push(l3[t4 + C2] > 1 ? F(l3, t4, this.clusterProps) : this.points[l3[t4 + T2]]);
          }
          return h3;
        }
        getChildren(e4) {
          const t3 = this._getOriginId(e4), r3 = this._getOriginZoom(e4), o3 = "No cluster with the specified id.", i3 = this.trees[r3];
          if (!i3)
            throw new Error(o3);
          const s6 = i3.data;
          if (t3 * this.stride >= s6.length)
            throw new Error(o3);
          const n4 = this.options.radius / (this.options.extent * Math.pow(2, r3 - 1)), a3 = i3.within(s6[t3 * this.stride], s6[t3 * this.stride + 1], n4), l3 = [];
          for (const t4 of a3) {
            const r4 = t4 * this.stride;
            s6[r4 + 4] === e4 && l3.push(s6[r4 + C2] > 1 ? F(s6, r4, this.clusterProps) : this.points[s6[r4 + T2]]);
          }
          if (0 === l3.length)
            throw new Error(o3);
          return l3;
        }
        getLeaves(e4, t3, r3) {
          const o3 = [];
          return this._appendLeaves(o3, e4, t3 = t3 || 10, r3 = r3 || 0, 0), o3;
        }
        getTile(e4, t3, r3) {
          const o3 = this.trees[this._limitZoom(e4)], i3 = Math.pow(2, e4), { extent: s6, radius: n4 } = this.options, a3 = n4 / s6, l3 = (r3 - a3) / i3, h3 = (r3 + 1 + a3) / i3, u3 = { features: [] };
          return this._addTileFeatures(o3.range((t3 - a3) / i3, l3, (t3 + 1 + a3) / i3, h3), o3.data, t3, r3, i3, u3), 0 === t3 && this._addTileFeatures(o3.range(1 - a3 / i3, l3, 1, h3), o3.data, i3, r3, i3, u3), t3 === i3 - 1 && this._addTileFeatures(o3.range(0, l3, a3 / i3, h3), o3.data, -1, r3, i3, u3), u3.features.length ? u3 : null;
        }
        getClusterExpansionZoom(e4) {
          let t3 = this._getOriginZoom(e4) - 1;
          for (; t3 <= this.options.maxZoom; ) {
            const r3 = this.getChildren(e4);
            if (t3++, 1 !== r3.length)
              break;
            e4 = r3[0].properties.cluster_id;
          }
          return t3;
        }
        _appendLeaves(e4, t3, r3, o3, i3) {
          const s6 = this.getChildren(t3);
          for (const t4 of s6) {
            const s7 = t4.properties;
            if (s7 && s7.cluster ? i3 + s7.point_count <= o3 ? i3 += s7.point_count : i3 = this._appendLeaves(e4, s7.cluster_id, r3, o3, i3) : i3 < o3 ? i3++ : e4.push(t4), e4.length === r3)
              break;
          }
          return i3;
        }
        _createTree(t3) {
          const r3 = new e3.K(t3.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e4 = 0; e4 < t3.length; e4 += this.stride)
            r3.add(t3[e4], t3[e4 + 1]);
          return r3.finish(), r3.data = t3, r3;
        }
        _addTileFeatures(e4, t3, r3, o3, i3, s6) {
          for (const n4 of e4) {
            const e5 = n4 * this.stride, a3 = t3[e5 + C2] > 1;
            let l3, h3, u3;
            if (a3)
              l3 = Z2(t3, e5, this.clusterProps), h3 = t3[e5], u3 = t3[e5 + 1];
            else {
              const r4 = this.points[t3[e5 + T2]];
              l3 = r4.properties;
              const [o4, i4] = r4.geometry.coordinates;
              h3 = z(o4), u3 = D(i4);
            }
            const c3 = { type: 1, geometry: [[Math.round(this.options.extent * (h3 * i3 - r3)), Math.round(this.options.extent * (u3 * i3 - o3))]], tags: l3 };
            let f3;
            f3 = a3 || this.options.generateId ? t3[e5 + T2] : this.points[t3[e5 + T2]].id, void 0 !== f3 && (c3.id = f3), s6.features.push(c3);
          }
        }
        _limitZoom(e4) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e4), this.options.maxZoom + 1));
        }
        _cluster(e4, t3) {
          const { radius: r3, extent: o3, reduce: i3, minPoints: s6 } = this.options, n4 = r3 / (o3 * Math.pow(2, t3)), a3 = e4.data, l3 = [], h3 = this.stride;
          for (let r4 = 0; r4 < a3.length; r4 += h3) {
            if (a3[r4 + 2] <= t3)
              continue;
            a3[r4 + 2] = t3;
            const o4 = a3[r4], u3 = a3[r4 + 1], c3 = e4.within(a3[r4], a3[r4 + 1], n4), f3 = a3[r4 + C2];
            let d3 = f3;
            for (const e5 of c3) {
              const r5 = e5 * h3;
              a3[r5 + 2] > t3 && (d3 += a3[r5 + C2]);
            }
            if (d3 > f3 && d3 >= s6) {
              let e5, s7 = o4 * f3, n5 = u3 * f3, p3 = -1;
              const g3 = ((r4 / h3 | 0) << 5) + (t3 + 1) + this.points.length;
              for (const o5 of c3) {
                const l4 = o5 * h3;
                if (a3[l4 + 2] <= t3)
                  continue;
                a3[l4 + 2] = t3;
                const u4 = a3[l4 + C2];
                s7 += a3[l4] * u4, n5 += a3[l4 + 1] * u4, a3[l4 + 4] = g3, i3 && (e5 || (e5 = this._map(a3, r4, true), p3 = this.clusterProps.length, this.clusterProps.push(e5)), i3(e5, this._map(a3, l4)));
              }
              a3[r4 + 4] = g3, l3.push(s7 / d3, n5 / d3, 1 / 0, g3, -1, d3), i3 && l3.push(p3);
            } else {
              for (let e5 = 0; e5 < h3; e5++)
                l3.push(a3[r4 + e5]);
              if (d3 > 1)
                for (const e5 of c3) {
                  const r5 = e5 * h3;
                  if (!(a3[r5 + 2] <= t3)) {
                    a3[r5 + 2] = t3;
                    for (let e6 = 0; e6 < h3; e6++)
                      l3.push(a3[r5 + e6]);
                  }
                }
            }
          }
          return l3;
        }
        _getOriginId(e4) {
          return e4 - this.points.length >> 5;
        }
        _getOriginZoom(e4) {
          return (e4 - this.points.length) % 32;
        }
        _map(e4, t3, r3) {
          if (e4[t3 + C2] > 1) {
            const o4 = this.clusterProps[e4[t3 + O]];
            return r3 ? Object.assign({}, o4) : o4;
          }
          const o3 = this.points[e4[t3 + T2]].properties, i3 = this.options.map(o3);
          return r3 && i3 === o3 ? Object.assign({}, i3) : i3;
        }
      }
      function F(e4, t3, r3) {
        return { type: "Feature", id: e4[t3 + T2], properties: Z2(e4, t3, r3), geometry: { type: "Point", coordinates: [(o3 = e4[t3], 360 * (o3 - 0.5)), E2(e4[t3 + 1])] } };
        var o3;
      }
      function Z2(e4, t3, r3) {
        const o3 = e4[t3 + C2], i3 = o3 >= 1e4 ? `${Math.round(o3 / 1e3)}k` : o3 >= 1e3 ? Math.round(o3 / 100) / 10 + "k" : o3, s6 = e4[t3 + O], n4 = -1 === s6 ? {} : Object.assign({}, r3[s6]);
        return Object.assign(n4, { cluster: true, cluster_id: e4[t3 + T2], point_count: o3, point_count_abbreviated: i3 });
      }
      function z(e4) {
        return e4 / 360 + 0.5;
      }
      function D(e4) {
        const t3 = Math.sin(e4 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
        return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
      }
      function E2(e4) {
        const t3 = (180 - 360 * e4) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
      }
      var N2 = { exports: {} };
      N2.exports = function() {
        function e4(r4, o4, i4, s7) {
          for (var n5, a4 = s7, l4 = i4 - o4 >> 1, h4 = i4 - o4, u4 = r4[o4], c4 = r4[o4 + 1], f4 = r4[i4], d4 = r4[i4 + 1], p4 = o4 + 3; p4 < i4; p4 += 3) {
            var g4 = t3(r4[p4], r4[p4 + 1], u4, c4, f4, d4);
            if (g4 > a4)
              n5 = p4, a4 = g4;
            else if (g4 === a4) {
              var m4 = Math.abs(p4 - l4);
              m4 < h4 && (n5 = p4, h4 = m4);
            }
          }
          a4 > s7 && (n5 - o4 > 3 && e4(r4, o4, n5, s7), r4[n5 + 2] = a4, i4 - n5 > 3 && e4(r4, n5, i4, s7));
        }
        function t3(e5, t4, r4, o4, i4, s7) {
          var n5 = i4 - r4, a4 = s7 - o4;
          if (0 !== n5 || 0 !== a4) {
            var l4 = ((e5 - r4) * n5 + (t4 - o4) * a4) / (n5 * n5 + a4 * a4);
            l4 > 1 ? (r4 = i4, o4 = s7) : l4 > 0 && (r4 += n5 * l4, o4 += a4 * l4);
          }
          return (n5 = e5 - r4) * n5 + (a4 = t4 - o4) * a4;
        }
        function r3(e5, t4, r4, i4) {
          var s7 = { id: void 0 === e5 ? null : e5, type: t4, geometry: r4, tags: i4, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e6) {
            var t5 = e6.geometry, r5 = e6.type;
            if ("Point" === r5 || "MultiPoint" === r5 || "LineString" === r5)
              o3(e6, t5);
            else if ("Polygon" === r5 || "MultiLineString" === r5)
              for (var i5 = 0; i5 < t5.length; i5++)
                o3(e6, t5[i5]);
            else if ("MultiPolygon" === r5)
              for (i5 = 0; i5 < t5.length; i5++)
                for (var s8 = 0; s8 < t5[i5].length; s8++)
                  o3(e6, t5[i5][s8]);
          }(s7), s7;
        }
        function o3(e5, t4) {
          for (var r4 = 0; r4 < t4.length; r4 += 3)
            e5.minX = Math.min(e5.minX, t4[r4]), e5.minY = Math.min(e5.minY, t4[r4 + 1]), e5.maxX = Math.max(e5.maxX, t4[r4]), e5.maxY = Math.max(e5.maxY, t4[r4 + 1]);
        }
        function i3(e5, t4, o4, l4) {
          if (t4.geometry) {
            var h4 = t4.geometry.coordinates, u4 = t4.geometry.type, c4 = Math.pow(o4.tolerance / ((1 << o4.maxZoom) * o4.extent), 2), f4 = [], d4 = t4.id;
            if (o4.promoteId ? d4 = t4.properties[o4.promoteId] : o4.generateId && (d4 = l4 || 0), "Point" === u4)
              s6(h4, f4);
            else if ("MultiPoint" === u4)
              for (var p4 = 0; p4 < h4.length; p4++)
                s6(h4[p4], f4);
            else if ("LineString" === u4)
              n4(h4, f4, c4, false);
            else if ("MultiLineString" === u4) {
              if (o4.lineMetrics) {
                for (p4 = 0; p4 < h4.length; p4++)
                  n4(h4[p4], f4 = [], c4, false), e5.push(r3(d4, "LineString", f4, t4.properties));
                return;
              }
              a3(h4, f4, c4, false);
            } else if ("Polygon" === u4)
              a3(h4, f4, c4, true);
            else {
              if ("MultiPolygon" !== u4) {
                if ("GeometryCollection" === u4) {
                  for (p4 = 0; p4 < t4.geometry.geometries.length; p4++)
                    i3(e5, { id: d4, geometry: t4.geometry.geometries[p4], properties: t4.properties }, o4, l4);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (p4 = 0; p4 < h4.length; p4++) {
                var g4 = [];
                a3(h4[p4], g4, c4, true), f4.push(g4);
              }
            }
            e5.push(r3(d4, u4, f4, t4.properties));
          }
        }
        function s6(e5, t4) {
          t4.push(l3(e5[0])), t4.push(h3(e5[1])), t4.push(0);
        }
        function n4(t4, r4, o4, i4) {
          for (var s7, n5, a4 = 0, u4 = 0; u4 < t4.length; u4++) {
            var c4 = l3(t4[u4][0]), f4 = h3(t4[u4][1]);
            r4.push(c4), r4.push(f4), r4.push(0), u4 > 0 && (a4 += i4 ? (s7 * f4 - c4 * n5) / 2 : Math.sqrt(Math.pow(c4 - s7, 2) + Math.pow(f4 - n5, 2))), s7 = c4, n5 = f4;
          }
          var d4 = r4.length - 3;
          r4[2] = 1, e4(r4, 0, d4, o4), r4[d4 + 2] = 1, r4.size = Math.abs(a4), r4.start = 0, r4.end = r4.size;
        }
        function a3(e5, t4, r4, o4) {
          for (var i4 = 0; i4 < e5.length; i4++) {
            var s7 = [];
            n4(e5[i4], s7, r4, o4), t4.push(s7);
          }
        }
        function l3(e5) {
          return e5 / 360 + 0.5;
        }
        function h3(e5) {
          var t4 = Math.sin(e5 * Math.PI / 180), r4 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
          return r4 < 0 ? 0 : r4 > 1 ? 1 : r4;
        }
        function u3(e5, t4, o4, i4, s7, n5, a4, l4) {
          if (i4 /= t4, n5 >= (o4 /= t4) && a4 < i4)
            return e5;
          if (a4 < o4 || n5 >= i4)
            return null;
          for (var h4 = [], u4 = 0; u4 < e5.length; u4++) {
            var d4 = e5[u4], g4 = d4.geometry, m4 = d4.type, y4 = 0 === s7 ? d4.minX : d4.minY, v4 = 0 === s7 ? d4.maxX : d4.maxY;
            if (y4 >= o4 && v4 < i4)
              h4.push(d4);
            else if (!(v4 < o4 || y4 >= i4)) {
              var w4 = [];
              if ("Point" === m4 || "MultiPoint" === m4)
                c3(g4, w4, o4, i4, s7);
              else if ("LineString" === m4)
                f3(g4, w4, o4, i4, s7, false, l4.lineMetrics);
              else if ("MultiLineString" === m4)
                p3(g4, w4, o4, i4, s7, false);
              else if ("Polygon" === m4)
                p3(g4, w4, o4, i4, s7, true);
              else if ("MultiPolygon" === m4)
                for (var x4 = 0; x4 < g4.length; x4++) {
                  var S4 = [];
                  p3(g4[x4], S4, o4, i4, s7, true), S4.length && w4.push(S4);
                }
              if (w4.length) {
                if (l4.lineMetrics && "LineString" === m4) {
                  for (x4 = 0; x4 < w4.length; x4++)
                    h4.push(r3(d4.id, m4, w4[x4], d4.tags));
                  continue;
                }
                "LineString" !== m4 && "MultiLineString" !== m4 || (1 === w4.length ? (m4 = "LineString", w4 = w4[0]) : m4 = "MultiLineString"), "Point" !== m4 && "MultiPoint" !== m4 || (m4 = 3 === w4.length ? "Point" : "MultiPoint"), h4.push(r3(d4.id, m4, w4, d4.tags));
              }
            }
          }
          return h4.length ? h4 : null;
        }
        function c3(e5, t4, r4, o4, i4) {
          for (var s7 = 0; s7 < e5.length; s7 += 3) {
            var n5 = e5[s7 + i4];
            n5 >= r4 && n5 <= o4 && (t4.push(e5[s7]), t4.push(e5[s7 + 1]), t4.push(e5[s7 + 2]));
          }
        }
        function f3(e5, t4, r4, o4, i4, s7, n5) {
          for (var a4, l4, h4 = d3(e5), u4 = 0 === i4 ? m3 : y3, c4 = e5.start, f4 = 0; f4 < e5.length - 3; f4 += 3) {
            var p4 = e5[f4], v4 = e5[f4 + 1], w4 = e5[f4 + 2], x4 = e5[f4 + 3], S4 = e5[f4 + 4], M4 = 0 === i4 ? p4 : v4, b4 = 0 === i4 ? x4 : S4, I4 = false;
            n5 && (a4 = Math.sqrt(Math.pow(p4 - x4, 2) + Math.pow(v4 - S4, 2))), M4 < r4 ? b4 > r4 && (l4 = u4(h4, p4, v4, x4, S4, r4), n5 && (h4.start = c4 + a4 * l4)) : M4 > o4 ? b4 < o4 && (l4 = u4(h4, p4, v4, x4, S4, o4), n5 && (h4.start = c4 + a4 * l4)) : g3(h4, p4, v4, w4), b4 < r4 && M4 >= r4 && (l4 = u4(h4, p4, v4, x4, S4, r4), I4 = true), b4 > o4 && M4 <= o4 && (l4 = u4(h4, p4, v4, x4, S4, o4), I4 = true), !s7 && I4 && (n5 && (h4.end = c4 + a4 * l4), t4.push(h4), h4 = d3(e5)), n5 && (c4 += a4);
          }
          var k4 = e5.length - 3;
          p4 = e5[k4], v4 = e5[k4 + 1], w4 = e5[k4 + 2], (M4 = 0 === i4 ? p4 : v4) >= r4 && M4 <= o4 && g3(h4, p4, v4, w4), k4 = h4.length - 3, s7 && k4 >= 3 && (h4[k4] !== h4[0] || h4[k4 + 1] !== h4[1]) && g3(h4, h4[0], h4[1], h4[2]), h4.length && t4.push(h4);
        }
        function d3(e5) {
          var t4 = [];
          return t4.size = e5.size, t4.start = e5.start, t4.end = e5.end, t4;
        }
        function p3(e5, t4, r4, o4, i4, s7) {
          for (var n5 = 0; n5 < e5.length; n5++)
            f3(e5[n5], t4, r4, o4, i4, s7, false);
        }
        function g3(e5, t4, r4, o4) {
          e5.push(t4), e5.push(r4), e5.push(o4);
        }
        function m3(e5, t4, r4, o4, i4, s7) {
          var n5 = (s7 - t4) / (o4 - t4);
          return e5.push(s7), e5.push(r4 + (i4 - r4) * n5), e5.push(1), n5;
        }
        function y3(e5, t4, r4, o4, i4, s7) {
          var n5 = (s7 - r4) / (i4 - r4);
          return e5.push(t4 + (o4 - t4) * n5), e5.push(s7), e5.push(1), n5;
        }
        function v3(e5, t4) {
          for (var o4 = [], i4 = 0; i4 < e5.length; i4++) {
            var s7, n5 = e5[i4], a4 = n5.type;
            if ("Point" === a4 || "MultiPoint" === a4 || "LineString" === a4)
              s7 = w3(n5.geometry, t4);
            else if ("MultiLineString" === a4 || "Polygon" === a4) {
              s7 = [];
              for (var l4 = 0; l4 < n5.geometry.length; l4++)
                s7.push(w3(n5.geometry[l4], t4));
            } else if ("MultiPolygon" === a4)
              for (s7 = [], l4 = 0; l4 < n5.geometry.length; l4++) {
                for (var h4 = [], u4 = 0; u4 < n5.geometry[l4].length; u4++)
                  h4.push(w3(n5.geometry[l4][u4], t4));
                s7.push(h4);
              }
            o4.push(r3(n5.id, a4, s7, n5.tags));
          }
          return o4;
        }
        function w3(e5, t4) {
          var r4 = [];
          r4.size = e5.size, void 0 !== e5.start && (r4.start = e5.start, r4.end = e5.end);
          for (var o4 = 0; o4 < e5.length; o4 += 3)
            r4.push(e5[o4] + t4, e5[o4 + 1], e5[o4 + 2]);
          return r4;
        }
        function x3(e5, t4) {
          if (e5.transformed)
            return e5;
          var r4, o4, i4, s7 = 1 << e5.z, n5 = e5.x, a4 = e5.y;
          for (r4 = 0; r4 < e5.features.length; r4++) {
            var l4 = e5.features[r4], h4 = l4.geometry, u4 = l4.type;
            if (l4.geometry = [], 1 === u4)
              for (o4 = 0; o4 < h4.length; o4 += 2)
                l4.geometry.push(S3(h4[o4], h4[o4 + 1], t4, s7, n5, a4));
            else
              for (o4 = 0; o4 < h4.length; o4++) {
                var c4 = [];
                for (i4 = 0; i4 < h4[o4].length; i4 += 2)
                  c4.push(S3(h4[o4][i4], h4[o4][i4 + 1], t4, s7, n5, a4));
                l4.geometry.push(c4);
              }
          }
          return e5.transformed = true, e5;
        }
        function S3(e5, t4, r4, o4, i4, s7) {
          return [Math.round(r4 * (e5 * o4 - i4)), Math.round(r4 * (t4 * o4 - s7))];
        }
        function M3(e5, t4, r4, o4, i4) {
          for (var s7 = t4 === i4.maxZoom ? 0 : i4.tolerance / ((1 << t4) * i4.extent), n5 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r4, y: o4, z: t4, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a4 = 0; a4 < e5.length; a4++) {
            n5.numFeatures++, b3(n5, e5[a4], s7, i4);
            var l4 = e5[a4].minX, h4 = e5[a4].minY, u4 = e5[a4].maxX, c4 = e5[a4].maxY;
            l4 < n5.minX && (n5.minX = l4), h4 < n5.minY && (n5.minY = h4), u4 > n5.maxX && (n5.maxX = u4), c4 > n5.maxY && (n5.maxY = c4);
          }
          return n5;
        }
        function b3(e5, t4, r4, o4) {
          var i4 = t4.geometry, s7 = t4.type, n5 = [];
          if ("Point" === s7 || "MultiPoint" === s7)
            for (var a4 = 0; a4 < i4.length; a4 += 3)
              n5.push(i4[a4]), n5.push(i4[a4 + 1]), e5.numPoints++, e5.numSimplified++;
          else if ("LineString" === s7)
            I3(n5, i4, e5, r4, false, false);
          else if ("MultiLineString" === s7 || "Polygon" === s7)
            for (a4 = 0; a4 < i4.length; a4++)
              I3(n5, i4[a4], e5, r4, "Polygon" === s7, 0 === a4);
          else if ("MultiPolygon" === s7)
            for (var l4 = 0; l4 < i4.length; l4++) {
              var h4 = i4[l4];
              for (a4 = 0; a4 < h4.length; a4++)
                I3(n5, h4[a4], e5, r4, true, 0 === a4);
            }
          if (n5.length) {
            var u4 = t4.tags || null;
            if ("LineString" === s7 && o4.lineMetrics) {
              for (var c4 in u4 = {}, t4.tags)
                u4[c4] = t4.tags[c4];
              u4.mapbox_clip_start = i4.start / i4.size, u4.mapbox_clip_end = i4.end / i4.size;
            }
            var f4 = { geometry: n5, type: "Polygon" === s7 || "MultiPolygon" === s7 ? 3 : "LineString" === s7 || "MultiLineString" === s7 ? 2 : 1, tags: u4 };
            null !== t4.id && (f4.id = t4.id), e5.features.push(f4);
          }
        }
        function I3(e5, t4, r4, o4, i4, s7) {
          var n5 = o4 * o4;
          if (o4 > 0 && t4.size < (i4 ? n5 : o4))
            r4.numPoints += t4.length / 3;
          else {
            for (var a4 = [], l4 = 0; l4 < t4.length; l4 += 3)
              (0 === o4 || t4[l4 + 2] > n5) && (r4.numSimplified++, a4.push(t4[l4]), a4.push(t4[l4 + 1])), r4.numPoints++;
            i4 && function(e6, t5) {
              for (var r5 = 0, o5 = 0, i5 = e6.length, s8 = i5 - 2; o5 < i5; s8 = o5, o5 += 2)
                r5 += (e6[o5] - e6[s8]) * (e6[o5 + 1] + e6[s8 + 1]);
              if (r5 > 0 === t5)
                for (o5 = 0, i5 = e6.length; o5 < i5 / 2; o5 += 2) {
                  var n6 = e6[o5], a5 = e6[o5 + 1];
                  e6[o5] = e6[i5 - 2 - o5], e6[o5 + 1] = e6[i5 - 1 - o5], e6[i5 - 2 - o5] = n6, e6[i5 - 1 - o5] = a5;
                }
            }(a4, s7), e5.push(a4);
          }
        }
        function k3(e5, t4) {
          var r4 = (t4 = this.options = function(e6, t5) {
            for (var r5 in t5)
              e6[r5] = t5[r5];
            return e6;
          }(Object.create(this.options), t4)).debug;
          if (r4 && console.time("preprocess data"), t4.maxZoom < 0 || t4.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t4.promoteId && t4.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var o4 = function(e6, t5) {
            var r5 = [];
            if ("FeatureCollection" === e6.type)
              for (var o5 = 0; o5 < e6.features.length; o5++)
                i3(r5, e6.features[o5], t5, o5);
            else
              i3(r5, "Feature" === e6.type ? e6 : { geometry: e6 }, t5);
            return r5;
          }(e5, t4);
          this.tiles = {}, this.tileCoords = [], r4 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t4.indexMaxZoom, t4.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (o4 = function(e6, t5) {
            var r5 = t5.buffer / t5.extent, o5 = e6, i4 = u3(e6, 1, -1 - r5, r5, 0, -1, 2, t5), s7 = u3(e6, 1, 1 - r5, 2 + r5, 0, -1, 2, t5);
            return (i4 || s7) && (o5 = u3(e6, 1, -r5, 1 + r5, 0, -1, 2, t5) || [], i4 && (o5 = v3(i4, 1).concat(o5)), s7 && (o5 = o5.concat(v3(s7, -1)))), o5;
          }(o4, t4)).length && this.splitTile(o4, 0, 0, 0), r4 && (o4.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function P3(e5, t4, r4) {
          return 32 * ((1 << e5) * r4 + t4) + e5;
        }
        return k3.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, k3.prototype.splitTile = function(e5, t4, r4, o4, i4, s7, n5) {
          for (var a4 = [e5, t4, r4, o4], l4 = this.options, h4 = l4.debug; a4.length; ) {
            o4 = a4.pop(), r4 = a4.pop(), t4 = a4.pop(), e5 = a4.pop();
            var c4 = 1 << t4, f4 = P3(t4, r4, o4), d4 = this.tiles[f4];
            if (!d4 && (h4 > 1 && console.time("creation"), d4 = this.tiles[f4] = M3(e5, t4, r4, o4, l4), this.tileCoords.push({ z: t4, x: r4, y: o4 }), h4)) {
              h4 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t4, r4, o4, d4.numFeatures, d4.numPoints, d4.numSimplified), console.timeEnd("creation"));
              var p4 = "z" + t4;
              this.stats[p4] = (this.stats[p4] || 0) + 1, this.total++;
            }
            if (d4.source = e5, i4) {
              if (t4 === l4.maxZoom || t4 === i4)
                continue;
              var g4 = 1 << i4 - t4;
              if (r4 !== Math.floor(s7 / g4) || o4 !== Math.floor(n5 / g4))
                continue;
            } else if (t4 === l4.indexMaxZoom || d4.numPoints <= l4.indexMaxPoints)
              continue;
            if (d4.source = null, 0 !== e5.length) {
              h4 > 1 && console.time("clipping");
              var m4, y4, v4, w4, x4, S4, b4 = 0.5 * l4.buffer / l4.extent, I4 = 0.5 - b4, k4 = 0.5 + b4, _3 = 1 + b4;
              m4 = y4 = v4 = w4 = null, x4 = u3(e5, c4, r4 - b4, r4 + k4, 0, d4.minX, d4.maxX, l4), S4 = u3(e5, c4, r4 + I4, r4 + _3, 0, d4.minX, d4.maxX, l4), e5 = null, x4 && (m4 = u3(x4, c4, o4 - b4, o4 + k4, 1, d4.minY, d4.maxY, l4), y4 = u3(x4, c4, o4 + I4, o4 + _3, 1, d4.minY, d4.maxY, l4), x4 = null), S4 && (v4 = u3(S4, c4, o4 - b4, o4 + k4, 1, d4.minY, d4.maxY, l4), w4 = u3(S4, c4, o4 + I4, o4 + _3, 1, d4.minY, d4.maxY, l4), S4 = null), h4 > 1 && console.timeEnd("clipping"), a4.push(m4 || [], t4 + 1, 2 * r4, 2 * o4), a4.push(y4 || [], t4 + 1, 2 * r4, 2 * o4 + 1), a4.push(v4 || [], t4 + 1, 2 * r4 + 1, 2 * o4), a4.push(w4 || [], t4 + 1, 2 * r4 + 1, 2 * o4 + 1);
            }
          }
        }, k3.prototype.getTile = function(e5, t4, r4) {
          var o4 = this.options, i4 = o4.extent, s7 = o4.debug;
          if (e5 < 0 || e5 > 24)
            return null;
          var n5 = 1 << e5, a4 = P3(e5, t4 = (t4 % n5 + n5) % n5, r4);
          if (this.tiles[a4])
            return x3(this.tiles[a4], i4);
          s7 > 1 && console.log("drilling down to z%d-%d-%d", e5, t4, r4);
          for (var l4, h4 = e5, u4 = t4, c4 = r4; !l4 && h4 > 0; )
            h4--, u4 = Math.floor(u4 / 2), c4 = Math.floor(c4 / 2), l4 = this.tiles[P3(h4, u4, c4)];
          return l4 && l4.source ? (s7 > 1 && console.log("found parent tile z%d-%d-%d", h4, u4, c4), s7 > 1 && console.time("drilling down"), this.splitTile(l4.source, h4, u4, c4, e5, t4, r4), s7 > 1 && console.timeEnd("drilling down"), this.tiles[a4] ? x3(this.tiles[a4], i4) : null) : null;
        }, function(e5, t4) {
          return new k3(e5, t4);
        };
      }();
      var J = e3.g(N2.exports);
      function Y(t3, r3) {
        const o3 = t3.tileID.canonical;
        if (!this._geoJSONIndex)
          return r3(null, null);
        const i3 = this._geoJSONIndex.getTile(o3.z, o3.x, o3.y);
        if (!i3)
          return r3(null, null);
        const s6 = new class {
          constructor(t4) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e3.E, this.length = t4.length, this._features = t4;
          }
          feature(t4) {
            return new class {
              constructor(t5) {
                this._feature = t5, this.extent = e3.E, this.type = t5.type, this.properties = t5.tags, "id" in t5 && !isNaN(t5.id) && (this.id = parseInt(t5.id, 10));
              }
              loadGeometry() {
                if (1 === this._feature.type) {
                  const t5 = [];
                  for (const r4 of this._feature.geometry)
                    t5.push([new e3.P(r4[0], r4[1])]);
                  return t5;
                }
                {
                  const t5 = [];
                  for (const r4 of this._feature.geometry) {
                    const o4 = [];
                    for (const t6 of r4)
                      o4.push(new e3.P(t6[0], t6[1]));
                    t5.push(o4);
                  }
                  return t5;
                }
              }
              toGeoJSON(e4, t5, r4) {
                return l2.call(this, e4, t5, r4);
              }
            }(this._features[t4]);
          }
        }(i3.features);
        let n4 = k2(s6);
        0 === n4.byteOffset && n4.byteLength === n4.buffer.byteLength || (n4 = new Uint8Array(n4)), r3(null, { vectorTile: s6, rawData: n4.buffer });
      }
      class G extends e3.d {
        constructor(e4, t3, r3, o3, i3, s6) {
          super(e4, t3, r3, o3, Y, s6), i3 && (this.loadGeoJSON = i3);
        }
        loadData(t3, r3) {
          const o3 = t3 && t3.request, i3 = o3 && o3.collectResourceTiming;
          this.loadGeoJSON(t3, (s6, n4) => {
            if (s6 || !n4)
              return r3(s6);
            if ("object" != typeof n4)
              return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
            {
              a2(n4, true);
              try {
                if (t3.filter) {
                  const r4 = e3.e(t3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === r4.result)
                    throw new Error(r4.value.map((e4) => `${e4.key}: ${e4.message}`).join(", "));
                  const o4 = n4.features.filter((e4) => r4.value.evaluate({ zoom: 0 }, e4));
                  n4 = { type: "FeatureCollection", features: o4 };
                }
                this._geoJSONIndex = t3.cluster ? new j2(function({ superclusterOptions: t4, clusterProperties: r4 }) {
                  if (!r4 || !t4)
                    return t4;
                  const o4 = {}, i4 = {}, s7 = { accumulated: null, zoom: 0 }, n5 = { properties: null }, a3 = Object.keys(r4);
                  for (const t5 of a3) {
                    const [s8, n6] = r4[t5], a4 = e3.e(n6), l4 = e3.e("string" == typeof s8 ? [s8, ["accumulated"], ["get", t5]] : s8);
                    o4[t5] = a4.value, i4[t5] = l4.value;
                  }
                  return t4.map = (e4) => {
                    n5.properties = e4;
                    const t5 = {};
                    for (const e5 of a3)
                      t5[e5] = o4[e5].evaluate(s7, n5);
                    return t5;
                  }, t4.reduce = (e4, t5) => {
                    n5.properties = t5;
                    for (const t6 of a3)
                      s7.accumulated = e4[t6], e4[t6] = i4[t6].evaluate(s7, n5);
                  }, t4;
                }(t3)).load(n4.features) : J(n4, t3.geojsonVtOptions);
              } catch (s7) {
                return r3(s7);
              }
              this.loaded = {};
              const l3 = {};
              if (i3) {
                const r4 = e3.f(o3);
                r4 && (l3.resourceTiming = {}, l3.resourceTiming[t3.source] = JSON.parse(JSON.stringify(r4)));
              }
              r3(null, l3);
            }
          });
        }
        reloadTile(e4, t3) {
          const r3 = this.loaded;
          return r3 && r3[e4.uid] ? super.reloadTile(e4, t3) : this.loadTile(e4, t3);
        }
        loadGeoJSON(t3, r3) {
          if (t3.request)
            e3.h(t3.request, r3);
          else {
            if ("string" != typeof t3.data)
              return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
            try {
              return r3(null, JSON.parse(t3.data));
            } catch (e4) {
              return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(e4, t3) {
          try {
            t3(null, this._geoJSONIndex.getClusterExpansionZoom(e4.clusterId));
          } catch (e5) {
            t3(e5);
          }
        }
        getClusterChildren(e4, t3) {
          try {
            t3(null, this._geoJSONIndex.getChildren(e4.clusterId));
          } catch (e5) {
            t3(e5);
          }
        }
        getClusterLeaves(e4, t3) {
          try {
            t3(null, this._geoJSONIndex.getLeaves(e4.clusterId, e4.limit, e4.offset));
          } catch (e5) {
            t3(e5);
          }
        }
      }
      class W {
        constructor(t3, r3) {
          this.tileID = new e3.O(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.tileZoom = t3.tileZoom, this.uid = t3.uid, this.zoom = t3.zoom, this.canonical = t3.tileID.canonical, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t3.projection, this.brightness = r3;
        }
        parse(t3, r3, o3, i3) {
          this.status = "parsing";
          const s6 = new e3.O(o3.tileID.overscaledZ, o3.tileID.wrap, o3.tileID.canonical.z, o3.tileID.canonical.x, o3.tileID.canonical.y), n4 = {}, a3 = r3.familiesBySource[o3.source], l3 = new e3.F(s6, o3.promoteId);
          return l3.bucketLayerIDs = [], e3.l(t3).then((t4) => {
            if (!t4)
              return i3(new Error("Could not parse tile"));
            const r4 = e3.j(t4, 1 / e3.t(o3.tileID.canonical)), h3 = t4.json.extensionsUsed && t4.json.extensionsUsed.includes("MAPBOX_mesh_features"), u3 = new e3.k(this.zoom, { brightness: this.brightness });
            for (const o4 in a3)
              for (const i4 of a3[o4]) {
                const o5 = i4[0], a4 = t4.json.extensionsUsed;
                o5.recalculate(u3, []);
                const l4 = new e3.T(r4, s6, a4 && a4.includes("MAPBOX_mesh_features"), this.brightness);
                h3 || (l4.needsUpload = true), n4[o5.fqid] = l4, l4.evaluate(o5);
              }
            this.status = "done", i3(null, { buckets: n4, featureIndex: l3 });
          }).catch((e4) => i3(new Error(e4.message)));
        }
      }
      class X {
        constructor(e4, t3, r3, o3, i3, s6) {
          this.actor = e4, this.layerIndex = t3, this.brightness = s6, this.loading = {}, this.loaded = {};
        }
        loadTile(t3, r3) {
          const o3 = t3.uid, i3 = this.loading[o3] = new W(t3, this.brightness);
          e3.i(t3.request, (e4, s6) => {
            const n4 = !this.loading[o3];
            return delete this.loading[o3], n4 || e4 ? (i3.status = "done", n4 || (this.loaded[o3] = i3), r3(e4)) : s6 && 0 !== s6.byteLength ? void i3.parse(s6, this.layerIndex, t3, (e5, t4) => {
              i3.status = "done", this.loaded = this.loaded || {}, this.loaded[o3] = i3, e5 || !t4 ? r3(e5) : r3(null, t4);
            }) : (i3.status = "done", this.loaded[o3] = i3, r3());
          });
        }
        reloadTile(e4, t3) {
          const r3 = this.loaded, o3 = e4.uid;
          if (r3 && r3[o3]) {
            const i3 = r3[o3];
            i3.projection = e4.projection, i3.brightness = e4.brightness;
            const s6 = (r4, o4) => {
              i3.reloadCallback && (delete i3.reloadCallback, this.loadTile(e4, t3)), t3(r4, o4);
            };
            "parsing" === i3.status ? i3.reloadCallback = s6 : "done" === i3.status && this.loadTile(e4, t3);
          }
        }
        abortTile(e4, t3) {
          const r3 = e4.uid;
          this.loading[r3] && delete this.loading[r3], t3();
        }
        removeTile(e4, t3) {
          const r3 = this.loaded, o3 = e4.uid;
          r3 && r3[o3] && delete r3[o3], t3();
        }
      }
      class V2 {
        constructor(t3) {
          this.self = t3, this.actor = new e3.A(t3, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e3.m({ name: "mercator" }), this.workerSourceTypes = { vector: e3.d, geojson: G, "batched-model": X }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e4, t4) => {
            if (this.workerSourceTypes[e4])
              throw new Error(`Worker source with name "${e4}" already registered.`);
            this.workerSourceTypes[e4] = t4;
          }, this.self.registerRTLTextPlugin = (t4) => {
            if (e3.n.isParsed())
              throw new Error("RTL text plugin already registered.");
            e3.n.applyArabicShaping = t4.applyArabicShaping, e3.n.processBidirectionalText = t4.processBidirectionalText, e3.n.processStyledBidirectionalText = t4.processStyledBidirectionalText;
          };
        }
        clearCaches(e4, t3, r3) {
          delete this.layerIndexes[e4], delete this.availableImages[e4], delete this.workerSources[e4], delete this.demWorkerSources[e4], r3();
        }
        checkIfReady(e4, t3, r3) {
          r3();
        }
        setReferrer(e4, t3) {
          this.referrer = t3;
        }
        spriteLoaded(t3, { scope: r3, isLoaded: o3 }) {
          if (this.isSpriteLoaded[t3] || (this.isSpriteLoaded[t3] = {}), this.isSpriteLoaded[t3][r3] = o3, this.workerSources[t3] && this.workerSources[t3][r3])
            for (const i3 in this.workerSources[t3][r3]) {
              const s6 = this.workerSources[t3][r3][i3];
              for (const t4 in s6)
                s6[t4] instanceof e3.d && (s6[t4].isSpriteLoaded = o3, s6[t4].fire(new e3.o("isSpriteLoaded")));
            }
        }
        setImages(e4, { scope: t3, images: r3 }, o3) {
          if (this.availableImages[e4] || (this.availableImages[e4] = {}), this.availableImages[e4][t3] = r3, this.workerSources[e4] && this.workerSources[e4][t3]) {
            for (const o4 in this.workerSources[e4][t3]) {
              const i3 = this.workerSources[e4][t3][o4];
              for (const e5 in i3)
                i3[e5].availableImages = r3;
            }
            o3();
          } else
            o3();
        }
        setProjection(t3, r3) {
          this.projections[t3] = e3.m(r3);
        }
        setBrightness(e4, t3, r3) {
          this.brightness = t3, r3();
        }
        setLayers(e4, t3, r3) {
          this.getLayerIndex(e4, t3.scope).replace(t3.layers, t3.options), r3();
        }
        updateLayers(e4, t3, r3) {
          this.getLayerIndex(e4, t3.scope).update(t3.layers, t3.removedIds, t3.options), r3();
        }
        loadTile(e4, t3, r3) {
          t3.projection = this.projections[e4] || this.defaultProjection, this.getWorkerSource(e4, t3.type, t3.source, t3.scope).loadTile(t3, r3);
        }
        loadDEMTile(e4, t3, r3) {
          this.getDEMWorkerSource(e4, t3.source, t3.scope).loadTile(t3, r3);
        }
        reloadTile(e4, t3, r3) {
          t3.projection = this.projections[e4] || this.defaultProjection, this.getWorkerSource(e4, t3.type, t3.source, t3.scope).reloadTile(t3, r3);
        }
        abortTile(e4, t3, r3) {
          this.getWorkerSource(e4, t3.type, t3.source, t3.scope).abortTile(t3, r3);
        }
        removeTile(e4, t3, r3) {
          this.getWorkerSource(e4, t3.type, t3.source, t3.scope).removeTile(t3, r3);
        }
        removeSource(e4, t3, r3) {
          if (!(this.workerSources[e4] && this.workerSources[e4][t3.scope] && this.workerSources[e4][t3.scope][t3.type] && this.workerSources[e4][t3.scope][t3.type][t3.source]))
            return;
          const o3 = this.workerSources[e4][t3.scope][t3.type][t3.source];
          delete this.workerSources[e4][t3.scope][t3.type][t3.source], void 0 !== o3.removeSource ? o3.removeSource(t3, r3) : r3();
        }
        loadWorkerSource(e4, t3, r3) {
          try {
            this.self.importScripts(t3.url), r3();
          } catch (e5) {
            r3(e5.toString());
          }
        }
        syncRTLPluginState(t3, r3, o3) {
          try {
            e3.n.setState(r3);
            const t4 = e3.n.getPluginURL();
            if (e3.n.isLoaded() && !e3.n.isParsed() && null != t4) {
              this.self.importScripts(t4);
              const r4 = e3.n.isParsed();
              o3(r4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t4}`), r4);
            }
          } catch (e4) {
            o3(e4.toString());
          }
        }
        setDracoUrl(e4, t3) {
          this.dracoUrl = t3;
        }
        getAvailableImages(e4, t3) {
          this.availableImages[e4] || (this.availableImages[e4] = {});
          let r3 = this.availableImages[e4][t3];
          return r3 || (r3 = []), r3;
        }
        getLayerIndex(e4, t3) {
          this.layerIndexes[e4] || (this.layerIndexes[e4] = {});
          let r3 = this.layerIndexes[e4][t3];
          return r3 || (r3 = this.layerIndexes[e4][t3] = new o2(), r3.scope = t3), r3;
        }
        getWorkerSource(e4, t3, r3, o3) {
          if (this.workerSources[e4] || (this.workerSources[e4] = {}), this.workerSources[e4][o3] || (this.workerSources[e4][o3] = {}), this.workerSources[e4][o3][t3] || (this.workerSources[e4][o3][t3] = {}), this.isSpriteLoaded[e4] || (this.isSpriteLoaded[e4] = {}), !this.workerSources[e4][o3][t3][r3]) {
            const i3 = { send: (t4, r4, o4, i4, s6, n4) => {
              this.actor.send(t4, r4, o4, e4, s6, n4);
            }, scheduler: this.actor.scheduler };
            this.workerSources[e4][o3][t3][r3] = new this.workerSourceTypes[t3](i3, this.getLayerIndex(e4, o3), this.getAvailableImages(e4, o3), this.isSpriteLoaded[e4][o3], void 0, this.brightness);
          }
          return this.workerSources[e4][o3][t3][r3];
        }
        getDEMWorkerSource(e4, t3, r3) {
          return this.demWorkerSources[e4] || (this.demWorkerSources[e4] = {}), this.demWorkerSources[e4][r3] || (this.demWorkerSources[e4][r3] = {}), this.demWorkerSources[e4][r3][t3] || (this.demWorkerSources[e4][r3][t3] = new i2()), this.demWorkerSources[e4][r3][t3];
        }
        enforceCacheSizeLimit(t3, r3) {
          e3.q(r3);
        }
        getWorkerPerformanceMetrics(e4, t3, r3) {
          r3(void 0, void 0);
        }
      }
      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new V2(self)), V2;
    });
    define(["./shared"], function(e3) {
      return e3.s;
    });
    var mapboxgl$1 = mapboxgl2;
    return mapboxgl$1;
  });
})(mapboxGl);
var mapboxGlExports = mapboxGl.exports;
const mapboxgl = /* @__PURE__ */ getDefaultExportFromCjs(mapboxGlExports);
const mapboxStyles = `.mapboxgl-map{font:12px/20px Helvetica Neue,Arial,Helvetica,sans-serif;overflow:hidden;position:relative;-webkit-tap-highlight-color:rgb(0 0 0/0)}.mapboxgl-canvas{left:0;position:absolute;top:0}.mapboxgl-map:-webkit-full-screen{height:100%;width:100%}.mapboxgl-canary{background-color:salmon}.mapboxgl-canvas-container.mapboxgl-interactive,.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass{cursor:grab;-webkit-user-select:none;user-select:none}.mapboxgl-canvas-container.mapboxgl-interactive.mapboxgl-track-pointer{cursor:pointer}.mapboxgl-canvas-container.mapboxgl-interactive:active,.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass:active{cursor:grabbing}.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate,.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate .mapboxgl-canvas{touch-action:pan-x pan-y}.mapboxgl-canvas-container.mapboxgl-touch-drag-pan,.mapboxgl-canvas-container.mapboxgl-touch-drag-pan .mapboxgl-canvas{touch-action:pinch-zoom}.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas{touch-action:none}.mapboxgl-ctrl-bottom-left,.mapboxgl-ctrl-bottom-right,.mapboxgl-ctrl-top-left,.mapboxgl-ctrl-top-right{pointer-events:none;position:absolute;z-index:2}.mapboxgl-ctrl-top-left{left:0;top:0}.mapboxgl-ctrl-top-right{right:0;top:0}.mapboxgl-ctrl-bottom-left{bottom:0;left:0}.mapboxgl-ctrl-bottom-right{bottom:0;right:0}.mapboxgl-ctrl{clear:both;pointer-events:auto;transform:translate(0)}.mapboxgl-ctrl-top-left .mapboxgl-ctrl{float:left;margin:10px 0 0 10px}.mapboxgl-ctrl-top-right .mapboxgl-ctrl{float:right;margin:10px 10px 0 0}.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl{float:left;margin:0 0 10px 10px}.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl{float:right;margin:0 10px 10px 0}.mapboxgl-ctrl-group{background:#fff;border-radius:4px}.mapboxgl-ctrl-group:not(:empty){box-shadow:0 0 0 2px rgba(0,0,0,.1)}@media (-ms-high-contrast:active){.mapboxgl-ctrl-group:not(:empty){box-shadow:0 0 0 2px ButtonText}}.mapboxgl-ctrl-group button{background-color:transparent;border:0;box-sizing:border-box;cursor:pointer;display:block;height:29px;outline:none;overflow:hidden;padding:0;width:29px}.mapboxgl-ctrl-group button+button{border-top:1px solid #ddd}.mapboxgl-ctrl button .mapboxgl-ctrl-icon{background-position:50%;background-repeat:no-repeat;display:block;height:100%;width:100%}@media (-ms-high-contrast:active){.mapboxgl-ctrl-icon{background-color:transparent}.mapboxgl-ctrl-group button+button{border-top:1px solid ButtonText}}.mapboxgl-ctrl-attrib-button:focus,.mapboxgl-ctrl-group button:focus{box-shadow:0 0 2px 2px #0096ff}.mapboxgl-ctrl button:disabled{cursor:not-allowed}.mapboxgl-ctrl button:disabled .mapboxgl-ctrl-icon{opacity:.25}.mapboxgl-ctrl-group button:first-child{border-radius:4px 4px 0 0}.mapboxgl-ctrl-group button:last-child{border-radius:0 0 4px 4px}.mapboxgl-ctrl-group button:only-child{border-radius:inherit}.mapboxgl-ctrl button:not(:disabled):hover{background-color:rgb(0 0 0/5%)}.mapboxgl-ctrl-group button:focus:focus-visible{box-shadow:0 0 2px 2px #0096ff}.mapboxgl-ctrl-group button:focus:not(:focus-visible){box-shadow:none}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}}.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}}.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath id='south' d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath id='south' d='M10.5 16l4 8 4-8h-8z' fill='%23999'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23000' viewBox='0 0 29 29'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath id='south' d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E")}}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23aaa'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' fill='%23f00'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2' display='none'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2' display='none'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-waiting .mapboxgl-ctrl-icon{animation:mapboxgl-spin 2s linear infinite}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23999'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' fill='%23f00'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2' display='none'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2' display='none'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23000'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' display='none'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23666'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle id='dot' cx='10' cy='10' r='2'/%3E%3Cpath id='stroke' d='M14 5l1 1-9 9-1-1 9-9z' fill='%23f00'/%3E%3C/svg%3E")}}@keyframes mapboxgl-spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}a.mapboxgl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd' viewBox='0 0 88 23'%3E%3Cdefs%3E%3Cpath id='logo' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='text' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='clip'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/mask%3E%3Cg id='outline' opacity='0.3' stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23clip)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23text' mask='url(%23clip)'/%3E%3C/g%3E%3Cg id='fill' opacity='0.9' fill='%23fff'%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/g%3E%3C/svg%3E");background-repeat:no-repeat;cursor:pointer;display:block;height:23px;margin:0 0 -4px -4px;overflow:hidden;width:88px}a.mapboxgl-ctrl-logo.mapboxgl-compact{width:23px}@media (-ms-high-contrast:active){a.mapboxgl-ctrl-logo{background-color:transparent;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd' viewBox='0 0 88 23'%3E%3Cdefs%3E%3Cpath id='logo' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='text' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='clip'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/mask%3E%3Cg id='outline' opacity='1' stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23clip)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23text' mask='url(%23clip)'/%3E%3C/g%3E%3Cg id='fill' opacity='1' fill='%23fff'%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/g%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){a.mapboxgl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd' viewBox='0 0 88 23'%3E%3Cdefs%3E%3Cpath id='logo' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='text' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='clip'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/mask%3E%3Cg id='outline' opacity='1' stroke='%23fff' stroke-width='3' fill='%23fff'%3E%3Ccircle mask='url(%23clip)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23text' mask='url(%23clip)'/%3E%3C/g%3E%3Cg id='fill' opacity='1' fill='%23000'%3E%3Cuse xlink:href='%23logo'/%3E%3Cuse xlink:href='%23text'/%3E%3C/g%3E%3C/svg%3E")}}.mapboxgl-ctrl.mapboxgl-ctrl-attrib{background-color:hsla(0,0%,100%,.5);margin:0;padding:0 5px}@media screen{.mapboxgl-ctrl-attrib.mapboxgl-compact{background-color:#fff;border-radius:12px;box-sizing:content-box;margin:10px;min-height:20px;padding:2px 24px 2px 0;position:relative}.mapboxgl-ctrl-attrib.mapboxgl-compact-show{padding:2px 28px 2px 8px;visibility:visible}.mapboxgl-ctrl-bottom-left>.mapboxgl-ctrl-attrib.mapboxgl-compact-show,.mapboxgl-ctrl-top-left>.mapboxgl-ctrl-attrib.mapboxgl-compact-show{border-radius:12px;padding:2px 8px 2px 28px}.mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-inner{display:none}.mapboxgl-ctrl-attrib-button{background-color:hsla(0,0%,100%,.5);background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E");border:0;border-radius:12px;box-sizing:border-box;cursor:pointer;display:none;height:24px;outline:none;position:absolute;right:0;top:0;width:24px}.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl-attrib-button,.mapboxgl-ctrl-top-left .mapboxgl-ctrl-attrib-button{left:0}.mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-button,.mapboxgl-ctrl-attrib.mapboxgl-compact-show .mapboxgl-ctrl-attrib-inner{display:block}.mapboxgl-ctrl-attrib.mapboxgl-compact-show .mapboxgl-ctrl-attrib-button{background-color:rgb(0 0 0/5%)}.mapboxgl-ctrl-bottom-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{bottom:0;right:0}.mapboxgl-ctrl-top-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{right:0;top:0}.mapboxgl-ctrl-top-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{left:0;top:0}.mapboxgl-ctrl-bottom-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{bottom:0;left:0}}@media screen and (-ms-high-contrast:active){.mapboxgl-ctrl-attrib.mapboxgl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' fill='%23fff'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")}}@media screen and (-ms-high-contrast:black-on-white){.mapboxgl-ctrl-attrib.mapboxgl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")}}.mapboxgl-ctrl-attrib a{color:rgba(0,0,0,.75);text-decoration:none}.mapboxgl-ctrl-attrib a:hover{color:inherit;text-decoration:underline}.mapboxgl-ctrl-attrib .mapbox-improve-map{font-weight:700;margin-left:2px}.mapboxgl-attrib-empty{display:none}.mapboxgl-ctrl-scale{background-color:hsla(0,0%,100%,.75);border:2px solid #333;border-top:#333;box-sizing:border-box;color:#333;font-size:10px;padding:0 5px;white-space:nowrap}.mapboxgl-popup{display:flex;left:0;pointer-events:none;position:absolute;top:0;will-change:transform}.mapboxgl-popup-anchor-top,.mapboxgl-popup-anchor-top-left,.mapboxgl-popup-anchor-top-right{flex-direction:column}.mapboxgl-popup-anchor-bottom,.mapboxgl-popup-anchor-bottom-left,.mapboxgl-popup-anchor-bottom-right{flex-direction:column-reverse}.mapboxgl-popup-anchor-left{flex-direction:row}.mapboxgl-popup-anchor-right{flex-direction:row-reverse}.mapboxgl-popup-tip{border:10px solid transparent;height:0;width:0;z-index:1}.mapboxgl-popup-anchor-top .mapboxgl-popup-tip{align-self:center;border-bottom-color:#fff;border-top:none}.mapboxgl-popup-anchor-top-left .mapboxgl-popup-tip{align-self:flex-start;border-bottom-color:#fff;border-left:none;border-top:none}.mapboxgl-popup-anchor-top-right .mapboxgl-popup-tip{align-self:flex-end;border-bottom-color:#fff;border-right:none;border-top:none}.mapboxgl-popup-anchor-bottom .mapboxgl-popup-tip{align-self:center;border-bottom:none;border-top-color:#fff}.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-tip{align-self:flex-start;border-bottom:none;border-left:none;border-top-color:#fff}.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-tip{align-self:flex-end;border-bottom:none;border-right:none;border-top-color:#fff}.mapboxgl-popup-anchor-left .mapboxgl-popup-tip{align-self:center;border-left:none;border-right-color:#fff}.mapboxgl-popup-anchor-right .mapboxgl-popup-tip{align-self:center;border-left-color:#fff;border-right:none}.mapboxgl-popup-close-button{background-color:transparent;border:0;border-radius:0 3px 0 0;cursor:pointer;position:absolute;right:0;top:0}.mapboxgl-popup-close-button:hover{background-color:rgb(0 0 0/5%)}.mapboxgl-popup-content{background:#fff;border-radius:3px;box-shadow:0 1px 2px rgba(0,0,0,.1);padding:10px 10px 15px;pointer-events:auto;position:relative}.mapboxgl-popup-anchor-top-left .mapboxgl-popup-content{border-top-left-radius:0}.mapboxgl-popup-anchor-top-right .mapboxgl-popup-content{border-top-right-radius:0}.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-content{border-bottom-left-radius:0}.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-content{border-bottom-right-radius:0}.mapboxgl-popup-track-pointer{display:none}.mapboxgl-popup-track-pointer *{pointer-events:none;user-select:none}.mapboxgl-map:hover .mapboxgl-popup-track-pointer{display:flex}.mapboxgl-map:active .mapboxgl-popup-track-pointer{display:none}.mapboxgl-marker{left:0;opacity:1;position:absolute;top:0;transition:opacity .2s;will-change:transform}.mapboxgl-user-location-dot,.mapboxgl-user-location-dot:before{background-color:#1da1f2;border-radius:50%;height:15px;width:15px}.mapboxgl-user-location-dot:before{animation:mapboxgl-user-location-dot-pulse 2s infinite;content:"";position:absolute}.mapboxgl-user-location-dot:after{border:2px solid #fff;border-radius:50%;box-shadow:0 0 3px rgba(0,0,0,.35);box-sizing:border-box;content:"";height:19px;left:-2px;position:absolute;top:-2px;width:19px}.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading{height:0;width:0}.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading:after,.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading:before{border-bottom:7.5px solid #4aa1eb;content:"";position:absolute}.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading:before{border-left:7.5px solid transparent;transform:translateY(-28px) skewY(-20deg)}.mapboxgl-user-location-show-heading .mapboxgl-user-location-heading:after{border-right:7.5px solid transparent;transform:translate(7.5px,-28px) skewY(20deg)}@keyframes mapboxgl-user-location-dot-pulse{0%{opacity:1;transform:scale(1)}70%{opacity:0;transform:scale(3)}to{opacity:0;transform:scale(1)}}.mapboxgl-user-location-dot-stale{background-color:#aaa}.mapboxgl-user-location-dot-stale:after{display:none}.mapboxgl-user-location-accuracy-circle{background-color:#1da1f233;border-radius:100%;height:1px;width:1px}.mapboxgl-crosshair,.mapboxgl-crosshair .mapboxgl-interactive,.mapboxgl-crosshair .mapboxgl-interactive:active{cursor:crosshair}.mapboxgl-boxzoom{background:#fff;border:2px dotted #202020;height:0;left:0;opacity:.5;position:absolute;top:0;width:0}@media print{.mapbox-improve-map{display:none}}.mapboxgl-scroll-zoom-blocker,.mapboxgl-touch-pan-blocker{align-items:center;background:rgba(0,0,0,.7);color:#fff;display:flex;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif;height:100%;justify-content:center;left:0;opacity:0;pointer-events:none;position:absolute;text-align:center;top:0;transition:opacity .75s ease-in-out;transition-delay:1s;width:100%}.mapboxgl-scroll-zoom-blocker-show,.mapboxgl-touch-pan-blocker-show{opacity:1;transition:opacity .1s ease-in-out}.mapboxgl-canvas-container.mapboxgl-touch-pan-blocker-override.mapboxgl-scrollable-page,.mapboxgl-canvas-container.mapboxgl-touch-pan-blocker-override.mapboxgl-scrollable-page .mapboxgl-canvas{touch-action:pan-x pan-y}`;
function bboxOfPoints(points, padding = 0) {
  const minLng = points.map((pt) => pt.lon).reduce((a2, b2) => Math.min(a2, b2), 180);
  const minLat = points.map((pt) => pt.lat).reduce((a2, b2) => Math.min(a2, b2), 180);
  const maxLng = points.map((pt) => pt.lon).reduce((a2, b2) => Math.max(a2, b2), -180);
  const maxLat = points.map((pt) => pt.lat).reduce((a2, b2) => Math.max(a2, b2), -180);
  const padLng = padding * (maxLng - minLng);
  const padLat = padding * (maxLat - minLat);
  return [
    { lon: minLng - padLng, lat: minLat - padLat },
    { lon: maxLng + padLng, lat: maxLat + padLat }
  ];
}
function bboxOfFeatures(features, padding = 0.125) {
  const featurePts = (ft) => {
    if ("lat" in ft && "lon" in ft)
      return [ft];
    if ("path" in ft)
      return bboxOfPoints(ft.path);
    return [];
  };
  const points = features.map(featurePts).flat();
  return bboxOfPoints(points, padding);
}
function featureLngLat(ft) {
  if ("lat" in ft && "lon" in ft)
    return [ft.lon, ft.lat];
  if ("path" in ft) {
    const [pt0, pt1] = bboxOfFeatures(ft.path);
    return [(pt0.lon + pt1.lon) / 2, (pt0.lat + pt1.lat) / 2];
  }
  return [0, 0];
}
var __defProp$f = Object.defineProperty;
var __getOwnPropDesc$f = Object.getOwnPropertyDescriptor;
var __decorateClass$f = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$f(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$f(target, key, result);
  return result;
};
let MapViewerElement = class extends s$3 {
  constructor() {
    super();
    this.places = [];
    this.accessToken = // TODO: get this over an API
    "pk.eyJ1Ijoia3ViaWFrLWNhbHBvbHkiLCJhIjoiY2x0MjBvZGd2MTQxYjJrbXJ2ZzFhZWgxMSJ9.zdBsMVeJtBL4WtDLBWrUmg";
  }
  updated(changes) {
    var _a2;
    const mapElement = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector(
      "#map"
    );
    if (changes.has("places") && mapElement && this.places.length > 0) {
      console.log("Mapping places:", this.places);
      let map = createMap(this.places, {
        accessToken: this.accessToken,
        container: mapElement,
        style: "mapbox://styles/mapbox/streets-v12"
        // style URL
      });
      markPlaces(map, this.places);
      if (this.route)
        markRoute(map, this.route);
    }
  }
  render() {
    return x`
      <div id="map"></div>
    `;
  }
};
MapViewerElement.styles = [
  r$5(mapboxStyles),
  i$3`#map { aspect-ratio: 3/4`
];
__decorateClass$f([
  r()
], MapViewerElement.prototype, "accessToken", 2);
__decorateClass$f([
  n$1({ attribute: false })
], MapViewerElement.prototype, "places", 2);
__decorateClass$f([
  n$1({ attribute: false })
], MapViewerElement.prototype, "route", 2);
MapViewerElement = __decorateClass$f([
  t("map-viewer")
], MapViewerElement);
function createMap(places, options) {
  const features = places.map((p2) => p2.feature);
  const bbox = bboxOfFeatures(features).map((pt) => [
    pt.lon,
    pt.lat
  ]);
  return new mapboxgl.Map({ bounds: bbox, ...options });
}
function markPlaces(map, places) {
  places.forEach((p2) => {
    const m2 = new mapboxGlExports.Marker().setLngLat(
      featureLngLat(p2.feature)
    );
    m2.addTo(map);
  });
}
function markRoute(map, route) {
  const { geometry } = route;
  console.log("Route Geometry is:", geometry);
  map.on("load", () => {
    map.addSource("route", {
      type: "geojson",
      data: {
        type: "Feature",
        properties: {},
        geometry
      }
    });
    map.addLayer({
      id: "route",
      type: "line",
      source: "route",
      layout: {
        "line-join": "round",
        "line-cap": "round"
      },
      paint: {
        "line-color": "#888",
        "line-width": 8
      }
    });
  });
}
const resetCSS = "* {\n  margin: 0;\n  box-sizing: border-box;\n}\nbody {\n  line-height: 1.5;\n  min-height: 100vh;\n  display: flex;\n  flex-direction: column;\n}\nimg {\n  max-width: 100%;\n}\n";
const pageCSS = ".page {\n  font-family: var(--font-family-body);\n  background-color: var(--color-background-page);\n  color: var(--color-text);\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  flex-basis: 100%;\n  flex-grow: 1;\n  width: 100%;\n  padding: 2rem;\n  overflow: auto;\n}\n\nbody > section {\n  margin: var(--size-spacing-medium);\n}\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\ndt,\nsummary {\n  font-family: var(--font-family-display);\n  line-height: var(--font-line-height-display);\n}\nh1 {\n  font-size: var(--size-type-xxlarge);\n  font-style: oblique;\n  line-height: 1;\n  font-weight: var(--font-weight-bold);\n}\nh2 {\n  font-size: var(--size-type-xlarge);\n  font-weight: var(--font-weight-bold);\n}\nh3 {\n  font-size: var(--size-type-large);\n  font-weight: var(--font-weight-normal);\n  font-style: oblique;\n}\nh4 {\n  font-size: var(--size-type-mlarge);\n  font-weight: var(--font-weight-bold);\n}\nh5 {\n  font-size: var(--size-type-body);\n  font-weight: var(--font-weight-bold);\n}\nh6 {\n  font-size: var(--size-type-body);\n  font-weight: var(--font-weight-normal);\n  font-style: italic;\n}\ndt {\n  font-weight: var(--size-type-body);\n}\nh3,\na {\n  color: var(--color-accent);\n}\nsvg.outline-map {\n  fill: #ff0;\n}\nsvg.icon {\n  display: inline;\n  fill: currentColor;\n  height: var(--size-icon-large);\n  width: var(--size-icon-large);\n  vertical-align: middle;\n}\n";
var __defProp$e = Object.defineProperty;
var __getOwnPropDesc$e = Object.getOwnPropertyDescriptor;
var __decorateClass$e = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$e(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$e(target, key, result);
  return result;
};
let TourPageElement = class extends View2 {
  get tourId() {
    var _a2;
    return (_a2 = this.location) == null ? void 0 : _a2.params.tour;
  }
  get tour() {
    return this.getFromModel("tour");
  }
  get route() {
    return this.getFromModel("route");
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "tour-id" && oldValue !== newValue && newValue) {
      console.log("Tour Page:", newValue);
      this.dispatchMessage({
        type: "TourSelected",
        tourId: newValue
      });
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  updated(changes) {
    console.log("Tour page updatged:", changes);
    if (changes.has("_model") && this.tour && !this.route) {
      this.dispatchMessage({
        type: "RouteRequested",
        points: this.tour.destinations.map((d2) => d2.location)
      });
    }
  }
  render() {
    var _a2;
    const {
      endDate,
      destinations = [],
      transportation = [],
      entourage,
      name,
      startDate
    } = this.tour || {};
    const renderDestination = (dest, i2) => {
      const { startDate: startDate2, endDate: endDate2, name: name2, featuredImage } = dest;
      return x`
        <itinerary-destination
          start-date=${startDate2}
          end-date=${endDate2}
          img-src=${featuredImage}
          href="./${this.tourId}/destination/${i2}">
          ${name2}
        </itinerary-destination>
      `;
    };
    const renderRoute = (route) => {
      const count = route.length;
      const origin = route[0];
      const terminus = route[count - 1];
      const via = count > 2 ? x`
              <span slot="via">
                ${route.slice(1, -1).join(", ")}
              </span>
            ` : null;
      return x`
        <span slot="origin">${origin}</span>
        <span slot="terminus">${terminus}</span>
        ${via}
      `;
    };
    const renderTransportation = (tran) => {
      const { startDate: startDate2, type, routing = [] } = tran || {};
      return x`
        <itinerary-transportation
          start-date=${startDate2}
          type=${type}>
          ${renderRoute(routing)}
        </itinerary-transportation>
      `;
    };
    const places = ((_a2 = this.tour) == null ? void 0 : _a2.destinations.map((d2) => ({
      name: d2.name,
      feature: d2.location
    }))) || [];
    return x`
      <main class="page">
        <header>
          <h2>${name}</h2>
          <p>
            from ${formatDate(startDate)} to
            ${formatDate(endDate)}
            ${endDate && endDate.getFullYear()}
          </p>
        </header>

        <calendar-widget
          start-date=${startDate}
          end-date=${endDate}></calendar-widget>

        <map-viewer
          .places=${places}
          .route=${this.route}></map-viewer>

        <section class="itinerary">
          ${destinations.map((d2, i2) => {
      const t0 = i2 === 0 ? renderTransportation(transportation[i2]) : "";
      const dthis = renderDestination(d2, i2);
      const tnext = renderTransportation(
        transportation[i2 + 1]
      );
      return x`
              ${t0}${dthis}${tnext}
            `;
    })}
        </section>

        <entourage-table
          .using=${entourage}
          href="./${this.tourId}/entourage"></entourage-table>
      </main>
    `;
  }
};
TourPageElement.styles = [
  r$5(resetCSS),
  r$5(pageCSS),
  i$3`
      main.page {
        display: grid;
        padding: var(--size-spacing-small)
          var(--size-spacing-medium);
        gap: var(--size-spacing-xlarge);

        grid-template-columns: min-content 1fr;
        grid-template-rows: auto auto auto auto 1fr;
        grid-template-areas:
          "header    itinerary"
          "calendar  itinerary"
          "map       itinerary"
          "entourage itinerary"
          "empty     itinerary";
      }

      header {
        grid-area: header;
      }

      calendar-widget {
        grid-area: calendar;
        align-self: start;
      }

      map-viewer {
        grid-area: map;
      }

      .itinerary {
        display: grid;
        grid-area: itinerary;
        align-self: start;
        grid-template-columns:
          [start] min-content [primary] 1fr var(
            --size-icon-large
          )
          1fr [end];
        gap: 0 var(--size-spacing-medium);
        align-items: baseline;
      }
    `
];
__decorateClass$e([
  n$1({ attribute: false })
], TourPageElement.prototype, "location", 2);
__decorateClass$e([
  n$1({ attribute: "tour-id", reflect: true })
], TourPageElement.prototype, "tourId", 1);
__decorateClass$e([
  n$1()
], TourPageElement.prototype, "tour", 1);
__decorateClass$e([
  n$1()
], TourPageElement.prototype, "route", 1);
TourPageElement = __decorateClass$e([
  t("tour-page")
], TourPageElement);
var __defProp$d = Object.defineProperty;
var __getOwnPropDesc$d = Object.getOwnPropertyDescriptor;
var __decorateClass$d = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$d(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$d(target, key, result);
  return result;
};
let UserProfileElement = class extends View2 {
  get profile() {
    return this.using || {};
  }
  render() {
    const {
      userid,
      name,
      nickname,
      city,
      airports = []
    } = this.profile;
    const renderAirport = (s5) => x`<dd>${s5}</dd>`;
    return x`
      <section>
        ${this._renderAvatar()}
        <a href="?edit=t">Edit</a>
        <h1>${name}</h1>
        <dl>
          <dt>Username</dt>
          <dd>${userid}</dd>
          <dt>Nickname</dt>
          <dd>${nickname}</dd>
          <dt>Home City</dt>
          <dd>${city}</dd>
          <dt>Airports</dt>
          ${airports.map(renderAirport)}
        </dl>
      </section>
    `;
  }
  _renderAvatar() {
    const { avatar, name, nickname, color } = this.profile || {};
    const url = this.newAvatar || avatar;
    const avatarImg = url ? x`<img id="avatarImg" src="${url}" />` : (nickname || name || " ").slice(0, 1);
    const colorStyle = color ? `--avatar-backgroundColor: ${color}` : "";
    return x` <div class="avatar" style=${colorStyle}>
      ${avatarImg}
    </div>`;
  }
};
UserProfileElement.styles = [
  r$5(resetCSS),
  r$5(pageCSS),
  i$3`
      :host {
        --avatar-backgroundColor: var(--color-accent);
        --avatar-size: 100px;
        padding: var(--size-spacing-medium);
      }
      section {
        display: grid;
        grid-template-columns: [key] 1fr [value] 2fr [end];
        gap: var(--size-spacing-xlarge);
        align-items: end;
      }
      h1 {
        grid-column: value;
      }
      dl {
        display: grid;
        grid-column: key / end;
        grid-template-columns: subgrid;
        gap: 0 var(--size-spacing-xlarge);
        align-items: baseline;
      }
      dt {
        grid-column: key;
        justify-self: end;
        color: var(--color-accent);
        font-family: var(--font-family-display);
      }
      dd {
        grid-column: value;
      }
      .avatar {
        grid-column: key;
        grid-row: auto/span 2;
        justify-self: end;
        position: relative;
        width: var(--avatar-size);
        aspect-ratio: 1;
        background-color: var(--avatar-backgroundColor);
        border-radius: 50%;
        text-align: center;
        line-height: var(--avatar-size);
        font-size: calc(0.66 * var(--avatar-size));
        font-family: var(--font-family-display);
        color: var(--color-link-inverted);
        overflow: hidden;
      }
      .name {
        width: 100%;
        font-family: var(--font-family-display);
        color: var(--color-accent);
      }
      img {
        width: 100%;
      }
    `
];
__decorateClass$d([
  n$1({ attribute: false })
], UserProfileElement.prototype, "using", 2);
__decorateClass$d([
  r()
], UserProfileElement.prototype, "newAvatar", 2);
UserProfileElement = __decorateClass$d([
  t("user-profile")
], UserProfileElement);
let UserProfileEditElement = class extends UserProfileElement {
  render() {
    const profile = this.profile || {};
    const {
      userid,
      name,
      nickname,
      city,
      airports = []
    } = profile;
    console.log("Rendering form", this.profile);
    return x`
      <section>
        <form @submit=${this._handleSubmit}>
          <dl>
            <dt>Username</dt>
            <dd
              ><input name="userid" disabled .value=${userid}
            /></dd>
            <dt>Avatar</dt>
            <dd
              ><input
                name="avatar"
                type="file"
                @change=${this._handleAvatarSelected}
            /></dd>
            <dd>${this._renderAvatar()}</dd>
            <dt>Name</dt>
            <dd><input name="name" .value=${name} /></dd>
            <dt>Nickname</dt>
            <dd
              ><input name="nickname" .value=${nickname}
            /></dd>
            <dt>Home City</dt>
            <dd><input name="city" .value=${city} /></dd>
            <dt>Airports</dt>
            <dd
              ><input
                name="airports"
                .value=${airports.join(", ")}
            /></dd>
          </dl>
          <button type="submit">Submit</button>
        </form>
      </section>
    `;
  }
  _handleAvatarSelected(ev) {
    const target = ev.target;
    const selectedFile = target.files[0];
    const reader = new Promise(
      (resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = (err) => reject(err);
        fr.readAsDataURL(selectedFile);
      }
    );
    reader.then((url) => this.newAvatar = url);
  }
  _handleSubmit(event) {
    var _a2;
    event.preventDefault();
    if (this.profile) {
      const target = event.target;
      const formdata = new FormData(target);
      let entries = Array.from(formdata.entries()).map(([k2, v2]) => v2 === "" ? [k2] : [k2, v2]).map(
        ([k2, v2]) => k2 === "airports" ? [k2, v2.split(",").map((s5) => s5.trim())] : [k2, v2]
      );
      if (this.newAvatar)
        entries.push(["avatar", this.newAvatar]);
      const json = Object.fromEntries(entries);
      console.log("Submitting Form", json);
      this.dispatchMessage({
        type: "ProfileSaved",
        userid: (_a2 = this.profile) == null ? void 0 : _a2.userid,
        profile: json
      });
    }
  }
};
UserProfileEditElement.styles = [
  ...UserProfileElement.styles,
  i$3`
      form {
        display: contents;
      }
      button {
        grid-column: value;
        width: 10em;
      }
      input {
        font: inherit;
      }
    `
];
UserProfileEditElement = __decorateClass$d([
  t("user-profile-edit")
], UserProfileEditElement);
var __defProp$c = Object.defineProperty;
var __getOwnPropDesc$c = Object.getOwnPropertyDescriptor;
var __decorateClass$c = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$c(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$c(target, key, result);
  return result;
};
let ProfilePageElement = class extends View2 {
  get userid() {
    var _a2;
    return (_a2 = this.location) == null ? void 0 : _a2.params.userid;
  }
  get edit() {
    if (this.location) {
      const params = new URL(document.location.toString()).searchParams;
      return params.has("edit");
    }
    return false;
  }
  get profile() {
    return this.getFromModel("profile");
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "userid" && oldValue !== newValue && newValue) {
      console.log("Profile Page:", newValue);
      this.dispatchMessage({
        type: "ProfileSelected",
        userid: newValue
      });
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  render() {
    return x`
      <main class="page">
        ${this.edit ? x`
              <user-profile-edit .using=${this.profile}>
              </user-profile-edit>
            ` : x`
              <user-profile .using=${this.profile}>
              </user-profile>
            `}
      </main>
    `;
  }
};
ProfilePageElement.styles = [
  r$5(resetCSS),
  r$5(pageCSS),
  i$3`
      :host {
        display: contents;
      }
    `
];
__decorateClass$c([
  n$1({ attribute: false })
], ProfilePageElement.prototype, "location", 2);
__decorateClass$c([
  n$1({ reflect: true })
], ProfilePageElement.prototype, "userid", 1);
__decorateClass$c([
  n$1({ reflect: true })
], ProfilePageElement.prototype, "edit", 1);
__decorateClass$c([
  n$1()
], ProfilePageElement.prototype, "profile", 1);
ProfilePageElement = __decorateClass$c([
  t("profile-page")
], ProfilePageElement);
var __defProp$b = Object.defineProperty;
var __getOwnPropDesc$b = Object.getOwnPropertyDescriptor;
var __decorateClass$b = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$b(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$b(target, key, result);
  return result;
};
let ExcursionCardElement = class extends s$3 {
  render() {
    return x`
      <svg class="icon">
        <use href="/icons/transportation.svg#icon-train" />
      </svg>
      <h3><slot>Name of Excursion</slot></h3>
    `;
  }
};
ExcursionCardElement.styles = i$3`
    :host {
      display: flex;
      flex-direction: column;
      border: var(--line-weight-fine) solid var(--color-accent);
      padding: var(--size-spacing-medium);
      height: 100%;
    }
    h3 {
      font-family: var(--font-family-display);
      line-height: var(--font-line-height-display);
      font-size: var(--size-type-large);
      font-weight: var(--font-weight-normal);
      font-style: oblique;
    }
    svg.icon {
      display: inline;
      fill: currentColor;
      height: var(--size-icon-large);
      width: var(--size-icon-large);
      vertical-align: middle;
      flex-shrink: 0;
    }
  `;
__decorateClass$b([
  n$1()
], ExcursionCardElement.prototype, "type", 2);
ExcursionCardElement = __decorateClass$b([
  t("excursion-card")
], ExcursionCardElement);
var __defProp$a = Object.defineProperty;
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __decorateClass$a = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$a(target, key, result);
  return result;
};
let DestinationPageElement = class extends View2 {
  constructor() {
    var _a2;
    super(...arguments);
    this.image = (_a2 = this.destination) == null ? void 0 : _a2.featuredImage;
  }
  get tourId() {
    var _a2;
    return (_a2 = this.location) == null ? void 0 : _a2.params.tour;
  }
  get destId() {
    var _a2;
    return parseInt(((_a2 = this.location) == null ? void 0 : _a2.params.dest) || "0");
  }
  get edit() {
    var _a2;
    if ((_a2 = this.location) == null ? void 0 : _a2.search) {
      console.log("Checking for edit", this.location);
      const params = new URLSearchParams(this.location.search);
      return params.has("edit");
    }
    return false;
  }
  get tour() {
    return this.getFromModel("tour");
  }
  get destination() {
    const tour = this.tour;
    const destinations = (tour == null ? void 0 : tour.destinations) || [];
    return destinations[this.destId] || {};
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "tour-id" && oldValue !== newValue && newValue) {
      console.log("Tour Page:", newValue);
      this.dispatchMessage({
        type: "TourSelected",
        tourId: newValue
      });
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  render() {
    var _a2;
    const {
      name,
      link,
      startDate,
      endDate,
      location,
      featuredImage,
      excursions = []
    } = this.destination;
    const tourName = (_a2 = this.tour) == null ? void 0 : _a2.name;
    const imageUrl = this.image || featuredImage;
    const formatPoint = (loc) => {
      if (!loc) {
        return "(Unknown Location)";
      }
      const latabs = Math.abs(loc.lat);
      const latsign = loc.lat < 0 ? -1 : 1;
      const lonabs = Math.abs(loc.lon);
      const lonsign = loc.lon < 0 ? -1 : 1;
      return `
        ( ${latabs}${latsign ? "N" : "S"},
        ${lonabs}${lonsign ? "E" : "W"} )
      `;
    };
    console.log("Destination:", this.destination);
    const renderDisplayOrForm = () => {
      if (this.edit) {
        const { lat, lon } = location || {};
        return x`
          <form @submit=${this._handleSubmit}>
            <dl>
              <dt>Destination Name</dt>
              <dd><input name="name" .value=${name} /></dd>
              <dt>Dates</dt>
              <dd>
                <input name="endDate" value=${startDate} />
                to
                <input name="startDate" value=${endDate} />
              </dd>
              <dt>Coordinates</dt>
              <dd>
                (
                <input
                  type="number"
                  min="0"
                  max="90"
                  name="latabs"
                  step="any"
                  value=${Math.abs(lat)} />
                <select name="latsign">
                  <option value="1" ?selected=${lat >= 0}>
                    N
                  </option>
                  <option value="-1" ?selected=${lat < 0}>
                    S
                  </option>
                </select>
                ,
                <input
                  type="number"
                  min="0"
                  max="180"
                  name="lonabs"
                  step="any"
                  value=${Math.abs(lon)} />
                <select name="lonsign">
                  <option value="1" ?selected=${lon >= 0}>
                    E
                  </option>
                  <option value="-1" ?selected=${lon < 0}>
                    W
                  </option>
                </select>
              </dd>
              <dt>Featured Image</dt>
              <dd>
                <input
                  type="file"
                  @change=${this._handleFileSelected} />
              </dd>
              <dd>
                <img src=${imageUrl} />
              </dd>
            </dl>
            <button type="submit">Submit</button>
          </form>
        `;
      } else {
        return x`
          <header>
            <a class="breadcrumb" href="/app/${this.tourId}">
              ${tourName}
            </a>
            <h2>${name}</h2>
            <p>
              from ${formatDate(startDate)} to
              ${formatDate(endDate)}
              ${endDate && endDate.getFullYear()}
            </p>
            <p>${formatPoint(location)}</p>
            <a href="?edit=t">Edit</a>
          </header>
          <a class="hero" href=${link}>
            <img src=${imageUrl} />
          </a>
          <ul class="excursions">
            ${excursions.map(
          (x$1) => x`
                  <li>
                    <excursion-card type="${x$1.type}}">
                      ${x$1.name}
                    </excursion-card>
                  </li>
                `
        )}
          </ul>
        `;
      }
    };
    return x`
      <main class="page">${renderDisplayOrForm()}</main>
    `;
  }
  _handleSubmit(event) {
    event.preventDefault();
    if (this.destination && this.tourId) {
      const target = event.target;
      const formdata = new FormData(target);
      let extract = {};
      let entries = Array.from(formdata.entries()).map(([k2, v2]) => v2 === "" ? [k2] : [k2, v2]).map(([k2, v2]) => {
        const key = k2.toString();
        if (["latabs", "latsign", "lonabs", "lonsign"].indexOf(
          key
        ) >= 0) {
          extract[key] = parseFloat(v2);
          return [];
        } else
          return [k2, v2];
      }).filter((tuple) => tuple.length > 0);
      const location = {
        lat: extract.latabs * extract.latsign,
        lon: extract.lonabs * extract.lonsign
      };
      entries.push([
        "featuredImage",
        this.image || this.destination.featuredImage || ""
      ]);
      const json = Object.assign(Object.fromEntries(entries), {
        location
      });
      console.log("Submitting Form", json);
      this.dispatchMessage({
        type: "DestinationSaved",
        tourId: this.tourId,
        destId: this.destId,
        destination: json
      });
    }
  }
  _handleFileSelected(ev) {
    const target = ev.target;
    const selectedFile = target.files[0];
    const reader = new Promise(
      (resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = (err) => reject(err);
        fr.readAsArrayBuffer(selectedFile);
      }
    );
    reader.then((buffer) => {
      const { name, size, type } = selectedFile;
      const query = new URLSearchParams({ filename: name });
      const url = new URL("/images", document.location.origin);
      url.search = query.toString();
      console.log("Uploading file:", selectedFile);
      fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": type,
          "Content-Length": size.toString()
        },
        body: buffer
      }).then((res) => {
        if (res.status === 201)
          return res.json();
        else
          throw res.status;
      }).then((json) => {
        if (json) {
          console.log("Image has been uploaded to", json.url);
          this.image = json.url;
        } else
          throw "No JSON response";
      }).catch((error) => {
        console.log("Upload failed", error);
      });
    });
  }
};
DestinationPageElement.styles = [
  r$5(resetCSS),
  r$5(pageCSS),
  i$3`
      .page {
        --page-grids: 8;

        display: grid;
        grid-template-columns: repeat(var(--page-grids), 1fr);
        gap: var(--size-spacing-medium);
      }
      .page > header {
        grid-column: 1 / span 3;
      }
      .page > .hero {
        grid-column: span min(5, var(--page-grids)) / -1;
      }
      .page > .excursions {
        display: contents;
        list-style: none;
        padding: 0;
      }
      .excursions > * {
        grid-column: auto / span 2;
      }
      @media screen and (max-width: 50rem) {
        .page {
          --page-grids: 4;
        }
      }
      @media screen and (max-width: 30rem) {
        .page {
          --page-grids: 2;
        }
      }
      @media screen and (min-width: 75rem) and (max-width: 100rem) {
        .page {
          --page-grids: 12;
        }
        .page > .hero {
          grid-column-start: span 8;
          grid-row: auto / span 2;
        }
      }
      @media screen and (min-width: 100rem) {
        .page {
          --page-grids: 16;
        }
        .page > .hero {
          grid-column: 5 / span 8;
          grid-row: auto / span 3;
        }
      }
    `
];
__decorateClass$a([
  n$1({ attribute: false })
], DestinationPageElement.prototype, "location", 2);
__decorateClass$a([
  n$1({ attribute: "tour-id", reflect: true })
], DestinationPageElement.prototype, "tourId", 1);
__decorateClass$a([
  n$1({ attribute: "dest-id", reflect: true })
], DestinationPageElement.prototype, "destId", 1);
__decorateClass$a([
  n$1({ reflect: true })
], DestinationPageElement.prototype, "edit", 1);
__decorateClass$a([
  n$1()
], DestinationPageElement.prototype, "tour", 1);
__decorateClass$a([
  n$1()
], DestinationPageElement.prototype, "destination", 1);
__decorateClass$a([
  r()
], DestinationPageElement.prototype, "image", 2);
DestinationPageElement = __decorateClass$a([
  t("destination-page")
], DestinationPageElement);
const WS_HOST = window.location.host;
const WS_PATH = "/ws";
function createConnection(channel, receiver) {
  const socket = new WebSocket(
    `ws://${WS_HOST}${WS_PATH}?channel=${channel}`
  );
  socket.onmessage = (event) => {
    console.log("Received message:", event.data);
    const json = JSON.parse(event.data);
    receiver(json);
  };
  return { channel, socket };
}
function sendMessage(connection, json) {
  connection.socket.send(JSON.stringify(json));
}
var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorateClass$9 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$9(target, key, result);
  return result;
};
let ChatRoomElement = class extends View2 {
  constructor() {
    super(...arguments);
    this.messages = [];
  }
  get username() {
    var _a2;
    return (_a2 = this.getFromModel("user")) == null ? void 0 : _a2.username;
  }
  firstUpdated() {
    if (!this.connection && this.tourId) {
      this.connection = createConnection(
        `chatroom${this.tourId}`,
        (msg) => this._handleMessage(msg)
      );
      console.log("Connection created", this.connection);
    }
  }
  render() {
    return x`
      <ul>
        ${this.messages.map(
      (msg) => x`
              <li>${msg.username}: ${msg.text}</li>
            `
    )}
      </ul>
      <form @submit=${this._handleSubmit}>
        <input name="text" placeholder="Type a message..." />
        <input type="submit" value="Send"></input>
      </form>
    `;
  }
  _handleSubmit(event) {
    var _a2;
    event.preventDefault();
    if (this.tourId && this.username && this.connection) {
      const target = event.target;
      const formdata = new FormData(target);
      const text = ((_a2 = formdata.get("text")) == null ? void 0 : _a2.toString()) || "";
      sendMessage(this.connection, {
        username: this.username,
        tourId: this.tourId,
        text
      });
      target.reset();
    }
  }
  _handleMessage(message) {
    console.log("Received message", message);
    this.messages = this.messages.concat([message]);
  }
};
ChatRoomElement.styles = [
  r$5(resetCSS),
  r$5(pageCSS),
  i$3``
];
__decorateClass$9([
  n$1({ attribute: "tour-id" })
], ChatRoomElement.prototype, "tourId", 2);
__decorateClass$9([
  r()
], ChatRoomElement.prototype, "messages", 2);
ChatRoomElement = __decorateClass$9([
  t("chat-room")
], ChatRoomElement);
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorateClass$8 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$8(target, key, result);
  return result;
};
let EntouragePageElement = class extends View2 {
  get tourId() {
    var _a2;
    return (_a2 = this.location) == null ? void 0 : _a2.params.tour;
  }
  get tour() {
    return this.getFromModel("tour");
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "tour-id" && oldValue !== newValue && newValue) {
      console.log("Tour Page:", newValue);
      this.dispatchMessage({
        type: "TourSelected",
        tourId: newValue
      });
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  render() {
    var _a2;
    const { entourage } = this.tour || {};
    const tourName = (_a2 = this.tour) == null ? void 0 : _a2.name;
    if (entourage) {
      return x`
        <main class="page">
          <aside>
            <a class="breadcrumb" href="/app/${this.tourId}">
              ${tourName}
            </a>
            <entourage-table
              .using=${entourage}></entourage-table>
          </aside>
          <section class="chat">
            <chat-room tour-id=${this.tourId}></chat-room>
          </section>
        </main>
      `;
    } else {
      return x``;
    }
  }
};
EntouragePageElement.styles = [
  r$5(resetCSS),
  r$5(pageCSS),
  i$3`
      :host {
        display: contents;
      }
      main.page {
        display: grid;
        grid-template-columns: fit-content 1fr;
        grid-template-areas: "aside chat";
      }
      aside {
        grid-area: aside;
      }
      .chat {
        grid-area: chat;
      }
    `
];
__decorateClass$8([
  n$1({ attribute: false })
], EntouragePageElement.prototype, "location", 2);
__decorateClass$8([
  n$1({ attribute: "tour-id", reflect: true })
], EntouragePageElement.prototype, "tourId", 1);
__decorateClass$8([
  n$1()
], EntouragePageElement.prototype, "tour", 1);
EntouragePageElement = __decorateClass$8([
  t("entourage-page")
], EntouragePageElement);
const routes = [
  {
    path: "/app/profile/:userid",
    component: "profile-page"
  },
  {
    path: "/app/:tour([0-9a-f]+)/destination/:dest([0-9]+)",
    component: "destination-page"
  },
  {
    path: "/app/:tour([0-9a-f]+)/entourage",
    component: "entourage-page"
  },
  { path: "/app/:tour([0-9a-f]+)", component: "tour-page" },
  { path: "/app", component: "tour-page" },
  { path: "(.*)", redirect: "/app" }
];
const dispatch = createDispatch();
const update = dispatch.update;
dispatch.addMessage(
  "UserLoggedIn",
  (msg, model) => {
    const { user } = msg;
    return updateProps({ user })(model);
  }
);
dispatch.addMessage("TourSelected", (msg) => {
  const { tourId } = msg;
  return new APIRequest().get(`/tours/${tourId}`).then((response) => {
    if (response.status === 200) {
      return response.json();
    }
    return void 0;
  }).then((json) => {
    if (json) {
      console.log("Tour:", json);
      let tour = convertStartEndDates(json);
      tour.destinations = tour.destinations.map(
        convertStartEndDates
      );
      return tour;
    }
  }).then(
    (tour) => tour ? updateProps({ tour }) : noUpdate
  );
});
dispatch.addMessage("ProfileSelected", (msg) => {
  const { userid } = msg;
  return new APIRequest().get(`/profiles/${userid}`).then((response) => {
    if (response.status === 200) {
      return response.json();
    }
    return void 0;
  }).then((json) => {
    if (json) {
      console.log("Profile:", json);
      return json;
    }
  }).then(
    (profile) => profile ? updateProps({ profile }) : noUpdate
  );
});
dispatch.addMessage("ProfileSaved", (msg) => {
  const { userid, profile } = msg;
  return new JSONRequest(profile).put(`/profiles/${userid}`).then((response) => {
    if (response.status === 200) {
      return response.json();
    }
    return void 0;
  }).then((json) => {
    if (json) {
      console.log("Profile:", json);
    }
    return void 0;
  }).then(
    (profile2) => profile2 ? updateProps({ profile: profile2 }) : noUpdate
  );
});
dispatch.addMessage("DestinationSaved", (msg) => {
  const { tourId, destId, destination } = msg;
  return new JSONRequest(destination).put(`/tours/${tourId}/destinations/${destId}`).then((response) => {
    if (response.status === 200) {
      return response.json();
    }
    return void 0;
  }).then((json) => {
    if (json) {
      console.log("Destination:", destination);
      return json;
    }
    return void 0;
  }).then((dest) => {
    if (dest) {
      return (model) => {
        const tour = model.tour;
        const destinations = tour == null ? void 0 : tour.destinations.map(
          (d2, i2) => i2 === destId ? dest : d2
        );
        return Object.assign({}, model, {
          tour: Object.assign({}, tour, { destinations })
        });
      };
    } else {
      return noUpdate;
    }
  });
});
dispatch.addMessage("RouteRequested", (msg) => {
  const { points } = msg;
  const coordinates = points.map((pt) => `${pt.lon},${pt.lat}`).join(";");
  console.log("Requesting route for points:", coordinates);
  return new APIRequest().get(`/directions?pts=${coordinates}`).then((response) => {
    if (response.status === 200)
      return response.json();
    else
      return void 0;
  }).then((json) => {
    if (json)
      return json;
    else
      return void 0;
  }).then(
    (route) => route ? updateProps({ route }) : noUpdate
  );
});
var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorateClass$7 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$7(target, key, result);
  return result;
};
let authContext = n2("auth");
let AuthRequiredElement = class extends s$3 {
  constructor() {
    super(...arguments);
    this.loginStatus = 0;
    this.registerStatus = 0;
    this.user = AuthenticatedUser.authenticateFromLocalStorage(
      () => this._signOut()
    );
  }
  isAuthenticated() {
    return this.user.authenticated;
  }
  firstUpdated() {
    this._toggleDialog(!this.isAuthenticated());
    if (this.isAuthenticated()) {
      this._dispatchUserLoggedIn(
        this.user
      );
    }
  }
  render() {
    const dialog = x`
      <dialog>
        <form
          @submit=${this._handleLogin}
          @change=${() => this.loginStatus = 0}>
          <h2>Existing User</h2>
          <label>
            <span>Username</span>
            <input name="username" />
          </label>
          <label>
            <span>Password</span>
            <input type="password" name="pwd" />
          </label>
          <button type="submit">Sign in</button>
          <p>
            ${this.loginStatus ? `Login failed: ${this.loginStatus}` : ""}
          </p>
        </form>
        <form
          @submit=${this._handleRegister}
          @change=${this.registerStatus = 0}>
          <h2>New User</h2>
          <label>
            <span>Username</span>
            <input name="username" />
          </label>
          <label>
            <span>Password</span>
            <input type="password" name="pwd" />
          </label>
          <button type="submit">Register</button>
          <p>
            ${this.registerStatus ? `Signup failed: ${this.registerStatus}` : ""}
          </p>
          <p></p>
        </form>
      </dialog>
    `;
    return x`
      ${this.isAuthenticated() ? "" : dialog}
      <slot></slot>
    `;
  }
  _handleLogin(event) {
    event.preventDefault();
    const form = event.target;
    const data = new FormData(form);
    const request = new FormDataRequest(data);
    request.base().post("/login").then((res) => {
      if (res.status === 200) {
        return res.json();
      } else {
        this.loginStatus = res.status;
      }
    }).then((json) => {
      if (json) {
        console.log("Authentication:", json.token);
        const authenticatedUser = AuthenticatedUser.authenticate(
          json.token,
          () => this._signOut()
        );
        this.user = authenticatedUser;
        this._toggleDialog(false);
        this._dispatchUserLoggedIn(authenticatedUser);
        this.requestUpdate();
      }
    });
  }
  _dispatchUserLoggedIn(user) {
    const userLoggedIn = new CustomEvent("mvu:message", {
      bubbles: true,
      composed: true,
      detail: {
        type: "UserLoggedIn",
        user
      }
    });
    this.dispatchEvent(userLoggedIn);
  }
  _handleRegister(event) {
    event.preventDefault();
    const form = event.target;
    const data = new FormData(form);
    const request = new FormDataRequest(data);
    request.base().post("/signup").then((res) => {
      if (res.status === 200) {
        return res.json();
      } else {
        this.registerStatus = res.status;
      }
    }).then((json) => {
      console.log("Registration:", json);
    });
  }
  _toggleDialog(open) {
    var _a2;
    const dialog = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector(
      "dialog"
    );
    if (dialog) {
      if (open) {
        console.log("Showing dialog");
        dialog.showModal();
      } else {
        console.log("Closing dialog");
        dialog.close();
      }
    }
  }
  _signOut() {
    this.user = APIUser.deauthenticate(this.user);
    this._toggleDialog(!this.isAuthenticated());
    document.location.reload();
  }
};
AuthRequiredElement.styles = i$3`
    :host {
      display: contents;
    }
    dialog {
      display: flex;
      gap: 4rem;
    }
    form {
      display: grid;
      grid-template-columns: [start] 1fr 2fr [end];
      align-items: baseline;
    }
    form > label {
      display: contents;
    }
    form > h2 {
      grid-column: start / end;
      text-align: center;
    }
    input,
    button {
      font: inherit;
      line-height: inherit;
      margin: 0.25em;
    }
    button {
      grid-column: 2;
    }
  `;
__decorateClass$7([
  r()
], AuthRequiredElement.prototype, "loginStatus", 2);
__decorateClass$7([
  r()
], AuthRequiredElement.prototype, "registerStatus", 2);
__decorateClass$7([
  e2({ context: authContext }),
  r()
], AuthRequiredElement.prototype, "user", 2);
AuthRequiredElement = __decorateClass$7([
  t("auth-required")
], AuthRequiredElement);
function toArray(objectOrArray) {
  objectOrArray = objectOrArray || [];
  return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];
}
function log(msg) {
  return `[Vaadin.Router] ${msg}`;
}
function logValue(value) {
  if (typeof value !== "object") {
    return String(value);
  }
  const stringType = Object.prototype.toString.call(value).match(/ (.*)\]$/)[1];
  if (stringType === "Object" || stringType === "Array") {
    return `${stringType} ${JSON.stringify(value)}`;
  } else {
    return stringType;
  }
}
const MODULE = "module";
const NOMODULE = "nomodule";
const bundleKeys = [MODULE, NOMODULE];
function ensureBundle(src) {
  if (!src.match(/.+\.[m]?js$/)) {
    throw new Error(
      log(`Unsupported type for bundle "${src}": .js or .mjs expected.`)
    );
  }
}
function ensureRoute(route) {
  if (!route || !isString(route.path)) {
    throw new Error(
      log(`Expected route config to be an object with a "path" string property, or an array of such objects`)
    );
  }
  const bundle = route.bundle;
  const stringKeys = ["component", "redirect", "bundle"];
  if (!isFunction(route.action) && !Array.isArray(route.children) && !isFunction(route.children) && !isObject(bundle) && !stringKeys.some((key) => isString(route[key]))) {
    throw new Error(
      log(
        `Expected route config "${route.path}" to include either "${stringKeys.join('", "')}" or "action" function but none found.`
      )
    );
  }
  if (bundle) {
    if (isString(bundle)) {
      ensureBundle(bundle);
    } else if (!bundleKeys.some((key) => key in bundle)) {
      throw new Error(
        log('Expected route bundle to include either "' + NOMODULE + '" or "' + MODULE + '" keys, or both')
      );
    } else {
      bundleKeys.forEach((key) => key in bundle && ensureBundle(bundle[key]));
    }
  }
  if (route.redirect) {
    ["bundle", "component"].forEach((overriddenProp) => {
      if (overriddenProp in route) {
        console.warn(
          log(
            `Route config "${route.path}" has both "redirect" and "${overriddenProp}" properties, and "redirect" will always override the latter. Did you mean to only use "${overriddenProp}"?`
          )
        );
      }
    });
  }
}
function ensureRoutes(routes2) {
  toArray(routes2).forEach((route) => ensureRoute(route));
}
function loadScript(src, key) {
  let script = document.head.querySelector('script[src="' + src + '"][async]');
  if (!script) {
    script = document.createElement("script");
    script.setAttribute("src", src);
    if (key === MODULE) {
      script.setAttribute("type", MODULE);
    } else if (key === NOMODULE) {
      script.setAttribute(NOMODULE, "");
    }
    script.async = true;
  }
  return new Promise((resolve, reject) => {
    script.onreadystatechange = script.onload = (e3) => {
      script.__dynamicImportLoaded = true;
      resolve(e3);
    };
    script.onerror = (e3) => {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
      reject(e3);
    };
    if (script.parentNode === null) {
      document.head.appendChild(script);
    } else if (script.__dynamicImportLoaded) {
      resolve();
    }
  });
}
function loadBundle(bundle) {
  if (isString(bundle)) {
    return loadScript(bundle);
  } else {
    return Promise.race(
      bundleKeys.filter((key) => key in bundle).map((key) => loadScript(bundle[key], key))
    );
  }
}
function fireRouterEvent(type, detail) {
  return !window.dispatchEvent(new CustomEvent(
    `vaadin-router-${type}`,
    { cancelable: type === "go", detail }
  ));
}
function isObject(o2) {
  return typeof o2 === "object" && !!o2;
}
function isFunction(f2) {
  return typeof f2 === "function";
}
function isString(s5) {
  return typeof s5 === "string";
}
function getNotFoundError(context2) {
  const error = new Error(log(`Page not found (${context2.pathname})`));
  error.context = context2;
  error.code = 404;
  return error;
}
const notFoundResult = new class NotFoundResult {
}();
function getAnchorOrigin(anchor) {
  const port = anchor.port;
  const protocol = anchor.protocol;
  const defaultHttp = protocol === "http:" && port === "80";
  const defaultHttps = protocol === "https:" && port === "443";
  const host = defaultHttp || defaultHttps ? anchor.hostname : anchor.host;
  return `${protocol}//${host}`;
}
function vaadinRouterGlobalClickHandler(event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.button !== 0) {
    return;
  }
  if (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey) {
    return;
  }
  let anchor = event.target;
  const path = event.composedPath ? event.composedPath() : event.path || [];
  for (let i2 = 0; i2 < path.length; i2++) {
    const target = path[i2];
    if (target.nodeName && target.nodeName.toLowerCase() === "a") {
      anchor = target;
      break;
    }
  }
  while (anchor && anchor.nodeName.toLowerCase() !== "a") {
    anchor = anchor.parentNode;
  }
  if (!anchor || anchor.nodeName.toLowerCase() !== "a") {
    return;
  }
  if (anchor.target && anchor.target.toLowerCase() !== "_self") {
    return;
  }
  if (anchor.hasAttribute("download")) {
    return;
  }
  if (anchor.hasAttribute("router-ignore")) {
    return;
  }
  if (anchor.pathname === window.location.pathname && anchor.hash !== "") {
    return;
  }
  const origin = anchor.origin || getAnchorOrigin(anchor);
  if (origin !== window.location.origin) {
    return;
  }
  const { pathname, search, hash } = anchor;
  if (fireRouterEvent("go", { pathname, search, hash })) {
    event.preventDefault();
    if (event && event.type === "click") {
      window.scrollTo(0, 0);
    }
  }
}
const CLICK = {
  activate() {
    window.document.addEventListener("click", vaadinRouterGlobalClickHandler);
  },
  inactivate() {
    window.document.removeEventListener("click", vaadinRouterGlobalClickHandler);
  }
};
const isIE = /Trident/.test(navigator.userAgent);
if (isIE && !isFunction(window.PopStateEvent)) {
  window.PopStateEvent = function(inType, params) {
    params = params || {};
    var e3 = document.createEvent("Event");
    e3.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
    e3.state = params.state || null;
    return e3;
  };
  window.PopStateEvent.prototype = window.Event.prototype;
}
function vaadinRouterGlobalPopstateHandler(event) {
  if (event.state === "vaadin-router-ignore") {
    return;
  }
  const { pathname, search, hash } = window.location;
  fireRouterEvent("go", { pathname, search, hash });
}
const POPSTATE = {
  activate() {
    window.addEventListener("popstate", vaadinRouterGlobalPopstateHandler);
  },
  inactivate() {
    window.removeEventListener("popstate", vaadinRouterGlobalPopstateHandler);
  }
};
var pathToRegexp_1 = pathToRegexp$1;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
var DEFAULT_DELIMITER = "/";
var DEFAULT_DELIMITERS = "./";
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  "(\\\\.)",
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
  // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
  "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"
].join("|"), "g");
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = "";
  var defaultDelimiter = options && options.delimiter || DEFAULT_DELIMITER;
  var delimiters = options && options.delimiters || DEFAULT_DELIMITERS;
  var pathEscaped = false;
  var res;
  while ((res = PATH_REGEXP.exec(str)) !== null) {
    var m2 = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m2.length;
    if (escaped) {
      path += escaped[1];
      pathEscaped = true;
      continue;
    }
    var prev = "";
    var next = str[index];
    var name = res[2];
    var capture = res[3];
    var group = res[4];
    var modifier = res[5];
    if (!pathEscaped && path.length) {
      var k2 = path.length - 1;
      if (delimiters.indexOf(path[k2]) > -1) {
        prev = path[k2];
        path = path.slice(0, k2);
      }
    }
    if (path) {
      tokens.push(path);
      path = "";
      pathEscaped = false;
    }
    var partial = prev !== "" && next !== void 0 && next !== prev;
    var repeat = modifier === "+" || modifier === "*";
    var optional = modifier === "?" || modifier === "*";
    var delimiter = prev || defaultDelimiter;
    var pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prev,
      delimiter,
      optional,
      repeat,
      partial,
      pattern: pattern ? escapeGroup(pattern) : "[^" + escapeString(delimiter) + "]+?"
    });
  }
  if (path || index < str.length) {
    tokens.push(path + str.substr(index));
  }
  return tokens;
}
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}
function tokensToFunction(tokens) {
  var matches = new Array(tokens.length);
  for (var i2 = 0; i2 < tokens.length; i2++) {
    if (typeof tokens[i2] === "object") {
      matches[i2] = new RegExp("^(?:" + tokens[i2].pattern + ")$");
    }
  }
  return function(data, options) {
    var path = "";
    var encode = options && options.encode || encodeURIComponent;
    for (var i3 = 0; i3 < tokens.length; i3++) {
      var token = tokens[i3];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value = data ? data[token.name] : void 0;
      var segment;
      if (Array.isArray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but got array');
        }
        if (value.length === 0) {
          if (token.optional)
            continue;
          throw new TypeError('Expected "' + token.name + '" to not be empty');
        }
        for (var j2 = 0; j2 < value.length; j2++) {
          segment = encode(value[j2], token);
          if (!matches[i3].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"');
          }
          path += (j2 === 0 ? token.prefix : token.delimiter) + segment;
        }
        continue;
      }
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        segment = encode(String(value), token);
        if (!matches[i3].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
        }
        path += token.prefix + segment;
        continue;
      }
      if (token.optional) {
        if (token.partial)
          path += token.prefix;
        continue;
      }
      throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? "an array" : "a string"));
    }
    return path;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function escapeGroup(group) {
  return group.replace(/([=!:$/()])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groups = path.source.match(/\((?!\?)/g);
  if (groups) {
    for (var i2 = 0; i2 < groups.length; i2++) {
      keys.push({
        name: i2,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        pattern: null
      });
    }
  }
  return path;
}
function arrayToRegexp(path, keys, options) {
  var parts = [];
  for (var i2 = 0; i2 < path.length; i2++) {
    parts.push(pathToRegexp$1(path[i2], keys, options).source);
  }
  return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}
function tokensToRegExp(tokens, keys, options) {
  options = options || {};
  var strict = options.strict;
  var start = options.start !== false;
  var end = options.end !== false;
  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);
  var delimiters = options.delimiters || DEFAULT_DELIMITERS;
  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat("$").join("|");
  var route = start ? "^" : "";
  var isEndDelimited = tokens.length === 0;
  for (var i2 = 0; i2 < tokens.length; i2++) {
    var token = tokens[i2];
    if (typeof token === "string") {
      route += escapeString(token);
      isEndDelimited = i2 === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;
    } else {
      var capture = token.repeat ? "(?:" + token.pattern + ")(?:" + escapeString(token.delimiter) + "(?:" + token.pattern + "))*" : token.pattern;
      if (keys)
        keys.push(token);
      if (token.optional) {
        if (token.partial) {
          route += escapeString(token.prefix) + "(" + capture + ")?";
        } else {
          route += "(?:" + escapeString(token.prefix) + "(" + capture + "))?";
        }
      } else {
        route += escapeString(token.prefix) + "(" + capture + ")";
      }
    }
  }
  if (end) {
    if (!strict)
      route += "(?:" + delimiter + ")?";
    route += endsWith === "$" ? "$" : "(?=" + endsWith + ")";
  } else {
    if (!strict)
      route += "(?:" + delimiter + "(?=" + endsWith + "))?";
    if (!isEndDelimited)
      route += "(?=" + delimiter + "|" + endsWith + ")";
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp$1(path, keys, options) {
  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys);
  }
  if (Array.isArray(path)) {
    return arrayToRegexp(
      /** @type {!Array} */
      path,
      keys,
      options
    );
  }
  return stringToRegexp(
    /** @type {string} */
    path,
    keys,
    options
  );
}
pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
const { hasOwnProperty } = Object.prototype;
const cache$1 = /* @__PURE__ */ new Map();
cache$1.set("|false", {
  keys: [],
  pattern: /(?:)/
});
function decodeParam(val) {
  try {
    return decodeURIComponent(val);
  } catch (err) {
    return val;
  }
}
function matchPath(routepath, path, exact, parentKeys, parentParams) {
  exact = !!exact;
  const cacheKey = `${routepath}|${exact}`;
  let regexp = cache$1.get(cacheKey);
  if (!regexp) {
    const keys = [];
    regexp = {
      keys,
      pattern: pathToRegexp_1(routepath, keys, {
        end: exact,
        strict: routepath === ""
      })
    };
    cache$1.set(cacheKey, regexp);
  }
  const m2 = regexp.pattern.exec(path);
  if (!m2) {
    return null;
  }
  const params = Object.assign({}, parentParams);
  for (let i2 = 1; i2 < m2.length; i2++) {
    const key = regexp.keys[i2 - 1];
    const prop = key.name;
    const value = m2[i2];
    if (value !== void 0 || !hasOwnProperty.call(params, prop)) {
      if (key.repeat) {
        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
      } else {
        params[prop] = value ? decodeParam(value) : value;
      }
    }
  }
  return {
    path: m2[0],
    keys: (parentKeys || []).concat(regexp.keys),
    params
  };
}
function matchRoute(route, pathname, ignoreLeadingSlash, parentKeys, parentParams) {
  let match;
  let childMatches;
  let childIndex = 0;
  let routepath = route.path || "";
  if (routepath.charAt(0) === "/") {
    if (ignoreLeadingSlash) {
      routepath = routepath.substr(1);
    }
    ignoreLeadingSlash = true;
  }
  return {
    next(routeToSkip) {
      if (route === routeToSkip) {
        return { done: true };
      }
      const children = route.__children = route.__children || route.children;
      if (!match) {
        match = matchPath(routepath, pathname, !children, parentKeys, parentParams);
        if (match) {
          return {
            done: false,
            value: {
              route,
              keys: match.keys,
              params: match.params,
              path: match.path
            }
          };
        }
      }
      if (match && children) {
        while (childIndex < children.length) {
          if (!childMatches) {
            const childRoute = children[childIndex];
            childRoute.parent = route;
            let matchedLength = match.path.length;
            if (matchedLength > 0 && pathname.charAt(matchedLength) === "/") {
              matchedLength += 1;
            }
            childMatches = matchRoute(
              childRoute,
              pathname.substr(matchedLength),
              ignoreLeadingSlash,
              match.keys,
              match.params
            );
          }
          const childMatch = childMatches.next(routeToSkip);
          if (!childMatch.done) {
            return {
              done: false,
              value: childMatch.value
            };
          }
          childMatches = null;
          childIndex++;
        }
      }
      return { done: true };
    }
  };
}
function resolveRoute(context2) {
  if (isFunction(context2.route.action)) {
    return context2.route.action(context2);
  }
  return void 0;
}
function isChildRoute(parentRoute, childRoute) {
  let route = childRoute;
  while (route) {
    route = route.parent;
    if (route === parentRoute) {
      return true;
    }
  }
  return false;
}
function generateErrorMessage(currentContext) {
  let errorMessage = `Path '${currentContext.pathname}' is not properly resolved due to an error.`;
  const routePath = (currentContext.route || {}).path;
  if (routePath) {
    errorMessage += ` Resolution had failed on route: '${routePath}'`;
  }
  return errorMessage;
}
function updateChainForRoute(context2, match) {
  const { route, path } = match;
  if (route && !route.__synthetic) {
    const item = { path, route };
    if (!context2.chain) {
      context2.chain = [];
    } else {
      if (route.parent) {
        let i2 = context2.chain.length;
        while (i2-- && context2.chain[i2].route && context2.chain[i2].route !== route.parent) {
          context2.chain.pop();
        }
      }
    }
    context2.chain.push(item);
  }
}
class Resolver {
  constructor(routes2, options = {}) {
    if (Object(routes2) !== routes2) {
      throw new TypeError("Invalid routes");
    }
    this.baseUrl = options.baseUrl || "";
    this.errorHandler = options.errorHandler;
    this.resolveRoute = options.resolveRoute || resolveRoute;
    this.context = Object.assign({ resolver: this }, options.context);
    this.root = Array.isArray(routes2) ? { path: "", __children: routes2, parent: null, __synthetic: true } : routes2;
    this.root.parent = null;
  }
  /**
   * Returns the current list of routes (as a shallow copy). Adding / removing
   * routes to / from the returned array does not affect the routing config,
   * but modifying the route objects does.
   *
   * @return {!Array<!Router.Route>}
   */
  getRoutes() {
    return [...this.root.__children];
  }
  /**
   * Sets the routing config (replacing the existing one).
   *
   * @param {!Array<!Router.Route>|!Router.Route} routes a single route or an array of those
   *    (the array is shallow copied)
   */
  setRoutes(routes2) {
    ensureRoutes(routes2);
    const newRoutes = [...toArray(routes2)];
    this.root.__children = newRoutes;
  }
  /**
   * Appends one or several routes to the routing config and returns the
   * effective routing config after the operation.
   *
   * @param {!Array<!Router.Route>|!Router.Route} routes a single route or an array of those
   *    (the array is shallow copied)
   * @return {!Array<!Router.Route>}
   * @protected
   */
  addRoutes(routes2) {
    ensureRoutes(routes2);
    this.root.__children.push(...toArray(routes2));
    return this.getRoutes();
  }
  /**
   * Removes all existing routes from the routing config.
   */
  removeRoutes() {
    this.setRoutes([]);
  }
  /**
   * Asynchronously resolves the given pathname, i.e. finds all routes matching
   * the pathname and tries resolving them one after another in the order they
   * are listed in the routes config until the first non-null result.
   *
   * Returns a promise that is fulfilled with the return value of an object that consists of the first
   * route handler result that returns something other than `null` or `undefined` and context used to get this result.
   *
   * If no route handlers return a non-null result, or if no route matches the
   * given pathname the returned promise is rejected with a 'page not found'
   * `Error`.
   *
   * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to
   *    resolve or a context object with a `pathname` property and other
   *    properties to pass to the route resolver functions.
   * @return {!Promise<any>}
   */
  resolve(pathnameOrContext) {
    const context2 = Object.assign(
      {},
      this.context,
      isString(pathnameOrContext) ? { pathname: pathnameOrContext } : pathnameOrContext
    );
    const match = matchRoute(
      this.root,
      this.__normalizePathname(context2.pathname),
      this.baseUrl
    );
    const resolve = this.resolveRoute;
    let matches = null;
    let nextMatches = null;
    let currentContext = context2;
    function next(resume, parent = matches.value.route, prevResult) {
      const routeToSkip = prevResult === null && matches.value.route;
      matches = nextMatches || match.next(routeToSkip);
      nextMatches = null;
      if (!resume) {
        if (matches.done || !isChildRoute(parent, matches.value.route)) {
          nextMatches = matches;
          return Promise.resolve(notFoundResult);
        }
      }
      if (matches.done) {
        return Promise.reject(getNotFoundError(context2));
      }
      currentContext = Object.assign(
        currentContext ? { chain: currentContext.chain ? currentContext.chain.slice(0) : [] } : {},
        context2,
        matches.value
      );
      updateChainForRoute(currentContext, matches.value);
      return Promise.resolve(resolve(currentContext)).then((resolution) => {
        if (resolution !== null && resolution !== void 0 && resolution !== notFoundResult) {
          currentContext.result = resolution.result || resolution;
          return currentContext;
        }
        return next(resume, parent, resolution);
      });
    }
    context2.next = next;
    return Promise.resolve().then(() => next(true, this.root)).catch((error) => {
      const errorMessage = generateErrorMessage(currentContext);
      if (!error) {
        error = new Error(errorMessage);
      } else {
        console.warn(errorMessage);
      }
      error.context = error.context || currentContext;
      if (!(error instanceof DOMException)) {
        error.code = error.code || 500;
      }
      if (this.errorHandler) {
        currentContext.result = this.errorHandler(error);
        return currentContext;
      }
      throw error;
    });
  }
  /**
   * URL constructor polyfill hook. Creates and returns an URL instance.
   */
  static __createUrl(url, base) {
    return new URL(url, base);
  }
  /**
   * If the baseUrl property is set, transforms the baseUrl and returns the full
   * actual `base` string for using in the `new URL(path, base);` and for
   * prepernding the paths with. The returned base ends with a trailing slash.
   *
   * Otherwise, returns empty string.
   */
  get __effectiveBaseUrl() {
    return this.baseUrl ? this.constructor.__createUrl(
      this.baseUrl,
      document.baseURI || document.URL
    ).href.replace(/[^\/]*$/, "") : "";
  }
  /**
   * If the baseUrl is set, matches the pathname with the routers baseUrl,
   * and returns the local pathname with the baseUrl stripped out.
   *
   * If the pathname does not match the baseUrl, returns undefined.
   *
   * If the `baseUrl` is not set, returns the unmodified pathname argument.
   */
  __normalizePathname(pathname) {
    if (!this.baseUrl) {
      return pathname;
    }
    const base = this.__effectiveBaseUrl;
    const normalizedUrl = this.constructor.__createUrl(pathname, base).href;
    if (normalizedUrl.slice(0, base.length) === base) {
      return normalizedUrl.slice(base.length);
    }
  }
}
Resolver.pathToRegexp = pathToRegexp_1;
const { pathToRegexp } = Resolver;
const cache = /* @__PURE__ */ new Map();
function cacheRoutes(routesByName, route, routes2) {
  const name = route.name || route.component;
  if (name) {
    if (routesByName.has(name)) {
      routesByName.get(name).push(route);
    } else {
      routesByName.set(name, [route]);
    }
  }
  if (Array.isArray(routes2)) {
    for (let i2 = 0; i2 < routes2.length; i2++) {
      const childRoute = routes2[i2];
      childRoute.parent = route;
      cacheRoutes(routesByName, childRoute, childRoute.__children || childRoute.children);
    }
  }
}
function getRouteByName(routesByName, routeName) {
  const routes2 = routesByName.get(routeName);
  if (routes2 && routes2.length > 1) {
    throw new Error(
      `Duplicate route with name "${routeName}". Try seting unique 'name' route properties.`
    );
  }
  return routes2 && routes2[0];
}
function getRoutePath(route) {
  let path = route.path;
  path = Array.isArray(path) ? path[0] : path;
  return path !== void 0 ? path : "";
}
function generateUrls(router, options = {}) {
  if (!(router instanceof Resolver)) {
    throw new TypeError("An instance of Resolver is expected");
  }
  const routesByName = /* @__PURE__ */ new Map();
  return (routeName, params) => {
    let route = getRouteByName(routesByName, routeName);
    if (!route) {
      routesByName.clear();
      cacheRoutes(routesByName, router.root, router.root.__children);
      route = getRouteByName(routesByName, routeName);
      if (!route) {
        throw new Error(`Route "${routeName}" not found`);
      }
    }
    let regexp = cache.get(route.fullPath);
    if (!regexp) {
      let fullPath = getRoutePath(route);
      let rt = route.parent;
      while (rt) {
        const path = getRoutePath(rt);
        if (path) {
          fullPath = path.replace(/\/$/, "") + "/" + fullPath.replace(/^\//, "");
        }
        rt = rt.parent;
      }
      const tokens = pathToRegexp.parse(fullPath);
      const toPath = pathToRegexp.tokensToFunction(tokens);
      const keys = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0; i2 < tokens.length; i2++) {
        if (!isString(tokens[i2])) {
          keys[tokens[i2].name] = true;
        }
      }
      regexp = { toPath, keys };
      cache.set(fullPath, regexp);
      route.fullPath = fullPath;
    }
    let url = regexp.toPath(params, options) || "/";
    if (options.stringifyQueryParams && params) {
      const queryParams = {};
      const keys = Object.keys(params);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (!regexp.keys[key]) {
          queryParams[key] = params[key];
        }
      }
      const query = options.stringifyQueryParams(queryParams);
      if (query) {
        url += query.charAt(0) === "?" ? query : `?${query}`;
      }
    }
    return url;
  };
}
let triggers = [];
function setNavigationTriggers(newTriggers) {
  triggers.forEach((trigger) => trigger.inactivate());
  newTriggers.forEach((trigger) => trigger.activate());
  triggers = newTriggers;
}
const willAnimate = (elem) => {
  const name = getComputedStyle(elem).getPropertyValue("animation-name");
  return name && name !== "none";
};
const waitForAnimation = (elem, cb) => {
  const listener = () => {
    elem.removeEventListener("animationend", listener);
    cb();
  };
  elem.addEventListener("animationend", listener);
};
function animate(elem, className) {
  elem.classList.add(className);
  return new Promise((resolve) => {
    if (willAnimate(elem)) {
      const rect = elem.getBoundingClientRect();
      const size = `height: ${rect.bottom - rect.top}px; width: ${rect.right - rect.left}px`;
      elem.setAttribute("style", `position: absolute; ${size}`);
      waitForAnimation(elem, () => {
        elem.classList.remove(className);
        elem.removeAttribute("style");
        resolve();
      });
    } else {
      elem.classList.remove(className);
      resolve();
    }
  });
}
const MAX_REDIRECT_COUNT = 256;
function isResultNotEmpty(result) {
  return result !== null && result !== void 0;
}
function copyContextWithoutNext(context2) {
  const copy = Object.assign({}, context2);
  delete copy.next;
  return copy;
}
function createLocation({ pathname = "", search = "", hash = "", chain = [], params = {}, redirectFrom, resolver }, route) {
  const routes2 = chain.map((item) => item.route);
  return {
    baseUrl: resolver && resolver.baseUrl || "",
    pathname,
    search,
    hash,
    routes: routes2,
    route: route || routes2.length && routes2[routes2.length - 1] || null,
    params,
    redirectFrom,
    getUrl: (userParams = {}) => getPathnameForRouter(
      Router.pathToRegexp.compile(
        getMatchedPath(routes2)
      )(Object.assign({}, params, userParams)),
      resolver
    )
  };
}
function createRedirect(context2, pathname) {
  const params = Object.assign({}, context2.params);
  return {
    redirect: {
      pathname,
      from: context2.pathname,
      params
    }
  };
}
function renderElement(context2, element) {
  element.location = createLocation(context2);
  const index = context2.chain.map((item) => item.route).indexOf(context2.route);
  context2.chain[index].element = element;
  return element;
}
function runCallbackIfPossible(callback, args, thisArg) {
  if (isFunction(callback)) {
    return callback.apply(thisArg, args);
  }
}
function amend(amendmentFunction, args, element) {
  return (amendmentResult) => {
    if (amendmentResult && (amendmentResult.cancel || amendmentResult.redirect)) {
      return amendmentResult;
    }
    if (element) {
      return runCallbackIfPossible(element[amendmentFunction], args, element);
    }
  };
}
function processNewChildren(newChildren, route) {
  if (!Array.isArray(newChildren) && !isObject(newChildren)) {
    throw new Error(
      log(
        `Incorrect "children" value for the route ${route.path}: expected array or object, but got ${newChildren}`
      )
    );
  }
  route.__children = [];
  const childRoutes = toArray(newChildren);
  for (let i2 = 0; i2 < childRoutes.length; i2++) {
    ensureRoute(childRoutes[i2]);
    route.__children.push(childRoutes[i2]);
  }
}
function removeDomNodes(nodes) {
  if (nodes && nodes.length) {
    const parent = nodes[0].parentNode;
    for (let i2 = 0; i2 < nodes.length; i2++) {
      parent.removeChild(nodes[i2]);
    }
  }
}
function getPathnameForRouter(pathname, router) {
  const base = router.__effectiveBaseUrl;
  return base ? router.constructor.__createUrl(pathname.replace(/^\//, ""), base).pathname : pathname;
}
function getMatchedPath(chain) {
  return chain.map((item) => item.path).reduce((a2, b2) => {
    if (b2.length) {
      return a2.replace(/\/$/, "") + "/" + b2.replace(/^\//, "");
    }
    return a2;
  }, "");
}
class Router extends Resolver {
  /**
   * Creates a new Router instance with a given outlet, and
   * automatically subscribes it to navigation events on the `window`.
   * Using a constructor argument or a setter for outlet is equivalent:
   *
   * ```
   * const router = new Router();
   * router.setOutlet(outlet);
   * ```
   * @param {?Node=} outlet
   * @param {?RouterOptions=} options
   */
  constructor(outlet, options) {
    const baseElement = document.head.querySelector("base");
    const baseHref = baseElement && baseElement.getAttribute("href");
    super([], Object.assign({
      // Default options
      baseUrl: baseHref && Resolver.__createUrl(baseHref, document.URL).pathname.replace(/[^\/]*$/, "")
    }, options));
    this.resolveRoute = (context2) => this.__resolveRoute(context2);
    const triggers2 = Router.NavigationTrigger;
    Router.setTriggers.apply(Router, Object.keys(triggers2).map((key) => triggers2[key]));
    this.baseUrl;
    this.ready;
    this.ready = Promise.resolve(outlet);
    this.location;
    this.location = createLocation({ resolver: this });
    this.__lastStartedRenderId = 0;
    this.__navigationEventHandler = this.__onNavigationEvent.bind(this);
    this.setOutlet(outlet);
    this.subscribe();
    this.__createdByRouter = /* @__PURE__ */ new WeakMap();
    this.__addedByRouter = /* @__PURE__ */ new WeakMap();
  }
  __resolveRoute(context2) {
    const route = context2.route;
    let callbacks = Promise.resolve();
    if (isFunction(route.children)) {
      callbacks = callbacks.then(() => route.children(copyContextWithoutNext(context2))).then((children) => {
        if (!isResultNotEmpty(children) && !isFunction(route.children)) {
          children = route.children;
        }
        processNewChildren(children, route);
      });
    }
    const commands = {
      redirect: (path) => createRedirect(context2, path),
      component: (component) => {
        const element = document.createElement(component);
        this.__createdByRouter.set(element, true);
        return element;
      }
    };
    return callbacks.then(() => {
      if (this.__isLatestRender(context2)) {
        return runCallbackIfPossible(route.action, [context2, commands], route);
      }
    }).then((result) => {
      if (isResultNotEmpty(result)) {
        if (result instanceof HTMLElement || result.redirect || result === notFoundResult) {
          return result;
        }
      }
      if (isString(route.redirect)) {
        return commands.redirect(route.redirect);
      }
      if (route.bundle) {
        return loadBundle(route.bundle).then(() => {
        }, () => {
          throw new Error(log(`Bundle not found: ${route.bundle}. Check if the file name is correct`));
        });
      }
    }).then((result) => {
      if (isResultNotEmpty(result)) {
        return result;
      }
      if (isString(route.component)) {
        return commands.component(route.component);
      }
    });
  }
  /**
   * Sets the router outlet (the DOM node where the content for the current
   * route is inserted). Any content pre-existing in the router outlet is
   * removed at the end of each render pass.
   *
   * NOTE: this method is automatically invoked first time when creating a new Router instance.
   *
   * @param {?Node} outlet the DOM node where the content for the current route
   *     is inserted.
   */
  setOutlet(outlet) {
    if (outlet) {
      this.__ensureOutlet(outlet);
    }
    this.__outlet = outlet;
  }
  /**
   * Returns the current router outlet. The initial value is `undefined`.
   *
   * @return {?Node} the current router outlet (or `undefined`)
   */
  getOutlet() {
    return this.__outlet;
  }
  /**
   * Sets the routing config (replacing the existing one) and triggers a
   * navigation event so that the router outlet is refreshed according to the
   * current `window.location` and the new routing config.
   *
   * Each route object may have the following properties, listed here in the processing order:
   * * `path`  the route path (relative to the parent route if any) in the
   * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
   *
   * * `children`  an array of nested routes or a function that provides this
   * array at the render time. The function can be synchronous or asynchronous:
   * in the latter case the render is delayed until the returned promise is
   * resolved. The `children` function is executed every time when this route is
   * being rendered. This allows for dynamic route structures (e.g. backend-defined),
   * but it might have a performance impact as well. In order to avoid calling
   * the function on subsequent renders, you can override the `children` property
   * of the route object and save the calculated array there
   * (via `context.route.children = [ route1, route2, ...];`).
   * Parent routes are fully resolved before resolving the children. Children
   * 'path' values are relative to the parent ones.
   *
   * * `action`  the action that is executed before the route is resolved.
   * The value for this property should be a function, accepting `context`
   * and `commands` parameters described below. If present, this function is
   * always invoked first, disregarding of the other properties' presence.
   * The action can return a result directly or within a `Promise`, which
   * resolves to the result. If the action result is an `HTMLElement` instance,
   * a `commands.component(name)` result, a `commands.redirect(path)` result,
   * or a `context.next()` result, the current route resolution is finished,
   * and other route config properties are ignored.
   * See also **Route Actions** section in [Live Examples](#/classes/Router/demos/demo/index.html).
   *
   * * `redirect`  other route's path to redirect to. Passes all route parameters to the redirect target.
   * The target route should also be defined.
   * See also **Redirects** section in [Live Examples](#/classes/Router/demos/demo/index.html).
   *
   * * `bundle`  string containing the path to `.js` or `.mjs` bundle to load before resolving the route,
   * or the object with "module" and "nomodule" keys referring to different bundles.
   * Each bundle is only loaded once. If "module" and "nomodule" are set, only one bundle is loaded,
   * depending on whether the browser supports ES modules or not.
   * The property is ignored when either an `action` returns the result or `redirect` property is present.
   * Any error, e.g. 404 while loading bundle will cause route resolution to throw.
   * See also **Code Splitting** section in [Live Examples](#/classes/Router/demos/demo/index.html).
   *
   * * `component`  the tag name of the Web Component to resolve the route to.
   * The property is ignored when either an `action` returns the result or `redirect` property is present.
   * If route contains the `component` property (or an action that return a component)
   * and its child route also contains the `component` property, child route's component
   * will be rendered as a light dom child of a parent component.
   *
   * * `name`  the string name of the route to use in the
   * [`router.urlForName(name, params)`](#/classes/Router#method-urlForName)
   * navigation helper method.
   *
   * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the callback
   * through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow function
   * because arrow functions do not have their own `this` reference.
   *
   * `context` object that is passed to `action` function holds the following properties:
   * * `context.pathname`  string with the pathname being resolved
   *
   * * `context.search`  search query string
   *
   * * `context.hash`  hash string
   *
   * * `context.params`  object with route parameters
   *
   * * `context.route`  object that holds the route that is currently being rendered.
   *
   * * `context.next()`  function for asynchronously getting the next route
   * contents from the resolution chain (if any)
   *
   * `commands` object that is passed to `action` function has
   * the following methods:
   *
   * * `commands.redirect(path)`  function that creates a redirect data
   * for the path specified.
   *
   * * `commands.component(component)`  function that creates a new HTMLElement
   * with current context. Note: the component created by this function is reused if visiting the same path twice in row.
   *
   *
   * @param {!Array<!Route>|!Route} routes a single route or an array of those
   * @param {?boolean} skipRender configure the router but skip rendering the
   *     route corresponding to the current `window.location` values
   *
   * @return {!Promise<!Node>}
   */
  setRoutes(routes2, skipRender = false) {
    this.__previousContext = void 0;
    this.__urlForName = void 0;
    super.setRoutes(routes2);
    if (!skipRender) {
      this.__onNavigationEvent();
    }
    return this.ready;
  }
  /**
   * Asynchronously resolves the given pathname and renders the resolved route
   * component into the router outlet. If no router outlet is set at the time of
   * calling this method, or at the time when the route resolution is completed,
   * a `TypeError` is thrown.
   *
   * Returns a promise that is fulfilled with the router outlet DOM Node after
   * the route component is created and inserted into the router outlet, or
   * rejected if no route matches the given path.
   *
   * If another render pass is started before the previous one is completed, the
   * result of the previous render pass is ignored.
   *
   * @param {!string|!{pathname: !string, search: ?string, hash: ?string}} pathnameOrContext
   *    the pathname to render or a context object with a `pathname` property,
   *    optional `search` and `hash` properties, and other properties
   *    to pass to the resolver.
   * @param {boolean=} shouldUpdateHistory
   *    update browser history with the rendered location
   * @return {!Promise<!Node>}
   */
  render(pathnameOrContext, shouldUpdateHistory) {
    const renderId = ++this.__lastStartedRenderId;
    const context2 = Object.assign(
      {
        search: "",
        hash: ""
      },
      isString(pathnameOrContext) ? { pathname: pathnameOrContext } : pathnameOrContext,
      {
        __renderId: renderId
      }
    );
    this.ready = this.resolve(context2).then((context3) => this.__fullyResolveChain(context3)).then((context3) => {
      if (this.__isLatestRender(context3)) {
        const previousContext = this.__previousContext;
        if (context3 === previousContext) {
          this.__updateBrowserHistory(previousContext, true);
          return this.location;
        }
        this.location = createLocation(context3);
        if (shouldUpdateHistory) {
          this.__updateBrowserHistory(context3, renderId === 1);
        }
        fireRouterEvent("location-changed", { router: this, location: this.location });
        if (context3.__skipAttach) {
          this.__copyUnchangedElements(context3, previousContext);
          this.__previousContext = context3;
          return this.location;
        }
        this.__addAppearingContent(context3, previousContext);
        const animationDone = this.__animateIfNeeded(context3);
        this.__runOnAfterEnterCallbacks(context3);
        this.__runOnAfterLeaveCallbacks(context3, previousContext);
        return animationDone.then(() => {
          if (this.__isLatestRender(context3)) {
            this.__removeDisappearingContent();
            this.__previousContext = context3;
            return this.location;
          }
        });
      }
    }).catch((error) => {
      if (renderId === this.__lastStartedRenderId) {
        if (shouldUpdateHistory) {
          this.__updateBrowserHistory(context2);
        }
        removeDomNodes(this.__outlet && this.__outlet.children);
        this.location = createLocation(Object.assign(context2, { resolver: this }));
        fireRouterEvent("error", Object.assign({ router: this, error }, context2));
        throw error;
      }
    });
    return this.ready;
  }
  // `topOfTheChainContextBeforeRedirects` is a context coming from Resolver.resolve().
  // It would contain a 'redirect' route or the first 'component' route that
  // matched the pathname. There might be more child 'component' routes to be
  // resolved and added into the chain. This method would find and add them.
  // `contextBeforeRedirects` is the context containing such a child component
  // route. It's only necessary when this method is called recursively (otherwise
  // it's the same as the 'top of the chain' context).
  //
  // Apart from building the chain of child components, this method would also
  // handle 'redirect' routes, call 'onBefore' callbacks and handle 'prevent'
  // and 'redirect' callback results.
  __fullyResolveChain(topOfTheChainContextBeforeRedirects, contextBeforeRedirects = topOfTheChainContextBeforeRedirects) {
    return this.__findComponentContextAfterAllRedirects(contextBeforeRedirects).then((contextAfterRedirects) => {
      const redirectsHappened = contextAfterRedirects !== contextBeforeRedirects;
      const topOfTheChainContextAfterRedirects = redirectsHappened ? contextAfterRedirects : topOfTheChainContextBeforeRedirects;
      const matchedPath = getPathnameForRouter(
        getMatchedPath(contextAfterRedirects.chain),
        contextAfterRedirects.resolver
      );
      const isFound = matchedPath === contextAfterRedirects.pathname;
      const findNextContextIfAny = (context2, parent = context2.route, prevResult) => {
        return context2.next(void 0, parent, prevResult).then((nextContext) => {
          if (nextContext === null || nextContext === notFoundResult) {
            if (isFound) {
              return context2;
            } else if (parent.parent !== null) {
              return findNextContextIfAny(context2, parent.parent, nextContext);
            } else {
              return nextContext;
            }
          }
          return nextContext;
        });
      };
      return findNextContextIfAny(contextAfterRedirects).then((nextContext) => {
        if (nextContext === null || nextContext === notFoundResult) {
          throw getNotFoundError(topOfTheChainContextAfterRedirects);
        }
        return nextContext && nextContext !== notFoundResult && nextContext !== contextAfterRedirects ? this.__fullyResolveChain(topOfTheChainContextAfterRedirects, nextContext) : this.__amendWithOnBeforeCallbacks(contextAfterRedirects);
      });
    });
  }
  __findComponentContextAfterAllRedirects(context2) {
    const result = context2.result;
    if (result instanceof HTMLElement) {
      renderElement(context2, result);
      return Promise.resolve(context2);
    } else if (result.redirect) {
      return this.__redirect(result.redirect, context2.__redirectCount, context2.__renderId).then((context3) => this.__findComponentContextAfterAllRedirects(context3));
    } else if (result instanceof Error) {
      return Promise.reject(result);
    } else {
      return Promise.reject(
        new Error(
          log(
            `Invalid route resolution result for path "${context2.pathname}". Expected redirect object or HTML element, but got: "${logValue(result)}". Double check the action return value for the route.`
          )
        )
      );
    }
  }
  __amendWithOnBeforeCallbacks(contextWithFullChain) {
    return this.__runOnBeforeCallbacks(contextWithFullChain).then((amendedContext) => {
      if (amendedContext === this.__previousContext || amendedContext === contextWithFullChain) {
        return amendedContext;
      }
      return this.__fullyResolveChain(amendedContext);
    });
  }
  __runOnBeforeCallbacks(newContext) {
    const previousContext = this.__previousContext || {};
    const previousChain = previousContext.chain || [];
    const newChain = newContext.chain;
    let callbacks = Promise.resolve();
    const prevent = () => ({ cancel: true });
    const redirect = (pathname) => createRedirect(newContext, pathname);
    newContext.__divergedChainIndex = 0;
    newContext.__skipAttach = false;
    if (previousChain.length) {
      for (let i2 = 0; i2 < Math.min(previousChain.length, newChain.length); i2 = ++newContext.__divergedChainIndex) {
        if (previousChain[i2].route !== newChain[i2].route || previousChain[i2].path !== newChain[i2].path && previousChain[i2].element !== newChain[i2].element || !this.__isReusableElement(previousChain[i2].element, newChain[i2].element)) {
          break;
        }
      }
      newContext.__skipAttach = // Same route chain
      newChain.length === previousChain.length && newContext.__divergedChainIndex == newChain.length && // Same element
      this.__isReusableElement(newContext.result, previousContext.result);
      if (newContext.__skipAttach) {
        for (let i2 = newChain.length - 1; i2 >= 0; i2--) {
          callbacks = this.__runOnBeforeLeaveCallbacks(callbacks, newContext, { prevent }, previousChain[i2]);
        }
        for (let i2 = 0; i2 < newChain.length; i2++) {
          callbacks = this.__runOnBeforeEnterCallbacks(callbacks, newContext, { prevent, redirect }, newChain[i2]);
          previousChain[i2].element.location = createLocation(newContext, previousChain[i2].route);
        }
      } else {
        for (let i2 = previousChain.length - 1; i2 >= newContext.__divergedChainIndex; i2--) {
          callbacks = this.__runOnBeforeLeaveCallbacks(callbacks, newContext, { prevent }, previousChain[i2]);
        }
      }
    }
    if (!newContext.__skipAttach) {
      for (let i2 = 0; i2 < newChain.length; i2++) {
        if (i2 < newContext.__divergedChainIndex) {
          if (i2 < previousChain.length && previousChain[i2].element) {
            previousChain[i2].element.location = createLocation(newContext, previousChain[i2].route);
          }
        } else {
          callbacks = this.__runOnBeforeEnterCallbacks(callbacks, newContext, { prevent, redirect }, newChain[i2]);
          if (newChain[i2].element) {
            newChain[i2].element.location = createLocation(newContext, newChain[i2].route);
          }
        }
      }
    }
    return callbacks.then((amendmentResult) => {
      if (amendmentResult) {
        if (amendmentResult.cancel) {
          this.__previousContext.__renderId = newContext.__renderId;
          return this.__previousContext;
        }
        if (amendmentResult.redirect) {
          return this.__redirect(amendmentResult.redirect, newContext.__redirectCount, newContext.__renderId);
        }
      }
      return newContext;
    });
  }
  __runOnBeforeLeaveCallbacks(callbacks, newContext, commands, chainElement) {
    const location = createLocation(newContext);
    return callbacks.then((result) => {
      if (this.__isLatestRender(newContext)) {
        const afterLeaveFunction = amend("onBeforeLeave", [location, commands, this], chainElement.element);
        return afterLeaveFunction(result);
      }
    }).then((result) => {
      if (!(result || {}).redirect) {
        return result;
      }
    });
  }
  __runOnBeforeEnterCallbacks(callbacks, newContext, commands, chainElement) {
    const location = createLocation(newContext, chainElement.route);
    return callbacks.then((result) => {
      if (this.__isLatestRender(newContext)) {
        const beforeEnterFunction = amend("onBeforeEnter", [location, commands, this], chainElement.element);
        return beforeEnterFunction(result);
      }
    });
  }
  __isReusableElement(element, otherElement) {
    if (element && otherElement) {
      return this.__createdByRouter.get(element) && this.__createdByRouter.get(otherElement) ? element.localName === otherElement.localName : element === otherElement;
    }
    return false;
  }
  __isLatestRender(context2) {
    return context2.__renderId === this.__lastStartedRenderId;
  }
  __redirect(redirectData, counter, renderId) {
    if (counter > MAX_REDIRECT_COUNT) {
      throw new Error(log(`Too many redirects when rendering ${redirectData.from}`));
    }
    return this.resolve({
      pathname: this.urlForPath(
        redirectData.pathname,
        redirectData.params
      ),
      redirectFrom: redirectData.from,
      __redirectCount: (counter || 0) + 1,
      __renderId: renderId
    });
  }
  __ensureOutlet(outlet = this.__outlet) {
    if (!(outlet instanceof Node)) {
      throw new TypeError(log(`Expected router outlet to be a valid DOM Node (but got ${outlet})`));
    }
  }
  __updateBrowserHistory({ pathname, search = "", hash = "" }, replace) {
    if (window.location.pathname !== pathname || window.location.search !== search || window.location.hash !== hash) {
      const changeState = replace ? "replaceState" : "pushState";
      window.history[changeState](null, document.title, pathname + search + hash);
      window.dispatchEvent(new PopStateEvent("popstate", { state: "vaadin-router-ignore" }));
    }
  }
  __copyUnchangedElements(context2, previousContext) {
    let deepestCommonParent = this.__outlet;
    for (let i2 = 0; i2 < context2.__divergedChainIndex; i2++) {
      const unchangedElement = previousContext && previousContext.chain[i2].element;
      if (unchangedElement) {
        if (unchangedElement.parentNode === deepestCommonParent) {
          context2.chain[i2].element = unchangedElement;
          deepestCommonParent = unchangedElement;
        } else {
          break;
        }
      }
    }
    return deepestCommonParent;
  }
  __addAppearingContent(context2, previousContext) {
    this.__ensureOutlet();
    this.__removeAppearingContent();
    const deepestCommonParent = this.__copyUnchangedElements(context2, previousContext);
    this.__appearingContent = [];
    this.__disappearingContent = Array.from(deepestCommonParent.children).filter(
      // Only remove layout content that was added by router
      (e3) => this.__addedByRouter.get(e3) && // Do not remove the result element to avoid flickering
      e3 !== context2.result
    );
    let parentElement = deepestCommonParent;
    for (let i2 = context2.__divergedChainIndex; i2 < context2.chain.length; i2++) {
      const elementToAdd = context2.chain[i2].element;
      if (elementToAdd) {
        parentElement.appendChild(elementToAdd);
        this.__addedByRouter.set(elementToAdd, true);
        if (parentElement === deepestCommonParent) {
          this.__appearingContent.push(elementToAdd);
        }
        parentElement = elementToAdd;
      }
    }
  }
  __removeDisappearingContent() {
    if (this.__disappearingContent) {
      removeDomNodes(this.__disappearingContent);
    }
    this.__disappearingContent = null;
    this.__appearingContent = null;
  }
  __removeAppearingContent() {
    if (this.__disappearingContent && this.__appearingContent) {
      removeDomNodes(this.__appearingContent);
      this.__disappearingContent = null;
      this.__appearingContent = null;
    }
  }
  __runOnAfterLeaveCallbacks(currentContext, targetContext) {
    if (!targetContext) {
      return;
    }
    for (let i2 = targetContext.chain.length - 1; i2 >= currentContext.__divergedChainIndex; i2--) {
      if (!this.__isLatestRender(currentContext)) {
        break;
      }
      const currentComponent = targetContext.chain[i2].element;
      if (!currentComponent) {
        continue;
      }
      try {
        const location = createLocation(currentContext);
        runCallbackIfPossible(
          currentComponent.onAfterLeave,
          [location, {}, targetContext.resolver],
          currentComponent
        );
      } finally {
        if (this.__disappearingContent.indexOf(currentComponent) > -1) {
          removeDomNodes(currentComponent.children);
        }
      }
    }
  }
  __runOnAfterEnterCallbacks(currentContext) {
    for (let i2 = currentContext.__divergedChainIndex; i2 < currentContext.chain.length; i2++) {
      if (!this.__isLatestRender(currentContext)) {
        break;
      }
      const currentComponent = currentContext.chain[i2].element || {};
      const location = createLocation(currentContext, currentContext.chain[i2].route);
      runCallbackIfPossible(
        currentComponent.onAfterEnter,
        [location, {}, currentContext.resolver],
        currentComponent
      );
    }
  }
  __animateIfNeeded(context2) {
    const from = (this.__disappearingContent || [])[0];
    const to = (this.__appearingContent || [])[0];
    const promises = [];
    const chain = context2.chain;
    let config;
    for (let i2 = chain.length; i2 > 0; i2--) {
      if (chain[i2 - 1].route.animate) {
        config = chain[i2 - 1].route.animate;
        break;
      }
    }
    if (from && to && config) {
      const leave = isObject(config) && config.leave || "leaving";
      const enter = isObject(config) && config.enter || "entering";
      promises.push(animate(from, leave));
      promises.push(animate(to, enter));
    }
    return Promise.all(promises).then(() => context2);
  }
  /**
   * Subscribes this instance to navigation events on the `window`.
   *
   * NOTE: beware of resource leaks. For as long as a router instance is
   * subscribed to navigation events, it won't be garbage collected.
   */
  subscribe() {
    window.addEventListener("vaadin-router-go", this.__navigationEventHandler);
  }
  /**
   * Removes the subscription to navigation events created in the `subscribe()`
   * method.
   */
  unsubscribe() {
    window.removeEventListener("vaadin-router-go", this.__navigationEventHandler);
  }
  __onNavigationEvent(event) {
    const { pathname, search, hash } = event ? event.detail : window.location;
    if (isString(this.__normalizePathname(pathname))) {
      if (event && event.preventDefault) {
        event.preventDefault();
      }
      this.render({ pathname, search, hash }, true);
    }
  }
  /**
   * Configures what triggers Router navigation events:
   *  - `POPSTATE`: popstate events on the current `window`
   *  - `CLICK`: click events on `<a>` links leading to the current page
   *
   * This method is invoked with the pre-configured values when creating a new Router instance.
   * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.
   *
   * See the `router-config.js` for the default navigation triggers config. Based on it, you can
   * create the own one and only import the triggers you need, instead of pulling in all the code,
   * e.g. if you want to handle `click` differently.
   *
   * See also **Navigation Triggers** section in [Live Examples](#/classes/Router/demos/demo/index.html).
   *
   * @param {...NavigationTrigger} triggers
   */
  static setTriggers(...triggers2) {
    setNavigationTriggers(triggers2);
  }
  /**
   * Generates a URL for the route with the given name, optionally performing
   * substitution of parameters.
   *
   * The route is searched in all the Router instances subscribed to
   * navigation events.
   *
   * **Note:** For child route names, only array children are considered.
   * It is not possible to generate URLs using a name for routes set with
   * a children function.
   *
   * @function urlForName
   * @param {!string} name the route name or the routes `component` name.
   * @param {Params=} params Optional object with route path parameters.
   * Named parameters are passed by name (`params[name] = value`), unnamed
   * parameters are passed by index (`params[index] = value`).
   *
   * @return {string}
   */
  urlForName(name, params) {
    if (!this.__urlForName) {
      this.__urlForName = generateUrls(this);
    }
    return getPathnameForRouter(
      this.__urlForName(name, params),
      this
    );
  }
  /**
   * Generates a URL for the given route path, optionally performing
   * substitution of parameters.
   *
   * @param {!string} path string route path declared in [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
   * @param {Params=} params Optional object with route path parameters.
   * Named parameters are passed by name (`params[name] = value`), unnamed
   * parameters are passed by index (`params[index] = value`).
   *
   * @return {string}
   */
  urlForPath(path, params) {
    return getPathnameForRouter(
      Router.pathToRegexp.compile(path)(params),
      this
    );
  }
  /**
   * Triggers navigation to a new path. Returns a boolean without waiting until
   * the navigation is complete. Returns `true` if at least one `Router`
   * has handled the navigation (was subscribed and had `baseUrl` matching
   * the `path` argument), otherwise returns `false`.
   *
   * @param {!string|!{pathname: !string, search: (string|undefined), hash: (string|undefined)}} path
   *   a new in-app path string, or an URL-like object with `pathname`
   *   string property, and optional `search` and `hash` string properties.
   * @return {boolean}
   */
  static go(path) {
    const { pathname, search, hash } = isString(path) ? this.__createUrl(path, "http://a") : path;
    return fireRouterEvent("go", { pathname, search, hash });
  }
}
const DEV_MODE_CODE_REGEXP = /\/\*[\*!]\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i;
const FlowClients = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;
function isMinified() {
  function test() {
    return true;
  }
  return uncommentAndRun(test);
}
function isDevelopmentMode() {
  try {
    if (isForcedDevelopmentMode()) {
      return true;
    }
    if (!isLocalhost()) {
      return false;
    }
    if (FlowClients) {
      return !isFlowProductionMode();
    }
    return !isMinified();
  } catch (e3) {
    return false;
  }
}
function isForcedDevelopmentMode() {
  return localStorage.getItem("vaadin.developmentmode.force");
}
function isLocalhost() {
  return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
}
function isFlowProductionMode() {
  if (FlowClients) {
    const productionModeApps = Object.keys(FlowClients).map((key) => FlowClients[key]).filter((client) => client.productionMode);
    if (productionModeApps.length > 0) {
      return true;
    }
  }
  return false;
}
function uncommentAndRun(callback, args) {
  if (typeof callback !== "function") {
    return;
  }
  const match = DEV_MODE_CODE_REGEXP.exec(callback.toString());
  if (match) {
    try {
      callback = new Function(match[1]);
    } catch (e3) {
      console.log("vaadin-development-mode-detector: uncommentAndRun() failed", e3);
    }
  }
  return callback(args);
}
window["Vaadin"] = window["Vaadin"] || {};
const runIfDevelopmentMode = function(callback, args) {
  if (window.Vaadin.developmentMode) {
    return uncommentAndRun(callback, args);
  }
};
if (window.Vaadin.developmentMode === void 0) {
  window.Vaadin.developmentMode = isDevelopmentMode();
}
function maybeGatherAndSendStats() {
}
const usageStatistics = function() {
  if (typeof runIfDevelopmentMode === "function") {
    return runIfDevelopmentMode(maybeGatherAndSendStats);
  }
};
window.Vaadin = window.Vaadin || {};
window.Vaadin.registrations = window.Vaadin.registrations || [];
window.Vaadin.registrations.push({
  is: "@vaadin/router",
  version: "1.7.4"
});
usageStatistics();
Router.NavigationTrigger = { POPSTATE, CLICK };
var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$6(target, key, result);
  return result;
};
let VaadinRouterElement = class extends s$3 {
  constructor() {
    super(...arguments);
    this.router = new Router(this);
    this.routes = [];
  }
  connectedCallback() {
    super.connectedCallback();
    this.router.setRoutes(this.routes);
    console.log("Router:", this.routes);
  }
  render() {
    return x`<slot></slot>`;
  }
};
__decorateClass$6([
  n$1({ attribute: false })
], VaadinRouterElement.prototype, "routes", 2);
VaadinRouterElement = __decorateClass$6([
  t("vaadin-router")
], VaadinRouterElement);
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$5(target, key, result);
  return result;
};
let DropDownElement = class extends s$3 {
  constructor() {
    super(...arguments);
    this.open = false;
    this.align = "left";
  }
  render() {
    const menuStyle = this.align === "left" ? "" : "--position-left: auto; --position-right: 0;";
    return x`
      <input
        type="checkbox"
        id="is-shown"
        @change=${this._handleChange}
        .checked=${this.open} />
      <label for="is-shown">
        <slot>Menu</slot>
      </label>
      <slot name="menu" style=${menuStyle}>
        <ul>
          <li>Command 1</li>
          <li>Command 2</li>
          <li>Command 3</li>
        </ul>
      </slot>
    `;
  }
  _handleChange(ev) {
    const target = ev.target;
    this._toggle(target.checked);
  }
  _toggle(open) {
    this.open = open;
    this._toggleClickAway(open);
  }
  _toggleClickAway(open) {
    const clickawayHandler = (ev) => {
      if (!ev.composedPath().includes(this)) {
        this._toggle(false);
      } else {
        ev.stopPropagation();
      }
    };
    if (open) {
      document.addEventListener("click", clickawayHandler);
    } else {
      document.removeEventListener("click", clickawayHandler);
    }
  }
};
DropDownElement.styles = i$3`
    :host {
      --position-left: 0;
      --position-right: auto;

      display: inline-block;
      position: relative;
    }

    #is-shown {
      display: none;
    }

    label {
      cursor: pointer;
    }

    slot[name="menu"] {
      display: none;
      position: absolute;
      top: 100%;
      left: var(--position-left);
      right: var(--position-right);
    }

    #is-shown:checked ~ slot[name="menu"] {
      display: block;
    }

    /* CSS for slotted elements and default slot content */

    ::slotted(ul[slot="menu"]),
    slot[name="menu"] > ul {
      margin: 0;
      padding: 0.25em;
      list-style: none;
      white-space: nowrap;
    }
  `;
__decorateClass$5([
  n$1({ reflect: true, type: Boolean })
], DropDownElement.prototype, "open", 2);
__decorateClass$5([
  n$1()
], DropDownElement.prototype, "align", 2);
DropDownElement = __decorateClass$5([
  t("drop-down")
], DropDownElement);
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$4(target, key, result);
  return result;
};
let ToggleSwitchElement = class extends s$3 {
  constructor() {
    super(...arguments);
    this.on = false;
  }
  render() {
    return x`<label>
      <slot>Label</slot>
      <span class="slider">
        <input type="checkbox" @change=${this._handleChange} />
      </span>
    </label>`;
  }
  _handleChange(ev) {
    const target = ev.target;
    const composedEvent = new Event(ev.type, {
      bubbles: true,
      composed: true
    });
    this.on = target == null ? void 0 : target.checked;
    this.dispatchEvent(composedEvent);
  }
};
ToggleSwitchElement.styles = i$3`
    :host {
      display: block;
    }
    label {
      display: flex;
      width: 100%;
      justify-content: space-between;
      align-items: center;
      gap: var(--size-spacing-medium);
      line-height: 2em;
      cursor: pointer;
    }
    .slider {
      display: inline-block;
      border: 1px solid var(--color-border-control);
      border-radius: 0.75em;
      background-color: var(--color-background-control);
      height: 1.5em;
      width: 2.75em;
      position: relative;
      transition: background-color
        var(--time-transition-control);
    }
    .slider:has(input:checked) {
      background-color: var(--color-accent);
    }
    input {
      appearance: none;
      cursor: pointer;
      background-color: var(--color-foreground-control);
      border-radius: 50%;
      width: 1.25em;
      height: 1.25em;
      font-size: inherit;
      position: absolute;
      left: 0;
      transition: left var(--time-transition-control);
    }
    input:checked {
      left: 1.5em;
    }
  `;
__decorateClass$4([
  n$1({ reflect: true, type: Boolean })
], ToggleSwitchElement.prototype, "on", 2);
ToggleSwitchElement = __decorateClass$4([
  t("toggle-switch")
], ToggleSwitchElement);
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
let PresetButtonsElement = class extends s$3 {
  constructor() {
    super(...arguments);
    this.name = "preset";
    this.options = [1, 2, 3, 4, 5];
  }
  _renderButton(n3) {
    const checked = this.value === n3;
    return x`
      <label>
        <input
          type="radio"
          name=${this.name}
          .value=${n3}
          .checked=${checked} />
        ${n3}
      </label>
    `;
  }
  render() {
    return x`
      <div>
        <span><slot></slot></span>
        <span class="switches" @change=${this._handleChange}>
          ${this.options.map((n3) => this._renderButton(n3))}
        </span>
      </div>
    `;
  }
  _handleChange(ev) {
    const target = ev.target;
    const composedEvent = new Event(ev.type, {
      bubbles: true,
      composed: true
    });
    console.log("Preset changed", ev);
    if (target) {
      this.value = target.value ? parseInt(target.value) : void 0;
    }
    this.dispatchEvent(composedEvent);
  }
};
PresetButtonsElement.styles = i$3`
    * {
      margin: 0;
      box-sizing: border-box;
    }
    div {
      display: flex;
      flex-direction: column;
    }
    span.switches {
      display: flex;
      justify-content: stretch;
      border-radius: var(--size-corner-medium);
      border: var(--line-weight-fine) solid var(--color-accent);
      overflow: hidden;
      align-item: end;
      margin: var(--size-spacing-small) 0;
    }
    label {
      display: inline-block;
      flex-grow: 1;
      padding: var(--size-spacing-small);
      line-height: 1em;
      background-color: var(--color-background-control);
      color: var(--color-text-control);
      font-family: var(--font-family-display);
      transition: background-color
        var(--time-transition-control);
      cursor: pointer;
    }
    label:has(input:checked) {
      background-color: var(--color-accent);
      color: var(--color-text-control-inverted);
    }
    label + label {
      border-left: var(--line-weight-fine) solid
        var(--color-accent);
    }
    input {
      display: none;
    }
  `;
__decorateClass$3([
  n$1({ reflect: true, type: Number })
], PresetButtonsElement.prototype, "value", 2);
__decorateClass$3([
  n$1()
], PresetButtonsElement.prototype, "name", 2);
__decorateClass$3([
  n$1({ attribute: false })
], PresetButtonsElement.prototype, "options", 2);
PresetButtonsElement = __decorateClass$3([
  t("preset-buttons")
], PresetButtonsElement);
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
let UserPanelElement = class extends s$3 {
  constructor() {
    super(...arguments);
    this.avatar = "";
  }
  render() {
    return x`
      <ul>
        <li class="header">
          <img src=${this.avatar} />
          <h1><slot name="name">Your Name</slot></h1>
        </li>
        <li>
          <toggle-switch @change=${this._toggleDarkMode}>
            Dark Mode
          </toggle-switch>
        </li>
        <li>
          <preset-buttons
            name="font-size"
            .options=${[12, 14, 16, 20, 24]}
            value="16"
            @change=${this._selectFontSize}>
            Font Size
          </preset-buttons>
        </li>
        <slot></slot>
        <li>
          <slot name="logout">Sign out&hellip;</slot>
        </li>
      </ul>
    `;
  }
  _toggleDarkMode(ev) {
    const target = ev.target;
    const body = document.body;
    console.log("Toggling Dark mode", ev);
    if (target == null ? void 0 : target.on)
      body.classList.add("dark-mode");
    else
      body.classList.remove("dark-mode");
  }
  _selectFontSize(ev) {
    const target = ev.target;
    const body = document.documentElement;
    console.log("Selecting Font Size", ev);
    if (target) {
      const fontSize = target.value ? target.value.toString() + "px" : "initial";
      body.style.fontSize = fontSize;
    }
  }
};
UserPanelElement.styles = [
  r$5(resetCSS),
  i$3`
      * {
        margin: 0;
        box-sizing: border-box;
      }
      ul {
        list-style: none;
        display: flex;
        flex-direction: column;
        background-color: var(--color-background-page);
        color: var(--color-text);
        border: 1px solid var(--color-accent);
        border-radius: var(--size-corner-medium);
        padding: var(--size-spacing-small);
        width: min-content;
        box-shadow: var(--shadow-dropdown);
      }
      li {
        white-space: nowrap;
        border-color: var(--color-accent);
        border-width: var(--line-weight-superfine);
      }
      li.header {
        display: flex;
        flex-wrap: nowrap;
        align-items: end;
        line-height: var(--font-line-height-display);
      }
      li:first-child {
        border-bottom-style: solid;
      }
      li:last-child {
        border-top-style: solid;
      }
      img {
        display: inline;
        height: var(--size-icon-large);
      }
      h1 {
        font-size: var(--size-type-mlarge);
        line-height: var(--font-line-height-display);
        white-space: normal;
        text-align: right;
      }
    `
];
__decorateClass$2([
  n$1()
], UserPanelElement.prototype, "avatar", 2);
UserPanelElement = __decorateClass$2([
  t("user-panel")
], UserPanelElement);
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
let BlazingHeaderElement = class extends s$3 {
  constructor() {
    super(...arguments);
    this.user = new APIUser();
  }
  render() {
    const { avatar, name, nickname, userid, color } = this.profile || {};
    const shortname = nickname || name && name.split(" ")[0] || this.user.username;
    return x`
      <header>
        <h1>Blazing Travels</h1>
        <p>
          Hello,
          <drop-down align="right">
            ${shortname}
            <user-panel
              slot="menu"
              avatar=${avatar}
              color=${color}
              userid=${userid}>
              <span slot="name">${name}</span>
              <button slot="logout" @click=${this._signOut}>
                Log out...
              </button>
            </user-panel>
          </drop-down>
        </p>
      </header>
    `;
  }
  updated(changedProperties) {
    console.log(
      "Profile Data has been updated",
      changedProperties
    );
    if (changedProperties.has("user")) {
      console.log("New user", this.user);
      const { username } = this.user;
      this._getData(`/profiles/${username}`);
    }
    return true;
  }
  _getData(path) {
    const request = new APIRequest();
    request.get(path).then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    }).then((json) => {
      console.log("Profile:", json);
      this.profile = json;
    });
  }
  _signOut() {
    console.log("Signout");
    this.user.signOut();
  }
};
BlazingHeaderElement.styles = [
  r$5(resetCSS),
  i$3`
      header {
        grid-area: header;
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        justify-content: space-between;
        padding: var(--size-spacing-medium);
        gap: 0 var(--size-spacing-xlarge);
        background-color: var(--color-background-header);
        color: var(--color-text-inverted);
      }
      header * + :last-child {
        flex-grow: 1;
        text-align: right;
      }
      header h1 {
        white-space: nowrap;
      }
      header a[href] {
        color: var(--color-link-inverted);
      }
      h1 {
        font-size: var(--size-type-xxlarge);
        font-style: oblique;
        font-weight: var(--font-weight-bold);
        font-family: var(--font-family-display);
        line-height: var(--font-line-height-display);
      }
      [slot="logout"] a {
        color: var(--color-accent);
        cursor: pointer;
        font-weight: var(--font-weight-bold);
      }
    `
];
__decorateClass$1([
  r()
], BlazingHeaderElement.prototype, "profile", 2);
__decorateClass$1([
  c({ context: authContext, subscribe: true }),
  n$1({ attribute: false })
], BlazingHeaderElement.prototype, "user", 2);
BlazingHeaderElement = __decorateClass$1([
  t("blazing-header")
], BlazingHeaderElement);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
let BlazingAppElement = class extends Main2 {
  constructor() {
    super(update);
  }
  render() {
    return x`
      <auth-required>
        <blazing-header></blazing-header>
        <vaadin-router .routes=${routes}> </vaadin-router>
      </auth-required>
    `;
  }
};
BlazingAppElement = __decorateClass([
  t("blazing-app")
], BlazingAppElement);
