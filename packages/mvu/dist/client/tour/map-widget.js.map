{
  "version": 3,
  "sources": ["../../../src/client/tour/map-widget.ts"],
  "sourcesContent": ["import { css, html, svg, LitElement } from \"lit\";\nimport {\n  customElement,\n  state,\n  property\n} from \"lit/decorators.js\";\nimport { createContext, consume, provide } from \"@lit/context\";\nimport {\n  geoEquirectangular,\n  geoPath,\n  GeoPath,\n  GeoPermissibleObjects\n} from \"d3-geo\";\nimport { Point } from \"../../models/Geo\";\nimport { Destination } from \"../../models/Tour\";\nimport { reset, elements } from \"../shared/css-base\";\n\ntype ProjectionFn = (pt: Point) => { x: number; y: number };\n\nclass MapProjection {\n  _projection: ProjectionFn = (_) => ({\n    x: 0,\n    y: 0\n  });\n\n  constructor(fn: ProjectionFn = (_) => ({ x: 0, y: 0 })) {\n    this._projection = fn;\n  }\n\n  project(pt: Point) {\n    return this._projection(pt);\n  }\n}\n\nconst mapContext = createContext<MapProjection>(\n  Symbol(\"mapProjection\")\n);\n\ntype Generator = GeoPath<any, GeoPermissibleObjects>;\n\n@customElement(\"map-widget\")\nexport class MapWidget extends LitElement {\n  _viewBox: [[number, number], [number, number]] = [\n    [0, 0],\n    [1000, 1000]\n  ];\n\n  @property()\n  src: string = \"\";\n\n  @state()\n  _mapSvg = svg`\n      <g class=\"basemap\">\n      </g>\n    `;\n\n  @provide({ context: mapContext })\n  @state()\n  projection = new MapProjection();\n\n  render() {\n    return html`\n      <section>\n        <h2>Map</h2>\n        <div class=\"overlay\">\n          <svg viewBox=\"0 0 1000 1000\" id=\"map-area\">\n            ${this._mapSvg}\n          </svg>\n          <div id=\"markers\">\n            <slot></slot>\n          </div>\n        </div>\n      </section>\n    `;\n  }\n\n  static styles = [\n    reset,\n    elements,\n    css`\n      :host {\n        padding: 0 var(--size-spacing-medium);\n      }\n      .overlay {\n        width: 100%;\n        aspect-ratio: 1;\n        position: relative;\n      }\n      .overlay > * {\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n      }\n      svg#map-area {\n        fill: none;\n        stroke: var(--color-accent);\n        stroke-width: 5px;\n      }\n    `\n  ];\n\n  connectedCallback() {\n    const src = this.getAttribute(\"src\");\n    super.connectedCallback();\n\n    if (src) {\n      this._fetchData(src);\n    }\n  }\n\n  attributeChangedCallback(\n    name: string,\n    oldValue: string,\n    newValue: string\n  ) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n    if (name === \"src\") {\n      if (oldValue) {\n        this._clearData();\n      }\n      if (newValue && oldValue !== null) {\n        this._fetchData(newValue);\n      }\n    }\n  }\n\n  _fetchData(src: string) {\n    fetch(src)\n      .then((response) => {\n        if (response.status === 200) {\n          return response.json();\n        }\n        return null;\n      })\n      .then((geojson) => {\n        const generator = this._updateGeoGenerator(geojson);\n        this._mapSvg = this._renderMap(geojson, generator);\n        this.projection = this._updateProjection(generator);\n      });\n  }\n\n  _clearData() {\n    this._mapSvg = svg`\n      <g class=\"basemap\">\n      </g>\n    `;\n    this.projection = new MapProjection();\n  }\n  _updateGeoGenerator(geojson: any): Generator {\n    const base = geoEquirectangular();\n    const projection = geojson\n      ? base.fitExtent(this._viewBox, geojson)\n      : base;\n    return geoPath(projection);\n  }\n\n  _renderMap(geojson: any, generator: Generator) {\n    const { features } = geojson;\n    const paths = features.map(generator);\n\n    return svg`\n    <g class=\"basemap\">\n      ${paths.map((p: any) => svg`<path d=${p} />`)}\n    </g>\n    `;\n  }\n\n  _updateProjection(generator: Generator) {\n    const mapArea = this.shadowRoot?.getElementById(\"map-area\");\n    const markers = Array.from(this.children);\n    const { width } = mapArea?.getBoundingClientRect() || {\n      width: 0\n    };\n    const scale = width / this._viewBox[1][1];\n\n    const projectionFn = (pt: Point) => {\n      const { lat, lon } = pt;\n      console.log(\"Projecting point:\", pt);\n      if (lat && lon) {\n        const features: any = [\n          {\n            type: \"Feature\",\n            properties: { name: \"marker\" },\n            geometry: {\n              type: \"Point\",\n              coordinates: [lon, lat]\n            }\n          }\n        ];\n        const [path] = features.map(generator);\n        const matches = path.match(/M([.0-9-]+),([.0-9-]+)/);\n        if (matches) {\n          const [_, x, y] = matches;\n          return {\n            x: scale * parseFloat(x),\n            y: scale * parseFloat(y)\n          };\n        }\n      }\n\n      return { x: 0, y: 0 };\n    };\n\n    return new MapProjection(projectionFn);\n  }\n}\n\n@customElement(\"map-marker\")\nexport class MapMarker extends LitElement {\n  @property()\n  lat = 0;\n\n  @property()\n  lon = 0;\n\n  @property({ type: Boolean, reflect: true })\n  selected = false;\n\n  @consume({ context: mapContext, subscribe: true })\n  @property({ attribute: false })\n  projection = new MapProjection();\n\n  render() {\n    const pt = this as Point;\n    const { x, y } = this.projection.project(pt);\n    const icon = svg`\n    <use href=\"/icons/markers.svg#icon-poi\" />\n    `;\n\n    return html`\n      <i style=\"transform: translate(${x}px,${y}px)\">\n        <svg class=\"icon\">${icon}</svg>\n        <label>\n          <slot></slot>\n        </label>\n      </i>\n    `;\n  }\n\n  static styles = css`\n    :host {\n      position: absolute;\n      bottom: 100%;\n      left: -1rem;\n      --transform-marker: scale(1);\n    }\n    :host([selected]) {\n      --transform-marker: scale(1.5);\n    }\n    i {\n      display: inline-block;\n    }\n    i:hover {\n      --transform-marker: scale(1.5);\n    }\n    svg.icon {\n      display: inline;\n      height: 2rem;\n      width: 2rem;\n      vertical-align: bottom;\n      fill: var(--color-accent);\n      transform-origin: bottom center;\n      transition: transform 0.5s;\n      transform: var(--transform-marker);\n    }\n    label {\n      margin-left: -0.5em;\n    }\n  `;\n}\n"],
  "mappings": "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",
  "names": []
}
